[
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # TODO: \n        # 1) Use a dictionary to store the current index \n        # 2) Loop through the array and compare each number with the target \n        # 3) If the current index + number is in the dictionary, return the index "
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        map = {}\n        for i, num in enumerate(nums):\n            remaining = target - num\n            if remaining in map:\n                return [map[remaining], i]\n            else:\n                map[num] = i"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # Start at the beginning of the array\n        index = 0\n        # Keep track of the number that comes before it\n        previous = None\n        # Loop through the array\n        while index < len(nums):\n            # If the current number is equal to the target minus the previous number\n            if nums[index] == target - previous:\n                # Return the index of the previous and the current number\n                return [index-1, index]\n            # Else if the current number is less than the target minus the previous number\n            elif nums[index] < target - previous:\n                # Iterate over the array\n                index += 1\n                # Pass the current number into the previous variable\n                previous = nums[index-1]\n            # If the current number is greater than the target minus the previous number\n            else:\n                # Iterate over the array\n                index += 1\n                # Pass the current number into the previous variable\n                previous = nums[index-1]\n        # If the current number is not equal to the target minus the previous number\n        return [None, None]"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # O(n)\n        # hash = {}\n        # for i, v in enumerate(nums):\n        #     if v in hash:\n        #         return [hash[v], i]\n        #     else:\n        #         hash[target - v] = i\n        # return None"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        hash_table = {}\n        for i, num in enumerate(nums):\n            diff = target - num\n            if diff in hash_table:\n                return [hash_table[diff], i]\n            hash_table[num] = i\n        return []"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        d = {}\n        for i, x in enumerate(nums):\n            if target-x in d:\n                return [d[target-x], i]\n            d[x] = i\n        \n        return None\n            <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        h = {}\n        for i, num in enumerate(nums):\n            n = target - num\n            if n not in h:\n                h[num] = i\n            else:\n                return [h[n], i]"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # dictionary = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dictionary:\n        #         return [dictionary[nums[i]], i]\n        #     else:\n        #         dictionary[target - nums[i]] = i\n        # return []\n        for i in range(len(nums)):\n            try:\n                return [i, nums.index(target - nums[i])]\n            except:\n                continue"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        for i, n in enumerate(nums):\n            if target - n in nums[i + 1:]:\n                return i, nums[i + 1:].index(target - n) + (i + 1)"
    },
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "prompt": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        Example 1:\n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        nums_dict = {}\n        for i, num in enumerate(nums):\n            if target - num in nums_dict:\n                return [nums_dict[target - num], i]\n            else:\n                nums_dict[num] = i"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        carry = 0\n        dummy = ListNode(0)\n        head = dummy\n        while l1 or l2 or carry:\n            l1_val = l1.val if l1 else 0\n            l2_val = l2.val if l2 else 0\n            carry, val = divmod(l1_val + l2_val + carry, 10)\n            head.next = ListNode(val)\n            head = head.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        return dummy.next"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # edge case\n        if not l1 and not l2:\n            return None\n        if not l1:\n            return l2\n        if not l2:\n            return l1"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        carry = 0\n        s = ListNode(0)\n        l = s\n        while l1 is not None or l2 is not None:\n            x = l1.val if l1 is not None else 0\n            y = l2.val if l2 is not None else 0\n            s.next = ListNode((x + y + carry) % 10)\n            carry = (x + y + carry) // 10\n            l1 = l1.next if l1 is not None else None\n            l2 = l2.next if l2 is not None else None\n            s = s.next\n        if carry!= 0:\n            s.next = ListNode(carry)\n        return l.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        carry = 0\n        root = n = ListNode(0)\n        while l1 or l2 or carry:\n            v1 = v2 = 0\n            if l1:\n                v1 = l1.val\n                l1 = l1.next\n            if l2:\n                v2 = l2.val\n                l2 = l2.next\n            carry, val = divmod(v1+v2+carry, 10)\n            n.next = ListNode(val)\n            n = n.next\n        return root.next"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        carry = 0\n        head = ListNode(0)\n        cur = head\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry%10)\n            carry = carry // 10\n            cur = cur.next\n        return head.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        i, j = l1, l2\n        sum = 0\n        s = ListNode()\n        l = s\n        while i or j:\n            if i:\n                sum += i.val\n                i = i.next\n            if j:\n                sum += j.val\n                j = j.next\n            l.next = ListNode(sum % 10)\n            sum = sum // 10\n            l = l.next\n        if sum == 1:\n            l.next = ListNode(1)\n        return s.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        l1_num, l2_num = 0, 0\n        while l1:\n            l1_num = l1_num*10 + l1.val\n            l1 = l1.next\n        while l2:\n            l2_num = l2_num*10 + l2.val\n            l2 = l2.next\n        ret_num = l1_num + l2_num\n        ret_lst = ListNode(ret_num % 10)\n        ret = ret_lst\n        ret_num = ret_num // 10\n        while ret_num:\n            node = ListNode(ret_num % 10)\n            ret.next = node\n            ret = ret.next\n            ret_num = ret_num // 10\n        return ret_lst\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        \n        \"\"\"\n        Consider an example:\n        l1 = [2, 4, 3]\n        l2 = [5, 6, 4]\n        sum = 342 + 465 = 807\n        \n        Iterate through the linked list from the head:\n        \n        Since the result will always be reversed:\n        step 1:  8 -> 7 -> 0 -> 8\n        step 2:  7 -> 0 -> 8\n        step 3:  7 -> 0 -> 8\n        step 4:  7 -> 0 -> 8\n        step 5:  7 -> 0 -> 8\n        step 6:  7 -> 0 -> 8\n        step 7:  7 -> 0 -> 8\n        step 8:  7 -> 0 -> 8\n        \n        \"\"\"\n        \n        res = ListNode(0)\n        r = res\n        \n        carry = 0\n        while l1 or l2:\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n            s = carry + x + y\n            carry = s // 10\n            r.next = ListNode(s % 10)\n            r = r.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n            \n        if carry > 0:\n            r.next ="
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        carry = 0\n        start = None\n        cur = None\n        while l1 or l2:\n            x = l1.val if l1 else 0\n            y = l2.val if l2 else 0\n            sum = x + y + carry\n            carry = sum // 10\n            sum = sum % 10\n            if not cur:\n                start = cur = ListNode(sum)\n            else:\n                cur.next = ListNode(sum)\n                cur = cur.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        if carry:\n            cur.next = ListNode(carry)\n        return start"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n        You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n        Example 1:\n        Input: l1 = [2,4,3], l2 = [5,6,4]\n        Output: [7,0,8]\n        Explanation: 342 + 465 = 807.\n        Example 2:\n        Input: l1 = [0], l2 = [0]\n        Output: [0]\n        Example 3:\n        Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n        Output: [8,9,9,9,0,0,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Go until one of them is not None\n        while l1 and l2:\n            # If no carry, add and go to next\n            if not self.carry(l1.val, l2.val):\n                l1.next = self.add_two_nums(l1.next, l2)\n                return l1\n            # Else add carry and go to next\n            else:\n                l1.next = self.add_two_nums(l1.next, ListNode(1))\n                l1, l2 = l1.next, l2.next\n        # If one of them is None, just add the remaining list to the other\n        if l1:\n            l1.next = self.add_two_nums(l1.next, l2)\n        if l2:\n            l2.next = self.add_two_nums(l1, l2.next)\n        return l1 or l2"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not s:\n            return 0"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        left = 0\n        right = 0\n        max_len = 0\n        if s is None or len(s) == 0:\n            return 0\n        if len(s) == 1:\n            return 1\n        hashmap = {}\n        while right < len(s):\n            if s[right] in hashmap:\n                left = max(hashmap[s[right]], left)\n            hashmap[s[right]] = right\n            right += 1\n            max_len = max(max_len, right - left)\n        return max_len"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        l = len(s)\n        if l == 1:\n            return 1\n        left, right = 0, 0\n        seen = set()\n        max_len = 0\n        while right < l:\n            if s[right] in seen:\n                max_len = max(max_len, len(seen))\n                seen.clear()\n                left = right - 1\n            else:\n                seen.add(s[right])\n            right += 1\n        max_len = max(max_len, len(seen))\n        return max_len"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        max_len = 0\n        l = 0\n        d = {}\n        for r in range(len(s)):\n            if s[r] not in d:\n                d[s[r]] = r\n            else:\n                if d[s[r]] < l:\n                    d[s[r]] = r\n                else:\n                    l = d[s[r]] + 1\n                    d[s[r]] = r\n            if r - l + 1 > max_len:\n                max_len = r - l + 1\n        return max_len"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        occ = set()\n        n = len(s)\n        # i, j are the leftmost bound and the rightmost bound\n        i, j = 0, 0\n        max_len = 0\n        while i < n and j < n:\n            # j stops at the first repeating character\n            while j < n and s[j] not in occ:\n                occ.add(s[j])\n                j += 1\n            max_len = max(max_len, j-i)\n            # i stops at the first repeating character\n            while i < n and s[i] in occ:\n                occ.remove(s[i])\n                i += 1\n        return max_len"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not s: return 0\n        start, end = 0, 0\n        max_len = 0\n        table = {}\n        for end in range(len(s)):\n            if s[end] in table:\n                max_len = max(max_len, end - start)\n                while s[start]!= s[end]:\n                    table.pop(s[start])\n                    start += 1\n                start += 1\n            else:\n                table[s[end]] = 1\n        max_len = max(max_len, end - start + 1)\n        return max_len"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        l = 0\n        r = 1\n        l_max = 0\n        r_max = 1\n        while l < len(s):\n            # get longest from l to r\n            if s[l] not in s[l+1:r]:\n                r += 1\n                r_max = max(r_max, r-l)\n            else:\n                l += 1\n                r = l + 1\n                l_max = max(l_max, r-l)\n        return r_max"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # two pointers to traverse the string\n        # i points to the beginning of the substring\n        # j points to the end of the substring\n        # if the char at j is already in the substring, increment j until the char is not in the substring\n        # keep track of the longest substring\n        # increment i and j\n        # if j > len(s) return the longest substring\n        # time complexity: O(n)\n        # space complexity: O(n)\n        i, j = 0, 0\n        dict = {}\n        max_length = 0\n        while j < len(s):\n            if s[j] in dict and i <= dict[s[j]]:\n                i = dict[s[j]] + 1\n            dict[s[j]] = j\n            max_length = max(max_length, j - i + 1)\n            j += 1\n        return max_length"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if s == \"\":\n            return 0\n        result = 1\n        start = 0\n        end = 1\n        while end < len(s):\n            if s[end] not in s[start:end]:\n                end += 1\n                result = max(result, end - start)\n            else:\n                start += s[start:end].index(s[end]) + 1\n                end = start + 1\n        return result"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "prompt": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        \"\"\"\n        Given a string s, find the length of the longest substring without repeating characters.\n        Example 1:\n        Input: s = \"abcabcbb\"\n        Output: 3\n        Explanation: The answer is \"abc\", with the length of 3.\n        Example 2:\n        Input: s = \"bbbbb\"\n        Output: 1\n        Explanation: The answer is \"b\", with the length of 1.\n        Example 3:\n        Input: s = \"pwwkew\"\n        Output: 3\n        Explanation: The answer is \"wke\", with the length of 3.\n        Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Sliding window\n        left, right = 0, 0\n        counter = {}\n        max_len = 0\n        while right < len(s):\n            if s[right] in counter:\n                max_len = max(max_len, right - left)\n                while s[left]!= s[right]:\n                    del counter[s[left]]\n                    left += 1\n                left += 1\n            else:\n                counter[s[right]] = True\n                right += 1\n        return max(max_len, right - left)"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # base cases\n        if len(nums1) == 0:\n            return (nums2[int(len(nums2)/2)] + nums2[int(len(nums2)/2)-1])/2\n        elif len(nums2) == 0:\n            return (nums1[int(len(nums1)/2)] + nums1[int(len(nums1)/2)-1])/2\n        elif len(nums1) == 1 and len(nums2) == 1:\n            return (nums1[0] + nums2[0])/2"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # this is the implementation of the median of the two sorted arrays\n        # if the length of the merged array is odd, we'll use the median\n        # of the last index in merged array\n        # if the length of the merged array is even, we'll use the average\n        # of the medians of the two middle index in merged array\n        # we will use the median function to get the median of the merged array\n        # and we will use the mean function to get the mean of the merged array\n        \n        def median(arr):\n            n = len(arr)\n            if n % 2 == 0:\n                return (arr[n // 2 - 1] + arr[n // 2]) / 2\n            else:\n                return arr[n // 2]"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        m = len(nums1)\n        n = len(nums2)\n        # \u4e24\u4e2a\u6570\u7ec4\u957f\u5ea6\u4e4b\u548c\u7684\u8f83\u5c0f\u8005\n        if (m + n) % 2 == 0:\n            median = (m + n) // 2\n        else:\n            median = (m + n + 1) // 2"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        nums3 = nums1 + nums2\n        nums3.sort()\n        if len(nums3)%2 == 0:\n            nums3 = nums3[len(nums3)//2-1:len(nums3)//2+1]\n        else:\n            nums3 = nums3[len(nums3)//2]\n        return nums3"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(nums1) + len(nums2) == 0:\n            return 0\n        l1 = len(nums1)\n        l2 = len(nums2)\n        if l1 < l2:\n            nums1, nums2 = nums2, nums1\n            l1, l2 = l2, l1\n        if l1 == 0:\n            return nums2[(l2 - 1) // 2]\n        i, j = 0, 0\n        k = 0\n        # print(nums1)\n        # print(nums2)\n        # print(l1, l2)\n        while True:\n            if i < l1 and j < l2:\n                if nums1[i] <= nums2[j]:\n                    i += 1\n                    k += 1\n                else:\n                    j += 1\n                    k += 1\n            elif i < l1:\n                k += l2\n                i += 1\n            elif j < l2:\n                k += l1\n                j += 1\n            if k >= len(nums1) + len(nums2):\n                break\n        return nums2[(l2 - 1) // 2] if l2 % 2 == 1 else (nums2[(l"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Create one final merged list\n        merged = nums1 + nums2\n        merged.sort()"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        m = len(nums1)\n        n = len(nums2)\n        if m == 0:\n            return (nums2[(n-1)//2] + nums2[n//2]) / 2\n        if n == 0:\n            return (nums1[(m-1)//2] + nums1[m//2]) / 2"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        l = len(nums1) + len(nums2)\n        if l % 2 == 0:\n            return (self.getKth(nums1, nums2, l // 2) + self.getKth(nums1, nums2, l // 2 + 1)) / 2\n        else:\n            return self.getKth(nums1, nums2, l // 2 + 1)"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        \"\"\"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n        The overall run time complexity should be O(log (m+n)).\n        Example 1:\n        Input: nums1 = [1,3], nums2 = [2]\n        Output: 2.00000\n        Explanation: merged array = [1,2,3] and median is 2.\n        Example 2:\n        Input: nums1 = [1,2], nums2 = [3,4]\n        Output: 2.50000\n        Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        def findKth(nums1, nums2, k):\n            len1, len2 = len(nums1), len(nums2)\n            if len1 == 0:\n                return nums2[k-1]\n            if len2 == 0:\n                return nums1[k-1]"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if len(s) == 0 or len(s) == 1:\n            return s"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not s:\n            return ''\n        longest = s[0]\n        for i in range(len(s)):\n            odd_start, odd_end = self.expand_from_center(s, i, i)\n            even_start, even_end = self.expand_from_center(s, i, i + 1)\n            if odd_end - odd_start > even_end - even_start:\n                longest = odd_start, odd_end\n            else:\n                longest = even_start, even_end\n        return longest"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # s = \"cbbd\"\n        if len(s) == 0:\n            return \"\""
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        l, r = 0, 0\n        max_l, max_r, max_len = 0, 0, 0"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        def expand(left: int, right: int) -> str:\n            \"\"\"\n            expand from left to right, expand in a way that center is always one char away from right\n            \"\"\"\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left+1:right]"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # initialize\n        result = ''\n        result_len = 0\n        max_palindrome_len = len(s)\n        for i in range(len(s)):\n            # odd case\n            if i < max_palindrome_len - 1 and s[i] == s[i+1]:\n                palindrome = self.get_palindrome(s, i, i+1)\n                result = palindrome if len(palindrome) > len(result) else result\n                result_len = len(palindrome) if len(palindrome) > result_len else result_len\n            # even case\n            palindrome = self.get_palindrome(s, i, i)\n            result = palindrome if len(palindrome) > len(result) else result\n            result_len = len(palindrome) if len(palindrome) > result_len else result_len"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # \u4ee5\u4e2d\u5fc3\u5411\u4e24\u8fb9\u6269\u5c55\uff0c\u627e\u5230\u56de\u6587\u5b50\u4e32\n        # \u5947\u6570\u65f6\u4e2d\u5fc3\u4e3a\u4e2d\u95f4\uff0c\u5076\u6570\u65f6\u4e2d\u5fc3\u4e3a\u4e2d\u95f4\u4e24\u4e2a\u6570\u7684\u5747\u503c\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1: right]"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        \n        def expand_from_center(s, left, right):\n            \"\"\"\n            s: string\n            left: left index of the current substring\n            right: right index of the current substring\n            \n            Time Complexity: O(n)\n            Space Complexity: O(n)\n            \"\"\"\n            \n            # return if invalid input\n            if left < 0 or right > len(s):\n                return None\n            \n            # return if the current substring is a palindrome\n            if left >= right:\n                return s[left]\n            \n            # check if the current substring is a palindrome\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n                \n            # return if the current substring is a palindrome\n            return s[left + 1 : right]\n        \n        # return if invalid input\n        if len(s) == 0:\n            return \"\"\n        \n        # return the longest substring\n        max_str = \"\"\n        for i in range(len(s)):\n            # left: index of the first character in the current substring\n            # right: index of the last character in the current substring\n            max_str = max(max_str, expand_from"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # trivial case\n        if len(s) == 1:\n            return s\n        # initialize answer\n        ans = s[0]\n        # loop over all possible even length palindromes in s\n        for i in range(len(s)-1):\n            left, right = i, i+1\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                ans = s[left:right+1] if len(ans) < right+1-left else ans\n                left -= 1\n                right += 1\n            # loop over all possible odd length palindromes in s\n            left, right = i, i+2\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                ans = s[left:right+1] if len(ans) < right+1-left else ans\n                left -= 1\n                right += 1\n        return ans"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "prompt": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Given a string s, return the longest palindromic substring in s.\n        Example 1:\n        Input: s = \"babad\"\n        Output: \"bab\"\n        Explanation: \"aba\" is also a valid answer.\n        Example 2:\n        Input: s = \"cbbd\"\n        Output: \"bb\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Approach 1: Brute Force: Time: O(n^3), Space: O(1)\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i:j+1] == s[i:j+1][::-1]:\n        #             return s[i:j+1]\n        # return s[0]"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if numRows <= 1:\n            return s\n        rows = [''] * numRows\n        s_len = len(s)\n        cycle = (numRows + numRows - 2)\n        if cycle == 0:\n            cycle = 2\n        i = 0\n        up = True\n        while i < s_len:\n            for j in range(numRows):\n                if up:\n                    if i < s_len:\n                        rows[j] += s[i]\n                        i += 1\n                    else:\n                        break\n                else:\n                    if s_len - i - 1 < numRows:\n                        rows[numRows - s_len + i] += s[i]\n                        i += 1\n                    else:\n                        break\n            up = not up\n        return ''.join(rows)\n    \n    def convert2(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n        if numRows == 2:\n            return s[::2] + s[1::2]\n        arr = []\n        for i in range(numRows):\n            arr.append(['']*(len(s)//numRows+1))\n        \n        cnt = 0\n        for"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if len(s) <= numRows or numRows == 1:\n            return s\n        if numRows == 2:\n            s_row = s[0::2]\n            s_row_add = s[1::2]\n            return s_row + s_row_add[::-1]\n        s_rows = [''] * numRows\n        iter_s = iter(s)\n        i = 0\n        for c in iter_s:\n            s_rows[i] += c\n            if i == 0:\n                step = 1\n            elif i == numRows - 1:\n                step = -1\n            i += step\n        return ''.join(s_rows)"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if numRows == 1 or numRows >= len(s):\n            return s\n        result = [\"\" for i in range(numRows)]\n        cur_row = 0\n        going_down = False\n        for char in s:\n            result[cur_row] += char\n            if cur_row == 0 or cur_row == numRows - 1:\n                going_down = not going_down\n            cur_row += 1 if going_down else -1\n        return \"\".join(result)"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # use double list to store row\n        # first row has one element, second row has 2 elements\n        # first column has one element, second column has two elements\n        # middle column has three elements"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if numRows <= 1:\n            return s\n        result = ''\n        i = 0\n        for row in range(numRows):\n            for col in range(row, len(s), 2 * numRows - 2):\n                if i >= len(s):\n                    break\n                result += s[i]\n                i += 1\n            i += row\n            for col in range(row + 1, len(s), 2 * numRows - 2):\n                if i >= len(s):\n                    break\n                result += s[i]\n                i += 1\n        return result"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \"\"\"\n        There are two directions here. The first one is the down-going direction.\n        We can find the next direction by counting numRows.\n        As we do, we have to decide whether we go up or down.\n        And after that, we have to check whether we meet the end of the string or not.\n        \"\"\"\n        if numRows == 1:\n            return s\n        str_len = len(s)\n        if str_len == 0:\n            return ''\n        rows = [[] for _ in range(numRows)]\n        up_down = 1\n        curr_row = 0\n        for i, c in enumerate(s):\n            rows[curr_row].append(c)\n            if curr_row == numRows - 1:\n                up_down = -1\n            elif curr_row == 0:\n                up_down = 1\n            if up_down == 1:\n                curr_row += 1\n            elif up_down == -1:\n                curr_row -= 1\n        res = ''\n        for row in rows:\n            res += ''.join(row)\n        return res"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # pad the zigzag string with zeros\n        rows = len(s) // numRows\n        if len(s) % numRows!= 0:\n            rows += 1\n        padded_string = ''\n        for i in range(rows):\n            padded_string += s[i * numRows: (i + 1) * numRows]\n        return padded_string\n        \"\"\"\n        Runtime: 36 ms, faster than 97.16% of Python3 online submissions for ZigZag Conversion.\n        Memory Usage: 13.8 MB, less than 5.90% of Python3 online submissions for ZigZag Conversion.\n        \"\"\""
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if numRows == 1:\n            return s"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if numRows == 1:\n            return s\n        \n        ans = []\n        curr_row = 0\n        going_down = True\n        for c in s:\n            if curr_row == 0 or curr_row == numRows - 1:\n                going_down = not going_down\n            ans.append(c)\n            curr_row += 1 if going_down else -1\n            \n        return \"\".join(ans)<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "prompt": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n        P   A   H   N\n        A P L S I I G\n        Y   I   R\n        And then read line by line: \"PAHNAPLSIIGYIR\"\n        Write the code that will take a string and make this conversion given a number of rows:\n        string convert(string s, int numRows);\n        Example 1:\n        Input: s = \"PAYPALISHIRING\", numRows = 3\n        Output: \"PAHNAPLSIIGYIR\"\n        Example 2:\n        Input: s = \"PAYPALISHIRING\", numRows = 4\n        Output: \"PINALSIGYAHRPI\"\n        Explanation:\n        P     I    N\n        A   L S  I G\n        Y A   H R\n        P     I\n        Example 3:\n        Input: s = \"A\", numRows = 1\n        Output: \"A\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if numRows < 2:\n            return s\n        res = [''] * numRows\n        flag = 0\n        for i in range(len(s)):\n            if flag == 0:\n                res[i % numRows] += s[i]\n                flag = 1\n            elif flag == numRows-1:\n                res[i % numRows] += s[i]\n                flag = 0\n            else:\n                res[numRows-2-flag] += s[i]\n                flag += 1\n        return ''.join(res)"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if x == 0:\n            return 0\n        res = 0\n        sign = 1\n        if x < 0:\n            sign = -1\n            x = -x\n        while x!= 0:\n            res = res*10 + x%10\n            x = x//10\n        res = res*sign\n        if res <= -2147483648 or res >= 2147483647:\n            return 0\n        return res"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        s = str(x)[::-1]\n        if x >= 0:\n            rev = int(s)\n        else:\n            s = s[:-1]\n            rev = -int(s)\n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        else:\n            return rev\n        \"\"\"\n        1st solution\n        import math\n        if x > 0:\n            return int(str(x)[::-1])\n        elif x < 0:\n            str_x = str(x)\n            if int(str_x[1:]) < -2**31:\n                return 0\n            elif -2**31 <= int(str_x[1:]) <= 2**31 - 1:\n                return int(str_x[::-1]) * -1\n            else:\n                str_x = str(x)\n                print(str_x)\n                sign = -1\n                res = sign * int(str_x[1:])\n                res = res * -1\n                return res\n        else:\n            return 0\n        \"\"\"\n        \"\"\"\n        2nd solution\n        import math\n        sign = 1\n        if x < 0:\n            sign = -1\n            x = x * -1\n        if x <"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        rev = 0\n        neg = False\n        if x < 0:\n            neg = True\n        if abs(x) < 10:\n            return x\n        while x > 0:\n            n = x % 10\n            x = int(x / 10)\n            rev = rev * 10 + n\n        if neg:\n            rev = -rev\n        return rev if -(2 ** 31) < rev < 2 ** 31 else 0"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if x < 0:\n            x = -x\n        rev = 0\n        while x:\n            rev = 10 * rev + x % 10\n            x //= 10\n        if rev < -2 ** 31 or rev > 2 ** 31 - 1:\n            return 0\n        return rev"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        if x >= 0:\n            x = int(str(x)[::-1])\n        else:\n            x = -1 * int(str(-x)[::-1])\n        \n        if -2**31 <= x <= 2**31 - 1:\n            return x\n        else:\n            return 0\n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if x == 0:\n            return 0"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # INITIAL\n        sign = 1\n        if x < 0:\n            sign = -1\n            x *= sign\n        rev = 0\n        while x > 0:\n            rev = (rev * 10) + (x % 10)\n            x //= 10\n        if rev > 2**31-1:\n            return 0\n        return rev * sign"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if x < -2147483648 or x > 2147483647:\n            return 0\n        elif x == 0:\n            return 0\n        else:\n            if x < 0:\n                s = str(abs(x))\n                s = s[::-1]\n                x = int(s) * -1\n                return x if x < 2147483648 else 0\n            else:\n                s = str(x)\n                s = s[::-1]\n                x = int(s)\n                return x if x < 2147483648 else 0"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        MAX_INT = 2 ** 31 - 1\n        MIN_INT = -(2 ** 31)\n        is_negative = x < 0\n        x = abs(x)\n        # \u6b63\u6570\uff0c\u6700\u5927\u6570\u662f2147483647\n        # \u8d1f\u6570\uff0c\u6700\u5927\u6570\u662f-2147483648\n        # \u6bcf\u6b21\u9664\u4ee510\u540e\uff0c\u4f59\u6570\u653e\u5728\u9996\u4f4d\uff0c\u6574\u6570\u7ed3\u679c\u653e\u5728\u540e\u9762\n        # \u6bcf\u6b21\u9664\u4ee510\u540e\uff0c\u8bb0\u5f55\u4f59\u6570\u662f\u5426\u5927\u4e8e9\uff0c\u5982\u679c\u5927\u4e8e\uff0c\u8bf4\u660e\u9700\u8981\u5728\u524d\u9762\u52a0\u4e00\u4e2a0\n        res = 0\n        while x > 0:\n            cur_digit = x % 10\n            if is_negative:\n                cur_digit = -cur_digit\n            if cur_digit < MIN_INT:\n                return 0\n            if res > MAX_INT // 10 + 1 or (res == MAX_INT // 10 + 1 and cur_digit > 8):\n                return 0"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "prompt": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n        Example 1:\n        Input: x = 123\n        Output: 321\n        Example 2:\n        Input: x = -123\n        Output: -321\n        Example 3:\n        Input: x = 120\n        Output: 21\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        x = str(x)\n        if x[0] == '-':\n            flag = -1\n            x = x[1:]\n        else:\n            flag = 1\n        if flag < 0:\n            x = x[::-1]\n            x = x[:-1]\n            x = x[::-1]\n            x = x + '-'\n        else:\n            x = x[::-1]\n            x = x[:-1]\n            x = x[::-1]\n            x = x + '+'\n        if int(x) < -2**31 or int(x) > 2**31 - 1:\n            return 0\n        else:\n            return int(x)"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # Check that the input is not empty\n        if not s:\n            return 0"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # remove leading whitespace\n        s = s.lstrip()\n        if not s:\n            return 0\n        is_negative = s[0] == '-'\n        if is_negative:\n            s = s[1:]\n        elif s[0] == '+':\n            s = s[1:]"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        s = s.strip()\n        sign = 1\n        res = 0\n        if not s:\n            return 0\n        elif s[0] == '-':\n            sign = -1\n            s = s[1:]\n        elif s[0] == '+':\n            s = s[1:]\n        for i in range(len(s)):\n            if not s[i].isdigit():\n                break\n            res = res * 10 + int(s[i])\n        res = res * sign\n        if res < -2 ** 31:\n            return -2 ** 31\n        elif res > 2 ** 31 - 1:\n            return 2 ** 31 - 1\n        else:\n            return res"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not s:\n            return 0\n        s = s.strip()\n        if not s:\n            return 0\n        num = 0\n        negative = False\n        if s[0] == '-':\n            negative = True\n        elif s[0] == '+':\n            negative = False\n        else:\n            negative = False\n            if not s[0].isdigit():\n                return 0\n        for i in s[1:]:\n            if i.isdigit():\n                num = num * 10 + int(i)\n            else:\n                break\n        num = int(-num) if negative else num\n        num = num if num <= 2 ** 31 - 1 else 2 ** 31 - 1\n        return num"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # step 1: ignore leading whitespace\n        start = 0\n        while start < len(s) and s[start] =='':\n            start += 1"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        s = s.strip()\n        if not s:\n            return 0\n        sign = 1\n        if s[0] in '+-':\n            if s[0] == '-':\n                sign = -1\n            s = s[1:]\n        res = 0\n        for c in s:\n            if c.isdigit():\n                res = res*10 + int(c)\n            else:\n                break\n        res *= sign\n        if res < -2**31:\n            return -2**31\n        if res > 2**31 - 1:\n            return 2**31 - 1\n        return res"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # step 1\n        s = s.lstrip()\n        # step 2\n        if len(s) == 0:\n            return 0\n        sign = 1\n        if s[0] == '-':\n            sign = -1\n        elif s[0] == '+':\n            sign = 1\n        elif not s[0].isdigit():\n            return 0\n        # step 3\n        n = len(s)\n        i = 0\n        while i < n and s[i].isdigit():\n            i += 1\n        if i == 0:\n            return 0\n        # step 4\n        ret = 0\n        for c in s[0:i]:\n            ret = ret * 10 + int(c)\n        ret *= sign\n        # step 5\n        if ret > 2**31 - 1:\n            return 2**31 - 1\n        elif ret < -2**31:\n            return -2**31\n        else:\n            return ret"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # general edge cases\n        if len(s) == 0:\n            return 0\n        if len(s) == 1:\n            if s == '-' or s == '+' or s =='':\n                return 0\n            else:\n                return s\n        \n        # for the rest of the cases\n        s = s.lstrip()\n        if s == '':\n            return 0\n        if len(s) == 1:\n            if s == '-' or s == '+' or s =='':\n                return 0\n            else:\n                return s\n        \n        # take care of first step\n        if s[0] == '-':\n            is_negative = True\n            s = s[1:]\n        elif s[0] == '+':\n            is_negative = False\n            s = s[1:]\n        else:\n            is_negative = False\n        if len(s) == 0:\n            return 0\n        \n        # take care of second step\n        if s[0] == '-' or s[0] == '+':\n            return 0\n        if len(s) == 1:\n            if s == '-' or s == '+' or s =='':\n                return 0\n            else:\n                return s\n        \n        # take"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        s = s.strip()\n        sign = 1\n        if s == \"\":\n            return 0\n        if s[0] == \"-\":\n            sign = -1\n            s = s[1:]\n            if s == \"\":\n                return 0\n        if s[0] == \"+\":\n            s = s[1:]\n            if s == \"\":\n                return 0\n        if not s[0].isdigit() and s[0]!= \".\" and s[0]!= \"-\":\n            return 0\n        for i in s:\n            if not i.isdigit():\n                break\n        if i.isdigit():\n            res = int(s[:i]) * sign\n        elif i == \".\":\n            res = int(s[:i]) * sign\n        else:\n            return 0\n        if res > pow(2, 31) - 1:\n            return pow(2, 31) - 1\n        if res < pow(-2, 31):\n            return pow(-2, 31)\n        return res"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n        The algorithm for myAtoi(string s) is as follows:\n            Read in and ignore any leading whitespace.\n            Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n            Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n            Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\n            If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\n            Return the integer as the final result.\n        Note:\n            Only the space character'' is considered a whitespace character.\n            Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n        Example 1:\n        Input: s = \"42\"\n        Output: 42\n        Explanation: The underlined characters are what is read in, the caret is the current reader position.\n        Step 1: \"42\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"42\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"42\" (\"42\" is read in)\n                   ^\n        The parsed integer is 42.\n        Since 42 is in the range [-231, 231 - 1], the final result is 42.\n        Example 2:\n        Input: s = \"   -42\"\n        Output: -42\n        Explanation:\n        Step 1: \"   -42\" (leading whitespace is read and ignored)\n                    ^\n        Step 2: \"   -42\" ('-' is read, so the result should be negative)\n                     ^\n        Step 3: \"   -42\" (\"42\" is read in)\n                       ^\n        The parsed integer is -42.\n        Since -42 is in the range [-231, 231 - 1], the final result is -42.\n        Example 3:\n        Input: s = \"4193 with words\"\n        Output: 4193\n        Explanation:\n        Step 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n                 ^\n        Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n                 ^\n        Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n                     ^\n        The parsed integer is 4193.\n        Since 4193 is in the range [-231, 231 - 1], the final result is 4193.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # strip white space\n        s = s.lstrip()"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if x < 0:\n            return False\n        x_str = str(x)\n        return x_str == x_str[::-1]"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # Solution 1:\n        # return str(x) == str(x)[::-1]"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if x < 0:\n            return False\n        elif x == 0:\n            return True\n        else:\n            num_list = []\n            num_str = str(x)\n            for i in range(len(num_str)):\n                num_list.append(num_str[i])\n            num_list_rev = num_list.copy()\n            num_list_rev.reverse()\n            if num_list == num_list_rev:\n                return True\n            else:\n                return False\n            \n            \nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is palindrome integer, and false otherwise.\n        An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left."
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # note that if you want to check if a number is a palindrome, you need to see if the number is the same as the number in reverse order\n        # thus you can compare the number at each position with the corresponding position in the reversed number\n        # you can use a string to store the number as a string, then convert it to an int to compare\n        # you can use a list to store the number as a list, then convert it to an int to compare\n        # you can use a string and then string manipulation to store the number as a string, then convert it to an int to compare\n        # you can use a list and then list manipulation to store the number as a list, then convert it to an int to compare\n        # you can use a string and then string manipulation to store the number as a string, then convert it to a list to compare\n        # you can use a list and then list manipulation to store the number as a list, then convert it to a string to compare\n        # in all of the above approaches, you can do a constant amount of string manipulation\n        # if you don't want to use a string or list, you can use a boolean variable\n        # if you use a boolean variable, you don't need to do string manipulation\n        # if you use a boolean variable, you don't need to convert the number to either a string or list\n        # if"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if x < 0 or (x % 10 == 0 and x!= 0):\n            return False\n        reverted = 0\n        while x > reverted:\n            reverted = reverted * 10 + x % 10\n            x = x // 10\n        return x == reverted or x == reverted // 10"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        return str(x)[::-1] == str(x)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        return str(x) == str(x)[::-1]"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if x < 0:\n            return False"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if x < 0:\n            return False\n        elif x == 0:\n            return True\n        else:\n            return self.compare(x, 0, len(str(x)) - 1)\n        \n    def compare(self, x, left, right):\n        if left >= right:\n            return True\n        if not x // 10**(right - left + 1):\n            return False\n        if x // 10**(right - left + 1) % 10!= x // 10**(right - left) % 10:\n            return False\n        return self.compare(x, left + 1, right - 1)\n        \n        \nif __name__ == '__main__':\n    x = 10\n    solution = Solution()\n    print(solution.isPalindrome(x))\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Given an integer x, return true if x is a palindrome, and false otherwise.\n        Example 1:\n        Input: x = 121\n        Output: true\n        Explanation: 121 reads as 121 from left to right and from right to left.\n        Example 2:\n        Input: x = -121\n        Output: false\n        Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n        Example 3:\n        Input: x = 10\n        Output: false\n        Explanation: Reads 01 from right to left. Therefore it is not a palindrome.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if x < 0:\n            return False"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if p == \"\":\n            return not s"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        self.memo = {}\n        return self.is_match_helper(s, p, 0, 0)\n        \n    def is_match_helper(self, s, p, s_ind, p_ind):\n        key = (s_ind, p_ind)\n        if key in self.memo:\n            return self.memo[key]\n        if s_ind == len(s) and p_ind == len(p):\n            return True\n        if s_ind < len(s) and p_ind == len(p):\n            return False\n        if p_ind+1 < len(p) and p[p_ind+1] == '*':\n            is_match = (self.is_match_helper(s, p, s_ind, p_ind+2) or\n                        self.is_match_helper(s, p, s_ind+1, p_ind) and\n                        (s[s_ind] == p[p_ind] or p[p_ind] == '.'))\n            self.memo[key] = is_match\n            return is_match\n        if p_ind < len(p) and (p_ind+1 < len(p) and p[p_ind+1] == '*'):"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # we need to match the exact length\n        if len(s)!= len(p):\n            return False"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        # find how many chars in p\n        # find how many chars in s\n        \n        # store a bool array of where the pattern matches the string\n        # start with all false\n        \n        p_len = len(p)\n        s_len = len(s)\n        \n        if p_len == 0 and s_len == 0:\n            return True\n        \n        elif s_len == 0:\n            if p_len > 1:\n                if p[1] == \"*\":\n                    return self.isMatch(s, p[2:])\n                else:\n                    return False\n            else:\n                return False\n        \n        elif p_len == 0:\n            return False\n        \n        else:\n            # if p char is *\n            if p[0] == \"*\":\n                # if p[1] is a single char\n                if len(p) >= 2 and p[1]!= \"*\":\n                    # if p[1] is s[0]\n                    if len(p) == 2:\n                        if p[1] == s[0]:\n                            return True\n                        else:\n                            return False\n                    else:\n                        if p[1] == s[0] or p[1] == \".\":\n                            return self.isMatch(s"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(p) == 0:\n            return len(s) == 0\n        first_match = len(s) > 0 and (p[0] == '.' or p[0] == s[0])\n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if p == '.*':\n            return True"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # a*c*a*a\n        # a*c*a*a?\n        #\n        # a*a*\n        # a*a*?\n        #\n        # *\n        # *?"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        return self.dfs(s, 0, p, 0, {})"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n            '.' Matches any single character.\u200b\u200b\u200b\u200b\n            '*' Matches zero or more of the preceding element.\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"a*\"\n        Output: true\n        Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n        Example 3:\n        Input: s = \"ab\", p = \".*\"\n        Output: true\n        Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        left = 0\n        right = len(height) - 1\n        max_area = 0"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # Brute force. Just compare every two heights\n        maxArea = 0\n        for i in range(len(height)):\n            for j in range(i + 1, len(height)):\n                area = (j - i) * min(height[i], height[j])\n                if area > maxArea:\n                    maxArea = area\n        return maxArea\n    \"\"\"\n    Approach: Two pointer\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\""
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if len(height) < 2: return 0\n        # brute force:\n        # max_area = 0\n        # for i in range(len(height) - 1):\n        #     for j in range(i + 1, len(height)):\n        #         h = min(height[i], height[j])\n        #         max_area = max(max_area, h * (j - i))\n        # return max_area\n        # time complexity: O(n^2), space complexity: O(1)\n        \n        # two pointers:\n        # time complexity: O(n), space complexity: O(1)\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        while left < right:\n            area = (right - left) * min(height[left], height[right])\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \"\"\"\n        DP[i] is the max area we can have after i vertical lines are put into the container.\n        So we have two conditions:\n        1. if height[i] is less than height[i-1], then we can't put vertical line i into the container, \n            otherwise, we can.\n        2. for i-1 vertical lines, we know the area, then we can figure out what is the area for i vertical lines\n        \"\"\"\n        max_area = 0\n        for i in range(1, len(height)):\n            if height[i] < height[i-1]:\n                continue\n            # we can put i vertical lines into the container\n            area = min(height[i-1], height[i]) * (i)\n            # maximize area by putting vertical lines i-1 and i into the container\n            area = max(area, self.maxArea(height[:i-1]) + self.maxArea(height[i:]))\n            max_area = max(max_area, area)\n        return max_area"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        left_max_area = 0\n        right_max_area = 0\n        left_max_height = 0\n        right_max_height = 0\n        max_area = 0\n        for h in height:\n            left_max_area = max(left_max_area, h * (len(height) - 1 - height[::-1].index(h)))\n            right_max_area = max(right_max_area, h * (height.index(h)))\n            left_max_height = max(left_max_height, h)\n            right_max_height = max(right_max_height, h)\n            max_area = max(max_area, min(left_max_height, right_max_height) * (len(height) - 1))\n        return max_area\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        left = 0\n        right = len(height) - 1\n        max_area = 0\n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        left = 0\n        right = len(height) - 1\n        max_water = 0\n        while left < right:\n            max_water = max(max_water, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_water\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Two pointers \n        # https://leetcode.com/problems/container-with-most-water/solution/\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            # Calculate the max_area \n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            # Move pointer which has larger value\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        #  Brute force\n        #  Time complexity: O(n^2)\n        #  Space complexity: O(1)\n        #  maxArea = 0\n        #  for i in range(0, len(height)):\n        #      for j in range(i+1, len(height)):\n        #          tempArea = (j-i) * min(height[i], height[j])\n        #          if tempArea > maxArea:\n        #              maxArea = tempArea\n        #  return maxArea"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        \"\"\"\n        You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        Return the maximum amount of water a container can store.\n        Notice that you may not slant the container.\n        Example 1:\n        Input: height = [1,8,6,2,5,4,8,3,7]\n        Output: 49\n        Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n        Example 2:\n        Input: height = [1,1]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        i, j = 0, len(height) - 1\n        ans = 0\n        while i < j:\n            ans = max(ans, (j - i) * min(height[i], height[j]))\n            if height[i] < height[j]:\n                i += 1\n            else:\n                j -= 1\n        return ans"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        roman = {\n            1: \"I\",\n            5: \"V\",\n            10: \"X\",\n            50: \"L\",\n            100: \"C\",\n            500: \"D\",\n            1000: \"M\"\n        }\n        n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        i = 0\n        result = \"\"\n        while i < len(n):\n            if num // n[i]!= 0:\n                count = num // n[i]\n                result += roman[n[i]] * count\n                num = num % n[i]\n            i += 1\n        return result"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        \"\"\"\n        1: \n        num_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        str_list = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n        \"\"\"\n        \"\"\"\n        2: \n        num_list = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n        str_list = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']\n        \"\"\"\n        \"\"\"\n        3: \n        num_list = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        str_list = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n        \"\"\"\n        \n        \"\"\"\n        4: \n        num_list = [1, 2, 3, 4, 5, 9,"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        mappings = {\n            1000: 'M', 900: 'CM', 500: 'D', 400: 'CD',\n            100: 'C', 90: 'XC', 50: 'L', 40: 'XL',\n            10: 'X', 9: 'IX', 5: 'V', 4: 'IV',\n            1: 'I',\n        }\n        \n        result = ''\n        for key in sorted(mappings.keys(), reverse=True):\n            while num >= key:\n                num -= key\n                result += mappings[key]\n        return result"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        # 1, 2, 3, 4, 5, 6, 7, 8, 9\n        symbol_list = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n        \n        symbol_dic = {\n            1000 : symbol_list[6],\n            900 : symbol_list[7],\n            500 : symbol_list[4],\n            400 : symbol_list[8],\n            100 : symbol_list[2],\n            90 : symbol_list[9],\n            50 : symbol_list[5],\n            40 : symbol_list[3],\n            10 : symbol_list[1],\n            9 : symbol_list[0],\n            5 : symbol_list[7],\n            4 : symbol_list[8],\n            1 : symbol_list[2],\n            0 : symbol_list[1],\n        }\n        \n        ans = ''\n        \n        while num > 0:\n            for key, value in symbol_dic.items():\n                if num >= key:\n                    ans += value\n                    num -= key\n                    break\n            \n        return ans\n            \n        # ==========================================================\n        \"\"\"\n        https://leetcode.com/"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # key: roman symbol, value: integer\n        roman = {'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 'IV':4, 'I':1}\n        \n        # loop through the dictionary and add each key to the res\n        res = ''\n        for key in roman:\n            while num >= roman[key]:\n                res += key\n                num -= roman[key]\n        return res"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        roman_numerals = {1000: \"M\", 900: \"CM\", 500: \"D\", 400: \"CD\", 100: \"C\", 90: \"XC\", 50: \"L\", 40: \"XL\", 10: \"X\", 9: \"IX\", 5: \"V\", 4: \"IV\", 1: \"I\"}\n        result = []\n        for value, symbol in roman_numerals.items():\n            if num == 0:\n                break\n            count, num = divmod(num, value)\n            result.append(symbol * count)\n        return \"\".join(result)"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        ROMAN_DIGITS = {\n            1: 'I',\n            4: 'IV',\n            5: 'V',\n            9: 'IX',\n            10: 'X',\n            40: 'XL',\n            50: 'L',\n            90: 'XC',\n            100: 'C',\n            400: 'CD',\n            500: 'D',\n            900: 'CM',\n            1000: 'M',\n        }"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        ROMAN_DICT = {'M': 1000, 'CM': 900, 'D': 500, 'CD': 400,\n                      'C': 100, 'XC': 90, 'L': 50, 'XL': 40,\n                      'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1}\n        roman_numeral = ''\n        for key in ROMAN_DICT:\n            while num >= ROMAN_DICT[key]:\n                roman_numeral += key\n                num -= ROMAN_DICT[key]\n        return roman_numeral\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "prompt": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.\n        Example 1:\n        Input: num = 3\n        Output: \"III\"\n        Explanation: 3 is represented as 3 ones.\n        Example 2:\n        Input: num = 58\n        Output: \"LVIII\"\n        Explanation: L = 50, V = 5, III = 3.\n        Example 3:\n        Input: num = 1994\n        Output: \"MCMXCIV\"\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        roman = {\n            1: 'I',\n            5: 'V',\n            10: 'X',\n            50: 'L',\n            100: 'C',\n            500: 'D',\n            1000: 'M'\n        }"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        roman_numerals = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n        }\n        res = 0\n        for i, c in enumerate(s):\n            if i + 1 < len(s) and roman_numerals[s[i]] < roman_numerals[s[i+1]]:\n                res -= roman_numerals[s[i]]\n            else:\n                res += roman_numerals[s[i]]\n        return res"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        num = 0\n        roman_map = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n            'IV': 4,\n            'IX': 9,\n            'XL': 40,\n            'XC': 90,\n            'CD': 400,\n            'CM': 900,\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000,\n            'IV': 4,\n            'IX': 9,\n            'XL': 40,\n            'XC': 90,\n            'CD': 400,\n            'CM': 900,\n        }\n        for i in range(len(s)):\n            if s[i:i+2] in roman_map:\n                num += roman_map[s[i:i+2]]\n                i += 2\n            else:\n                num += roman_map[s[i]]\n                i += 1\n        return num\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        roman = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        res = 0\n        for i in range(len(s)):\n            if i > 0 and roman[s[i]] > roman[s[i-1]]:\n                res += roman[s[i]] - 2*roman[s[i-1]]\n            else:\n                res += roman[s[i]]\n        return res\n        \n# @lc code=end"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        roman_dict = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000,\n            \"IV\": 4,\n            \"IX\": 9,\n            \"XL\": 40,\n            \"XC\": 90,\n            \"CD\": 400,\n            \"CM\": 900\n        }"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        d = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        l = len(s)\n        sum = 0\n        for i in range(0, l):\n            if i < l-1 and d[s[i]] < d[s[i+1]]:\n                sum -= d[s[i]]\n            else:\n                sum += d[s[i]]\n        return sum"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        mapper = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}\n        num = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and s[i:i+2] in mapper:\n                num += mapper[s[i:i+2]]\n                i += 2\n            else:\n                num += mapper[s[i]]\n                i += 1\n        return num"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # M\n        # C\n        # X\n        # L\n        # V\n        # I\n        # => M C X C V I\n        # => 2\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        # => C = 100\n        # => X = 10\n        # => L = 50\n        # => V = 5\n        # => I = 1\n        # => M = 1000\n        #"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        dict_roman = {\n            'M': 1000,\n            'D': 500,\n            'C': 100,\n            'L': 50,\n            'X': 10,\n            'V': 5,\n            'I': 1\n        }\n        roman = s\n        total = 0\n        if roman[0] == 'I':\n            for i in roman:\n                if i == 'V' or i == 'X':\n                    total -= 1\n                    break\n                total += dict_roman[i]\n        else:\n            total += dict_roman[roman[0]]\n            roman = roman[1:]"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        ROMAN_MAP = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000\n        }\n        ret = 0\n        s = s.replace(\"IV\", \"IIII\").replace(\"IX\", \"VIIII\")\n        s = s.replace(\"XL\", \"XXXX\").replace(\"XC\", \"LXXXX\")\n        s = s.replace(\"CD\", \"CCCC\").replace(\"CM\", \"DCCCC\")\n        for ch in s:\n            ret += ROMAN_MAP[ch]\n        return ret\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "prompt": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n            I can be placed before V (5) and X (10) to make 4 and 9. \n            X can be placed before L (50) and C (100) to make 40 and 90. \n            C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.\n        Example 1:\n        Input: s = \"III\"\n        Output: 3\n        Explanation: III = 3.\n        Example 2:\n        Input: s = \"LVIII\"\n        Output: 58\n        Explanation: L = 50, V= 5, III = 3.\n        Example 3:\n        Input: s = \"MCMXCIV\"\n        Output: 1994\n        Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        dic_roman_numeral_values = {\n            \"I\": 1,\n            \"V\": 5,\n            \"X\": 10,\n            \"L\": 50,\n            \"C\": 100,\n            \"D\": 500,\n            \"M\": 1000,\n        }\n        total_value = 0\n        if not s:\n            return 0\n        for i in range(len(s)):\n            if i > 0 and dic_roman_numeral_values[s[i]] > dic_roman_numeral_values[s[i - 1]]:\n                total_value += dic_roman_numeral_values[s[i]] - 2 * dic_roman_numeral_values[s[i - 1]]\n            else:\n                total_value += dic_roman_numeral_values[s[i]]\n        return total_value"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not strs:\n            return \"\"\n        res = strs[0]\n        for str in strs:\n            str_len = min(len(res), len(str))\n            for i in range(str_len):\n                if res[i]!= str[i]:\n                    res = res[:i]\n                    break\n            res = res[:str_len]\n        return res"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if len(strs) == 0:\n            return \"\"\n        if len(strs) == 1:\n            return strs[0]\n        ans = strs[0]\n        for i in range(1, len(strs)):\n            ans = self.longestCommonPrefix(ans, strs[i])\n            if len(ans) == 0:\n                return \"\"\n        return ans"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        min_len = min([len(string) for string in strs])\n        # if all chars in first string are unique, and also all chars in second string are unique, and so on....\n        if min_len == 0:\n            return \"\"\n        # check if all strings have the same length\n        if len(set([len(string) for string in strs])) == 1:\n            return strs[0][:min_len]\n        else:\n            # at least 2 strings are different in length\n            prefix = \"\"\n            for i in range(min_len):\n                # check if all chars in first string are unique, and also all chars in second string are unique, and so on....\n                if len(set([string[i] for string in strs])) == 1:\n                    prefix += strs[0][i]\n                else:\n                    break\n            return prefix"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if len(strs) == 0:\n            return \"\"\n        if len(strs) == 1:\n            return strs[0]\n        longest_prefix = \"\"\n        min_str_length = float('inf')\n        for s in strs:\n            min_str_length = min(min_str_length, len(s))\n        for i in range(min_str_length):\n            current_letter = strs[0][i]\n            for s in strs:\n                if s[i]!= current_letter:\n                    return longest_prefix\n            longest_prefix = longest_prefix + current_letter\n        return longest_prefix"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not strs:\n            return ''\n        n = min(len(i) for i in strs)\n        i = 0\n        while i < n:\n            for j in range(1, len(strs)):\n                if strs[0][i]!= strs[j][i]:\n                    return strs[0][:i]\n            i += 1\n        return strs[0][:i]"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Method 1: Brute Force, Time: O(s1*s2*..sn) Space: O(1)\n        # if len(strs) == 0:\n        #     return ''\n        # result = []\n        # for i in range(len(strs[0])):\n        #     temp = strs[0][i]\n        #     for j in range(1, len(strs)):\n        #         if i >= len(strs[j]) or strs[j][i]!= temp:\n        #             return ''.join(result)\n        #     result.append(temp)\n        # return ''.join(result)\n        \n        # Method 2: Divide and Conquer, Time: O(s1*s2*..sn) Space: O(1)\n        if len(strs) == 0:\n            return ''\n        elif len(strs) == 1:\n            return strs[0]\n        else:\n            mid = len(strs)//2\n            lcp_left = self.longestCommonPrefix(strs[:mid])\n            lcp_right = self.longestCommonPrefix(strs[mid:])\n            return self.findLCP(strs, lcp_left, lcp_right)\n"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if len(strs) == 0:\n            return \"\"\n        if len(strs) == 1:\n            return strs[0]\n        strs = sorted(strs, key=len)\n        if len(strs[0]) == 0:\n            return \"\"\n        i = 0\n        while i < len(strs[0]):\n            for j in range(1, len(strs)):\n                if strs[j][i]!= strs[0][i]:\n                    return strs[0][:i]\n            i += 1\n        return strs[0][:i]"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not strs:\n            return \"\"\n        prefix = strs[0]\n        for str in strs[1:]:\n            for i in range(min(len(prefix), len(str))):\n                if prefix[i]!= str[i]:\n                    prefix = prefix[:i]\n                    break\n        return prefix"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if len(strs) == 0: return \"\"\n        \n        l = list(zip(*strs))\n        \n        \n        def helper(x):\n            if len(x) == 1:\n                return x[0]\n            res = \"\"\n            for i in range(len(x)):\n                if i == 0:\n                    res += x[i]\n                else:\n                    if x[i] == x[i-1]:\n                        res += x[i]\n                    else:\n                        break\n            return res\n        \n        return helper(l)\n        \n        \n    def longestCommonPrefix_brute_force(self, strs: List[str]) -> str:\n        if len(strs) == 0: return \"\"\n        \n        res = \"\"\n        for i in range(len(strs[0])):\n            for j in range(len(strs)):\n                if i == len(strs[j]) or strs[j][i]!= strs[0][i]:\n                    return res\n            res += strs[0][i]\n        return res\n    \n    def longestCommonPrefix_short_hashmap(self, strs: List[str]) -> str:\n        if len(strs) == 0: return \"\"\n        \n        res"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "prompt": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".\n        Example 1:\n        Input: strs = [\"flower\",\"flow\",\"flight\"]\n        Output: \"fl\"\n        Example 2:\n        Input: strs = [\"dog\",\"racecar\",\"car\"]\n        Output: \"\"\n        Explanation: There is no common prefix among the input strings.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if len(strs) == 0: return ''\n        s = strs[0]\n        for i in range(1, len(strs)):\n            s = self.lcp(s, strs[i])\n            if len(s) == 0:\n                break\n        return s"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        res = []\n        # nums.sort()\n        nums.sort()\n        n = len(nums)\n        for i in range(n-2):\n            if nums[i] > 0:\n                break\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            j = i+1\n            k = n-1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s < 0:\n                    j += 1\n                elif s > 0:\n                    k -= 1\n                else:\n                    res.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j+1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k-1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n        return res\n    \n    \n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        nums.sort()\n        length = len(nums)\n        # i: the index of nums\n        # j: the index of the array after nums\n        # last_seen: last seen index of a pair which is the same as current value\n        result = []\n        for i in range(length-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            # 2 pointers, 2 sum\n            j = i + 1\n            last_seen = {}\n            while j < length:\n                # skip duplicates\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    j += 1\n                    continue\n                # nums[i] + nums[j] + nums[end] = 0\n                two_sum = nums[i] + nums[j]\n                if two_sum in last_seen:\n                    # we have seen a pair of values that equals to two_sum\n                    # we only need to find the other value\n                    # and add the pair into the result\n                    result.append([nums[i], nums[last_seen[two_sum]], nums[j]])\n                    # skip duplicates\n                    while j + 1 < length and nums[j] == num"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        ans = []\n        nums.sort()\n        n = len(nums)\n        if n < 3:\n            return ans\n        \n        # O(n^2)\n        for i in range(n-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            l, r = i + 1, n - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    ans.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    l += 1\n        return ans\n        \n    \n    def threeSum_O1(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        def twosum(arr, target):\n            s = set()\n            for num in arr:\n                if num in s:\n                    return True\n                s.add(target - num)\n            return False\n        nums.sort()\n        ans = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    ans.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return ans"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # [[-4,-1,1,2],[-4,0,1,3],[-4,0,2,3],[-4,0,1,3],[-4,-1,1,2],[-4,0,2,3],[-4,0,3,3],[-4,-1,1,3],[-4,0,3,3],[-4,-1,2,3]]\n        # [[-4,0,1,2],[-4,-1,0,3],[-4,0,1,3],[-4,0,2,3],[-4,0,3,3],[-4,0,1,3],[-4,1,0,2],[-4,1,0,3],[-4,1,2,3],[-4,1,3,3],[-4,2,0,3],[-4,2,1,3],[-4,2,3,3],[-4,3,0,3],[-4,3,1,2],[-4,3,2,3]]\n        # sorted list to search through\n        # brute force\n        # set to remove duplicates\n        # sort list\n        # remove duplicates\n        # set triplet\n        # return list"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        nums.sort()\n        N = len(nums)\n        res = []\n        for i in range(N):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            target = nums[i] * -1\n            l = i + 1\n            r = N - 1\n            while l < r:\n                if nums[l] + nums[r] == target:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n                elif nums[l] + nums[r] < target:\n                    l += 1\n                else:\n                    r -= 1\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        nums.sort()\n        triplets = []\n        for i, x in enumerate(nums):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    triplets.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return triplets"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Solution 1\n        # twoSumHashmap = {}\n        # for i, num in enumerate(nums):\n        #     if num in twoSumHashmap:\n        #         twoSumHashmap[num].append(i)\n        #     else:\n        #         twoSumHashmap[num] = [i]\n        # triplets = []\n        # for key in twoSumHashmap.keys():\n        #     i = twoSumHashmap[key][0]\n        #     for j in twoSumHashmap[key][1:]:\n        #         if -key*2 == nums[j] + nums[i]:\n        #             triplets.append([key, nums[j], nums[i]])\n        # return triplets\n        \n        # Solution 2\n        # O(n^2) time, O(1) space\n        result = []\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                break\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l]"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i!= j, i!= k, and j!= k, and nums[i] + nums[j] + nums[k] == 0.\n        Notice that the solution set must not contain duplicate triplets.\n        Example 1:\n        Input: nums = [-1,0,1,2,-1,-4]\n        Output: [[-1,-1,2],[-1,0,1]]\n        Explanation: \n        nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n        nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n        nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n        The distinct triplets are [-1,0,1] and [-1,-1,2].\n        Notice that the order of the output and the order of the triplets does not matter.\n        Example 2:\n        Input: nums = [0,1,1]\n        Output: []\n        Explanation: The only possible triplet does not sum up to 0.\n        Example 3:\n        Input: nums = [0,0,0]\n        Output: [[0,0,0]]\n        Explanation: The only possible triplet sums up to 0.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        nums.sort()\n        sol = []\n        # Start the left and right pointers at the first and last element respectively\n        # i.e. L = 0 and R = len(nums)-1\n        L = 0\n        R = len(nums)-1\n        # Set the initial sum to be zero\n        sum = 0\n        # Loop through the array\n        while L < R:\n            # Sum the first element and second element and check if it is zero.\n            # If it is zero, then append the array [0,0,0] to the solution list.\n            if nums[L] + nums[R] == 0:\n                sol.append([nums[L],nums[R],0])\n                # Move the left pointer to the right to ensure we don't have duplicates\n                L += 1\n                R -= 1\n            # If the sum is greater than zero, then move the right pointer to the left.\n            # This is because we want to move the left pointer to the right and vice versa.\n            elif nums[L] + nums[R] > 0:\n                R -= 1\n            # If the sum is less than zero, then move the left pointer to the right.\n            # This is because we want to move the right pointer to the left and vice versa.\n            else"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        nums.sort()\n        s, min_diff = 0, float('inf')\n        for i, v in enumerate(nums[:-2]):\n            if i > 0 and v == nums[i - 1]:\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = v + nums[left] + nums[right]\n                if abs(s - target) < min_diff:\n                    min_diff = abs(s - target)\n                    solution = s\n                if s > target:\n                    right -= 1\n                elif s < target:\n                    left += 1\n                else:\n                    return s\n        return solution"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        diff = float('inf')\n        for i in range(n):\n            l = i + 1\n            r = n - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(diff - target):\n                    diff = s - target\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return target\n        return target + diff\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        nums.sort()\n        res = None\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sums = nums[i] + nums[left] + nums[right]\n                if res is None or abs(sums - target) < abs(res - target):\n                    res = sums\n                if sums < target:\n                    left += 1\n                elif sums > target:\n                    right -= 1\n                else:\n                    return target\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        nums.sort()\n        n = len(nums)\n        best_diff = float('inf')\n        for i in range(n-2):\n            left = i+1\n            right = n-1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if abs(total - target) < best_diff:\n                    best_diff = abs(total - target)\n                    result = total\n                if total - target < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        nums.sort()\n        min_diff = 1000000\n        min_diff_sum = 0\n        for i in range(len(nums)-2):\n            left, right = i+1, len(nums)-1\n            while left < right:\n                s = nums[left] + nums[right] + nums[i]\n                if abs(s - target) < min_diff:\n                    min_diff = abs(s - target)\n                    min_diff_sum = s\n                if s == target:\n                    return target\n                elif s > target:\n                    right -= 1\n                else:\n                    left += 1\n        return min_diff_sum"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        nums.sort()\n        print(nums)\n        l = len(nums)\n        closest_sum = 0\n        diff = 0\n        for i in range(0,l-2):\n            j = i+1\n            k = l-1\n            while j < k:\n                s = nums[i]+nums[j]+nums[k]\n                if s == target:\n                    return s\n                elif abs(s-target) < diff or (abs(s-target) == diff and s < closest_sum):\n                    closest_sum = s\n                    diff = abs(s-target)\n                    if closest_sum > 0:\n                        return closest_sum\n                elif s > target:\n                    k = k-1\n                else:\n                    j = j+1\n        return closest_sum\n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # sort the list\n        nums.sort()\n        # initialize the output\n        curr_min = abs(nums[0] + nums[1] + nums[2] - target)\n        result = nums[0] + nums[1] + nums[2]\n        # iterate over the list\n        for i in range(len(nums) - 2):\n            # skip the duplicates\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            # set the left and right pointers\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                # calculate the sum\n                curr_sum = nums[i] + nums[left] + nums[right]\n                # update the current minimum\n                curr_min = min(curr_min, abs(curr_sum - target))\n                # check if the sum is closer than the current min\n                if curr_sum == target:\n                    return curr_sum\n                # update the current sum if closer than the current min\n                if abs(curr_sum - target) < curr_min:\n                    result = curr_sum\n                # move left to the right\n                elif curr_sum"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        nums.sort()\n        output = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                temp = nums[i] + nums[l] + nums[r]\n                if temp == target:\n                    return target\n                elif abs(temp - target) < abs(output - target):\n                    output = temp\n                if temp < target:\n                    l += 1\n                else:\n                    r -= 1\n        return output\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        nums.sort()\n        length = len(nums)\n        closest_sum = float('inf')\n        for i in range(length - 2):\n            j, k = i + 1, length - 1\n            while j < k:\n                three_sum = nums[i] + nums[j] + nums[k]\n                if abs(three_sum - target) < abs(closest_sum - target):\n                    closest_sum = three_sum\n                if three_sum < target:\n                    j += 1\n                elif three_sum > target:\n                    k -= 1\n                else:\n                    return three_sum"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "prompt": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n        Return the sum of the three integers.\n        You may assume that each input would have exactly one solution.\n        Example 1:\n        Input: nums = [-1,2,1,-4], target = 1\n        Output: 2\n        Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n        Example 2:\n        Input: nums = [0,0,0], target = 1\n        Output: 0\n        Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        nums.sort()\n        ans = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            j = i+1\n            k = len(nums) - 1\n            while j < k:\n                threeSum = nums[i] + nums[j] + nums[k]\n                if abs(target - threeSum) < abs(target - ans):\n                    ans = threeSum\n                if threeSum < target:\n                    j += 1\n                else:\n                    k -= 1\n        return ans\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if digits == \"\":\n            return []"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        if len(digits) == 0:\n            return []\n        \n        d = {\n            \"2\": [\"a\",\"b\",\"c\"],\n            \"3\": [\"d\",\"e\",\"f\"],\n            \"4\": [\"g\",\"h\",\"i\"],\n            \"5\": [\"j\",\"k\",\"l\"],\n            \"6\": [\"m\",\"n\",\"o\"],\n            \"7\": [\"p\",\"q\",\"r\",\"s\"],\n            \"8\": [\"t\",\"u\",\"v\"],\n            \"9\": [\"w\",\"x\",\"y\",\"z\"],\n        }\n        output = [\"\"]\n        \n        for n in digits:\n            new_output = []\n            for prev in output:\n                for next_letter in d[n]:\n                    new_output.append(prev + next_letter)\n            output = new_output\n        \n        return output\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        phoneMap = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r','s'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        combinations = []\n        \n        if len(digits) > 0:\n            self.recursiveHelper(combinations, digits, phoneMap, \"\", 0)\n        \n        return combinations\n        \n    def recursiveHelper(self, combinations, digits, phoneMap, currentString, index):\n        if index == len(digits):\n            combinations.append(currentString)\n            return\n        \n        for char in phoneMap[digits[index]]:\n            self.recursiveHelper(combinations, digits, phoneMap, currentString + char, index + 1)\n        \n        <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if len(digits)==0:\n            return []\n        mapping = {2:'abc',3:'def',4:'ghi',5:'jkl',6:'mno',7:'pqrs',8:'tuv',9:'wxyz'}\n        def backtrack(mapping, digits, path, res):\n            if not digits:\n                res.append(path)\n            else:\n                for letter in mapping[int(digits[0])]:\n                    backtrack(mapping,digits[1:],path+letter,res)\n        res = []\n        backtrack(mapping,digits,'',res)\n        return res"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        def phone_num(nums, res, temp, i, j):\n            if i == len(nums):\n                res.append(temp)\n                return\n            for c in range(len(num[i])):\n                phone_num(nums, res, temp + num[i][c], i+1, j)"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not digits:\n            return []\n        d = {\"2\":\"abc\",\n             \"3\":\"def\",\n             \"4\":\"ghi\",\n             \"5\":\"jkl\",\n             \"6\":\"mno\",\n             \"7\":\"pqrs\",\n             \"8\":\"tuv\",\n             \"9\":\"wxyz\"}\n        res = ['']\n        for s in digits:\n            res = [x + y for x in res for y in d[s]]\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Creating the dictionary for all the phone numbers\n        phone = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"}\n        output = []"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not digits:\n            return []\n        \n        result = []\n        digits_mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6':'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        self.dfs(digits_mapping, digits, '', result)\n        return result\n    \n    def dfs(self, mapping, digits, path, result):\n        if not digits:\n            result.append(path)\n            return \n        for letter in mapping[digits[0]]:\n            self.dfs(mapping, digits[1:], path + letter, result)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if digits == \"\":\n            return []\n        self.m = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r','s'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z'],\n        }\n        self.ans = []\n        self.dfs(digits, 0, \"\")\n        return self.ans"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "prompt": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        \"\"\"\n        Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n        A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n        Example 1:\n        Input: digits = \"23\"\n        Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n        Example 2:\n        Input: digits = \"\"\n        Output: []\n        Example 3:\n        Input: digits = \"2\"\n        Output: [\"a\",\"b\",\"c\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if digits == \"\":\n            return []\n        \n        nums = {\n            \"2\": [\"a\", \"b\", \"c\"],\n            \"3\": [\"d\", \"e\", \"f\"],\n            \"4\": [\"g\", \"h\", \"i\"],\n            \"5\": [\"j\", \"k\", \"l\"],\n            \"6\": [\"m\", \"n\", \"o\"],\n            \"7\": [\"p\", \"q\", \"r\", \"s\"],\n            \"8\": [\"t\", \"u\", \"v\"],\n            \"9\": [\"w\", \"x\", \"y\", \"z\"],\n        }\n        \n        result = []\n        self.backtrack(digits, nums, [], result)\n        return result\n    \n    def backtrack(self, digits, nums, curr, result):\n        if len(curr) == len(digits):\n            result.append(\"\".join(curr))\n            return\n        \n        for letter in nums[digits[len(curr)]]:\n            curr.append(letter)\n            self.backtrack(digits, nums, curr, result)\n            curr.pop()\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        ans = []\n        nums.sort()\n        for i in range(0, len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, len(nums) - 1\n                while left < right:\n                    sum = nums[i] + nums[j] + nums[left] + nums[right]\n                    if sum < target:\n                        left += 1\n                    elif sum > target:\n                        right -= 1\n                    else:\n                        ans.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n        return ans"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not nums or len(nums) < 4:\n            return []\n        nums.sort()\n        result = []\n        for i in range(len(nums)-3):\n            if i!= 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1,len(nums)-2):\n                if j!= i + 1 and nums[j] == nums[j-1]:\n                    continue\n                l = j + 1\n                r = len(nums) - 1\n                while l < r:\n                    sum_ = nums[i] + nums[j] + nums[l] + nums[r]\n                    if sum_ == target:\n                        result.append([nums[i],nums[j],nums[l],nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif sum_ < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return result"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # No solution\n        if not nums or len(nums) < 4:\n            return []\n        # Hash map to store the frequencies of each number\n        freq_map = dict()\n        # Hash set to store all possible combinations\n        hash_set = set()\n        # Get the frequencies of each number\n        for num in nums:\n            freq_map[num] = freq_map.get(num, 0) + 1\n        # The number of unique combinations\n        num_combinations = 0\n        # All possible combinations\n        for a in freq_map:\n            for b in freq_map:\n                if a!= b:\n                    num_combinations += freq_map.get(a) * freq_map.get(b)\n                    # The sum of all combinations is greater than the target\n                    if a + b + a + b > target:\n                        break\n        # Backtracking\n        def backtrack(curr_combo, left_freq, target_sum):\n            nonlocal hash_set, num_combinations\n            # All possible combinations have been found\n            if target_sum == 0 and len(curr_combo) == 4:\n                hash_set.add(tuple(sorted(curr_combo)))\n                return\n            # Not"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        #Brute force O(N3)\n        if len(nums) < 4:\n            return []\n        res = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    for l in range(k+1, len(nums)):\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                            if sorted([nums[i], nums[j], nums[k], nums[l]]) not in res:\n                                res.append(sorted([nums[i], nums[j], nums[k], nums[l]]))\n        return res"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if len(nums) < 4:\n            return []\n        if len(nums) == 4:\n            if sum(nums) == target:\n                return [nums]\n            return []"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        def findNsum(nums, target, N, result, results):\n            if len(nums) < N or N < 2 or target < nums[0] * N or target > nums[-1] * N:  # early termination\n                return\n            if N == 2: # two pointers solve sorted 2-sum problem\n                l, r = 0, len(nums) - 1\n                while l < r:\n                    s = nums[l] + nums[r]\n                    if s == target:\n                        results.append(result + [nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l - 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r + 1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n            else: # recursively reduce N\n                for i in range(len(nums) - N + 1):\n                    if i == 0 or (i > 0 and nums[i - 1]!= nums[i]):\n                        findNsum(nums[i + 1:], target - nums[i], N - 1,"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \n        if len(nums) < 4:\n            return []\n        nums = sorted(nums)\n        result = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    continue\n                l = j + 1\n                r = len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n        return result\n    \n    def fourSum2(self, nums: List[int"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        n = len(nums)\n        if n < 4:\n            return []\n        nums.sort()\n        res = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                l = j + 1\n                r = n - 1\n                while l < r:\n                    temp = nums[i] + nums[j] + nums[l] + nums[r]\n                    if temp == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l + 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r - 1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n                    elif temp < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Sort the numbers in the array\n        nums.sort()"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n            0 <= a, b, c, d < n\n            a, b, c, and d are distinct.\n            nums[a] + nums[b] + nums[c] + nums[d] == target\n        You may return the answer in any order.\n        Example 1:\n        Input: nums = [1,0,-1,0,-2,2], target = 0\n        Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n        Example 2:\n        Input: nums = [2,2,2,2,2], target = 8\n        Output: [[2,2,2,2]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # first sort the array\n        nums.sort()\n        # store all the quadruplets that we have found so far\n        quadruplets = []\n        # iterate through the list\n        for i in range(len(nums)):\n            # iterate through the list again\n            for j in range(i+1, len(nums)):\n                # iterate through the list again\n                for k in range(j+1, len(nums)):\n                    # iterate through the list again\n                    for l in range(k+1, len(nums)):\n                        # calculate the sum of the current quadruplet\n                        current_sum = nums[i] + nums[j] + nums[k] + nums[l]\n                        # if the current sum is equal to the target, then we have found a quadruplet\n                        if current_sum == target:\n                            # if the quadruplet is not already in the list of quadruplets, then add it to the list\n                            if [nums[i], nums[j], nums[k], nums[l]] not in quadruplets:\n                                quadruplets.append([nums[i], nums[j], nums[k], nums[l]])\n        return quadruplets\n        \n    \n    def fourSum(self, num"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        dummy = ListNode(0)\n        dummy.next = head\n        slow = dummy\n        fast = dummy\n        for _ in range(n+1):\n            fast = fast.next\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return dummy.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if head.next is None:\n            return None"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        dummy_head = ListNode(0, head)\n        first = dummy_head\n        second = dummy_head\n        for i in range(n + 1):\n            first = first.next\n        while first:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy_head.next"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if n == 0:\n            return head\n        dummy = ListNode(0, head)\n        first = second = dummy\n        for _ in range(n + 1):\n            first = first.next\n        while first:\n            first = first.next\n            second = second.next\n        second.next = second.next.next\n        return dummy.next"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if n==0:\n            return head"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        p1 = head\n        p2 = head\n        if p1.next is None:\n            return None\n        while p1.next is not None:\n            p1 = p1.next\n            if n < 1:\n                n = n + 1\n            else:\n                n = n - 1\n        if n == 1:\n            if p1.next is not None:\n                p1 = p1.next\n                head = p1\n            else:\n                head = None\n        else:\n            if p2.next is not None:\n                p2 = p2.next.next\n                p1.next = p2\n            else:\n                p1.next = None\n        return head\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        curr = head\n        fast = head\n        count = 0\n        while curr:\n            count += 1\n            if count > n:\n                fast = fast.next\n            curr = curr.next\n        if count == n:\n            return head.next\n        fast.next = fast.next.next\n        return head\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # add dummy head\n        dummy = ListNode(0, head)\n        p = dummy\n        p1 = p\n        for i in range(n):\n            p = p.next\n        while p and p.next:\n            p = p.next\n            p1 = p1.next\n        p1.next = p1.next.next\n        return dummy.next"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        dummy = ListNode(-1)\n        dummy.next = head\n        fast = slow = dummy\n        for _ in range(n):\n            fast = fast.next\n        while fast and fast.next:\n            fast = fast.next\n            slow = slow.next\n        slow.next = slow.next.next\n        return dummy.next"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, remove the nth node from the end of the list and return its head.\n        Example 1:\n        Input: head = [1,2,3,4,5], n = 2\n        Output: [1,2,3,5]\n        Example 2:\n        Input: head = [1], n = 1\n        Output: []\n        Example 3:\n        Input: head = [1,2], n = 1\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Time: O(N)\n        # Space: O(1)\n        \n        # Remember the length of the list\n        length = 0\n        node = head\n        while node:\n            length += 1\n            node = node.next\n            \n        # Get the index of the node to be removed\n        idx = length - n\n        if idx == 0:\n            return head.next\n        # Make sure index is not out of bound\n        if idx < 0 or idx >= length:\n            return head\n        \n        node = head\n        # Iterate to the node before the one to be removed\n        for _ in range(idx - 1):\n            node = node.next\n        \n        # Remove the node\n        node.next = node.next.next\n        return head\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for c in s:\n            if c in mapping:\n                if not stack or stack.pop()!= mapping[c]:\n                    return False\n            else:\n                stack.append(c)\n                \n        return not stack\n    \n    def isValid2(self, s: str) -> bool:\n        \"\"\"\n        Same logic as above, except use a stack to keep track of matching brackets.\n        Runtime: O(n)\n        Space: O(n)\n        \"\"\"\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for c in s:\n            if c in mapping:\n                if not stack or stack.pop()!= mapping[c]:\n                    return False\n            else:\n                stack.append(c)\n                \n        return not stack\n    \n    def isValid3(self, s: str) -> bool:\n        \"\"\"\n        Same as above, but use a deque to keep track of matching brackets.\n        Runtime: O(n)\n        Space: O(n)\n        \"\"\"\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        stack = []\n        open = {'(':')','[':']','{':'}'}\n        for char in s:\n            if char in open:\n                stack.append(char)\n            elif len(stack) == 0 or open[stack.pop()]!= char:\n                return False\n        return len(stack) == 0\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # \"()\"\n        # \"()[]{}\"\n        # \"(]\"\n        # \"([)]\"\n        # \"([)]\"\n        # \"([]]\"\n        # \"()[]{}[][[()]]\"\n        # \"([)]\"\n        # \"()[]{}[]()[{}()[]{}[()]{}\""
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \n        \"\"\"\n        if the len(s) % 2 == 1:\n            return False\n        stack = []\n        for char in s:\n            if char in ['(', '{', '[']:\n                stack.append(char)\n            else:\n                if len(stack) == 0:\n                    return False\n                last_char = stack.pop()\n                if char == ')' and last_char!= '(':\n                    return False\n                elif char == '}' and last_char!= '{':\n                    return False\n                elif char == ']' and last_char!= '[':\n                    return False\n        if len(stack) > 0:\n            return False\n        return True\n        \"\"\"\n        \n        stack = []\n        \n        for char in s:\n            if char in ['(', '{', '[']:\n                stack.append(char)\n            else:\n                if len(stack) == 0:\n                    return False\n                last_char = stack.pop()\n                if char == ')' and last_char!= '(':\n                    return False\n                elif char == '}' and last_char!= '{':\n                    return False\n                elif char == ']' and last_char!= '[':\n                    return False\n                \n        if len(stack) > 0:\n            "
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Approach 1: Stack\n        # Time: O(n)\n        # Space: O(n)\n        # stack = []\n        # for char in s:\n        #     if char in {'(', '{', '['}:\n        #         stack.append(char)\n        #     else:\n        #         if not stack or char!= self.get_corresponding_bracket(stack.pop()):\n        #             return False\n        # return not stack"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # return self.isValid_1(s)"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Use a stack to store the brackets\n        # Every open bracket must have a corresponding close bracket\n        # Every close bracket must have a corresponding open bracket\n        # The stack must be empty at the end\n        stack = []\n        open_brackets = set('([{')\n        for bracket in s:\n            if bracket in open_brackets:\n                stack.append(bracket)\n            else:\n                if not stack:\n                    return False\n                last_bracket = stack.pop()\n                # Check if the corresponding open bracket matches the current close bracket\n                if open_brackets[last_bracket]!= bracket:\n                    return False\n        return not stack\n    \n    def isValid1(self, s: str) -> bool:\n        # Use a dictionary to store the brackets\n        # Every open bracket must have a corresponding close bracket\n        # Every close bracket must have a corresponding open bracket\n        # The dictionary must be empty at the end\n        brackets = {'(':')', '[':']', '{':'}'}\n        stack = []\n        for bracket in s:\n            if bracket in brackets:\n                stack.append(bracket)\n            else:\n                if not stack:\n                    return False\n                last_bracket = stack.pop()\n                if last_bracket not in brackets:"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # \u904d\u5386\u5b57\u7b26\u4e32\uff0c\u9047\u5230\u5de6\u62ec\u53f7\u52a0\u5165\u6808\uff0c\u9047\u5230\u53f3\u62ec\u53f7\uff0c\u4ece\u6808\u4e2d\u53d6\u51fa\u4e00\u4e2a\u5de6\u62ec\u53f7\uff0c\u5982\u679c\u76f8\u540c\uff0c\u5219\u6808\u4e3a\u7a7a\uff0c\u5426\u5219\u4e3afalse\n        # \u5b8c\u6210\uff0c\u904d\u5386\u5b8c\u540e\uff0c\u518d\u770b\u6808\u662f\u5426\u4e3a\u7a7a\n        if s == '':\n            return True\n        else:\n            brackets = {'(': ')', '[': ']', '{': '}'}\n            stack = []\n            for item in s:\n                if item in brackets.keys():\n                    stack.append(item)\n                elif item in brackets.values():\n                    if len(stack) == 0:\n                        return False\n                    elif brackets[stack[-1]] == item:\n                        stack.pop()\n                    else:\n                        return False\n            if len(stack) == 0:\n                return True\n            else:\n                return False"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        stack = []\n        opens = \"{[(\"\n        for c in s:\n            if c in opens:\n                stack.append(c)\n            else:\n                if len(stack) == 0:\n                    return False\n                x = stack.pop()\n                if opens.index(x)!= opens.index(c):\n                    return False\n        return len(stack) == 0"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "prompt": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n            Open brackets must be closed by the same type of brackets.\n            Open brackets must be closed in the correct order.\n            Every close bracket has a corresponding open bracket of the same type.\n        Example 1:\n        Input: s = \"()\"\n        Output: true\n        Example 2:\n        Input: s = \"()[]{}\"\n        Output: true\n        Example 3:\n        Input: s = \"(]\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        bracket_dict = {'(': ')', '{': '}', '[': ']'}\n        stack = []"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val <= list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        start = head\n        while list1 and list2:\n            if list1.val <= list2.val:\n                head.next = list1\n                list1 = list1.next\n            else:\n                head.next = list2\n                list2 = list2.next\n            head = head.next\n        if list1:\n            head.next = list1\n        if list2:\n            head.next = list2\n            \n        return start\n                \n        \n        <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # # Recursive\n        # if not list1 or not list2: return list1 or list2\n        # if list1.val < list2.val:\n        #     list1.next = self.mergeTwoLists(list1.next, list2)\n        #     return list1\n        # else:\n        #     list2.next = self.mergeTwoLists(list1, list2.next)\n        #     return list2"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # Approach 1: merge by sorting\n        # Time: O(n)\n        # Space: O(1)\n        # if not list1:\n        #     return list2\n        # if not list2:\n        #     return list1\n        # if list1.val < list2.val:\n        #     merged = list1\n        #     merged.next = self.mergeTwoLists(list1.next, list2)\n        # else:\n        #     merged = list2\n        #     merged.next = self.mergeTwoLists(list1, list2.next)\n        # return merged"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        head = ListNode()\n        node = head\n        \n        while list1 and list2:\n            if list1.val <= list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n        if list1:\n            node.next = list1\n        else:\n            node.next = list2\n        return head.next\n    \n    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          "
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not list1 and not list2:\n            return None\n        if not list1:\n            return list2\n        if not list2:\n            return list1"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not list1 or not list2:\n            return list1 or list2"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        cur1 = list1\n        cur2 = list2\n        if not cur1:\n            return cur2\n        if not cur2:\n            return cur1\n        if not cur1 and not cur2:\n            return\n        new = ListNode(0)\n        temp = new\n        while cur1 and cur2:\n            if cur1.val <= cur2.val:\n                temp.next = cur1\n                cur1 = cur1.next\n            else:\n                temp.next = cur2\n                cur2 = cur2.next\n            temp = temp.next\n        if cur1:\n            temp.next = cur1\n        if cur2:\n            temp.next = cur2\n        return new.next\n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not list1:\n            return list2\n        if not list2:\n            return list1\n        head = ListNode(0)\n        node = head\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n        if list1:\n            node.next = list1\n        if list2:\n            node.next = list2\n        return head.next"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        head1, head2 = list1, list2\n        \n        if list1.val < list2.val:\n            head1, head2 = list1, list2\n        else:\n            head1, head2 = list2, list1\n        \n        p1, p2 = head1, head2\n        \n        head = ListNode(0)\n        head1 = head\n        \n        while p1 and p2:\n            if p1.val < p2.val:\n                head.next = p1\n                p1 = p1.next\n            else:\n                head.next = p2\n                p2 = p2.next\n            head = head.next\n            \n        if p1:\n            head.next = p1\n        elif p2:\n            head.next = p2\n            \n        return head1.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        You are given the heads of two sorted linked lists list1 and list2.\n        Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n        Return the head of the merged linked list.\n        Example 1:\n        Input: list1 = [1,2,4], list2 = [1,3,4]\n        Output: [1,1,2,3,4,4]\n        Example 2:\n        Input: list1 = [], list2 = []\n        Output: []\n        Example 3:\n        Input: list1 = [], list2 = [0]\n        Output: [0]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not list1:\n            return list2\n        if not list2:\n            return list1\n        if list1.val <= list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        self.res = []\n        self.helper(n, n, [])\n        return self.res"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        res = []\n        # 1.\n        self.helper(n, n, n, [], res)\n        return res\n    \n    def helper(self, left, right, n, cur, res):\n        # 2.\n        # if left == 0 and right == 0:\n        #     res.append(''.join(cur))\n        #     return\n        if left == right == n:\n            res.append(''.join(cur))\n            return\n        if left < n:\n            self.helper(left + 1, right, n, cur + ['('], res)\n        if right < left:\n            self.helper(left, right + 1, n, cur + [')'], res)<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if n == 0:\n            return []\n        self.res = []"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        res = []"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        def gen_paran(n):\n            res = []\n            \n            def backtrack(combine, i):\n                if i == 2*n:\n                    res.append(combine)\n                    return\n                if i < n:\n                    backtrack(combine+'(', i+1)\n                    backtrack(combine+')', i+1)\n                else:\n                    backtrack(combine+')', i+1)\n                    \n            backtrack('', 0)\n            return res\n        \n        return gen_paran(n)"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        res = []"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        self.res = []\n        self.helper(n, n, \"\", 0, 0)\n        return self.res\n    \n    def helper(self, n, open, current, closed, count):\n        \"\"\"\n        Backtracking.\n        \"\"\"\n        if count == n*2:\n            self.res.append(current)\n            return \n        \n        if closed < open:\n            self.helper(n, open, current+\")\", closed+1, count+1)\n        \n        if closed < n and open < n:\n            self.helper(n, open+1, current+\"(\", closed, count+1)\n            \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        res = []\n        self.dfs(res, '', n, 0, n)\n        return res\n    \n    def dfs(self, res, path, n, left, right):\n        if len(path) == 2*n:\n            res.append(path)\n            return \n        if left < n:\n            self.dfs(res, path+'(', n, left+1, right)\n        if right < left:\n            self.dfs(res, path+')', n, left, right+1)<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # we'll iterate all possible lengths from 1 to 2n\n        for length in range(1, 2*n + 1):\n            # we'll create a current combination by adding the number of opening\n            # parentheses that should be there at the beginning of the combination,\n            # in addition to the number of closing parentheses that should be\n            # there at the end of the combination\n            current = ['('] * (length // 2) + [')'] * (length // 2)\n            # we'll create an empty list where we'll store the combinations that we'll\n            # add to the final result\n            result = []\n            # we'll iterate through all possible combinations\n            for i in range(2*n + 1):\n                # we'll check if it is possible to add it to the current combination\n                if len(current) > i:\n                    # we'll add the current combination to the list of combinations\n                    result.append(''.join(current[:i]))\n                # we'll also add the current combination to the final result\n                self.backtrack(n, i, current, result)\n            return result\n    \n    def backtrack(self, n, i, current, result):\n        \"\"\"\n        A backtracking algorithm that takes three parameters:\n        n - the number of parentheses we want to generate\n        i -"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        \"\"\"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n        Example 1:\n        Input: n = 3\n        Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n        Example 2:\n        Input: n = 1\n        Output: [\"()\"]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        result = []\n        def backtracking(temp, left, right):\n            if len(temp) == 2*n:\n                result.append(temp)\n                return\n            if left < n:\n                backtracking(temp+'(', left+1, right)\n            if right < left:\n                backtracking(temp+')', left, right+1)"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not lists:\n            return None\n        head = ListNode(0)\n        cur = head\n        while True:\n            min_index, min_val = -1, None\n            for i, l in enumerate(lists):\n                if l:\n                    if not min_val:\n                        min_val = l.val\n                        min_index = i\n                    elif min_val > l.val:\n                        min_val = l.val\n                        min_index = i\n            if min_index == -1:\n                break\n            cur.next = lists[min_index]\n            lists[min_index] = lists[min_index].next\n            cur = cur.next\n        return head.next"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # This is an input class. The solution is to use the head node of each list to make a new list.\n        # Then you can iterate through the list and get the value of the node by using index.\n        # When you iterate through the node, compare the current value with the previous value and\n        # if the current value is larger than the previous value, then swap the values.\n        # Note: the head node of each linked list is a list of integer values, and the head node is a sorted list.\n        # So this method is effective because it can sort the linked list.\n        if not lists:\n            return None\n        elif len(lists) == 1:\n            return lists[0]"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if len(lists) == 0:\n            return None\n        return self.merge_two(lists, 0, len(lists) - 1)\n    \n    def merge_two(self, lists, low, high):\n        if low == high:\n            return lists[low]\n        mid = low + ((high - low) >> 1)\n        list1 = self.merge_two(lists, low, mid)\n        list2 = self.merge_two(lists, mid + 1, high)\n        return self.merge(list1, list2)\n    \n    def merge(self, list1, list2):\n        dummy = cur = ListNode(0)\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n            cur = cur.next\n        cur.next = list1 or list2\n        return dummy.next\n        \n    def merge_two_recursive(self, lists, low, high):\n        if low == high:\n            return lists[low]\n        mid = low + ((high - low) >> 1)\n        list1 = self.merge_"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        l = []\n        for lst in lists:\n            while lst:\n                l.append(lst.val)\n                lst = lst.next\n        l.sort()\n        res = dummy = ListNode(0)\n        for i in l:\n            dummy.next = ListNode(i)\n            dummy = dummy.next\n        return res.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not lists:\n            return None\n        if not lists[0]:\n            return None"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not lists:\n            return None\n        import heapq\n        dummy = ListNode(0)\n        cur = dummy\n        pq = []\n        for l in lists:\n            if l:\n                heapq.heappush(pq, (l.val, id(l), l))\n        while pq:\n            val, _, node = heapq.heappop(pq)\n            cur.next = node\n            cur = cur.next\n            node = node.next\n            if node:\n                heapq.heappush(pq, (node.val, id(node), node))\n        return dummy.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if len(lists) == 0:\n            return []\n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            head = ListNode(0)\n            cur = head\n            cur.next = lists[0]\n            cur = cur.next\n            cur.next = lists[1]\n            cur = cur.next\n            return head.next\n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        return self.merge2Lists(left, right)"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if len(lists) == 0:\n            return None\n        elif len(lists) == 1:\n            return lists[0]\n        else:\n            for i in range(1, len(lists)):\n                lists[0] = self.mergeTwoLists(lists[0], lists[i])\n            return lists[0]\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        \"\"\"\n        Given two sorted linked lists, merge them into one sorted linked list.\n        The number of nodes in both lists is m and n,\n        where m and n are both less than 1000.\n        Both linked lists are guaranteed to be sorted.\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        res = None\n        if l1.val < l2.val:\n            res = l1\n            res.next = self.mergeTwoLists(l1.next, l2)\n        else:\n            res = l2\n            res.next = self.mergeTwoLists(l1, l2.next)\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # based on \"Merge Two Sorted Lists\" from GFG\n        # time complexity: O(n log k), where n is the number of nodes in the final list and k is the number of linked lists\n        # space complexity: O(1)\n        head = point = ListNode(0)\n        heap = []\n        for l in lists:\n            if l:\n                heapq.heappush(heap, (l.val, l))\n        while heap:\n            smallest = heapq.heappop(heap)[1]\n            point.next = smallest\n            point = point.next\n            smallest = smallest.next\n            if smallest:\n                heapq.heappush(heap, (smallest.val, smallest))\n        return head.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "prompt": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        \"\"\"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n        Merge all the linked-lists into one sorted linked-list and return it.\n        Example 1:\n        Input: lists = [[1,4,5],[1,3,4],[2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: The linked-lists are:\n        [\n          1->4->5,\n          1->3->4,\n          2->6\n        ]\n        merging them into one sorted list:\n        1->1->2->3->4->4->5->6\n        Example 2:\n        Input: lists = []\n        Output: []\n        Example 3:\n        Input: lists = [[]]\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        # use a min-heap\n        # you don't know the size of the number\n        # so you don't know how many times you need to extract the minimum\n        # so use a min heap\n        heap = []\n        for i in range(len(lists)):\n            if lists[i]:\n                # make the linked-list as a list of tuple\n                # tuple includes the first node of the linked-list\n                # and the second node of the linked-list\n                heap.append((lists[i].val, i, lists[i]))\n        heapq.heapify(heap)\n        dummy = ListNode(0)\n        cur = dummy\n        while heap:\n            # the current minimum value from the heap\n            val, i, node = heapq.heappop(heap)\n            cur.next = node\n            cur = cur.next\n            if node.next:\n                # if the node.next is not None, means it is not the end of the linked list\n                heapq.heappush(heap, (node.next.val, i, node.next))\n        return dummy.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not head:\n            return None"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not head:\n            return head\n        node = head\n        while node:\n            # swap node and node.next\n            node.val, node.next.val = node.next.val, node.val\n            node = node.next.next if node.next else None\n        return head"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # # Method 1: Iterative\n        # # Time complexity: O(n)\n        # # Space complexity: O(1)\n        # # Initialize:\n        # prev_node = ListNode(0)\n        # prev_node.next = head\n        # node = head\n        # # Loop:\n        # while node and node.next:\n        #     first_node = node\n        #     second_node = node.next\n        #     first_node.next = second_node.next\n        #     second_node.next = first_node\n        #     prev_node.next = second_node\n        #     prev_node = first_node\n        #     node = first_node.next\n        # return head"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not head:\n            return\n        if not head.next:\n            return head\n        result = head.next\n        first = head\n        second = result\n        # advance both pointers until second is at the end of the list\n        while second.next and second.next.next:\n            first.next = second.next\n            first = first.next\n            second.next = first.next\n            second = second.next\n        first.next = second\n        return result"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if head is None:\n            return None"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not head: return head\n        if head.next:\n            head.val, head.next.val = head.next.val, head.val\n            return self.swapPairs(head.next.next)\n        else:\n            return head"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not head:\n            return head\n        prev = None\n        node = head\n        while node and node.next:\n            next_node = node.next\n            node.next = next_node.next\n            next_node.next = node\n            if prev:\n                prev.next = next_node\n            prev = node\n            node = node.next\n        return head<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        def swap(head):\n            if not head:\n                return head\n            if not head.next:\n                return head\n            prev = None\n            cur = head\n            next = head.next\n            while next:\n                cur.next = next.next\n                next.next = cur\n                if prev:\n                    prev.next = next\n                prev = next\n                next = cur.next\n                cur = prev\n            return prev"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        start = head\n        head = head.next\n        while head:\n            start.val, head.val = head.val, start.val\n            start = head\n            head = head.next\n            if not head:\n                break\n            head = head.next\n        return head"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "prompt": "class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n        Example 1:\n        Input: head = [1,2,3,4]\n        Output: [2,1,4,3]\n        Example 2:\n        Input: head = []\n        Output: []\n        Example 3:\n        Input: head = [1]\n        Output: [1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not head:\n            return None\n        dummy = ListNode()\n        dummy.next = head\n        p = dummy\n        while p.next and p.next.next:\n            node1 = p.next\n            node2 = p.next.next\n            node3 = p.next.next.next\n            p.next = node2\n            node1.next = node3\n            node2.next = node1\n            p = node1\n        return dummy.next"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if k < 2:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            prev = prev.next\n        cur = prev.next\n        head = prev\n        while cur:\n            t = cur.next\n            cur.next = prev\n            prev = cur\n            cur = t\n        prev.next = cur\n        return head.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not head: return\n        cur = head\n        n = 0\n        while cur:\n            n += 1\n            cur = cur.next\n        def reverse(head, k):\n            if k == 1 or not head:\n                return head\n            prev, cur = None, head\n            for _ in range(k):\n                nextNode = cur.next\n                cur.next = prev\n                prev = cur\n                cur = nextNode\n            head.next = cur\n            return prev\n        count = 0\n        start = end = head\n        new_start = new_end = None\n        while end:\n            count += 1\n            if count % k == 0:\n                if not new_start:\n                    new_start = end\n                new_end = end.next\n                end.next = None\n                new_start = reverse(new_start, k)\n                if not new_end:\n                    break\n                new_start.next = reverse(new_end, k)\n            end = end.next\n        if not new_start:\n            return head\n        new_start.next = head\n        return new_start\n        \n    def reverseKGroup2(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # Get length of list\n        length = 0\n        node = head\n        while node:\n            length += 1\n            node = node.next\n        if k <= 1 or not head or not head.next or k > length:\n            return head\n        # Get the new start\n        new_head = head\n        for _ in range(k - 1):\n            new_head = new_head.next\n        # Reverse the next k nodes\n        prev, curr = new_head, new_head.next\n        for _ in range(k - 1):\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        new_head.next = curr\n        # Connect with the rest\n        head.next = self.reverseKGroup(new_head, k)\n        return prev"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \n        #Approach: iterative\n        #Time Complexity: O(n)\n        #Space Complexity: O(1)\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = dummy\n        \n        while True:\n            count = k\n            stack = []\n            \n            while count and cur:\n                stack.append(cur)\n                cur = cur.next\n                count -= 1\n                \n            if not count: break\n                \n            #reverse a k sized sublist\n            tail = stack.pop()\n            cur = tail\n            \n            #connecting sublist with the rest of the list\n            while stack:\n                node = stack.pop()\n                cur.next = node\n                cur = node\n                cur.next = None\n            cur.next = tail\n            \n        return dummy.next\n    \n    def reverseKGroup2(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        curr = head\n        curr_list = []\n        while curr:\n            curr_list.append(curr.val)\n            curr = curr.next\n        if len(curr_list) < k:\n            return head\n        curr_list = curr_list[len(curr_list) - k: ] + curr_list[: len(curr_list) - k]\n        dummy = ListNode(0)\n        curr = dummy\n        for val in curr_list:\n            curr.next = ListNode(val)\n            curr = curr.next\n        return dummy.next<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if k < 2:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        p1 = dummy\n        for i in range(k):\n            if p1.next:\n                p1 = p1.next\n            else:\n                return dummy.next\n        p2 = p1\n        while p1.next:\n            tmp = p1.next\n            p1.next = p1.next.next\n            tmp.next = p2.next\n            p2.next = tmp\n            p1 = p1.next\n        return dummy.next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Edge cases\n        if k == 1:\n            return head"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if k == 1:\n            return head\n        dummy = ListNode(-1)\n        dummy.next = head\n        slow = dummy\n        fast = dummy\n        for _ in range(k-1):\n            fast = fast.next\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        fast = slow.next\n        prev = None\n        curr = head\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        slow.next = fast\n        return prev\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # while(head.next!= None):\n        #     head = head.next\n        # return head\n        if(k == 1):\n            return head\n        count = 1\n        head_pointer = head\n        while(count!= k and head_pointer.next!= None):\n            head_pointer = head_pointer.next\n            count += 1\n        if(count!= k):\n            return head\n        tail = self.reverseKGroup(head_pointer.next, k)\n        head_pointer.next = None\n        prev = head_pointer\n        curr = head\n        while(curr!= tail):\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        head_pointer.next = prev\n        return head"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "prompt": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n        k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n        You may not alter the values in the list's nodes, only nodes themselves may be changed.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [2,1,4,3,5]\n        Example 2:\n        Input: head = [1,2,3,4,5], k = 3\n        Output: [3,2,1,4,5]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        dummy = ListNode(0, head)\n        # dummy = None\n        # dummy = ListNode(0)\n        # dummy.next = head\n        prev, curr = dummy, head\n        while prev:\n            if not curr or not curr.next:\n                return dummy.next\n            while curr.next and not curr.next.next:\n                head, tail = curr.next, prev\n                curr.next = None\n                prev.next = head\n                return dummy.next\n            head, tail = curr.next, prev\n            curr.next = None\n            prev.next = head\n            curr = tail\n        return dummy.next"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not nums: return 0\n        if len(nums) == 1: return 1\n        i, j = 0, 1\n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                nums[i+1] = nums[j]\n                i += 1\n                j += 1\n        return i + 1"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if len(nums) == 0:\n            return 0\n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] == nums[i + 1]:\n                nums.pop(i)\n            else:\n                i += 1\n        return i + 1"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # # O(n^2)\n        # for i in range(len(nums) - 1):\n        #     if nums[i] == nums[i+1]:\n        #         nums.pop(i)\n        # return len(nums)\n        # O(n)\n        if len(nums) == 0:\n            return 0\n        j = 0\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[j]:\n                j += 1\n                nums[j] = nums[i]\n        return j + 1"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if len(nums) == 0:\n            return 0\n        elif len(nums) == 1:\n            return 1\n        i = 0\n        for j in range(1,len(nums)):\n            if nums[i]!= nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i+1"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if len(nums) == 0: return 0\n        if len(nums) == 1: return 1"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not nums:\n            return 0\n        last = nums[0]\n        i = 1\n        while i < len(nums):\n            if nums[i]!= last:\n                nums[i - 1] = nums[i]\n                last = nums[i]\n            i += 1\n        return i"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if len(nums) < 2:\n            return len(nums)\n        \n        if len(nums) == 2:\n            if nums[0]!= nums[1]:\n                nums[0] = nums[1]\n            return 1\n        \n        # keep track of previous element\n        prev_idx = 0\n        # loop over the array from start to end (included)\n        for i in range(1, len(nums)):\n            # if the next element is not equal to the previous element\n            if nums[i]!= nums[prev_idx]:\n                # move the next element to the previous element's position\n                nums[prev_idx + 1] = nums[i]\n                # increase the index of the previous element\n                prev_idx += 1\n        # return the number of elements\n        return prev_idx + 1\n    \n    def removeDuplicates_no_sort(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # index = 1\n        # for i in range(len(nums)-1):\n        #     if nums[i]!=nums[i+1]:\n        #         nums[index]=nums[i+1]\n        #         index+=1\n        # return index\n        \"\"\"\n        Algorithm: 2 pointer\n        i: slow pointer\n        j: fast pointer\n        i: 1\n        nums = [1,2,3,3,4]\n        j: 1\n        i: 0\n        nums = [1,2,3,3,4]\n        i: 1\n        nums = [1,1,2,3,3,4]\n        i: 2\n        nums = [1,1,1,2,3,3,4]\n        i: 3\n        nums = [1,1,1,1,2,3,3,4]\n        i: 4\n        nums = [1,1,1,1,1,2,3,3,4]\n        i: 5\n        nums = [1,1,1,1,1,2,3,3,4]\n        i: 6\n        nums = [1,1,1,1,1,2,3,3,4]\n        "
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        n = len(nums)\n        j = 0\n        for i in range(1, n):\n            if nums[i]!= nums[j]:\n                j += 1\n                nums[j] = nums[i]\n        return j + 1\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int[] expectedNums = [...]; // The expected answer with correct length\n        int k = removeDuplicates(nums); // Calls your implementation\n        assert k == expectedNums.length;\n        for (int i = 0; i < k; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output: 2, nums = [1,2,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,0,1,1,1,2,2,3,3,4]\n        Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        j=0\n        for i in range(1,len(nums)):\n            if nums[i]!=nums[j]:\n                j+=1\n                nums[j]=nums[i]\n        return j+1\n                \n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # Runtime: 108 ms, faster than 17.41% of Python3 online submissions for Remove Element.\n        # Memory Usage: 15.3 MB, less than 54.87% of Python3 online submissions for Remove Element.\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        while True:\n            if nums[0] == val:\n                nums.pop(0)\n            else:\n                break\n        return len(nums)\n        \"\"\"\n        # Runtime: 96 ms, faster than 43.48% of Python3 online submissions for Remove Element.\n        # Memory Usage: 15.2 MB, less than 6.75% of Python3 online submissions for Remove Element.\n        \"\"\"\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] == val:\n                nums.pop(i)\n        return len(nums)\n        \"\"\"\n        # Runtime: 96 ms, faster than 43.48% of Python3 online submissions for Remove Element.\n        # Memory Usage: 15.3 MB, less than 6.75% of Python3 online submissions for Remove Element.\n        \"\"\"\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] =="
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # index = 0\n        # for i in range(len(nums)):\n        #     if nums[i]!= val:\n        #         nums[index] = nums[i]\n        #         index += 1\n        # return index"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        n = len(nums)\n        for i in range(n - 1, -1, -1):\n            if nums[i] == val:\n                n -= 1\n                if i!= n:\n                    nums[i] = nums[n]\n                n -= 1\n        return n"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # last_index = 0\n        # for i in range(0, len(nums)):\n        #     if nums[i]!= val:\n        #         nums[last_index] = nums[i]\n        #         last_index += 1\n        # return last_index"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # https://www.youtube.com/watch?v=xvGYDNaDx1c\n        # brute force: time complexity O(n^2), space complexity O(1)\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i] == val:\n                for j in range(i+1, n):\n                    if nums[j] == val:\n                        nums[j] = nums[j-1]\n                        j -= 1\n                    else:\n                        nums[j] = nums[j-1]\n                n -= 1\n        return n\n        \"\"\"\n        # Two pointers\n        # https://leetcode.com/problems/remove-element/discuss/230133/Python-solution-with-comments-time-and-space\n        n = len(nums)\n        l, r = 0, n-1\n        while l <= r:\n            if nums[l] == val:\n                nums[l] = nums[r]\n                r -= 1\n            else:\n                l += 1\n        return l"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # remove all elements equal to val\n        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Time Complexity = O(N)\n        # Space Complexity = O(1)\n        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if len(nums) == 0:\n            return 0\n        \n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            if nums[left] == val:\n                nums[left] = nums[right]\n                right -= 1\n            else:\n                left += 1\n        \n        return left + 1 if nums[left]!= val else left\n    \n    \n    def removeElement_2(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        # if not nums:\n        #     return 0\n        # length = len(nums)\n        # count = length\n        # for i in range(length):\n        #     while nums[i] == val:\n        #         count -= 1\n        #         nums.pop(i)\n        #         break\n        # return count\n        if not nums:\n            return 0\n        \n        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "prompt": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        \"\"\"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.\n        Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n        Return k after placing the final result in the first k slots of nums.\n        Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n        Custom Judge:\n        The judge will test your solution with the following code:\n        int[] nums = [...]; // Input array\n        int val =...; // Value to remove\n        int[] expectedNums = [...]; // The expected answer with correct length.\n                                    // It is sorted with no values equaling val.\n        int k = removeElement(nums, val); // Calls your implementation\n        assert k == expectedNums.length;\n        sort(nums, 0, k); // Sort the first k elements of nums\n        for (int i = 0; i < actualLength; i++) {\n            assert nums[i] == expectedNums[i];\n        }\n        If all assertions pass, then your solution will be accepted.\n        Example 1:\n        Input: nums = [3,2,2,3], val = 3\n        Output: 2, nums = [2,2,_,_]\n        Explanation: Your function should return k = 2, with the first two elements of nums being 2.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        Example 2:\n        Input: nums = [0,1,2,2,3,0,4,2], val = 2\n        Output: 5, nums = [0,1,4,0,3,_,_,_]\n        Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\n        Note that the five elements can be returned in any order.\n        It does not matter what you leave beyond the returned k (hence they are underscores).\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Edge Case\n        if len(nums) == 0:\n            return 0\n        # General Case\n        # Pop indexs of val from nums\n        # return the length of nums\n        while True:\n            if val not in nums:\n                break\n            else:\n                nums.pop(nums.index(val))\n        return len(nums)"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not needle:\n            return 0\n        return haystack.find(needle)"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        haystackLen = len(haystack)\n        needleLen = len(needle)\n        \n        # Edge cases\n        if needleLen == 0:\n            return 0\n        if needleLen > haystackLen:\n            return -1\n        \n        # Set counters\n        i = 0\n        j = 0\n        \n        # Iterate through the string\n        while i < haystackLen:\n            if haystack[i] == needle[j]:\n                # If the character is the same, move pointers to the next character\n                i += 1\n                j += 1\n                \n                # If the needle is empty, return the index\n                if j == needleLen:\n                    return i - needleLen\n                \n            else:\n                # If the character is not the same, reset counters\n                i -= j\n                j = 0\n                \n        # If the string is empty or does not contain the needle, return -1\n        return -1\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if needle in haystack:\n            return haystack.index(needle)\n        return -1"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if needle == \"\":\n            return 0\n        \n        if haystack == \"\":\n            return -1\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1\n        <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not needle:\n            return 0\n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Check if needle is an empty string\n        if len(needle) == 0:\n            return 0"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        h, n = len(haystack), len(needle)"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not needle:\n            return 0\n        if len(needle) > len(haystack):\n            return -1"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        return self.bruteforce(haystack, needle)"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "prompt": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Example 1:\n        Input: haystack = \"sadbutsad\", needle = \"sad\"\n        Output: 0\n        Explanation: \"sad\" occurs at index 0 and 6.\n        The first occurrence is at index 0, so we return 0.\n        Example 2:\n        Input: haystack = \"leetcode\", needle = \"leeto\"\n        Output: -1\n        Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if needle == \"\":\n            return 0\n        if len(needle) > len(haystack):\n            return -1\n        for i in range(0, len(haystack)-len(needle)+1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if dividend == 0:\n            return 0\n        is_negative = False\n        if (dividend < 0 and divisor < 0) or (dividend > 0 and divisor > 0):\n            is_negative = False\n        else:\n            is_negative = True\n        quotient = 0\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        while dividend >= divisor:\n            tmp = divisor\n            i = 1\n            while dividend >= tmp:\n                dividend -= tmp\n                quotient += i\n                i <<= 1\n                tmp <<= 1\n        if is_negative:\n            return -quotient\n        return quotient"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # pass\n        # \u5c06\u88ab\u9664\u6570\u548c\u9664\u6570\u76f8\u53cd\uff0c\u8fd4\u56de\u6b63\u6570\n        sign = 1 if (dividend ^ divisor) > 0 else -1"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        # -1. 32bit signed int -> \u4e0d\u7b97\u6709\u6ea2\u4f4d\n        # -2. \u53ef\u4ee5\u7528\u79fb\u4f4d\u64cd\u4f5c\uff0c\u5728\u5de6\u79fb\u4e00\u4f4d\u5373\u53ef\n        # -3. \u4e0d\u80fd\u7528\u52a0\u51cf\u4e58\u9664\uff0c\u79fb\u4f4d\u4e00\u6837\u7684\u6548\u7387\u66f4\u9ad8\uff0c\u4e58\u9664\u66f4\u6162\n        # -4. \u8ba1\u7b97\u65f6\u5e94\u8be5\u5ffd\u7565\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u6570\uff0c\u7ed3\u679c\u8fd8\u8981\u53d6\u53cd\n        \n        MAX_INT = 2**31 - 1\n        MIN_INT = -2**31\n        \n        # -5. python3\u6ca1\u6709long\u578b\uff0c\u4e0d\u80fd\u76f4\u63a5\u7528\u4e8c\u8fdb\u5236\u5206\u79bb\uff0c\u53ea\u80fd\u5206\u79bb32\u4f4d\n        if divisor == 0:\n            return MAX_INT\n        \n        sign = (dividend > 0) ^ (divisor > 0)\n        dividend"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if dividend == 0:\n            return 0\n        sign = 1\n        if (dividend > 0 and divisor < 0) or (dividend < 0 and divisor > 0):\n            sign = -1"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        MAX_INT = 2 ** 31 - 1\n        MIN_INT = -2 ** 31\n        # determine if there is overflow\n        if dividend > MAX_INT or divisor > MAX_INT:\n            return MAX_INT\n        if dividend < MIN_INT or divisor < MIN_INT:\n            return MIN_INT\n        # check if divisor is 0\n        if divisor == 0:\n            return 0"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if (dividend < 0 and divisor > 0) or (dividend > 0 and divisor < 0):\n            flag = -1\n        else:\n            flag = 1\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        if divisor == 1:\n            if dividend < 0:\n                return flag * (-1)\n            else:\n                return flag\n        if dividend < divisor:\n            return 0\n        res = 1\n        i = 0\n        while divisor << i <= dividend:\n            i += 1\n        i -= 1\n        divisor = divisor << i\n        if i == 0:\n            return res * flag\n        return res * flag + self.divide(dividend - divisor, divisor)"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        MAX_INT = 2**31 - 1\n        MIN_INT = -2**31\n        result = 0\n        flag = 1\n        if dividend < 0:\n            flag = -1\n            dividend = -dividend\n        if divisor < 0:\n            flag = -1\n            divisor = -divisor\n        divisor = abs(divisor)\n        dividend = abs(dividend)\n        while dividend >= divisor:\n            if dividend >= divisor:\n                dividend -= divisor\n                result += 1\n        if result >= MAX_INT or result <= MIN_INT:\n            return MAX_INT if flag == 1 else MIN_INT\n        return result * flag\n        # binary search\n        # if dividend < 0:\n        #     flag = -1\n        #     dividend = -dividend\n        # if divisor < 0:\n        #     flag = -1\n        #     divisor = -divisor\n        # dividend = abs(dividend)\n        # divisor = abs(divisor)\n        # if dividend == divisor:\n        #     if flag == 1:\n        #         return 2**31 - 1\n        #     return -2**31\n        #\n        #"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        positive = (dividend < 0) is (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        res = 0\n        while dividend >= divisor:\n            temp, i = divisor, 1\n            while dividend >= temp:\n                dividend -= temp\n                res += i\n                i <<= 1\n                temp <<= 1\n        if not positive:\n            res = -res\n        return min(max(-2 ** 31, res), 2 ** 31 - 1)"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if dividend == 0:\n            return 0\n        sign = 1 if (dividend > 0 and divisor > 0) or (dividend < 0 and divisor < 0) else -1\n        dividend, divisor = abs(dividend), abs(divisor)\n        if dividend < divisor:\n            return 0\n        if dividend == divisor:\n            return sign\n        result = 1\n        while divisor <= dividend:\n            divisor <<= 1\n            result <<= 1\n        while divisor!= dividend:\n            divisor >>= 1\n            result >>= 1\n        return sign*result"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "prompt": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        Return the quotient after dividing dividend by divisor.\n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n        Example 1:\n        Input: dividend = 10, divisor = 3\n        Output: 3\n        Explanation: 10/3 = 3.33333.. which is truncated to 3.\n        Example 2:\n        Input: dividend = 7, divisor = -3\n        Output: -2\n        Explanation: 7/-3 = -2.33333.. which is truncated to -2.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # \u627e\u8d1f\u6570\u7684\u7b26\u53f7\n        sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n        # \u6574\u9664\uff0c\u8fd4\u56de\u7684\u503c\u8fd8\u8981\u52a0\u7b26\u53f7\n        res = 0\n        # \u989d\u5916\u5904\u7406\u7b26\u53f7\uff0c\u4e0d\u7136python\u7684\u6574\u9664\u4f1a\u8fd4\u56de0\uff0c\u8d85\u65f6\n        dividend = abs(dividend)\n        divisor = abs(divisor)"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not words:\n            return []\n        if not s or len(s) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        window_size = word_count * word_len\n        \n        if len(s) < window_size:\n            return []\n        \n        start_idx = 0\n        word_freq = {}\n        for word in words:\n            if word not in word_freq:\n                word_freq[word] = 1\n            else:\n                word_freq[word] += 1\n        \n        ans = []\n        while start_idx + window_size <= len(s):\n            sub_str_chars = [s[i] for i in range(start_idx, start_idx + window_size)]\n            sub_str_chars_set = set(sub_str_chars)\n            if sub_str_chars_set!= set(words):\n                start_idx += 1\n                continue\n            \n            sub_str_chars_list = list(sub_str_chars)\n            sub_str_chars_list.sort()\n            sub_str = \"\".join(sub_str_chars_list)"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        n = len(s)\n        \n        if n < word_count*word_len:\n            return []\n        \n        hash_map = dict()\n        \n        for word in words:\n            if word not in hash_map:\n                hash_map[word] = 1\n            else:\n                hash_map[word] += 1\n        \n        res = []\n        for i in range(word_len):\n            curr_hash = dict()\n            for j in range(i, n, word_len):\n                word = s[j:j+word_len]\n                if word not in hash_map:\n                    continue\n                if word not in curr_hash:\n                    curr_hash[word] = 1\n                else:\n                    curr_hash[word] += 1\n                if curr_hash[word] > hash_map[word]:\n                    break\n                if len(curr_hash) == word_count:\n                    res.append(j-word_len*(word_count-1))\n                    \n        return res\n    \n    \"\"\"\n    Given an array of strings words, return all"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        if not s or not words: return []\n        \n        len_w, len_s = len(words[0]), len(s)\n        \n        if len_w > len_s: return []\n        \n        all_sub = []\n        # perm_subs = []\n        \n        for i in range(len_w):\n            # perm_subs.append(permutations(words, i+1))\n            perm = permutations(words, i+1)\n            for p in perm:\n                perm_s = ''\n                for c in p:\n                    perm_s += c\n                # perm_subs.append(perm_s)\n                all_sub.append(perm_s)\n                \n        \n        \n        \n        # for perm_sub in perm_subs:\n        \n        \n        # for perm_sub in all_sub:\n        #     i = 0\n        #     while i < len_s - len_w + 1:\n        #         if perm_sub == s[i:i+len_w]:\n        #             perm_subs.append(perm_sub)\n        #         i += 1\n            \n        # return perm_subs\n        \n        res = []\n        for perm_sub in all_sub:\n            start_"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # Solution 1\n        # if not s or not words:\n        #     return []\n        # l, n, m = len(s), len(words), len(words[0])\n        # d = dict()\n        # for i in words:\n        #     d[i] = d.get(i, 0) + 1\n        # res = []\n        # for i in range(m):\n        #     curr, count = [], 0\n        #     for j in range(i, l - m + 1, m):\n        #         curr.append(s[j:j + m])\n        #         count += 1\n        #         if count == len(d):\n        #             res.append(j - m + 1)\n        #             curr, count = [], 0\n        # return res"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        res = []\n        N, M = len(s), len(words[0])\n        i = 0\n        while i < N - M * len(words) + 1:\n            j = i + M\n            for k in range(i, N - M + 1, M):\n                if s[k:j] in words:\n                    if k + M * len(words) - M <= N:\n                        res.append(k)\n                        break\n                else:\n                    break\n            i += 1\n        return res"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \n        # Time and Space: O(N)\n        # N = len(s)\n        # words_length = len(words[0])\n        # words_list = list(words)\n        # result = []\n        \n        # for i in range(words_length):\n        #     curr_str = s[i:i+words_length*words_list.index(words[0])]\n        #     if curr_str == words_list[0]:\n        #         result.append(i)\n        #     j = 1\n        #     while j < len(words_list):\n        #         curr_str += s[i+words_length*j:i+words_length*(j+1)]\n        #         if curr_str == words_list[j]:\n        #             result.append(i)\n        #         j += 1\n        \n        # return result\n        \n        # Hashmap + 2-pointer\n        # Time and Space: O(N)\n        \"\"\"\n        n = length of string s\n        m = length of string words[i]\n        k = length of concatenated substring\n        \"\"\"\n        n = len(s)\n        m = len(words)\n        k = len(words[0])\n        words_set"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \"\"\"\n        I can't think of an intuitive solution, but I guess I'm going to \n        use the sliding window approach. \n        \n        I first need to find the number of words that need to be in \n        the window. To do this, I create a counter of the words. \n        Then I'll find the number of unique elements in this counter. \n        \n        After, I'll slide the window by the length of all the words, \n        and then I'll go through the original string, starting at i = 0, \n        and I'll keep increasing i until I reach the end of the string. \n        If i is at the length of the concatenated substring, then I'll \n        append i to the list of indices.\n        \n        Then, I'll decrement i by the length of the words and repeat the \n        above steps until the beginning of the string.\n        \n        Finally, I'll return the list of indices. \n        \n        \"\"\"\n        from collections import Counter\n        \n        counter, words = Counter(words), set(words)\n        n, i, res = len(s), 0, []\n        \n        while i <= n - len(words) * len(words[0]):\n            if n - i < len(words) * len(words[0]):\n"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not words: return []\n        ans = []\n        n, m, t = len(s), len(words[0]), len(words)\n        if m > n: return ans\n        for i in range(n - m * t + 1):\n            if self.valid(s[i:], words):\n                ans.append(i)\n        return ans"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Time  complexity: O(N^2 * L + N * L)\n        # Space complexity: O(L + L)\n        res = []\n        n = len(s)\n        if not s or not words or not words[0]: return res\n        n_word = len(words[0])\n        for i in range(n - n_word * len(words) + 1):\n            if len(set(s[i:i + n_word * len(words)].split()))!= len(words):\n                continue\n            res.append(i)"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "prompt": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        \"\"\"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n        A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n            For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n        Return the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n        Example 1:\n        Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n        Output: [0,9]\n        Explanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\n        The substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\n        The substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\n        The output order does not matter. Returning [9,0] is fine too.\n        Example 2:\n        Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n        Output: []\n        Explanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\n        There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n        We return an empty array.\n        Example 3:\n        Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n        Output: [6,9,12]\n        Explanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\n        The substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\n        The substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\n        The substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \n        # Time: O(n*m*m), n is the length of the string, m is the average length of words\n        # Space: O(m), m is the number of words in the input\n        \n        if not words:\n            return []\n        if len(words) == 1 and len(words[0]) == len(s):\n            return [0]\n        \n        output = []\n        word_length = len(words[0])\n        word_count = len(words)\n        window_start = 0\n        while window_start < len(s):\n            curr_window_word = \"\"\n            for i in range(word_length):\n                if window_start + word_length * word_count >= len(s):\n                    return output\n                curr_window_word += s[window_start + i * word_length : window_start + (i + 1) * word_length]\n            if curr_window_word not in words:\n                window_start += 1\n                continue\n            output.append(window_start)\n            for j in range(word_count):\n                window_start += word_length\n                if window_start + word_length * word_count >= len(s):\n                    return output\n                curr_window_word = \"\"\n                "
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not nums:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        # find the first strictly decreasing element\n        start = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                start = i-1\n                break\n        \n        # iterate from end of list and find the first element that is larger than nums[start]\n        # and swap them\n        for i in range(len(nums)-1, start, -1):\n            if nums[i] > nums[start]:\n                nums[start], nums[i] = nums[i], nums[start]\n                break\n        \n        # reverse the array from index start+1 to end\n        nums[start+1:] = nums[start+1:][::-1]\n        return nums\n    \n    def nextPermutation(self, nums):\n        \"\"\"\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not nums or len(nums) < 2:\n            return\n        \n        i = j = len(nums) - 1\n        while i > 0 and nums[i"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # 1. Iterate backwards\n        # 2. find the first decreasing element i\n        # 3. find the first element larger than i which is the smallest element to its right which is greater than i.\n        # 4. swap these 2 elements\n        # 5. reverse the elements to its right of i\n        # 6. reverse the list from index i to the end.\n        # 7. reverse the list\n        if not nums:\n            return []\n        length = len(nums)\n        i = length - 1\n        while i > 0 and nums[i-1] >= nums[i]:\n            i -= 1\n        if i == 0:\n            nums[:] = nums[::-1]\n            return nums\n        j = length - 1\n        while nums[j] <= nums[i-1]:\n            j -= 1\n        nums[i-1], nums[j] = nums[j], nums[i-1]\n        nums[i:] = nums[length-1:i-1:-1]\n        return nums"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \"\"\"\n        my solution\n        \"\"\"\n        # def swap(arr, i, j):\n        #     arr[i], arr[j] = arr[j], arr[i]\n        #\n        # def reverse(arr, start):\n        #     i, j = start, len(arr) - 1\n        #     while i < j:\n        #         swap(arr, i, j)\n        #         i += 1\n        #         j -= 1\n        #\n        # def reverse_all(arr):\n        #     reverse(arr, 0)\n        #     reverse(arr, 1)\n        #\n        # def next_greatest_index(arr, start, end):\n        #     next_greatest_index = start\n        #     for i in range(start, end):\n        #         if arr[i] > arr[next_greatest_index]:\n        #             next_greatest_index = i\n        #\n        #     return next_greatest_index\n        #\n        # def find_swap(arr, start, end):\n        #     for i in range(start, end):\n        #         for j in range(i + 1, end):\n        #             if arr[i] > arr[j]:\n        #                 return i, j\n        "
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # # 1. \u8fd9\u9053\u9898\u6ca1\u61c2\uff0c\u53ea\u662f\u60f3\u660e\u767d\u4e3a\u4ec0\u4e48\u8981\u6c42in place\uff0c\u6570\u7ec4\u53ef\u4ee5\u6539\u53d8\n        # # 2. \u627e\u5230\u90a3\u4e00\u5217\uff0c\u5168\u662f\u964d\u5e8f\u7684\uff0c\u6392\u5217\u7ec4\u5408\u5c31\u53ea\u6709\u5347\u5e8f\uff0c\u627e\u5230\u90a3\u4e00\u5217\uff0c\u5168\u662f\u5347\u5e8f\u7684\n        # # 3. \u770b\u5230\u4e0b\u9762\u9898\u89e3\u7684\u65f6\u5019\uff0c\u89c9\u5f97\u9898\u76ee\u8fd8\u662f\u6709\u70b9\u96be\uff0c\u5c31\u81ea\u5df1\u6784\u9020\u4e86\u4e00\u4e2a\u7b97\u6cd5\n        # # 4. \u4ed4\u7ec6\u770b\u89e3\u9898\uff0c\u8fd9\u9053\u9898\u5c31\u662f\u4e00\u4e2a\u6392\u5e8f\u95ee\u9898\uff0c\u8981\u6c42\u91cd\u65b0\u6392\u5e8f\uff0c\u5168\u662f\u964d\u5e8f\u7684\u6392\u5217\u7ec4\u5408\u5c31"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not nums or len(nums) <= 1: return"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # swap and reverse\n        n = len(nums)\n        if n < 2:\n            return nums\n        # find the first non-decreasing place\n        p = n - 1\n        while p > 0:\n            if nums[p] > nums[p - 1]:\n                break\n            p -= 1\n        if p == 0:\n            nums.reverse()\n            return\n        # find the first number in the descending order\n        m = n - 1\n        while m > p - 1:\n            if nums[m] > nums[p - 1]:\n                break\n            m -= 1\n        # swap numbers\n        nums[p - 1], nums[m] = nums[m], nums[p - 1]\n        # reverse the rest\n        l, r = p, n - 1\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l += 1\n            r -= 1"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Strategy 1: Find the last decreasing index of the array\n        # When we find the last decreasing index, we then swap it with the next bigger element\n        # If we cannot find the last decreasing element, then we reverse the array from index 1 to end"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        n = len(nums)\n        if n < 2:\n            return\n        i = n - 2\n        # find the first decreasing number\n        while i >= 0:\n            if nums[i] < nums[i + 1]:\n                break\n            i -= 1\n        if i == -1:\n            return nums.sort()\n        j = n - 1\n        # find the first number larger than nums[i]\n        while j >= 0:\n            if nums[j] > nums[i]:\n                break\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = nums[i + 1:][::-1]\n        return nums"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \"\"\"\n        To find the next permutation of a given array:\n            1. From the rightmost element, find the index i where nums[i] < nums[i+1].\n            2. If such index i is not found, we are in the last permutation. Return the last permutation.\n            3. Otherwise, swap nums[i] and nums[i+1].\n            4. From the rightmost element, find the index i where nums[i] > nums[i+1].\n            5. Swap nums[i] and nums[i+1].\n            6. Reverse the subarray nums[i+1:] to get the next lexicographically largest permutation.\n            7. Return the next permutation.\n        \"\"\"\n        # # O(n) time, O(1) space, iterate through the array, and find the first index where nums[i] < nums[i+1]\n        # if len(nums) <= 1:\n        #     return nums\n        # if len(nums) == 2:\n        #     return [nums[1], nums[0]]\n        # for i in range(len(nums)-2, -1, -1):\n        #     if nums[i] < nums[i+1"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "prompt": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n            For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n        The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n            For example, the next permutation of arr = [1,2,3] is [1,3,2].\n            Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n            While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n        Given an array of integers nums, find the next permutation of nums.\n        The replacement must be in place and use only constant extra memory.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [1,3,2]\n        Example 2:\n        Input: nums = [3,2,1]\n        Output: [1,2,3]\n        Example 3:\n        Input: nums = [1,1,5]\n        Output: [1,5,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # find the rightmost number that is smaller than its right neighbor\n        # if not found, the array is in the highest lexicographic order\n        # reverse the right half of the array, and append the rightmost number that is larger than its right neighbor to the left\n        \"\"\"\n        If we use a stack to store the indices of the next greater number for each number,\n        then we can just keep popping the indices until the current number is no longer greater than the next one\n        \"\"\"\n        # find the index where the next greatest number is smaller than the current number\n        i = len(nums) - 2\n        while i >= 0 and nums[i+1] <= nums[i]:\n            i -= 1"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # stack\n        dp = [0] * len(s)\n        stack = []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    last_open_parentheses = stack.pop()\n                    dp[i] = dp[last_open_parentheses] + i - last_open_parentheses\n        return max(dp)\n    \n    def longestValidParentheses2(self, s: str) -> int:\n        \"\"\"\n        Let's assume we have dp[i][j] to represent the longest length of valid parentheses from the substring s[i:j].\n        Then:\n        dp[i][j] = 0, if s[i] or s[j] is not a valid pair (when s[i] == '(' and s[j] == ')' or s[i] == ')' and s[j] == '(')\n        dp[i][j] = 0, if i > j, or i < 0, or j < 0\n        dp[i][j] = dp[i+1][j-1] + 2, if s[i] == '(' and s[j] == ')'\n        This works because if we have s[i] == '('"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        stack = []\n        prev_item = None\n        max_len = 0\n        for item in s:\n            if item == ')':\n                if prev_item == '(':\n                    stack.append('(')\n                elif prev_item == ')':\n                    if stack and stack[-1] == '(':\n                        stack.pop()\n                        stack.append(2)\n                    else:\n                        stack.append(1)\n            else:\n                stack.append(')')\n            prev_item = item\n            if stack:\n                max_len = max(max_len, sum(stack))\n        return max_len"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        s_len = len(s)\n        dp = [0] * s_len\n        max_dp = 0\n        for i in range(1, s_len):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2 if i > 1 else 2\n                else:\n                    if i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                        dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n            max_dp = max(max_dp, dp[i])\n        return max_dp"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not s:\n            return 0\n        dp = [0] * len(s)\n        dp[0] = 2 if s[0] == \"(\" else 0\n        for i in range(1, len(s)):\n            if s[i] == \")\":\n                if s[i - 1] == \"(\":\n                    dp[i] = dp[i - 2] + 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \"(\":\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2]\n                # dp[i] = max(dp[i - 1] + dp[i - dp[i - 1] - 2], dp[i - 1] + 2)\n        return max(dp)"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # stack, len(res)\n        # 1. if len(stack) == 0, push (s[i])\n        # 2. if s[i] == ')' and stack[-1] == '(', remove stack[-1]\n        # 3. otherwise, stack push s[i]\n        stack = []\n        res = 0\n        for i in range(len(s)):\n            if len(stack) == 0 or (s[i] == '(' and stack[-1] == ')'):\n                stack.append(s[i])\n            else:\n                stack.append(s[i])\n                if s[i] == ')':\n                    stack.pop()\n                    if len(stack) == 0:\n                        res = max(res, i + 1)\n                    else:\n                        res = max(res, i - stack[-1])\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \"\"\"\n        self.longest = 0\n        for i in range(len(s)):\n            if self.isValid(s[i:]):\n                self.longest = max(self.longest, len(s[i:]))\n        return self.longest\n    def isValid(self, s):\n        n = len(s)\n        for i in range(n):\n            if s[i] == ')':\n                if s[i+1] == '(':\n                    s = s[:i]+'('+s[i+2:]\n        return s==''\n        \"\"\""
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        max_length = 0\n        if len(s) < 2:\n            return 0"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        longest_count = 0\n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(i)\n            else:\n                try:\n                    stack.pop()\n                    if len(stack) == 0:\n                        stack.append(i)\n                    else:\n                        stack.append(i)\n                except:\n                    stack.append(i)\n        if len(stack) == 0:\n            return longest_count\n        return len(stack) * 2"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if s == \"\": return 0\n        \n        n = len(s)\n        dp = [0 for i in range(n)]\n        for i in range(1,n):\n            if s[i] == \")\":\n                if s[i-1] == \"(\":\n                    if i >=2:\n                        dp[i] = dp[i-2] + 2\n                    else:\n                        dp[i] = 2\n                else:\n                    if i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == \"(\":\n                        if i-dp[i-1]-2 >= 0:\n                            dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2\n                        else:\n                            dp[i] = dp[i-1] + 2\n        return max(dp)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "prompt": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n        Example 1:\n        Input: s = \"(()\"\n        Output: 2\n        Explanation: The longest valid parentheses substring is \"()\".\n        Example 2:\n        Input: s = \")()())\"\n        Output: 4\n        Explanation: The longest valid parentheses substring is \"()()\".\n        Example 3:\n        Input: s = \"\"\n        Output: 0\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if len(s) == 0:\n            return 0\n        elif len(s) == 1:\n            return 0\n        elif len(s) == 2:\n            return 1 if s == \"()\" else 0"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not nums:\n            return -1\n        if len(nums) == 1:\n            return 0 if nums[0] == target else -1\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            if nums[0] <= target < nums[m]:\n                r = m - 1\n            elif nums[m] < target <= nums[len(nums) - 1]:\n                l = m + 1\n            elif nums[m] < nums[0]:\n                r = m - 1\n            else:\n                l = m + 1\n        return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not nums:\n            return -1\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if nums[pivot] == target:\n                return pivot\n            if nums[pivot] < nums[right]:\n                if nums[pivot] < target <= nums[right]:\n                    left = pivot + 1\n                else:\n                    right = pivot - 1\n            elif nums[pivot] > nums[right]:\n                if nums[left] <= target < nums[pivot]:\n                    right = pivot - 1\n                else:\n                    left = pivot + 1\n            else:\n                right -= 1\n        return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if not nums:\n            return -1\n        p = self.binary_search(nums, target, 0, len(nums)-1)\n        return p if p!= -1 else -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # find the pivot\n        # reverse the right part\n        # do binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            # left side is ordered\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target <= nums[mid]:\n                    # search on the right side\n                    left = mid + 1\n                else:\n                    # search on the left side\n                    right = mid - 1\n            # right side is ordered\n            else:\n                if nums[mid] <= target <= nums[right]:\n                    # search on the left side\n                    right = mid - 1\n                else:\n                    # search on the right side\n                    left = mid + 1\n        return -1\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not nums: return -1\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if nums[mid] == target:\n                return mid\n            # no rotation\n            if nums[mid] <= nums[r]:\n                if nums[mid] <= target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            # nums[mid] > nums[r]\n            else:\n                if nums[l] <= target <= nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        l, h = 0, len(nums) - 1\n        while l <= h:\n            mid = (l + h) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < nums[h]:\n                if nums[mid] < target and target <= nums[h]:\n                    l = mid + 1\n                else:\n                    h = mid - 1\n            elif nums[mid] > nums[h]:\n                if nums[l] <= target and target < nums[mid]:\n                    h = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                h -= 1\n        return -1\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Find the pivot index in O(n)\n        # Rotate nums[:pivot] in O(n)\n        # Find the target in O(log n)\n        # Check if target is in nums[pivot:]\n        # Return the index\n        n = len(nums)\n        if n == 1:\n            return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # Find the index of the smallest element\n        # or the first occurence of target\n        start = 0\n        end = len(nums)-1\n        while end > start:\n            mid = start + (end-start)//2\n            if nums[mid] >= nums[start]:\n                start = mid + 1\n            else:\n                end = mid\n        \n        # Start from the end to find first occurrence\n        # of the target or return -1 if not found\n        # This is done to handle duplicate values\n        start = end\n        end = len(nums)-1\n        while start <= end:\n            mid = start + (end-start)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return -1"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        There is an integer array nums sorted in ascending order (with distinct values).\n        Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n        Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [4,5,6,7,0,1,2], target = 0\n        Output: 4\n        Example 2:\n        Input: nums = [4,5,6,7,0,1,2], target = 3\n        Output: -1\n        Example 3:\n        Input: nums = [1], target = 0\n        Output: -1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # binary search for rotation index\n        start, end = 0, len(nums) - 1\n        while start < end:\n            mid = (start + end) // 2\n            if nums[mid] > nums[end]:\n                start = mid + 1\n            else:\n                end = mid\n        rotation_index = start\n        # binary search for target\n        start, end = 0, len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            mid_val = nums[mid]\n            if target == mid_val:\n                return mid\n            if target < mid_val:\n                if target > nums[0] and nums[0] <= mid_val:\n                    end = mid - 1\n                else:\n                    start = mid + 1\n            else:\n                if target <= nums[len(nums) - 1] and mid_val >= nums[len(nums) - 1]:\n                    start = mid + 1\n                else:\n                    end = mid - 1\n        return -1"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # binary search\n        if not nums:\n            return [-1, -1]\n        start, end = 0, len(nums) - 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if nums[mid] >= target:\n                end = mid\n            else:\n                start = mid\n        if nums[start] == target:\n            left = start\n        elif nums[end] == target:\n            left = end\n        else:\n            return [-1, -1]\n        start, end = left, len(nums) - 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if nums[mid] <= target:\n                start = mid\n            else:\n                end = mid\n        if nums[end] == target:\n            right = end\n        else:\n            right = start\n        return [left, right]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        result = [-1, -1]\n        if not nums:\n            return result\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        if left >= len(nums) or nums[left]!= target:\n            return result\n        result[0] = left"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        l = 0\n        r = len(nums) - 1"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # Find the index of the first occurrence of the target value.\n        left, right = 0, len(nums)-1\n        while left < right:\n            mid = left + (right-left)//2\n            if nums[mid] < target:\n                left = mid+1\n            else:\n                right = mid\n        # If the value does not exist in the array.\n        if nums[left]!= target:\n            return [-1, -1]\n        # Find the index of the last occurrence of the target value.\n        left, right = left, len(nums)-1\n        while left < right:\n            mid = left + (right-left)//2 + 1\n            if nums[mid] > target:\n                right = mid-1\n            else:\n                left = mid\n        return [left, right]<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not nums:\n            return [-1,-1]\n        low,high = 0,len(nums)-1\n        while low<=high:\n            mid = (low+high)//2\n            if nums[mid]<target:\n                low = mid+1\n            elif nums[mid]>target:\n                high = mid-1\n            else:\n                l = mid\n                r = mid\n                while True:\n                    if nums[l]!=target:\n                        l -= 1\n                    else:\n                        break\n                while True:\n                    if nums[r]!=target:\n                        r += 1\n                    else:\n                        break\n                return [l,r]\n        return [-1,-1]<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not nums:\n            return [-1, -1]"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # time complexity O(log(n))\n        # space complexity O(1)\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + ((right - left) // 2)\n            if nums[mid] == target:\n                break\n            if target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        if nums[mid]!= target:\n            return [-1, -1]"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        def binary_search(left, right):\n            if left > right:\n                return -1"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # binary search, O(logN)\n        # starting position\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                if nums[mid - 1]!= target:\n                    return [mid, mid]\n                else:\n                    r = mid - 1\n        # ending position\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                if nums[mid + 1]!= target:\n                    return [mid, mid]\n                else:\n                    l = mid + 1\n        return [-1, -1]\n        \n        # recursion\n        def binary_search(left, right, target):\n            if left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    if mid"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n        If target is not found in the array, return [-1, -1].\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [5,7,7,8,8,10], target = 8\n        Output: [3,4]\n        Example 2:\n        Input: nums = [5,7,7,8,8,10], target = 6\n        Output: [-1,-1]\n        Example 3:\n        Input: nums = [], target = 0\n        Output: [-1,-1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # target = target\n        # i = 0\n        # while i < len(nums):\n        #     if nums[i] == target:\n        #         return [i, i]\n        #     i += 1\n        # return [-1, -1]"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        # Assume the array is sorted and has no duplicates.\n        # if the target is not in the array, return the index where it would be inserted\n        # if the target is in the array, return the index of the target\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] > target:\n                right = mid - 1\n            \n            if nums[mid] < target:\n                left = mid + 1\n                \n        return left"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        return self.helper(nums, 0, len(nums) - 1, target)"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        #l,r = 0,len(nums)-1\n        #while l <= r:\n        #    mid = (l+r)//2\n        #    if nums[mid] == target:\n        #        return mid\n        #    elif nums[mid] < target:\n        #        l = mid + 1\n        #    else:\n        #        r = mid - 1\n        #return l\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if target in nums:\n            return nums.index(target)\n        if target < nums[0]:\n            return 0\n        elif target > nums[-1]:\n            return len(nums)\n        else:\n            for index, num in enumerate(nums):\n                if num <= target and index + 1 < len(nums):\n                    continue\n                elif num > target:\n                    return index\n                else:\n                    return index + 1"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        l = 0\n        r = len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l if nums[l] == target else l + 1\n        \"\"\"\n        Time complexity: O(log n)\n        Space complexity: O(1)\n        \"\"\""
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \n        start = 0\n        end = len(nums) - 1\n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return start<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        def binary_search(nums, target, start, end):\n            if start >= end:\n                return start\n            \n            mid = start + (end - start) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                return binary_search(nums, target, start, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, end)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if target in nums:\n            return nums.index(target)\n        else:\n            nums.append(target)\n            nums.sort()\n            return nums.index(target)"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "prompt": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        \"\"\"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.\n        Example 1:\n        Input: nums = [1,3,5,6], target = 5\n        Output: 2\n        Example 2:\n        Input: nums = [1,3,5,6], target = 2\n        Output: 1\n        Example 3:\n        Input: nums = [1,3,5,6], target = 7\n        Output: 4\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        nums.append(float('inf'))\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num == '.':\n                    continue\n                if num not in rows[i]:\n                    rows[i].add(num)\n                else:\n                    return False\n                if num not in cols[j]:\n                    cols[j].add(num)\n                else:\n                    return False\n                # 3x3 box\n                box_x = j // 3\n                box_y = i // 3\n                if num not in boxes[box_y * 3 + box_x]:\n                    boxes[box_y * 3 + box_x].add(num)\n                else:\n                    return False\n        return True\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not board:\n            return True\n        \n        cols = [dict() for _ in range(9)]\n        rows = [dict() for _ in range(9)]\n        boxes = [dict() for _ in range(9)]\n        for i, row in enumerate(board):\n            for j, ch in enumerate(row):\n                if ch.isdigit():\n                    digit = int(ch)\n                    box_idx = (i // 3) * 3 + j // 3\n                    # check if this value has been seen before in any of the nine boxes\n                    if rows[i].get(ch):\n                        return False\n                    rows[i][ch] = True\n                    cols[j][ch] = True\n                    boxes[box_idx][ch] = True\n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        def is_valid_row(row):\n            \"\"\"\n            Check if each row is valid.\n            \"\"\"\n            row = [s.replace('.','') for s in row]\n            for i in range(1, len(row) + 1):\n                row_str =''.join(row)\n                if row_str.count('{}'.format(i)) > 1:\n                    return False\n            return True"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        row_map = [set() for _ in range(9)]\n        col_map = [set() for _ in range(9)]\n        sub_map = [[set() for _ in range(3)] for _ in range(3)]"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # rows\n        for row in board:\n            if not self.isValid(row): return False\n        # cols\n        for i in range(9):\n            col = []\n            for j in range(9):\n                col.append(board[j][i])\n            if not self.isValid(col): return False\n        # sub boxes\n        for i in range(0,9,3):\n            for j in range(0,9,3):\n                sub = []\n                for k in range(i, i+3):\n                    for h in range(j, j+3):\n                        sub.append(board[k][h])\n                if not self.isValid(sub): return False\n        return True\n        \n    def isValid(self, nums):\n        return len(set(nums)) == len(nums)<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not board: return True\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [[set() for _ in range(3)] for _ in range(3)]\n        for i in range(9):\n            for j in range(9):\n                val = board[i][j]\n                if val == '.': continue\n                if val in rows[i] or val in cols[j] or val in boxes[i // 3][j // 3]:\n                    return False\n                rows[i].add(val)\n                cols[j].add(val)\n                boxes[i // 3][j // 3].add(val)\n        return True"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        return self.is_valid_board(board)"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        row = [{} for _ in range(9)]\n        col = [{} for _ in range(9)]\n        box = [{} for _ in range(9)]\n        for i in range(9):\n            for j in range(9):\n                if board[i][j]!= '.':\n                    val = int(board[i][j])\n                    box_index = (i // 3) * 3 + j // 3\n                    if row[i].get(val): return False\n                    if col[j].get(val): return False\n                    if box[box_index].get(val): return False\n                    row[i][val] = 1\n                    col[j][val] = 1\n                    box[box_index][val] = 1\n        return True"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Check row\n        for row in board:\n            s = set()\n            for i in row:\n                if i == '.': continue\n                if i not in s: s.add(i)\n                else: return False\n        # Check column\n        for i in range(9):\n            s = set()\n            for j in range(9):\n                if board[j][i] == '.': continue\n                if board[j][i] not in s: s.add(board[j][i])\n                else: return False\n        # Check box\n        for i in range(3):\n            for j in range(3):\n                s = set()\n                for r in range(3*i, 3*i+3):\n                    for c in range(3*j, 3*j+3):\n                        if board[r][c] == '.': continue\n                        if board[r][c] not in s: s.add(board[r][c])\n                        else: return False\n        return True"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "prompt": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: true\n        Example 2:\n        Input: board = \n        [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n       ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n       ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n       ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n       ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n       ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n       ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n       ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n       ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: false\n        Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        row_dict = dict()\n        col_dict = dict()\n        box_dict = dict()\n        for row in range(len(board)):\n            for col in range(len(board[row])):\n                if board[row][col]!= \".\":\n                    if board[row][col] in row_dict:\n                        return False\n                    row_dict[board[row][col]] = 1\n                    col_dict[board[row][col]] = 1\n                    box_dict[board[row][col]] = 1\n        return True\n        \n    \n        \n    def isValidSudoku_set(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n            Each row must contain the digits 1-9 without repetition.\n            Each column must contain the digits 1-9 without repetition.\n            Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n        Note:\n            A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n            Only the filled cells need to be validated according to the mentioned rules.\n        Example 1:\n        Input: board = \n        [[\""
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        self.board = board\n        self.solve()\n    \n    def solve(self):\n        \"\"\"\n        Backtracking\n        \"\"\"\n        # Find the next empty cell\n        for i in range(9):\n            for j in range(9):\n                if self.board[i][j] == '.':\n                    return self.solve_cell(i, j)"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        self.board = board\n        self.solve()"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        self.board = board\n        for i in range(9):\n            self.process_line(i)\n            self.process_column(i)\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                self.process_square(i, j)\n        for i in range(9):\n            for j in range(9):\n                if self.board[i][j] == \".\":\n                    for k in range(1, 10):\n                        self.board[i][j] = str(k)\n                        if self.is_valid() and self.solve():\n                            return\n                        self.board[i][j] = \".\"\n                    return\n        return\n        \n    def process_line(self, i):\n        line = self.board[i]\n        chars = [c for c in line]\n        if set(chars)!= set(\"123456789.\"):\n            return False\n        return True\n    \n    def process_column(self, i):\n        column = [row[i] for row in self.board]\n        chars = [c for c in column]\n        if set(chars)!= set(\"123456789.\"):\n            return False\n        return True\n    \n    def"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        self.board = board\n        self.solve()"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # global variable\n        self.board = board\n        self.rows = 9\n        self.columns = 9\n        self.sub_box_size = 3\n        self.EMPTY = '.'"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Step 0. Initialize variables.\n        rows, cols = [], []\n        for i in range(0, 9):\n            rows.append([])\n            cols.append([])\n        # Step 1. Enumerate all cells.\n        for r in range(0, 9):\n            for c in range(0, 9):\n                # Step 2. If the cell is empty, append the cell to row and column lists.\n                if board[r][c] == \".\":\n                    rows[r].append(r)\n                    cols[c].append(c)\n        # Step 3. Enumerate all candidates.\n        candidates = []\n        for r in range(0, 9):\n            for c in range(0, 9):\n                candidates.append((r, c))\n        # Step 4. Remove invalid candidates.\n        for r, c in candidates:\n            if len(rows[r]) == 1 and len(cols[c]) == 1:\n                # Remove the row and column of the cell.\n                rows[r], cols[c] = [], []\n                # Remove the cell itself.\n                candidates.remove((r, c))\n        # Step 5. Backtrack to fill in the cell.\n        self.backtrack(board, candidates, rows, col"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        row_dic = collections.defaultdict(set)\n        col_dic = collections.defaultdict(set)\n        block_dic = collections.defaultdict(set)"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        self.row = []\n        self.col = []\n        self.box = []"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # step 1: init data\n        rows = [set() for _ in range(9)]\n        columns = [set() for _ in range(9)]\n        blocks = [set() for _ in range(9)]\n        empty = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty.append((i, j))\n                else:\n                    rows[i].add(board[i][j])\n                    columns[j].add(board[i][j])\n                    blocks[(i // 3) * 3 + j // 3].add(board[i][j])\n        \n        # step 2: backtracking\n        self.solveSudoku_dfs(board, 0, empty, rows, columns, blocks)\n        \n        \n    def solveSudoku_dfs(self, board, index, empty, rows, columns, blocks):\n        # terminator\n        if index == len(empty):\n            return True\n        \n        # update data\n        i, j = empty[index]\n        possible_values = ['1', '2', '3', '4', '5', '6', '7', '8', '9']\n        for value in possible_values:\n            if"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n        A sudoku solution must satisfy all of the following rules:\n            Each of the digits 1-9 must occur exactly once in each row.\n            Each of the digits 1-9 must occur exactly once in each column.\n            Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n        The '.' character indicates empty cells.\n        Example 1:\n        Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n        Output: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n        Explanation: The input board is shown above and the only valid solution is shown below:\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        def dfs(board, x, y):\n            for i in range(9):\n                if board[x][i] == \".\":\n                    board[x][i] = str(y)\n                    break\n                elif y!= board[x][i]:\n                    return False"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        def say(s):\n            res = []\n            count = 0\n            for i in range(len(s)):\n                if s[i]!= s[count]:\n                    res.append(str(count))\n                    res.append(s[i])\n                    count = i\n                if i == len(s) - 1:\n                    res.append(str(count + 1))\n                    res.append(s[i])\n            return ''.join(res)\n        \n        if n == 1:\n            return \"1\"\n        return say(self.countAndSay(n - 1))\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # base case\n        if n == 1:\n            return \"1\"\n        else:\n            # count and say\n            s = self.countAndSay(n-1)\n            # make new string\n            new = []\n            i = 0\n            # loop through string\n            while i < len(s):\n                # count number of times\n                counter = 1\n                # loop through string\n                while i+counter < len(s) and s[i] == s[i+counter]:\n                    counter += 1\n                # add number to new string\n                new.append(str(counter))\n                new.append(s[i])\n                i += counter\n            return \"\".join(new)"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        res = '1'\n        if n == 1:\n            return res\n        for i in range(n - 1):\n            res = self.say(res)\n        return res"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if n == 1:\n            return \"1\"\n        else:\n            return self.count_say(n)"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # TIME COMPLEXITY: O(n)\n        # SPACE COMPLEXITY: O(n)\n        # Base Case\n        if n == 1:\n            return \"1\""
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if n == 1: return \"1\"\n        if n == 2: return \"11\"\n        \n        def say(s):\n            new = \"\"\n            count = 0\n            last = s[0]\n            for i in range(len(s)):\n                if s[i]!= last:\n                    new += str(count) + last\n                    count = 0\n                    last = s[i]\n                count += 1\n            new += str(count) + last\n            return new\n            \n        s = self.countAndSay(n-1)\n        return say(s)\n            \n            \n    def countAndSay_iter(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        s = \"1\"\n        for i in range(n-1):\n            j = 0\n            tmp = []\n            while j < len(s):\n                count = 1\n                while j+1 < len(s) and s[j] == s[j+1]:\n                    j += 1\n                    count += 1\n                tmp.append(str(count) + s[j])\n                j += 1\n            s = \"\".join(tmp)\n        return s"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        count_and_say = \"1\"\n        for i in range(n - 1):\n            count_and_say = self.count_and_say_recursive(count_and_say)\n        return count_and_say\n    \n    def count_and_say_recursive(self, input_string):\n        if len(input_string) == 1:\n            return \"1\" + input_string\n        else:\n            count = 1\n            result = \"\"\n            for i in range(1, len(input_string)):\n                if input_string[i] == input_string[i - 1]:\n                    count += 1\n                else:\n                    result += str(count)\n                    result += input_string[i - 1]\n                    count = 1\n            result += str(count)\n            result += input_string[len(input_string) - 1]\n            return self.count_and_say_recursive(result)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if n == 1:\n            return \"1\"\n        else:\n            result = \"1\"\n            for i in range(1, n):\n                count, count_result = 1, \"\"\n                for j in range(len(result) - 1):\n                    if result[j] == result[j + 1]:\n                        count += 1\n                    else:\n                        count_result += str(count) + str(result[j])\n                        count = 1\n                count_result += str(count) + str(result[-1])\n                result = count_result\n            return result"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "prompt": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n            countAndSay(1) = \"1\"\n            countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n        To determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n        For example, the saying and conversion for digit string \"3322251\":\n        Given a positive integer n, return the nth term of the count-and-say sequence.\n        Example 1:\n        Input: n = 1\n        Output: \"1\"\n        Explanation: This is the base case.\n        Example 2:\n        Input: n = 4\n        Output: \"1211\"\n        Explanation:\n        countAndSay(1) = \"1\"\n        countAndSay(2) = say \"1\" = one 1 = \"11\"\n        countAndSay(3) = say \"11\" = two 1's = \"21\"\n        countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if n == 1:\n            return \"1\"\n        else:\n            previous = self.countAndSay(n-1)\n            current = \"\"\n            current_char = None\n            count = 0\n            for char in previous:\n                if char == current_char:\n                    count += 1\n                else:\n                    if current_char is not None:\n                        current = current + str(count) + str(current_char)\n                    current_char = char\n                    count = 1\n            current = current + str(count) + str(current_char)\n            return current"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        res = []\n        n = len(candidates)\n        self.combinationSum_helper(candidates, 0, [], 0, target, res)\n        return res"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        res = []"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        results = []\n        if not candidates:\n            return results\n        candidates.sort()\n        self.combine_sum_helper(candidates, 0, [], results, target)\n        return results"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        result = []\n        self.combination_sum_helper(sorted(candidates), target, [], result)\n        return result\n    \n    def combination_sum_helper(self, candidates, target, current, result):\n        \"\"\"\n        Time: O(n^m) m is the maximum length of each combination\n        Space: O(m)\n        \"\"\"\n        if target < 0:\n            return\n        if target == 0:\n            result.append(current)\n            return\n        for i in range(len(candidates)):\n            self.combination_sum_helper(candidates[i:], target - candidates[i], current + [candidates[i]], result)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        self.res = []\n        self.candidates = candidates\n        self.target = target\n        self.dfs(0, [])\n        return self.res\n        \n    def dfs(self, curr_sum, curr_list):\n        if curr_sum > self.target:\n            return\n        if curr_sum == self.target:\n            self.res.append(curr_list)\n        else:\n            for i in range(len(self.candidates)):\n                self.dfs(curr_sum + self.candidates[i], curr_list + [self.candidates[i]])"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        self.ans = []\n        self.candidates = candidates\n        self.dfs(target, [], 0)\n        return self.ans\n    \n    def dfs(self, target, path, index):\n        if target < 0:\n            return\n        if target == 0:\n            self.ans.append(path[:])\n            return\n        for i in range(index, len(self.candidates)):\n            self.dfs(target - self.candidates[i], path + [self.candidates[i]], i)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # idea: for each candidate, traverse it to target, generate a list of lists.\n        # then combine all the lists into one list of lists.\n        # O(n^m * m), m = the sum of candidates\n        # O(n * m^2)\n        # m = target + 1\n        # brute force: O(n * m^m)\n        # there are two cases: if candidate is included, there are n*m - 1 candidates left, and if not included, there are n*(m - 1) candidates left\n        # 1 <= candidates.length <= 30\n        # 1 <= candidates[i] <= 200\n        # 1 <= target <= 500\n        candidates.sort()\n        res = []\n        self.dfs(candidates, 0, [], res, target)\n        return res"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        def combination_sum(candidates, target, cur_sum, index, path, result):\n            if cur_sum == target:\n                result.append(path)\n                return\n            if cur_sum > target or index >= len(candidates):\n                return"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        result = []"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n        The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n        The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n        Example 1:\n        Input: candidates = [2,3,6,7], target = 7\n        Output: [[2,2,3],[7]]\n        Explanation:\n        2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n        7 is a candidate, and 7 = 7.\n        These are the only two combinations.\n        Example 2:\n        Input: candidates = [2,3,5], target = 8\n        Output: [[2,2,2,2],[2,3,3],[3,5]]\n        Example 3:\n        Input: candidates = [2], target = 1\n        Output: []\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        results = []\n        for i, num in enumerate(candidates):\n            if target - num == 0:\n                results.append([num])\n            elif target - num >= 0:\n                for result in self.combinationSum(candidates[i:], target - num):\n                    result.append(num)\n                    results.append(result)\n        return results"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not candidates or target <= 0:\n            return []\n        candidates.sort()\n        self.res = []\n        self.target = target\n        self.dfs(0, [], 0)\n        return self.res\n    \n    def dfs(self, start, path, path_sum):\n        if path_sum > self.target:\n            return\n        if path_sum == self.target:\n            self.res.append(path[:])\n            return\n        for i in range(start, len(self.candidates)):\n            if i > start and self.candidates[i] == self.candidates[i - 1]:\n                continue\n            self.dfs(i + 1, path + [self.candidates[i]], path_sum + self.candidates[i])\n        \n    \n    \nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), \n        find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        def dfs(nums, path, remain):\n            if remain == 0:\n                result.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                if nums[i] <= remain:\n                    dfs(nums[i+1:], path + [nums[i]], remain - nums[i])\n        \n        result = []\n        candidates.sort()\n        dfs(candidates, [], target)\n        return result"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        # Solution 1\n        ans = []\n        self.dfs(candidates, target, [], ans, 0)\n        return ans\n        \n    def dfs(self, candidates, target, cur, ans, index):\n        if target == 0:\n            ans.append(cur[:])\n            return\n        for i in range(index, len(candidates)):\n            if i > index and candidates[i] == candidates[i - 1]:\n                continue\n            cur.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], cur, ans, i + 1)\n            cur.pop()\n        return\n    \n    # Solution 2\n    def combinationSum2_1(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \n        if not candidates or not target:\n            return []\n        \n        def dfs(nums, target, path):\n            if target < 0:\n                return\n            if target == 0:\n                result.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                if nums[i] > target:\n                    return\n                dfs(nums[i+1:], target - nums[i], path + [nums[i]])\n                \n        result = []\n        nums = sorted(candidates)\n        dfs(nums, target, [])\n        return result\n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        def dfs(target, idx, path):\n            if target == 0:\n                result.append(path)\n                return\n            \n            if target < 0:\n                return\n            \n            for i in range(idx, len(candidates)):\n                if i > idx and candidates[i] == candidates[i-1]:\n                    continue\n                dfs(target - candidates[i], i+1, path + [candidates[i]])\n        \n        candidates.sort()\n        result = []\n        dfs(target, 0, [])\n        return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        def findCombination(candidates, target):\n            if target == 0:\n                result.append(temp)\n            elif target < candidates[0]:\n                return\n            else:\n                for i in range(len(candidates)):\n                    if i > 0 and candidates[i] == candidates[i-1]:\n                        continue\n                    temp.append(candidates[i])\n                    findCombination(candidates[i+1:], target-candidates[i])\n                    temp.pop()"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \n        # DFS\n        # O(n^2)\n        self.res = []\n        candidates.sort()\n        self.backtrack(candidates, target, 0, [])\n        return self.res\n    \n    def backtrack(self, nums, target, index, comb):\n        if target < 0:\n            return\n        if target == 0:\n            self.res.append(comb)\n            return\n        \n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            self.backtrack(nums, target-nums[i], i+1, comb+[nums[i]])\n    \n    # DFS + memorization\n    # O(n^2)\n    def combinationSum2(self, candidates, target):\n        res = []\n        candidates.sort()\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, index, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(index, len(nums)):"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        candidates.sort()\n        n = len(candidates)\n        res = []\n        \n        def backtracking(i, total, temp):\n            if total == target:\n                res.append(temp)\n                return\n            for j in range(i, n):\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                if total + candidates[j] > target:\n                    break\n                backtracking(j+1, total+candidates[j], temp + [candidates[j]])\n                \n        backtracking(0, 0, [])\n        return res\n    \n    def combinationSum2_2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        "
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # Each number in candidates may only be used once in the combination\n        # Use a set to remove duplicates\n        self.res = set()\n        self.dfs(sorted(candidates), 0, target, [])\n        return list(self.res)\n        \n    def dfs(self, candidates, start, target, comb):\n        if target == 0:\n            self.res.add(tuple(comb))\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, i+1, target - candidates[i], comb + [candidates[i]])\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n        Each number in candidates may only be used once in the combination.\n        Note: The solution set must not contain duplicate combinations.\n        Example 1:\n        Input: candidates = [10,1,2,7,6,1,5], target = 8\n        Output: \n        [\n        [1,1,6],\n        [1,2,5],\n        [1,7],\n        [2,6]\n        ]\n        Example 2:\n        Input: candidates = [2,5,2,1,2], target = 5\n        Output: \n        [\n        [1,2,2],\n        [5]\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        def dfs(candidates, target, idx, path, res):\n            if target == 0:\n                res.append(path[:])\n            if target < 0:\n                return\n            for i in range(idx, len(candidates)):\n                if i > idx and candidates[i] == candidates[i-1]:\n                    continue\n                path.append(candidates[i])\n                dfs(candidates, target-candidates[i], i+1, path, res)\n                path.pop()\n        \n        candidates.sort()\n        res = []\n        dfs(candidates, target, 0, [], res)\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        n = len(nums)\n        if n == 0: return 1"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 1\n        \n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i]-1]!= nums[i]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n                \n        for i in range(n):\n            if nums[i]!= i+1:\n                return i+1\n        \n        return n+1\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # Basic case\n        if 1 not in nums:\n            return 1\n        if len(nums) == 1:\n            return 2\n        # Step 1: add the nums to a set\n        s = set()\n        for n in nums:\n            if n < 0:\n                continue\n            elif n == 0:\n                continue\n            s.add(n)\n        # Step 2: sort the set and return the first element\n        return min([n for n in range(1, len(s) + 2) if n not in s])"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # 1. \u6570\u7ec4\u6392\u5e8f\n        # 2. \u4ece\u7b2c\u4e00\u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u627e\u5230\u5b83\u5728\u6570\u7ec4\u4e2d\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u8ba9\u5b83\u7d22\u5f15\u4e3a\u6b63\u786e\u7684\u4f4d\u7f6e\u3002\n        # 3. \u4f9d\u6b21\u7ee7\u7eed\u4ece\u6392\u5e8f\u540e\u6570\u7ec4\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u5f00\u59cb\uff0c\u7ee7\u7eed\u627e\u5230\u5143\u7d20\u5728\u6570\u7ec4\u4e2d\u7684\u4f4d\u7f6e\u3002\n        # 4. \u904d\u5386\u4e00\u904d\u6570\u7ec4\uff0c\u82e5\u51fa\u73b0\u6b63\u6574\u6570\u5c31\u5c06\u5176\u66ff\u6362\u4e3a\u5b83\u7684\u7d22\u5f15\uff0c\u76f4\u5230\u6ca1\u6709\u51fa\u73b0\u6b63\u6574\u6570\n        # 5. \u8fd4\u56de\u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u6b63\u7d22\u5f15\u7684\u4e0b\u6807+1\u3002\n        # \u65f6\u95f4\u590d\u6742\ufffd"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        for i in range(len(nums)):\n            if nums[i]<0:\n                nums[i] = len(nums)+1\n        nums.sort()\n        for i in range(1,len(nums)):\n            if nums[i]!=nums[i-1]:\n                return nums[i-1]+1\n        return len(nums)+1\n        \n        \n        \n        \"\"\"\n        Algorithm:\n        1. Find all the elements in the array\n        2. Find the smallest positive integer that is missing from the array\n        \"\"\"\n        \n        # 1. Find all the elements in the array\n        n = len(nums)\n        for i in range(n):\n            nums[i] = abs(nums[i])\n        nums.sort()\n        \n        # 2. Find the smallest positive integer that is missing from the array\n        i, missing = 0, 1\n        while i < n and nums[i] == missing:\n            i += 1\n            missing += 1\n        return missing<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Method 1: Using HashSet\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # sorted_nums = set(nums)\n        # for i in range(1, len(nums) + 1):\n        #     if i not in sorted_nums:\n        #         return i\n        \n        # # Method 2: Using OrderedDict\n        # # Time complexity: O(n)\n        # # Space complexity: O(n)\n        # # sorted_nums = collections.OrderedDict.fromkeys(nums)\n        # # for i in range(1, len(nums) + 1):\n        # #     if i not in sorted_nums:\n        # #         return i\n        \n        # Method 3: Using Sorting\n        # Time complexity: O(nlogn)\n        # Space complexity: O(1)\n        # # nums = sorted(nums)\n        # # for i in range(len(nums)):\n        # #     if nums[i] <= 0:\n        # #         nums[i] = len(nums) + 1\n        # #     if nums[i]!= nums[i - 1]:\n        # #         return nums[i - 1]\n"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # list of positive ints\n        nums = set(nums)\n        # lowest pos int\n        nums_min = min(nums)\n        # highest pos int\n        nums_max = max(nums)\n        # if one or zero pos int, return highest pos int + 2\n        if nums_min == 0 or nums_max == 0:\n            return 1\n        # if nums_min > 0, return lowest missing pos int\n        if nums_min > 1:\n            return 1\n        # if nums_max < 0, return lowest missing pos int\n        if nums_max < 1:\n            return 1\n        # nums_max < 0 and nums_min > 0, return lowest missing pos int + 1\n        return 1\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Solution:\n        # 1. Sort all elements in the array.\n        # 2. If there is a number which is out of the range of the array, then it means that the number is missing.\n        # 3. Otherwise, we need to find the first element which is missing, which means that we need to find the number which is not in the range of the array.\n        # 4. Therefore, we have to find the first number that is not positive, which is the answer.\n        # Note that we need to remove all the duplicates first.\n        nums = list(set(nums))\n        n = len(nums)\n        if n == 0:\n            return 1\n        if 1 not in nums:\n            return 1\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n+1\n        nums.sort()\n        for i in range(1, n+1):\n            if nums[i-1]!= i:\n                return i\n        return n+1"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        #find the number of positives\n        n = len(nums)\n        positives = set()\n        for num in nums:\n            if num > 0:\n                positives.add(num)\n        # sort the set of positives\n        positives = sorted(list(positives))\n        # check if the first positive is missing\n        if positives[0] > 1:\n            return 1\n        # check if all the positives are in the array\n        if len(positives) == n:\n            return max(positives) + 1\n        #check if we need to add one positive\n        if len(positives) + 1 < n:\n            return positives[-1] + 1\n        # check if we need to add several positives\n        return positives[-1] + 1 + len(positives) - n\n        "
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "prompt": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n        You must implement an algorithm that runs in O(n) time and uses constant extra space.\n        Example 1:\n        Input: nums = [1,2,0]\n        Output: 3\n        Explanation: The numbers in the range [1,2] are all in the array.\n        Example 2:\n        Input: nums = [3,4,-1,1]\n        Output: 2\n        Explanation: 1 is in the array but 2 is missing.\n        Example 3:\n        Input: nums = [7,8,9,11,12]\n        Output: 1\n        Explanation: The smallest positive integer 1 is missing.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not nums:\n            return 1\n        for i, n in enumerate(nums):\n            while i + 1!= n and n - 1!= i and n!= i + 1:\n                # print(f'i: {i}, n: {n}, n-1: {n-1}, {n!=n-1}, {n-1!= i}, {i+1!= n}, {n!=i+1}')\n                if n - 1 == i:\n                    nums[n - 1], nums[n - 1] = nums[n - 1], nums[n - 1]\n                elif n - 1!= i:\n                    nums[i], nums[n - 1] = nums[n - 1], nums[i]\n        # print(nums)\n        for i, n in enumerate(nums, 1):\n            if n!= i:\n                return i\n        return i + 1"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        # Approach 1: Two Pointers + Stack\n        # Stack stores index of left highest bar, height of highest bar, and index of right highest bar.\n        # Two pointers move through array and then pops off stack when left pointer exceeds right pointer.\n        # Time: O(n)\n        # Space: O(n)\n        # Intuition:\n        # Find left and right side of the water\n        # compare the left side with right side, move the pointer that is more left to the right\n        # if left < right, then there is a place to fill water\n        # The water only goes from left to right, so we can use the left height to fill the water\n        # Once we find the right side, we will need to move the left pointer to the right and move the left pointer\n        # and right pointer to the left. This will be done by checking the index of left, right and stack\n        # We have to do this because left pointer cannot exceed right pointer\n        \n        n = len(height)\n        \n        left_height = 0\n        right_height = 0\n        stack = []\n        \n        for i in range(n):\n            if i < n - 1 and height[i] >= height[i+1]:\n                while len(stack) > 0:\n                    if stack[-1][0] < height"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # \u53cc\u6307\u9488\n        # left, right = 0, len(height) - 1\n        # left_max, right_max = 0, 0\n        # res = 0\n        #\n        # while left < right:\n        #     left_max = max(left_max, height[left])\n        #     right_max = max(right_max, height[right])\n        #     if left_max < right_max:\n        #         res += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         res += right_max - height[right]\n        #         right -= 1\n        # return res"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if len(height) < 3:\n            return 0\n        l, r = 0, len(height) - 1\n        l_max, r_max = height[l], height[r]\n        result = 0\n        while l < r:\n            l_max, r_max = max(l_max, height[l]), max(r_max, height[r])\n            if l_max <= r_max:\n                result += l_max - height[l]\n                l += 1\n            else:\n                result += r_max - height[r]\n                r -= 1\n        return result\n    \n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        "
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # TODO: Approach 1: Brute Force [O(n2) & O(1)]\n        # TODO: Approach 2: Stack [O(n) & O(n)]\n        # TODO: Approach 3: Two pointers [O(n) & O(1)]"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        ans = 0\n        left = 0\n        right = len(height) - 1\n        left_max = 0\n        right_max = 0\n        while left < right:\n            if height[left] < height[right]:\n                if height[left] >= left_max:\n                    left_max = height[left]\n                else:\n                    ans += left_max - height[left]\n                left += 1\n            else:\n                if height[right] >= right_max:\n                    right_max = height[right]\n                else:\n                    ans += right_max - height[right]\n                right -= 1\n        return ans\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not height:\n            return 0\n        left_max = [height[0]] * len(height)\n        right_max = [height[-1]] * len(height)\n        for i in range(1, len(height)):\n            left_max[i] = max(height[i], left_max[i - 1])\n        for i in range(len(height) - 2, -1, -1):\n            right_max[i] = max(height[i], right_max[i + 1])\n        ans = 0\n        for i in range(len(height)):\n            if min(left_max[i], right_max[i]) - height[i] > 0:\n                ans += min(left_max[i], right_max[i]) - height[i]\n        return ans\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        res = 0\n        left, right = 0, len(height)-1\n        left_max, right_max = 0, 0\n        while left <= right:\n            left_max = max(left_max, height[left])\n            right_max = max(right_max, height[right])\n            if left_max <= right_max:\n                res += left_max - height[left]\n                left += 1\n            else:\n                res += right_max - height[right]\n                right -= 1\n        return res"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # \u4f7f\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u54110\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u672b\u5c3e\u3002\n        # \u5f53\u524d\u7684\u6307\u9488\u6307\u5411\u7684\u5143\u7d20\u4e3a\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u503c\uff0c\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u503c\uff0c\n        # \u5982\u679c\u4e24\u8fb9\u6ca1\u6709\u6bd4\u5b83\u5927\u7684\uff0c\u8fd4\u56de0\u3002\n        # \u8ba1\u7b97\u9762\u79ef\uff0c\u8fd4\u56de\u79ef\u6c34\u91cf\uff01\n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        total_water = 0\n        while left < right:\n            left_max = max(left_max, height[left])\n            right_max = max(right_max, height[right])\n            if left_max < right_max:\n                total_water += left_max - height[left]\n                left"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not height:\n            return 0\n        n = len(height)\n        left, right = [0] * n, [0] * n\n        left[0] = height[0]\n        for i in range(1, n):\n            left[i] = max(left[i-1], height[i])\n        right[n-1] = height[n-1]\n        for i in range(n-2, -1, -1):\n            right[i] = max(right[i+1], height[i])\n        ans = 0\n        for i in range(n):\n            ans += min(left[i], right[i]) - height[i]\n        return ans"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "prompt": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        \"\"\"\n        Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n        Example 1:\n        Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\n        Output: 6\n        Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n        Example 2:\n        Input: height = [4,2,0,3,2,5]\n        Output: 9\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \"\"\"\n        \u89e3\u9898\u601d\u8def\uff1a\n        \u9996\u5148\u5bf9height\u8fdb\u884c\u5355\u8c03\u6808\u7684\u64cd\u4f5c\n        \u5982\u679c\u6700\u9ad8\u7684\u67f1\u5b50\u7684\u9ad8\u5ea6\u88ab\u5176\u4ed6\u67f1\u5b50\u5f62\u6210\u5824\u5761\uff0c\u90a3\u4e48\u8fd9\u4e2a\u67f1\u5b50\u5c31\u4e0d\u662f\u6700\u9ad8\u7684\uff0c\u9700\u8981\u79fb\u9664\n        \u6700\u540e\u8ba1\u7b97\u7b54\u6848\n        \u8fd9\u9053\u9898\u53ef\u4ee5\u5206\u4e3a\u4e24\u79cd\u65b9\u6cd5\uff0c\u5373\u4e24\u79cd\u65b9\u6cd5\u7684\u601d\u8def\u4e0d\u540c\uff0c\u9700\u8981\u6ce8\u610f\u5730\u65b9\u3002\n        \u65b9\u6cd51\uff1a\n        1. \u6bcf\u6b21\u627e\u5230\u4e00\u4e2a\u67f1\u5b50\u9ad8\u5ea6\u8f83\u9ad8\uff0c\u8ba1\u7b97\u5824\u5761\u9762\u79ef\uff0c\u8fd9\u6837\u603b\u9762\u79ef\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u67f1\u5b50\u503c\ufffd"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        n1 = num1[::-1]\n        n2 = num2[::-1]\n        n_len1 = len(n1)\n        n_len2 = len(n2)\n        n_n_len = n_len1 + n_len2\n        res = [0 for _ in range(n_n_len + 1)]\n        res[0] = 1\n        for i in range(1, n_len1 + 1):\n            res[i] = res[i - 1] * int(n1[i - 1])\n        for j in range(1, n_len2 + 1):\n            cur_digit = int(n2[j - 1]) * res[n_len1 + j - 1]\n            cur_digit += res[n_len1 + j - 1]\n            res[n_len1 + j] = cur_digit\n        for i in range(n_n_len):\n            res[i + 1] += res[i] // 10\n            res[i] %= 10\n        for i in range(1, n_n_len + 1):\n            if res[i] == 0:\n                continue\n            if res[i - 1] == 0:\n                res[i] = 0\n            else:\n                res["
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        m, n = len(num1), len(num2)\n        if m == 0 or n == 0:\n            return '0'\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        i, j = 0, 0\n        res = [0 for _ in range(m+n)]\n        for k in range(m+n):\n            p = 0\n            q = 0\n            if k < m+n-1:\n                if k >= m:\n                    p = int(num2[j])\n                    j += 1\n                else:\n                    p = int(num1[i])\n                    i += 1\n            else:\n                p = 1\n            if k >= m+n-1:\n                q = 1\n            elif k >= m:\n                q = int(num2[j])\n                j += 1\n            else:\n                q = int(num1[i])\n                i += 1\n            # print(k, p, q)\n            cur = int(p) * int(q) + res[k-1]\n            res[k] = cur % 10\n            res[k-1] = cur // 10\n        # print(res)\n        j = len(res) - 1\n        while res[j"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if num1 == \"0\" or num2 == \"0\":\n            return \"0\""
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        n1 = len(num1)\n        n2 = len(num2)\n        if n1 == 0 or n2 == 0:\n            return ''\n        # \u7528\u4e8e\u5b58\u50a8\u8fdb\u4f4d\n        sign = 1\n        # \u4e24\u4e2a\u957f\u5ea6\u4e0d\u540c\uff0c\u6570\u5b57\u7684\u5f62\u5f0f\u4e0d\u540c\n        if n1 > n2:\n            num2 = '0'*(n1-n2) + num2\n            sign = -1\n        else:\n            num1 = '0'*(n2-n1) + num1\n        # \u8ba1\u7b97\u4e58\u79ef\n        mul = 0\n        for i,num in enumerate(num1[::-1]):\n            # \u6bcf\u4e00\u4f4d\u7684\u4e58\u79ef\n            mul += int(num)*int(num2[::-1][i])*sign\n            # \u8ba1\u7b97\u8fdb\u4f4d\n            if mul >= 10:\n                # \u6bcf\u4e00\u4f4d\u7684\u8fdb\u4f4d\n                mul %= 10\n                # \u52a0\u4e0a\u4e2a\u5b57\u7b26\n                res += str(int(num))\n            else:\n                res = str(mul) + res"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Runtime: 60 ms\n        # Memory: 13.8 MB\n        self.num1 = num1\n        self.num2 = num2\n        return str(self.multiplication(num1, num2))"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        num1, num2 = num1[::-1], num2[::-1]\n        ans = 0\n        for i, n1 in enumerate(num1):\n            n1 = int(n1)\n            for j, n2 in enumerate(num2):\n                n2 = int(n2)\n                ans += (n1 * n2) * 10 ** i * 10 ** j\n        return str(ans)"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \n        # Convert each number to an integer\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # Initialize a variable to store the product of the two numbers\n        product = 0\n        \n        # A helper method to multiply two numbers\n        def multiplyTwo(num1, num2):\n            # Initialize a variable to store the product of the two numbers\n            product = 0\n            # Initialize a variable to store the powers of 10\n            power10 = 1\n            \n            # Go through each digit of num1\n            for digit1 in num1:\n                # Go through each digit of num2\n                for digit2 in num2:\n                    # Multiply digit1 and digit2 and add the product to the product variable\n                    product += int(digit1) * int(digit2) * power10\n                    \n                # Multiply power10 by 10\n                power10 *= 10\n            \n            # Return the product of the two numbers\n            return product\n        \n        # Check if num1 is greater than num2\n        if len(num1) > len(num2):\n            # Store the difference in the lengths\n            diff = len(num1) - len(num2)\n            # Initialize a variable to store the product of the two numbers\n            product = 0\n"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if num1 == \"0\" or num2 == \"0\": return \"0\"\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        n1, n2 = len(num1), len(num2)\n        res = [0 for _ in range(n1 + n2)]\n        for i in range(n1):\n            for j in range(n2):\n                s = int(num1[i]) * int(num2[j])\n                res[i+j] += s\n                res[i+j+1] += s // 10\n                res[i+j] %= 10\n        res = \"\".join([str(x) for x in res[::-1]])\n        return res if res[0]!= \"0\" else res[1:]\n        # @lc code=end\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        m = len(num1)\n        n = len(num2)\n        if m == 0 or n == 0:\n            return ''\n        res = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                multi = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                multi_val = multi + res[i + j + 1]\n                val = multi_val % 10\n                res[i + j + 1] = multi_val // 10\n                res[i + j] += val\n        head = 0\n        while head < len(res) and res[head] == 0:\n            head += 1\n        return ''.join([chr(i + ord('0')) for i in res[head:]])"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "prompt": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n        Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n        Example 1:\n        Input: num1 = \"2\", num2 = \"3\"\n        Output: \"6\"\n        Example 2:\n        Input: num1 = \"123\", num2 = \"456\"\n        Output: \"56088\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        n1 = len(num1)\n        n2 = len(num2)\n        n = n1 + n2\n        if n1 == 0 or n2 == 0:\n            return \"0\""
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n        return dp[-1][-1]"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            if p[i - 1] == '*':\n                dp[0][i] = dp[0][i - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] in [s[i - 1], '?']:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        return dp[m][n]\n    \n    def isMatch_TLE(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # Time Complexity: O(2^n), where n is the length of the pattern string\n        # Space Complexity: O(n)\n        if s == p:\n            return True\n        if not s:\n            return p == '*'"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        ## (1) edge case:\n        # string is empty and pattern is empty\n        # string is empty and pattern is not empty\n        # string is not empty and pattern is empty\n        \n        # (2) state\n        # \".\"   \"a\"   \"*\"\n        #    s\n        #    p\n        #    dp[s_len][p_len]\n        \n        ## (3) initialization\n        s_len, p_len = len(s), len(p)\n        \n        dp = [[False] * (p_len + 1) for _ in range(s_len + 1)]\n        dp[0][0] = True\n        for i in range(1, p_len + 1):\n            if p[i - 1] == \"*\":\n                dp[0][i] = dp[0][i - 1]\n        \n        ## (4) state transformation\n        for i in range(1, s_len + 1):\n            for j in range(1, p_len + 1):\n                if p[j - 1] == \".\" or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == \"*\":\n"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        m = len(s)\n        n = len(p)"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not s:\n            if p.count('*') == len(p):\n                return True\n            else:\n                return False\n        if not p:\n            return False\n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        elif p[0] == '*':\n            while s and (p[1] in {'.', s[0]}):\n                if self.isMatch(s, p[2:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[2:])\n        else:\n            return False"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        m, n = len(s), len(p)\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if i > 0 and (s[i - 1] == p[j - 2] or p[j - 2] == '?'):\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                else:\n                    if i > 0 and (s[i - 1] == p[j - 1] or p[j - 1] == '?'):\n                        dp[i][j] = dp[i - 1][j - 1]\n        return dp[m][n]"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # base cases\n        if not p:\n            return not s\n        if len(p) == 1:\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return True\n            else:\n                return False\n        # two characters\n        if len(p) == 2:\n            if s and (p[0] == s[0] or p[0] == '?') and (p[1] == '*' or p[1] == s[0] or p[1] == '?'):\n                return True\n            elif p[1] == '*':\n                return self.isMatch(s, p[2:])\n            else:\n                return False"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n            '?' Matches any single character.\n            '*' Matches any sequence of characters (including the empty sequence).\n        The matching should cover the entire input string (not partial).\n        Example 1:\n        Input: s = \"aa\", p = \"a\"\n        Output: false\n        Explanation: \"a\" does not match the entire string \"aa\".\n        Example 2:\n        Input: s = \"aa\", p = \"*\"\n        Output: true\n        Explanation: '*' matches any sequence.\n        Example 3:\n        Input: s = \"cb\", p = \"?a\"\n        Output: false\n        Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        sl, pl = len(s), len(p)\n        if sl > 0 and pl == 0:\n            return False\n        memo = {}\n        def dp(i, j):\n            if (i, j) not in memo:\n                if j == pl:\n                    return i == sl\n                first_match = i < sl and p[j] in [s[i], '?']\n                if j < pl - 1 and p[j+1] == '*':\n                    ans = dp(i, j+2) or first_match and dp(i+1, j)\n                else:\n                    ans = first_match and dp(i+1, j+1)\n                memo[i, j] = ans\n            return memo[i, j]\n        return dp(0, 0)"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if len(nums) == 1:\n            return 0\n        elif len(nums) == 2:\n            return 1 if nums[1] >= 1 else 0\n        elif nums[0] >= len(nums) - 1:\n            return 1\n        elif nums[0] == 0:\n            return 0"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # https://leetcode.com/problems/jump-game/discuss/18375/Java-BFS-%2B-DP-solution-with-explanation\n        # BFS\n        # Time complexity: O(N)\n        # Space complexity: O(N)\n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        dp = [float('inf') for _ in range(n)]\n        dp[0] = 0\n        \n        for i in range(n):\n            for j in range(1, nums[i] + 1):\n                if i + j < n:\n                    dp[i + j] = min(dp[i + j], dp[i] + 1)\n                    \n        return dp[-1]"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        n = len(nums)\n        dp = [0]*n\n        dp[0] = 0\n        i = 0\n        while i < n:\n            for j in range(nums[i]):\n                if i+j+1 < n:\n                    dp[i+j+1] = min(dp[i+j+1], dp[i]+1)\n            i += 1\n        return dp[-1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if nums[0] == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        curr_pos = 0\n        jump = 0\n        for i in range(0, len(nums) - 1):\n            jump += 1\n            curr_pos = i + nums[i]\n            if curr_pos >= len(nums) - 1:\n                return jump\n            nums[i + 1] = max(nums[i + 1], nums[i] + nums[i + 1])"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        curr_pos = 0\n        num_of_jumps = 0\n        while curr_pos < len(nums) - 1:\n            # jump till we can get to the end\n            max_jump = nums[curr_pos]\n            next_pos = curr_pos + 1\n            while next_pos <= max_jump + curr_pos and next_pos < len(nums):\n                max_jump = max(max_jump, nums[next_pos])\n                next_pos += 1\n            # increment\n            num_of_jumps += 1\n            curr_pos = next_pos - 1"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        n = len(nums)\n        if n <= 1:\n            return 0\n        if n == 2:\n            return 1 if nums[1] > 0 else 0\n        return self.jump_recursive(nums, 0, n - 1)"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # TC: O(N)\n        # SC: O(1)\n        reach_end = 0\n        jump_cnt = 0\n        curr_end = 0\n        for i in range(len(nums) - 1):\n            curr_end = max(curr_end, i + nums[i])\n            if i == reach_end:\n                reach_end = curr_end\n                jump_cnt += 1\n        return jump_cnt"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # dp[i] = min(dp[i-1]+1, dp[i-nums[i]]+1)\n        n = len(nums)\n        if n == 1: return 0\n        dp = [None]*n\n        dp[0] = 0\n        for i in range(n):\n            dp[i] = min(dp[i-1]+1, dp[i-nums[i]]+1) if i >= 1 else min(dp[i-1]+1, dp[i-1]+1)\n        return dp[-1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        n = len(nums)\n        max_pos, end, step = 0, 0, 0\n        for i in range(n - 1):\n            if max_pos >= i:\n                max_pos = max(max_pos, i + nums[i])\n                if i == end:\n                    end = max_pos\n                    step += 1\n        return step"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        \"\"\"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n        Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n            0 <= j <= nums[i] and\n            i + j < n\n        Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: 2\n        Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [2,3,0,1,4]\n        Output: 2\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        length = len(nums)\n        if length == 1:\n            return 0\n        nums.insert(0, 0)\n        dp = [0] * length\n        dp[0] = 1\n        for i in range(1, length):\n            for j in range(1, nums[i] + 1):\n                if i + j < length:\n                    dp[i + j] = min(dp[i + j], dp[i] + 1)\n        return dp[length - 1]"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # Runtime: 88 ms, faster than 59.89% of Python3 online submissions for Permutations.\n        # Memory Usage: 13.9 MB, less than 7.41% of Python3 online submissions for Permutations.\n        result = []\n        def backtracking(cur_list: List[int] = [], used: List[bool] = [False] * len(nums)):\n            if len(cur_list) == len(nums):\n                result.append(cur_list[:])\n                return\n            for i in range(len(nums)):\n                if not used[i]:\n                    used[i] = True\n                    backtracking(cur_list+[nums[i]], used)\n                    used[i] = False\n        backtracking()\n        return result"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        def backtrack(nums, used, path, result):\n            if len(path) == len(nums):\n                result.append(path[:])\n            for i in range(len(nums)):\n                if not used[i]:\n                    used[i] = True\n                    path.append(nums[i])\n                    backtrack(nums, used, path, result)\n                    used[i] = False\n                    path.pop()\n        result = []\n        backtrack(nums, [False for _ in range(len(nums))], [], result)\n        return result"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        #check the length of the list\n        if len(nums) == 0:\n            return []\n        \n        #check if there is only one element in the list\n        if len(nums) == 1:\n            return [nums]\n        \n        #go through all the numbers in the list\n        for i in range(len(nums)):\n            \n            #let the current number be the first number of the list\n            current_number = nums[i]\n            \n            #we need to use the current number as the first element of the list\n            #we need to use the remaining list to create all the permutations with the first element\n            #we need to create a new list everytime to store the permutations\n            #[2,1] -> [2,1] -> [1,2] -> [1,2] -> [2,1] -> [2,1] -> [1,2] -> [1,2]\n            #we need to go through all the permutations in the current list \n            for perm in self.permute(nums[:i] + nums[i+1:]):\n                \n                #append the current number into the list\n                #[1,2,3] -> [1,2,3] -> [1,2,3] -> [1"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if len(nums) <= 1:\n            return [nums]\n        else:\n            result = []\n            for i in range(len(nums)):\n                rest = self.permute(nums[:i] + nums[i+1:])\n                for r in rest:\n                    result.append([nums[i]] + r)\n            return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        return self.permute_helper(nums, 0)"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        self.output = []\n        self.recursive(nums, 0)\n        return self.output"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # time complexity: O(n*n!), n is the len of nums\n        # space complexity: O(n*n!)\n        res = []\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                nums[i], nums[first] = nums[first], nums[i]\n                backtrack(first + 1)\n                nums[i], nums[first] = nums[first], nums[i]\n        \n        n = len(nums)\n        backtrack()\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Approach 1: Backtracking\n        # Time O(n!*n)\n        # Space O(n!*n)"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        n = len(nums)\n        if n == 0:\n            return [[]]\n        if n == 1:\n            return [nums]\n        ans = []\n        for i in range(n):\n            x = nums.pop(i)\n            for j in self.permute(nums):\n                ans.append([x]+j)\n            nums.insert(i, x)\n        return ans"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            tmp = nums[i]\n            res += self.permute(nums[:i] + nums[i+1:])\n            res += self.permute(nums[:i] + nums[i+1:])\n        return res\n    \n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        Example 2:\n        Input: nums = [0,1]\n        Output: [[0,1],[1,0]]\n        Example 3:\n        Input: nums = [1]\n        Output: [[1]]\n        \"\"\"\n        \n        if len(nums) == 0:\n"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        res = []\n        nums.sort()\n        \n        def backtrack(path, used):\n            # if the path is done\n            if len(path) == len(nums):\n                res.append(path[:])\n                return \n            \n            for i in range(len(nums)):\n                # choose\n                if used[i] or i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue\n                # explore\n                used[i] = True\n                backtrack(path+[nums[i]], used)\n                # unchoose\n                used[i] = False\n        \n        backtrack([], [False]*len(nums))\n        \n        return res\n    \n    # time complexity: O(N * 2^N)\n    # space complexity: O(N * 2^N)\n    \n    def permuteUnique(self, nums):\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # The basic idea is to generate all possible permutations and\n        # then to remove duplicates. The basic idea is to use a visited array\n        # that keeps track of the elements that have already appeared in the current\n        # permutation. The visited array is used similarly to the stack. The basic\n        # idea is to do DFS. The basic idea is to generate all possible permutations\n        # and then to remove duplicates.\n        #  The basic idea is to generate all possible permutations and then to remove\n        # duplicates. The basic idea is to do DFS. The basic idea is to generate all\n        # possible permutations and then to remove duplicates.\n        # We begin by initializing a visited array that keeps track of elements that have\n        # already appeared in the current permutation. We also begin by initializing a\n        # call stack that will help us keep track of where we are in the recursive DFS.\n        # We then initialize the first permutation to be []. We then call the recursive\n        # function. The recursive function has a few parameters. The first is nums, the\n        # array of numbers. The second is visited, the visited array. The third is p,\n        # the current permutation. The fourth is stack, the call stack. The recursive\n        # function should keep track of the current stack, visited array, current"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                if i!= first and nums[i] == nums[i - 1]:\n                    continue\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output, permutations = [], []\n        backtrack()\n        return permutations\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # DFS\n        def dfs(nums, curr, visited, res):\n            if len(curr) == len(nums):\n                res.append(curr[:])\n                return\n            for i in range(len(nums)):\n                if not visited[i]:\n                    if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:\n                        continue\n                    visited[i] = True\n                    curr.append(nums[i])\n                    dfs(nums, curr, visited, res)\n                    curr.pop()\n                    visited[i] = False"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        res = []\n        # Approach 1:\n        # 1. Create a visited list.\n        # 2. Check for duplicates in the list\n        # 3. Check if the list is empty. If yes, add the result to the res list\n        # 4. Else, for each number in the list, generate the permutations using recursion and push in the res list\n        # 5. Return the res list\n        visited = []\n        if len(nums) == 0:\n            return res\n        elif len(nums) == 1:\n            return [nums]\n        else:\n            nums.sort()\n            self.generate_permutations(nums, visited, res)\n            return res"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        result = []\n        self.dfs(nums, [], result)\n        return result\n    \n    def dfs(self, nums, path, result):\n        if not nums:\n            result.append(path)\n            return\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], result)\n        \n        \n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        \n        def backtrack(nums, path):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]])\n                \n        backtrack(nums, [])\n        return res"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        result = []\n        nums.sort()\n        self.dfs(nums, [], result)\n        return result"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        def dfs(nums, permutation, res):\n            if len(nums) == len(permutation):\n                res.append(permutation[:])\n                return\n            for i in range(len(nums)):\n                if nums[i] in permutation:\n                    continue\n                permutation.append(nums[i])\n                dfs(nums, permutation, res)\n                permutation.pop()"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        results = []\n        nums.sort()\n        self.backtrack(nums, [], results)\n        return results"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n        Example 1:\n        Input: nums = [1,1,2]\n        Output:\n        [[1,1,2],\n         [1,2,1],\n         [2,1,1]]\n        Example 2:\n        Input: nums = [1,2,3]\n        Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        self.ans = []\n        self.dfs([], nums)\n        return self.ans"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        self.swap()\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        return matrix"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # General Idea: Move all rows to the first column and then move all columns to the last row.\n        # Time: O(n^2)\n        # Space: O(1)\n        def rotate_row(row):\n            row_len = len(row)\n            for i in range(row_len // 2):\n                row[i], row[row_len - 1 - i] = row[row_len - 1 - i], row[i]"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # \u65cb\u8f6c\u7684\u610f\u601d\u662f\u5c06\u6bcf\u4e00\u5217\u7ffb\u8f6c\uff0c\u7136\u540e\u4ece\u5de6\u5230\u53f3\u4f9d\u6b21\u7ffb\u8f6c\uff0c\u518d\u4ece\u4e0a\u5230\u4e0b\u4f9d\u6b21\u7ffb\u8f6c\n        # \u56e0\u4e3a\u6bcf\u6b21\u7ffb\u8f6c\u662f\u6bcf\u4e2a\u5143\u7d20\u5faa\u73af\u4e00\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u77e9\u9635\u7684\u5de6\u4e0a\u89d2\u5143\u7d20\u548c\u53f3\u4e0b\u89d2\u5143\u7d20\n        # \u5982\u679c\u8be5\u5143\u7d20\u5728\u6700\u540e\u4e00\u884c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5176\u79fb\u52a8\u5230\u6700\u540e\u4e00\u884c\n        # \u5982\u679c\u8be5\u5143\u7d20\u5728\u6700\u540e\u4e00\u5217\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06\u5176\u79fb\u52a8\u5230\u6700\u540e\u4e00\u5217\n        # \u5176\u4f59\u60c5\u51b5\ufffd"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        n = len(matrix)\n        for i in range(n//2):\n            for j in range((n+1)//2):\n                tmp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = tmp\n        return matrix\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(n):\n                matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]\n            for k in range(n):\n                matrix[k][i], matrix[k][n-1-i] = matrix[k][n-1-i], matrix[k][i]\n        \n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # transpose\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        n = len(matrix)\n        for i in range(n // 2):\n            matrix[i], matrix[n - 1 - i] = matrix[n - 1 - i], matrix[i]"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        n = len(matrix)\n        for i in range(n // 2 + n % 2):\n            for j in range(n // 2):\n                tmp = matrix[n - 1 - j][i]\n                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1]\n                matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 - i]\n                matrix[j][n - 1 - i] = matrix[i][j]\n                matrix[i][j] = tmp"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Get length of matrix\n        n = len(matrix)"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n        You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [[7,4,1],[8,5,2],[9,6,3]]\n        Example 2:\n        Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n        Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \n        for i in range(len(matrix)):\n            for j in range(i, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # First solution with dictionary\n        # d = {}\n        # for i in strs:\n        #     d[tuple(sorted(i))] = d.get(tuple(sorted(i)), []) + [i]\n        # return list(d.values())"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        ret = []\n        sorted_strs = []\n        for i in range(len(strs)):\n            sorted_strs.append(self.sorted_str(strs[i]))\n        \n        dic = {}\n        for i in range(len(sorted_strs)):\n            if sorted_strs[i] not in dic:\n                dic[sorted_strs[i]] = []\n            dic[sorted_strs[i]].append(strs[i])\n            \n        for key in dic:\n            ret.append(dic[key])\n        return ret\n    \n    def sorted_str(self, s):\n        ret = []\n        for i in s:\n            ret.append(i)\n        ret.sort()\n        ret = ''.join(ret)\n        return ret<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        d = {}\n        for s in strs:\n            k = \"\".join(sorted(s))\n            d[k] = d.get(k, []) + [s]\n        return list(d.values())<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        hashmap = {}\n        for i in strs:\n            sorted_str = \"\".join(sorted(i))\n            if sorted_str not in hashmap:\n                hashmap[sorted_str] = [i]\n            else:\n                hashmap[sorted_str].append(i)\n        return [value for value in hashmap.values()]"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        hash = {}\n        for i in range(len(strs)):\n            s = \"\".join(sorted(strs[i]))\n            if s not in hash:\n                hash[s] = [strs[i]]\n            else:\n                hash[s].append(strs[i])\n        result = []\n        for val in hash.values():\n            result.append(val)\n        return result\n    \n    \n    def wordPattern(self, pattern: str, str: str) -> bool:\n        \"\"\"\n        Given a pattern and a string str, find if str follows the same pattern.\n        Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\n        Example 1:\n        Input: pattern = \"abba\", str = \"dog cat cat dog\"\n        Output: true\n        Example 2:\n        Input: pattern = \"abba\", str = \"dog cat cat fish\"\n        Output: false\n        Example 3:\n        Input: pattern = \"aaaa\", str = \"dog cat cat dog\"\n        Output: false\n        Example 4:\n        Input: pattern = \"abba\", str = \"dog dog dog dog\"\n        Output: false\n        Notes:\n        You may assume pattern contains only lowercase letters, and str contains lower"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        d = {}\n        for s in strs:\n            s_sorted = \"\".join(sorted(s))\n            if s_sorted in d:\n                d[s_sorted].append(s)\n            else:\n                d[s_sorted] = [s]\n        return d.values()"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        from collections import defaultdict\n        dic = defaultdict(list)\n        for s in strs:\n            dic[tuple(sorted(s))].append(s)\n        return dic.values()\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Sort each string in strs\n        # Group into dict\n        # {'eat': ['eat'], 'tea': ['tea'], 'tan': ['tan'], 'ate': ['ate'], 'nat': ['nat'], 'bat': ['bat']}\n        # Split dict keys into groups"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        result = collections.defaultdict(list)\n        for s in strs:\n            result[tuple(sorted(s))].append(s)\n        return list(result.values())<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "prompt": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        \"\"\"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n        Example 1:\n        Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n        Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n        Example 2:\n        Input: strs = [\"\"]\n        Output: [[\"\"]]\n        Example 3:\n        Input: strs = [\"a\"]\n        Output: [[\"a\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \n        if not strs:\n            return [[\"\"]]\n        # Dict storing the keys, with values of anagrams\n        anagram_dict = {}\n        # Loop through list of strings\n        for s in strs:\n            # sort the string\n            sorted_string = ''.join(sorted(s))\n            # if sorted string is not a key in anagram_dict\n            if sorted_string not in anagram_dict:\n                # add the key to the dictionary\n                anagram_dict[sorted_string] = [s]\n            # if sorted string is already a key in anagram_dict\n            else:\n                # add the string to the list of values for that key\n                anagram_dict[sorted_string].append(s)\n        # return list of values from the dictionary\n        return list(anagram_dict.values())<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        return x**n"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        if n == -1:\n            return 1 / x\n        if n > 0:\n            if n % 2 == 1:\n                return self.myPow(x, n // 2) ** 2 * x\n            return self.myPow(x, n // 2) ** 2\n        if n < 0:\n            n = -n\n            if n % 2 == 1:\n                return self.myPow(x, n // 2) ** 2 * 1 / x\n            return self.myPow(x, n // 2) ** 2 * 1 / x"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if n == 0:\n            return 1\n        elif n < 0:\n            x = 1 / x\n            n = -n\n        return self.myPow(x * x, n // 2) if n % 2 == 0 else x * self.myPow(x * x, n // 2)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # return x ** n\n        # if n == 0: return 1\n        # if n < 0: return 1 / self.myPow(x, -n)\n        # half = self.myPow(x, n // 2)\n        # if n % 2 == 0:\n        #     return half * half\n        # else:\n        #     return half * half * x"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if n < 0:\n            return self.myPow(1/x, -n)\n        if n == 0:\n            return 1\n        if n == 1:\n            return x\n        if n % 2 == 0:\n            return self.myPow(x*x, n/2)\n        else:\n            return x*self.myPow(x*x, (n-1)/2)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if n < 0:\n            x, n = 1 / x, -n\n        return x if n == 0 else x * self.myPow(x, n - 1)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if n == 0:\n            return 1\n        elif n < 0:\n            return 1 / self.myPow(x, -n)\n        else:\n            if n % 2 == 0:\n                return self.myPow(x * x, n // 2)\n            else:\n                return x * self.myPow(x * x, n // 2)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        if n % 2:\n            return x * self.myPow(x, n - 1)\n        return self.myPow(x * x, n // 2)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if n == 0:\n            return 1\n        if n < 0:\n            x = 1/x\n            n = -n\n        if n % 2 == 0:\n            return self.myPow(x, n/2) ** 2\n        else:\n            return x * self.myPow(x, n-1)"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "prompt": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n        Example 1:\n        Input: x = 2.00000, n = 10\n        Output: 1024.00000\n        Example 2:\n        Input: x = 2.10000, n = 3\n        Output: 9.26100\n        Example 3:\n        Input: x = 2.00000, n = -2\n        Output: 0.25000\n        Explanation: 2-2 = 1/22 = 1/4 = 0.25\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        if n % 2:\n            return x * self.myPow(x, n - 1)\n        return self.myPow(x * x, n // 2)"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        def generateBoard(row, col, diag, anti_diag, n):\n            if row == n:\n                res.append(list(board))\n                return"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # Q: what is the basic idea for the solution?\n        # A: actually, we just need to put '1' and '0' on a map (col == row)\n        # Q: can we use a list? what is the meaning of the key\n        # A: actually, we can use the list to store the num of row and col that we have already filled\n        #     like [3, 3]\n        # Q: what is the meaning of the map?\n        # A: the map is to store which row and col we have filled\n        # Q: what is the meaning of the board?\n        # A: the board is to represent the solution\n        # Q: what is the meaning of the queen?\n        # A: the queen is to represent the position\n        # Q: what is the meaning of the column?\n        # A: the column is to represent the column index where we put the queen\n        # Q: what is the meaning of the row?\n        # A: the row is to represent the row index where we put the queen\n        # Q: what is the meaning of the numOfRow and numOfCol?\n        # A: the numOfRow and numOfCol is to represent the num of row and col that we have already filled"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        # backtrack\n        # we can only place one queen at each row, thus we can use a backtrack function to recursively check\n        # whether we have found a valid solution or not\n        \n        # The key to this problem is to use backtracking to try out all possible solutions.\n        # As we want to check all possible solutions for n queens, we will have n! combinations.\n        # Therefore, we need to have a backtracking function that generates all combinations and check whether they are valid or not.\n        # We use backtracking to generate all combinations, and use a helper function isValid(board, row, col) to check whether a certain placement is valid.\n        # A set is used as a hash table to store the row and column of a queen, because we only want to record the position of one queen, \n        # but there can be more than one queen on the same row and the same column.\n        \n        # we can also use dfs to solve this problem\n        # it is also similar to the n-queens problem, but we have to use recursion and backtracking to recursively call the dfs to try out different solutions\n        # the recursion stack will be the current row, and each time we go into the dfs we need to check if the current row is valid or not\n        \n        # we also use set to"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        res = []\n        board = [[\".\"] * n for _ in range(n)]"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        def check(state):\n            for i in range(n):\n                if state[i] == \"Q\":\n                    continue\n                for j in range(n):\n                    if abs(i-j) == abs(state[i]-state[j]):\n                        return False\n            return True"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \n        def dfs(n,row,column,diagonal1,diagonal2,solution):\n            if row == n:\n                solution.append([\"\".join(queen) for queen in solution])\n                return\n            for col in range(n):\n                if col in column or row - col in diagonal1 or row + col in diagonal2:\n                    continue\n                column.add(col)\n                diagonal1.add(row - col)\n                diagonal2.add(row + col)\n                dfs(n,row+1,column,diagonal1,diagonal2,solution)\n                column.remove(col)\n                diagonal1.remove(row - col)\n                diagonal2.remove(row + col)\n        \n        solution = []\n        dfs(n,0,set(),set(),set(),solution)\n        return solution\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if n < 1:\n            return []\n        self.result = []\n        self.helper([-1] * n, 0, n)\n        return self.result"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        self.res = []\n        self.solve(n, [])\n        return self.res"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        def isValid(row, col, board):\n            for i in range(row):\n                if board[i][col] == \"Q\":\n                    return False\n            row_start = row - row % n\n            col_start = col - col % n\n            for i in range(row_start, row, n):\n                for j in range(col_start, col, n):\n                    if board[i][j] == \"Q\":\n                        return False\n            return True\n        def solveNQUtil(board, col):\n            if col >= n:\n                result.append(board)\n            for i in range(n):\n                if isValid(i, col, board):\n                    board[i][col] = \"Q\"\n                    solveNQUtil(board, col + 1)\n                    board[i][col] = \".\"\n        result = []\n        board = [[\".\"] * n for _ in range(n)]\n        solveNQUtil(board, 0)\n        return result"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "prompt": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n        Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n        Example 1:\n        Input: n = 4\n        Output: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n        Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n        Example 2:\n        Input: n = 1\n        Output: [[\"Q\"]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # BFS\n        # reuse the result from previous board\n        if n < 1:\n            return []\n        self.result = []\n        self.cols = set()\n        self.pie = set()\n        self.na = set()\n        self.DFS(n, 0, [])\n        return self.result"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        self.result = []\n        self.dfs(n, 0, 0, 0, 0)\n        return len(self.result)"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        self.res = 0\n        visited = [False] * n"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        self.output = 0\n        self.helper(n, 0, 0, 0, 0)\n        return self.output"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        self.res = 0\n        self.backtrack(0, n, [])\n        return self.res"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # The trivial solution is to generate all permutations of the list of integers 1..n and return the length of the list\n        # of permutations. This solution is simpler in the sense that it is not dependent on any constraints other than\n        # the value of n."
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        self.res = 0\n        self.cols = [0] * n\n        self.main_diag = [0] * (2 * n)\n        self.anti_diag = [0] * (2 * n)\n        self.dfs(n, 0, 0, 0, 0)\n        return self.res\n    def dfs(self, n, row, cur_sum, cur_sum2, cur_sum3):\n        if row == n:\n            self.res += 1\n            return\n        for col in range(n):\n            if self.cols[col] or self.main_diag[row + col] or self.anti_diag[n - row + col]:\n                continue\n            self.cols[col] = self.main_diag[row + col] = self.anti_diag[n - row + col] = 1\n            self.dfs(n, row + 1, cur_sum + col, cur_sum2 + n - row - col, cur_sum3 + 1)\n            self.cols[col] = self.main_diag[row + col] = self.anti_diag[n - row + col] = 0\n        return\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        self.result = 0\n        self.helper(n, [], [])\n        return self.result"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        self.sol = 0"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        def DFS(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                self.res += 1\n                return\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        self.res = 0\n        DFS([], [], [])\n        return self.res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "prompt": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        \"\"\"\n        The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n        Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n        Example 1:\n        Input: n = 4\n        Output: 2\n        Explanation: There are two distinct solutions to the 4-queens puzzle as shown.\n        Example 2:\n        Input: n = 1\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if n == 1:\n            return 1\n        self.res = 0\n        self.solveNQueens(n, 0, 0)\n        return self.res"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        for i in range(1, len(nums)):\n            nums[i] += max(nums[i - 1], 0)\n        return max(nums)"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        def find_max_subarray(nums, left, right):\n            if left > right:\n                return -float('inf')\n            \n            # subarray sum is 0\n            if left == right:\n                return 0\n            \n            # subarray sum is negative, the largest sum is the sum of positive elements\n            if nums[left] < 0:\n                return nums[left]\n            \n            # subarray sum is positive, the largest sum is the sum of all the elements\n            curr_sum = 0\n            for i in range(left, right+1):\n                curr_sum += nums[i]\n            max_sum = curr_sum\n            \n            # try every possible subarray\n            for i in range(left+1, right+1):\n                # try i and i+1\n                if nums[i] > nums[i-1] + nums[i]:\n                    curr_sum = nums[i]\n                else:\n                    curr_sum = nums[i] + curr_sum\n                \n                # update maximum sum\n                if curr_sum > max_sum:\n                    max_sum = curr_sum\n            \n            return max_sum\n        \n        n = len(nums)\n        if n == 1:"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        max_sum = nums[0]\n        sum = nums[0]\n        for num in nums[1:]:\n            if sum > 0:\n                sum = sum + num\n            else:\n                sum = num\n            if sum > max_sum:\n                max_sum = sum"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        elif n == 1:\n            return nums[0]\n        else:\n            current_sum = 0\n            max_sum = nums[0]\n            for i in range(n):\n                current_sum += nums[i]\n                if current_sum > max_sum:\n                    max_sum = current_sum\n                if current_sum < 0:\n                    current_sum = 0\n            return max_sum"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Brute Force\n        # O(n^3)\n        # def find_max(nums):\n        #     max_sum = nums[0]\n        #     for i in range(len(nums)):\n        #         for j in range(i,len(nums)):\n        #             cur_sum = sum(nums[i:j+1])\n        #             if cur_sum > max_sum:\n        #                 max_sum = cur_sum\n        #     return max_sum\n        # return find_max(nums)\n        \n        # Knapsack\n        # O(n^2)\n        # def find_max(nums):\n        #     cur_sum = 0\n        #     max_sum = 0\n        #     for i in range(len(nums)):\n        #         cur_sum = cur_sum + nums[i]\n        #         if cur_sum > 0:\n        #             cur_sum = 0\n        #         elif cur_sum < 0:\n        #             cur_sum = 0\n        #         else:\n        #             cur_sum = 0\n        #         if cur_sum > max_sum:\n        #             max_sum = cur_sum\n        #     return max_sum\n        "
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # dp = [0 for _ in range(len(nums))]\n        # for i in range(len(nums)):\n        #     dp[i] = nums[i]\n        #     for j in range(i):\n        #         dp[i] = max(dp[i], dp[j]+nums[i])\n        # return max(dp)"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        cur = 0\n        max_sum = float('-inf')\n        for num in nums:\n            cur = max(cur + num, num)\n            max_sum = max(max_sum, cur)\n        return max_sum"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        nums_sum = 0\n        nums_max = float('-inf')\n        for num in nums:\n            nums_sum += num\n            nums_max = max(nums_sum, nums_max)\n            if nums_sum < 0:\n                nums_sum = 0\n        return nums_max"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not nums: return 0"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "prompt": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        \"\"\"\n        Given an integer array nums, find the subarray with the largest sum, and return its sum.\n        Example 1:\n        Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\n        Output: 6\n        Explanation: The subarray [4,-1,2,1] has the largest sum 6.\n        Example 2:\n        Input: nums = [1]\n        Output: 1\n        Explanation: The subarray [1] has the largest sum 1.\n        Example 3:\n        Input: nums = [5,4,-1,7,8]\n        Output: 23\n        Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if len(nums) == 0:\n            return 0"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # \u6b64\u9898\u76ee\u8ddf0190\u9898\u76ee\u6bd4\u8f83\u7c7b\u4f3c\uff0c\u9700\u8981\u7ee7\u7eed\u6df1\u5316\uff0c\u9010\u6b65\u63a8\u8fdb\n        # 1. \u539f\u59cb\u6570\u636e\u7ed3\u6784\u63cf\u8ff0\uff0c\u8f6c\u5316\u4e3a\u4e00\u4e2a\u7b80\u5355\u6570\u7ec4\uff0c\u539f\u59cb\u6570\u636e\u6784\u6210\u7684\u77e9\u9635\uff0c\u4e2d\u95f4\u6570\u636e\u6784\u6210\u6bcf\u4e00\u6b21\u7684\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u6bcf\u4e00\u6b21\u7684\u8f6c\u79fb\u8fc7\u7a0b\uff0c\u4e0d\u65ad\u7f29\u5c0f\u6bcf\u6b21\u8f6c\u79fb\u7684\u89c4\u6a21\n        # 2. \u8003\u5bdf\u7528\u56de\u6eaf\u6cd5\u7684\u601d\u8def\u8fdb\u884c\u89e3\u51b3\uff0c\u5b9a\u4e49\u5168\u5c40\u53d8\u91cfr\uff0c\u8868\u793a\u5f53\u524d\u662f\u7b2c\u51e0\u5c42\n        # 3. \ufffd"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        # \u8bb0\u5f55\u5df2\u7ecf\u8d70\u8fc7\u7684\u5143\u7d20\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\n        visited = [[0 for i in range(n)] for j in range(m)]\n        res = []\n        # \u8bbe\u7f6e\u56db\u4e2a\u65b9\u5411\n        # right, left, top, bottom\n        dir = 0\n        # \u79fb\u52a8\u65b9\u5411\n        move_dir = [[0,1],[0,-1],[-1,0],[1,0]]\n        # \u8d77\u59cb\u4f4d\u7f6e\n        i, j = 0, -1\n        # \u79fb\u52a8\u7684\u8ddd\u79bb\n        step = 0\n        # \u7ec8\u70b9\u4e3a\u5de6\u4e0b\u89d2\n        while step < m*n:\n            while 0<=i<m and 0<=j<n and visited[i][j]==0:\n                res.append(matrix[i][j])\n                visited[i][j] = 1\n                # \u4e0b\u4e00\u6b65\u4f4d\u7f6e\n                step += 1"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if not matrix:\n            return []\n        # # 1. m*n \u4e8c\u7ef4\u6570\u7ec4\n        # res = []\n        # while len(matrix) > 0:\n        #     res += matrix.pop(0)\n        #     matrix = list(zip(*matrix))[::-1]\n        # return res\n        \n        # 2. \u4e00\u7ef4\u6570\u7ec4\n        # res = []\n        # while matrix:\n        #     res += matrix.pop(0)\n        #     matrix = list(zip(*matrix))[::-1]\n        # return res\n        \n        # 3. \u4e00\u7ef4\u6570\u7ec4\n        # res = []\n        # row = len(matrix)\n        # col = len(matrix[0])\n        # while row > 0 and col > 0:\n        #     for i in range(col):\n        #         res.append(matrix[row-1][i])\n        #     row -= 1\n        #     for i in range(row):\n        #         res.append(matrix[i][col-1])\n        #     col -= 1\n        #     if row > 0:\n        #         for i in range(col-1, -1,"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        res = []\n        if not matrix: return res\n        left, right = 0, len(matrix[0]) - 1\n        top, bottom = 0, len(matrix) - 1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            for j in range(top+1, bottom+1):\n                res.append(matrix[j][right])\n            if top < bottom:\n                for i in range(right-1, left, -1):\n                    res.append(matrix[bottom][i])\n                for j in range(bottom, top, -1):\n                    res.append(matrix[j][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        result = []\n        row, col, clockwise = 0, 0, 0\n        while row < m and col < n:\n            if clockwise == 0:\n                for j in range(col, n):\n                    result.append(matrix[row][j])\n                row += 1\n            elif clockwise == 1:\n                for j in range(row, m):\n                    result.append(matrix[j][n-1])\n                n -= 1\n            elif clockwise == 2:\n                for j in range(n-1, col-1, -1):\n                    result.append(matrix[m-1][j])\n                m -= 1\n            elif clockwise == 3:\n                for j in range(m-1, row-1, -1):\n                    result.append(matrix[j][col])\n                col += 1\n            clockwise = (clockwise+1)%4\n        return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # https://leetcode.com/problems/spiral-matrix/discuss/3413/A-general-approach-to-solve-spiral-matrix-in-Python-(Explained)\n        if not matrix: return []\n        m, n = len(matrix), len(matrix[0])\n        ans = []\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        x, y, directionIdx = 0, 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[x][y])\n            matrix[x][y] = None\n            dx, dy = directions[directionIdx]\n            x, y = x + dx, y + dy\n            if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] is None:\n                directionIdx = (directionIdx + 1) % 4\n                dx, dy = directions[directionIdx]\n                x, y = x + dx, y + dy\n        return ans<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not matrix:\n            return []\n        res = []\n        row_start, row_end = 0, len(matrix) - 1\n        col_start, col_end = 0, len(matrix[0]) - 1\n        while row_start <= row_end and col_start <= col_end:\n            # left to right\n            for j in range(col_start, col_end + 1):\n                res.append(matrix[row_start][j])\n            row_start += 1"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not matrix:\n            return []\n        l, r, u, d = 0, len(matrix[0]) - 1, 0, len(matrix) - 1\n        res = []\n        while True:\n            for i in range(l, r + 1):\n                res.append(matrix[u][i])\n            u += 1\n            if u > d:\n                break\n            for i in range(u, d + 1):\n                res.append(matrix[i][r])\n            r -= 1\n            if l > r:\n                break\n            for i in range(r, l - 1, -1):\n                res.append(matrix[d][i])\n            d -= 1\n            if u > d:\n                break\n            for i in range(d, u - 1, -1):\n                res.append(matrix[i][l])\n            l += 1\n            if l > r:\n                break\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not matrix or not matrix[0]: return []\n        res, m, n = [], len(matrix), len(matrix[0])\n        l, t, r, b = 0, 0, n - 1, m - 1\n        while l < r and t < b:\n            for i in range(l, r):\n                res.append(matrix[t][i])\n            for i in range(t, b):\n                res.append(matrix[i][r])\n            for i in range(r, l, -1):\n                res.append(matrix[b][i])\n            for i in range(b, t, -1):\n                res.append(matrix[i][l])\n            l, t, r, b = l + 1, t + 1, r - 1, b - 1\n        if l == r:\n            for i in range(t, b + 1):\n                res.append(matrix[i][l])\n        elif t == b:\n            for i in range(l, r + 1):\n                res.append(matrix[t][i])\n        return res"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Given an m x n matrix, return all elements of the matrix in spiral order.\n        Example 1:\n        Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n        Output: [1,2,3,6,9,8,7,4,5]\n        Example 2:\n        Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n        Output: [1,2,3,4,8,12,11,10,9,5,6,7]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if len(matrix) == 0:\n            return []\n        row, col = len(matrix), len(matrix[0])\n        out_list = []\n        left, right, top, bottom = 0, col-1, 0, row-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                out_list.append(matrix[top][i])\n            for i in range(top+1, bottom+1):\n                out_list.append(matrix[i][right])\n            if top!= bottom:\n                for i in range(right-1, left-1, -1):\n                    out_list.append(matrix[bottom][i])\n            if left!= right:\n                for i in range(bottom-1, top, -1):\n                    out_list.append(matrix[i][left])\n            left += 1\n            right -= 1\n            top += 1\n            bottom -= 1\n        return out_list\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        n = len(nums)\n        for i in range(n - 1, -1, -1):\n            if nums[i] + i >= n - 1:\n                return True\n            if nums[i] == 0:\n                continue\n            for j in range(1, nums[i] + 1):\n                if i + j >= n - 1:\n                    return True\n        return False"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        # Bottom-up DP\n        if len(nums) <= 1:\n            return True\n        \n        dp = [True] * len(nums)\n        for i in range(len(nums)):\n            for j in range(0,i):\n                if nums[j] >= i - j and dp[j]:\n                    dp[i] = True\n                    break\n        return dp[-1]\n    \n    # Top-down DP\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        last_index = len(nums) - 1\n        for i in range(len(nums) - 1, -1, -1):\n            if i + nums[i] >= last_index:\n                last_index = i\n        return last_index == 0"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        return self.dfs(nums, 0)"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # dp[i] = if the number at index i can reach the end\n        # dp[i] = dp[i+1] or dp[i+2] or dp[i+3] or...\n        # if dp[i] = True\n        # return True"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(nums) == 1: return True\n        max_jump = nums[0]\n        for i in range(len(nums)-1):\n            if max_jump < i:\n                return False\n            max_jump = max(max_jump, nums[i]+i)\n        return True\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # The idea is to keep track of the position of the furthest jump and do a dfs\n        furthest = 0\n        for i in range(len(nums)):\n            if i > furthest:\n                break\n            furthest = max(furthest, i + nums[i])\n        return furthest >= len(nums)-1"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # \u89e3\u6cd5\u4e00\uff1a\u8d2a\u5fc3+BFS\uff08\u8fd9\u4e2a\u89e3\u6cd5\u662f\u4e0d\u4f1a\u7684\uff0c\u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u662f\u53ef\u4ee5\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u8d2a\u5fc3\u601d\u8def\u662f\u4e0d\u5bf9\u7684\uff09\n        # \u5982\u679c\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u90fd\u6709\u4e00\u4e2a\u6700\u5927\u80fd\u8df3\u8dc3\u7684\u8ddd\u79bb\uff0c\u90a3\u4e48\u4ece\u5de6\u5230\u53f3\u8d70\uff0c\u548c\u4ece\u53f3\u5230\u5de6\u8d70\u5c31\u53ef\u4ee5\u6ee1\u8db3\u8981\u6c42\uff0c\u90a3\u4e48\u4e00\u5b9a\u4f1a\u8d70\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\n        # \u5148\u4ece\u5de6\u5230\u53f3\u8df3\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u628a\u53ef\u4ee5\u5230\u8fbe\u8be5\u4f4d\u7f6e\u7684\u8ddd\u79bb\u52a0\u5165\u7ed3\u679c\u4e2d\ufffd"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        reach_end = 0\n        current_end = 0\n        for i in range(len(nums) - 1):\n            if current_end < i:\n                return False\n            reach_end = max(reach_end, i + nums[i])\n            if reach_end >= len(nums) - 1:\n                return True\n            current_end = max(current_end, i + nums[i])\n        return False"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "prompt": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        \"\"\"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n        Return true if you can reach the last index, or false otherwise.\n        Example 1:\n        Input: nums = [2,3,1,1,4]\n        Output: true\n        Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n        Example 2:\n        Input: nums = [3,2,1,0,4]\n        Output: false\n        Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if len(nums) == 1:\n            return True\n        if nums[0] == 0:\n            return False\n        i = 0\n        while i < len(nums) - 1:\n            jump_len = nums[i]\n            if jump_len == 0:\n                return False\n            next_index = i + jump_len\n            if next_index > len(nums):\n                break\n            for j in range(i + 1, next_index):\n                if nums[j] == 0:\n                    return False\n                jump_len = min(jump_len, nums[j])\n            i = next_index\n        return True\n    \n    def canJump_set(self, nums: List[int]) -> bool:\n        # Set O(n) time and O(n) space\n        if len(nums) == 1:\n            return True\n        if nums[0] == 0:\n            return False\n        reachable = set([0])\n        for i in range(len(nums)):\n            if i in reachable:\n                for j in range(i + 1, min(i + nums[i] + 1, len(nums))):\n                    reachable.add(j)\n                    if j == len(nums)"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # sort intervals\n        intervals = sorted(intervals)\n        \n        # if there are no intervals, return\n        if len(intervals) == 0:\n            return intervals\n        \n        # create a list to hold the final merged intervals\n        merged = []\n        \n        # go through each interval and see if it overlaps with previous interval\n        for interval in intervals:\n            \n            # if there are no merged intervals, add interval\n            if len(merged) == 0:\n                merged.append(interval)\n                \n            # if the last merged interval is after the current interval starts\n            elif merged[-1][1] < interval[0]:\n                merged.append(interval)\n                \n            # if the last merged interval ends before the current interval ends\n            elif merged[-1][1] < interval[1]:\n                merged[-1][1] = interval[1]\n                \n            # if the last merged interval ends after the current interval ends\n            else:\n                continue\n                \n        return merged\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # Sort the intervals using merge sort\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        for i in range(1, len(intervals)):\n            current_interval = intervals[i]\n            merged_interval = merged[-1]\n            if current_interval[0] <= merged_interval[1]:\n                merged[-1] = [merged_interval[0], max(merged_interval[1], current_interval[1])]\n            else:\n                merged.append(current_interval)\n        return merged"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \n        # sort by start\n        intervals.sort()\n        merged = []\n        # only need to consider the first element in the list\n        for i in intervals:\n            if merged == [] or merged[-1][1] < i[0]:\n                merged.append(i)\n            else:\n                merged[-1][1] = max(merged[-1][1], i[1])\n        return merged\n        \n        \n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5]"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        intervals.sort(key=lambda x:x[0])\n        result = []\n        cur_start, cur_end = intervals[0][0], intervals[0][1]\n        for start, end in intervals[1:]:\n            if start > cur_end:\n                result.append([cur_start, cur_end])\n                cur_start, cur_end = start, end\n            else:\n                cur_start, cur_end = min(cur_start, start), max(cur_end, end)\n        result.append([cur_start, cur_end])\n        return result"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        res = []\n        for i, j in intervals:\n            if not res or res[-1][1] < i:\n                res.append([i, j])\n            else:\n                res[-1][1] = max(res[-1][1], j)\n        return res"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(intervals) == 0:\n            return []"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # sort the interval\n        # input: [[1,3],[2,6],[8,10],[15,18]]\n        # output: [[1,6],[8,10],[15,18]]\n        if not intervals:\n            return []\n        intervals.sort()\n        # output list\n        res = [intervals[0]]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] > res[-1][1]:\n                res.append(intervals[i])\n            else:\n                res[-1][1] = max(intervals[i][1], res[-1][1])\n        return res"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # nums = len(intervals)\n        # if nums == 0:\n        #     return intervals\n        # intervals.sort()\n        # cur_start = intervals[0][0]\n        # cur_end = intervals[0][1]\n        # ret = [intervals[0]]\n        # for i in range(1, nums):\n        #     next_start = intervals[i][0]\n        #     next_end = intervals[i][1]\n        #     if cur_end >= next_start:\n        #         cur_end = max(cur_end, next_end)\n        #     else:\n        #         ret.append([cur_start, cur_end])\n        #         cur_start = next_start\n        #         cur_end = next_end\n        # ret.append([cur_start, cur_end])\n        # return ret"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # O(nlogn)\n        intervals.sort(key=lambda x: x[0])\n        res = []\n        res.append(intervals[0])\n        \n        for interval in intervals[1:]:\n            if interval[0] <= res[-1][1]:\n                res[-1][1] = max(res[-1][1], interval[1])\n            else:\n                res.append(interval)\n                \n        return res\n        \n    def merge(self, intervals):\n        \n        if not intervals or len(intervals) == 0: return []\n        intervals.sort(key = lambda x : x[0])\n        \n        result = []\n        result.append(intervals[0])\n        \n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], intervals[i][1])\n            else:\n                result.append(intervals[i])\n                \n        return result<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "prompt": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        \"\"\"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n        Example 1:\n        Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n        Output: [[1,6],[8,10],[15,18]]\n        Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n        Example 2:\n        Input: intervals = [[1,4],[4,5]]\n        Output: [[1,5]]\n        Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        ret = []\n        for interval in intervals:\n            if not ret or ret[-1][1] < interval[0]:\n                ret.append(interval)\n            else:\n                ret[-1][1] = max(ret[-1][1], interval[1])\n        return ret"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        l = len(intervals)\n        \n        def findOverlapping(index, i, dif, flag):\n            \n            while index<l and intervals[index][0]<=i+dif and intervals[index][1]>=i+dif:\n                index += 1\n            if index<l:\n                if flag:\n                    if intervals[index][1]>i+dif:\n                        return [i, intervals[index][0]-1]\n                else:\n                    if intervals[index][0]<i+dif:\n                        return [intervals[index][1]+1, i]\n                return findOverlapping(index, i, dif, not flag)\n            else:\n                return None\n        \n        if l==0:\n            return [newInterval]\n        \n        if newInterval[0]<=intervals[0][0] and newInterval[1]>=intervals[0][0]:\n            # interval i is completely included in the new interval\n            return [[min(newInterval[0], intervals[0][0]), max(newInterval[1], intervals[0][1])]] + intervals[1:]\n        \n        if newInterval[1]<=intervals[0][0] or newInterval[0]"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # sort intervals by start\n        start = [i[0] for i in intervals]\n        end = [i[1] for i in intervals]\n        # find the index to insert newInterval\n        insert_index = self.get_insert_index(start, newInterval[0])\n        # insert newInterval\n        start.insert(insert_index, newInterval[0])\n        end.insert(insert_index, newInterval[1])\n        result = []\n        # sort intervals by start\n        start = start[:insert_index+1]\n        end = end[:insert_index+1]\n        for i,j in zip(start,end):\n            if not result or result[-1][1] < i:\n                result.append([i,j])\n            else:\n                result[-1][1] = max(result[-1][1], j)\n        return result\n    \n    def get_insert_index(self, start, target):\n        if target in start:\n            return start.index(target)\n        else:\n            return 0"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # Solution 1: sort, then binary search\n        # Solution 2: merge\n        if not intervals:\n            return [newInterval]\n        intervals.append(newInterval)\n        intervals.sort()\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        return self.mergeIntervals(self.insert_helper(intervals, newInterval))\n    \n    def insert_helper(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        Return the merged intervals after inserting newInterval into intervals.\n        \"\"\"\n        s, e = newInterval\n        \n        i = 0\n        while i < len(intervals) and s > intervals[i][1]:\n            i += 1\n        \n        if i == len(intervals) or s <= intervals[i][0]:\n            intervals.insert(i, newInterval)\n        elif intervals[i][0] <= s <= intervals[i][1]:\n            intervals[i][1] = max(intervals[i][1], e)\n        elif intervals[i][0] <= e <= intervals[i][1]:\n            intervals[i][0] = min(intervals[i][0], s)\n        \n        res = []\n        for s, e in intervals:\n            if not res or res[-1][1] < s:\n                res.append([s, e])\n            else:\n                res[-1][1] = max(res[-1][1], e"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # newInterval = [start, end]\n        # start, end, mergedInterval = newInterval[0], newInterval[1], []\n        # for i in range(len(intervals)):\n        #     if intervals[i][0] > end:\n        #         mergedInterval.append(intervals[i])\n        #     elif intervals[i][1] < start:\n        #         mergedInterval.append(intervals[i])\n        #     else:\n        #         start = min(start, intervals[i][0])\n        #         end = max(end, intervals[i][1])\n        # mergedInterval.append([start, end])\n        # return mergedInterval\n        \n        # O(n)\n        # intervals.append(newInterval)\n        # intervals = sorted(intervals, key=lambda x:x[0])\n        # res = []\n        # for i in range(len(intervals)):\n        #     if not res or intervals[i][0] > res[-1][1]:\n        #         res.append(intervals[i])\n        #     else:\n        #         res[-1][1] = max(res[-1][1], intervals[i][1])\n        # return res"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not intervals:\n            return [newInterval]\n        if not newInterval:\n            return intervals\n        result = intervals\n        if newInterval[0] <= result[0][0]:\n            if newInterval[1] >= result[0][1]:\n                return [newInterval]\n            result[0] = newInterval\n        elif newInterval[0] >= result[-1][0]:\n            result.append(newInterval)\n        else:\n            for i, interval in enumerate(result):\n                if newInterval[0] > result[i][1]:\n                    continue\n                elif interval[0] > newInterval[1]:\n                    result.insert(i, newInterval)\n                    break\n                elif newInterval[1] < result[i][0]:\n                    result.insert(i, newInterval)\n                    break\n                else:\n                    if newInterval[1] <= result[i][1]:\n                        continue\n                    else:\n                        newInterval[0] = min(interval[0], newInterval[0])\n                        newInterval[1] = max(interval[1], newInterval[1])\n                        result.pop(i)\n                        break\n        result.sort()\n        return result\n    def"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        \n        # binary search to locate the position to insert the new interval\n        # O(N)\n        \n        # sort the new interval so that its start is at the beginning of the list\n        intervals = self.merge_intervals(intervals, newInterval)\n        \n        # # the insert position is the last position \n        # if not intervals or intervals[-1][1] < newInterval[0]:\n        #     intervals.append(newInterval)\n        #     return intervals\n        # # binary search to find the insert position\n        # l, r = 0, len(intervals) - 1\n        # while l <= r:\n        #     m = (l + r) // 2\n        #     if intervals[m][1] < newInterval[0]:\n        #         l = m + 1\n        #     else:\n        #         r = m - 1\n        # # insert\n        # intervals[l:l] = [newInterval]\n        # return intervals\n        \n        # binary search to locate the position to insert the new interval\n        # O(NlogN)\n        if not intervals or intervals[-1][1] < newInterval[0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # binary search to find"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # My Solution\n        # Get the index of the interval that newInterval can be inserted in.\n        # If the newInterval can be inserted at the end of the list,\n        # just append the newInterval to intervals.\n        # If the newInterval can be inserted in the middle of the list,\n        # append the newInterval to the intervals array,\n        # then remove the last element of the intervals array,\n        # because it can overlap with newInterval.\n        # If the newInterval can be inserted at the beginning of the list,\n        # just remove the first element of the intervals array,\n        # because it can overlap with the first element of newInterval.\n        # Runtime: 40 ms, faster than 55.85% of Python3 online submissions for Insert Interval.\n        # Memory Usage: 14.3 MB, less than 36.38% of Python3 online submissions for Insert Interval.\n        if not intervals:\n            return [newInterval]\n        if newInterval[0] > intervals[-1][1]:\n            return intervals + [newInterval]\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        start = 0\n        end = len(intervals)\n        while end > start:\n            mid = (end"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        intervals.append(newInterval)\n        intervals = sorted(intervals)"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "prompt": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n        Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        Return intervals after the insertion.\n        Example 1:\n        Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        Output: [[1,5],[6,9]]\n        Example 2:\n        Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        Output: [[1,2],[3,10],[12,16]]\n        Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # two pointers: \n        # 1. find the insertion point by binary search\n        # 2. only insert if new interval is greater than the current interval\n        \n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        insert_index = self.binary_search(intervals, newInterval)\n        if insert_index!= len(intervals) and newInterval[0] < intervals[insert_index][0]:\n            return intervals[:insert_index] + [newInterval] + intervals[insert_index:]\n        return intervals + [newInterval]\n        \n    def binary_search(self, intervals, newInterval):\n        left, right = 0, len(intervals)\n        while left < right:\n            mid = left + (right - left) // 2\n            if newInterval[0] > intervals[mid][0]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not s:\n            return 0\n        i = len(s) - 1\n        while i > 0 and s[i] =='':\n            i -= 1\n        l = i + 1\n        while i > 0 and s[i]!='':\n            i -= 1\n        r = i\n        return r - l + 1"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not s:\n            return 0\n        i = 0\n        for j in range(len(s)):\n            if s[j]!= \" \":\n                i += 1\n            elif i > 0:\n                break\n        return i"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        s = s.strip()\n        s_l = s.split()\n        if not s_l:\n            return 0\n        return len(s_l[-1])"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        res = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i]!= \" \":\n                res += 1\n            elif res!= 0:\n                return res\n        return res"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        return len(s.rstrip().split(' ')[-1])"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not s:\n            return 0\n        count = 0\n        for i in s:\n            if i =='':\n                if count!= 0:\n                    return count\n            else:\n                count += 1\n        return count"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        s = s.strip()\n        s = s.split(\" \")\n        return len(s[-1])"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u5012\u6570\u7b2c\u4e00\u4e2a\u5143\u7d20\n        s = s.rstrip(' ').split(' ')\n        return len(s[-1])"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        i = j = len(s) - 1\n        # use flag to track whether a space is encountered in the string\n        has_space = False\n        # use flag to track whether a word is started\n        is_started = False\n        while i >= 0:\n            if s[i] =='':\n                if not has_space:\n                    # if the previous character is not a space, a word is started\n                    if i < j:\n                        # if there is a word, move the pointer to the start of the word\n                        is_started = True\n                        j = i\n                has_space = True\n            elif has_space:\n                # if the current character is not a space, a word is started\n                is_started = True\n                # if the current character is not a space, move the pointer to the start of the word\n                j = i\n            elif is_started:\n                # if the current character is not a space, move the pointer to the start of the word\n                j = i\n            i -= 1\n        return j - j // j"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "prompt": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.\n        Example 1:\n        Input: s = \"Hello World\"\n        Output: 5\n        Explanation: The last word is \"World\" with length 5.\n        Example 2:\n        Input: s = \"   fly me   to   the moon  \"\n        Output: 4\n        Explanation: The last word is \"moon\" with length 4.\n        Example 3:\n        Input: s = \"luffy is still joyboy\"\n        Output: 6\n        Explanation: The last word is \"joyboy\" with length 6.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        s = s.strip()\n        if not s:\n            return 0\n        i = len(s) - 1\n        while i >= 0:\n            if s[i]!='':\n                break\n            i -= 1\n        return len(s) - i - 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if n <= 0:\n            return []\n        r_start, r_end = 0, n\n        c_start, c_end = 0, n\n        res = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        while r_start <= r_end and c_start <= c_end:\n            # // to get the right number\n            for i in range(c_start, c_end):\n                res[r_start][i] = num\n                num += 1\n            r_start += 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        r1, r2 = 0, n - 1\n        c1, c2 = 0, n - 1\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        while r1 <= r2 and c1 <= c2:\n            for i in range(c1, c2 + 1):\n                matrix[r1][i] = num\n                num += 1\n            r1 += 1\n            for i in range(r1, r2 + 1):\n                matrix[i][c2] = num\n                num += 1\n            c2 -= 1\n            if r1 <= r2:\n                for i in range(c2, c1 - 1, -1):\n                    matrix[r2][i] = num\n                    num += 1\n                r2 -= 1\n            if c1 <= c2:\n                for i in range(r2, r1 - 1, -1):\n                    matrix[i][c1] = num\n                    num += 1\n                c1 += 1\n        return matrix\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        res = [[0 for i in range(n)] for j in range(n)]\n        i, j = 0, 0\n        top = 0\n        right = n-1\n        bottom = n-1\n        left = n-1\n        direct = 0\n        num = 1\n        while num <= n**2:\n            if direct == 0:\n                if j > left:\n                    direct = 1\n                    top += 1\n                    j -= 1\n                else:\n                    res[i][j] = num\n                    num += 1\n                    i += 1\n            elif direct == 1:\n                if i < top:\n                    direct = 2\n                    j -= 1\n                else:\n                    res[i][j] = num\n                    num += 1\n                    j -= 1\n            elif direct == 2:\n                if j < right:\n                    direct = 3\n                    bottom -= 1\n                    j += 1\n                else:\n                    res[i][j] = num\n                    num += 1\n                    i -= 1\n            else:\n                if i > bottom:\n                    direct = 0\n                    left += 1\n                    i -= 1\n                else:\n                    res[i][j] = num\n                    num += 1\n                    i -= 1\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        res = [[0 for _ in range(n)] for _ in range(n)]\n        i, j, di, dj = 0, 0, 0, 1\n        for x in range(1, n ** 2 + 1):\n            res[i][j] = x\n            if res[(i + di) % n][(j + dj) % n]:\n                di, dj = dj, -di\n            i, j = i + di, j + dj\n        return res"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        return self.spiral_matrix_bfs(n)"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Append the first row\n        ret = [[None for _ in range(n)] for _ in range(n)]\n        # Append the first column\n        for i in range(n):\n            ret[i][0] = i + 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if n == 1:\n            return [[1]]\n        \n        result = [[0] * n for _ in range(n)]\n        \n        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n        \n        cur_direction = 0\n        x, y = 0, 0\n        count = 1\n        \n        while count <= n * n:\n            result[x][y] = count\n            count += 1\n            \n            new_x, new_y = x + directions[cur_direction][0], y + directions[cur_direction][1]\n            if 0 <= new_x < n and 0 <= new_y < n and result[new_x][new_y] == 0:\n                x, y = new_x, new_y\n            else:\n                cur_direction = (cur_direction + 1) % 4\n                x, y = x + directions[cur_direction][0], y + directions[cur_direction][1]\n        \n        return result"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        l, r = 0, n - 1\n        t, b = 0, n - 1\n        m = [[0] * n for _ in range(n)]\n        num = 1\n        while l <= r and t <= b:\n            for i in range(l, r + 1):\n                m[t][i] = num\n                num += 1\n            t += 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if n == 0:\n            return []\n        elif n == 1:\n            return [[1]]\n        elif n == 2:\n            return [[1, 2], [4, 3]]"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        \"\"\"\n        Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n        Example 1:\n        Input: n = 3\n        Output: [[1,2,3],[8,9,4],[7,6,5]]\n        Example 2:\n        Input: n = 1\n        Output: [[1]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        matrix = [[0]*n for i in range(n)]\n        row = 0\n        col = 0\n        val = 1\n        for i in range(n**2):\n            matrix[row][col] = val\n            val += 1\n            if row == n-1:\n                row = 0\n            else:\n                row += 1\n            if col == n-1:\n                col = 0\n            else:\n                col += 1\n            if matrix[row][col] == 0:\n                if row == n-1 and col == n-1:\n                    row, col = 0, 0\n                elif row == n-1:\n                    row, col = row, col+1\n                elif col == n-1:\n                    row, col = row+1, col\n                else:\n                    row, col = row+1, col+1\n        return matrix"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        nums = [str(i) for i in range(1, n + 1)]"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        nums = [str(i) for i in range(1, n + 1)]"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if n < 1 or k < 1:\n            return \"\""
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        nums = [i + 1 for i in range(n)]\n        ans = []\n        k -= 1\n        for i in range(1, n + 1):\n            fact = math.factorial(n - i)\n            index = k // fact\n            ans.append(str(nums.pop(index)))\n            k -= fact * index\n        return ''.join(ans)"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        ret = []\n        nums = [str(i) for i in range(1, n+1)]\n        fac = [1]\n        for i in range(1, n):\n            fac.append(fac[-1] * i)\n        for i in range(n, 0, -1):\n            q, k = divmod(k, fac[i-1])\n            ret.append(nums[q])\n            nums.remove(nums[q])\n        return ''.join(ret)"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        self.k = k\n        nums = [str(i + 1) for i in range(n)]\n        ans = []\n        self.helper(nums, ans)\n        return ''.join(ans)"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        factorial = [1]\n        for i in range(1, n):\n            factorial.append(factorial[-1] * i)\n        nums = [str(i + 1) for i in range(n)]\n        for i in range(n - 1, 0, -1):\n            # n - i is the number of nums left to try\n            # k % factorial(i) is the index of nums[i] in the remaining nums\n            # (k - 1) // factorial(i) is the number of nums before nums[i] that we tried\n            # (k - 1) % factorial(i) is the index of nums[i] in those nums\n            # nums[(k - 1) % factorial(i) + 1] is the value to replace nums[i]\n            j = (k - 1) // factorial[i]\n            nums[i], nums[j] = nums[j], nums[i]\n            k -= factorial[i] * j\n        return ''.join(nums)\n        \n        # 1st solution\n        # n = 3\n        # nums = [1,2,3]\n        # return self.getPermutationHelper(nums, k)\n        \n"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        k -= 1\n        nums = [str(i) for i in range(1, n+1)]\n        permutations = []\n        while n > 0:\n            n -= 1\n            factorial = factorial_func(n)\n            index, k = divmod(k, factorial)\n            permutations.append(nums.pop(index))\n        return ''.join(permutations)"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        nums = list(range(1, n + 1))\n        result = \"\"\n        while n > 0:\n            n -= 1\n            num, k = divmod(k, math.factorial(n))\n            result += str(nums.pop(num))\n        return result"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "prompt": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"\n        The set [1, 2, 3,..., n] contains a total of n! unique permutations.\n        By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n            \"123\"\n            \"132\"\n            \"213\"\n            \"231\"\n            \"312\"\n            \"321\"\n        Given n and k, return the kth permutation sequence.\n        Example 1:\n        Input: n = 3, k = 3\n        Output: \"213\"\n        Example 2:\n        Input: n = 4, k = 9\n        Output: \"2314\"\n        Example 3:\n        Input: n = 3, k = 1\n        Output: \"123\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        ans = ''\n        \n        # list of numbers\n        nums = list(range(1, n + 1))\n        \n        # build nums\n        while n > 1:\n            p = factorial(n - 1)\n            ind = (k - 1) // p\n            # k = k - (n - 1) * p - 1 + n\n            k = k - (n - 1) * p\n            ans += str(nums[ind])\n            nums.pop(ind)\n            n -= 1\n        \n        return ans + str(nums[0])\n    \n    \"\"\"\n    Given a non-negative integer numRows, generate the first numRows of Pascal's triangle."
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not head or not head.next or k == 0:\n            return head\n        \n        # Count the length of the linked list\n        # Find the tail of the linked list\n        # Reverse the tail to the head\n        # Make the tail point to the head\n        # Return the head\n        \n        # The number of nodes in the linked list\n        n = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            n += 1\n            \n        # Find the tail of the linked list\n        k = k % n\n        if k == 0:\n            return head\n        \n        tail.next = head\n        # Make the tail point to the head\n        new_head = head\n        \n        # Iterate over k nodes to the right\n        # and reverse them\n        for _ in range(n - k - 1):\n            # Take the current node\n            current = new_head\n            # Iterate until the end of the linked list\n            while current.next:\n                # Take the next node\n                next_node = current.next\n                # Change the current.next pointer\n                current.next = next_node.next\n                # Update the next node to point to the current node\n                next_node.next = current\n                # Move to the next node\n                current = next_"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not head:\n            return None\n        curr = head\n        length = 0\n        while curr:\n            curr = curr.next\n            length += 1\n        k %= length\n        if k == 0:\n            return head\n        k = length - k\n        curr = head\n        i = 0\n        while i < k:\n            curr = curr.next\n            i += 1\n        next = curr.next\n        curr.next = None\n        curr = next\n        while curr.next:\n            curr = curr.next\n        curr.next = head\n        return next\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if not head or not head.next:\n            return head"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not head:\n            return None\n        \n        # First, we need to find the length of the linked list.\n        # We'll take the fast and slow pointer approach\n        # so that we can update the length of the list efficiently.\n        length, last = 0, head\n        while last:\n            length += 1\n            last = last.next\n            \n        # If we have an even number of nodes, then we'll just rotate\n        # the linked list in place. If the linked list is not even,\n        # then we'll need to make sure that the k-th node ends up\n        # in the front.\n        if length % 2 == 0:\n            # The length is even, no modification needed\n            k %= length\n        else:\n            # The length is not even. This means we'll need to make\n            # sure that the k-th node ends up at the front.\n            # Since the list is not even, we'll need to increase\n            # the length of the list by one.\n            length += 1\n            k %= length\n        \n        # Now that we have the length, we can loop to the k-th node\n        # and set that as the new head.\n        current, prev = head, None\n        while k > 0:\n            prev = current\n            current = current.next"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if not head:\n            return None"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if not head:\n            return head\n        if not head.next:\n            return head\n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        curr.next = head\n        curr = head\n        for _ in range(length-k%length-1):\n            curr = curr.next\n        head = curr.next\n        curr.next = None\n        return head<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not head or not head.next or k == 0:\n            return head"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # if not head or not head.next: return head\n        if not head or not head.next: return head\n        curr, length, k = head, 0, k % len(head)\n        while curr: curr, length = curr.next, length + 1\n        # print(curr, length, k)\n        if k:\n            curr = head\n            for i in range(length - k):\n                curr = curr.next\n            newhead = curr.next\n            curr.next = None\n            while newhead.next: newhead = newhead.next\n            newhead.next = head\n            return newhead\n        else:\n            return head"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # 2. Iterate the linked list using two pointers, pre and curr. The idea is that we have two pointers, pre and curr. pre will go k steps ahead of curr, and then they will point to the same node. So at the end, curr will be pointing to the (k+1)th node from the beginning of the list. We can then change the next pointer of pre to be the next of the node pointed to by curr.\n        if not head:\n            return head\n        pre = head\n        curr = head\n        steps = 0\n        while curr.next:\n            curr = curr.next\n            steps += 1\n            if steps >= k:\n                pre = pre.next\n        if k > steps:\n            k %= steps\n        if not k:\n            return head\n        while pre.next:\n            pre = pre.next\n        nextNode = curr.next\n        curr.next = None\n        pre.next = head\n        return nextNode"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "prompt": "class Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \"\"\"\n        Given the head of a linked list, rotate the list to the right by k places.\n        Example 1:\n        Input: head = [1,2,3,4,5], k = 2\n        Output: [4,5,1,2,3]\n        Example 2:\n        Input: head = [0,1,2], k = 4\n        Output: [2,0,1]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not head or not head.next:\n            return head"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # solution 1\n        # path = [[1] * n] * m\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         path[i][j] = path[i - 1][j] + path[i][j - 1]\n        # return path[-1][-1]\n        \n        # solution 2\n        # path[i][j] = path[i - 1][j] + path[i][j - 1]\n        # return path[m - 1][n - 1]\n        \n        # solution 3\n        # if m == 1 or n == 1: return 1\n        # return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)\n        \n        # solution 4\n        # if m == 1 or n == 1: return 1\n        # m, n = m - 1, n - 1\n        # a = b = 1\n        # for i in range(n - 1):\n        #     b, a = b + a, b\n        # return b\n        \n        # solution 5\n        if m == 1 or n == 1: return 1\n        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        dp = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i==0 or j==0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                down = 0\n                right = 0\n                if i > 0:\n                    down = dp[i - 1][j]\n                if j > 0:\n                    right = dp[i][j - 1]\n                dp[i][j] = down + right\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if m == 1 or n == 1:\n            return 1\n        paths = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                paths[j] += paths[j - 1]\n        return paths[-1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # Initialization\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        # Update the values\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i - 1 >= 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j - 1 >= 0:\n                    dp[i][j] += dp[i][j - 1]\n        return dp[m - 1][n - 1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        grid = [[0] * n for _ in range(m)]\n        for i in range(m):\n            grid[i][0] = 1\n        for i in range(n):\n            grid[0][i] = 1"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # If the m and n are in the range of [1, 2 * 109].\n        # We can use the dynamic programming method\n        if m >= 1 and n >= 1 and m <= 2 * 10 ** 9 and n <= 2 * 10 ** 9:\n            dp = [[0 for j in range(n)] for i in range(m)]\n            # We only need to start from the first row and first column\n            dp[0][0] = 1\n            for i in range(m):\n                for j in range(n):\n                    if i == 0 and j == 0:\n                        continue\n                    if i!= 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j!= 0:\n                        dp[i][j] += dp[i][j - 1]\n            return dp[-1][-1]"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        grid = [[1 for _ in range(n)] for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i][j - 1] + grid[i - 1][j]\n        return grid[m - 1][n - 1]"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        \"\"\"\n        There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The test cases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: m = 3, n = 7\n        Output: 28\n        Example 2:\n        Input: m = 3, n = 2\n        Output: 3\n        Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n        1. Right -> Down -> Down\n        2. Down -> Down -> Right\n        3. Down -> Right -> Down\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # recursion (Fibonacci)\n        # if m == 1 or n == 1:\n        #     return 1\n        # return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # Solution 1 - 32 ms\n        \"\"\"\n        if not obstacleGrid: return 0\n        if obstacleGrid[0][0] == 1: return 0\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n        return dp[m - 1][n - 1]\n        \"\"\"\n        # Solution 2 - 24 ms\n        if not obstacleGrid: return 0\n        if obstacleGrid[0][0] == 1: return 0\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(1, m):\n            if"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not obstacleGrid:\n            return 0\n        if obstacleGrid[0][0] == 1:\n            return 0\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1 - obstacleGrid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] * (1 - obstacleGrid[i][j])\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] * (1 - obstacleGrid[i][j])\n                else:\n                    dp[i][j] = dp[i-1][j] * (1 - obstacleGrid[i][j]) + dp[i][j-1] * (1 - obstacleGrid[i][j])\n        return dp[m-1][n-1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if not obstacleGrid: return 0\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1\n        for j in range(n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = 1\n            else:\n                break\n        for i in range(m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = 1\n            else:\n                break\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        if m == 1 or n == 1:\n            return 0 if obstacleGrid[0][0] else 1\n        dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j]:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Backtracking with pruning.\n        # Time: O(mn), space: O(mn)\n        # if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1: return 0\n        # obstacleGrid[0][0] = 1\n        # for i in range(1, m):\n        #     obstacleGrid[i][0] = obstacleGrid[i-1][0] * (obstacleGrid[i][0] == 0)\n        # for j in range(1, n):\n        #     obstacleGrid[0][j] = obstacleGrid[0][j-1] * (obstacleGrid[0][j] == 0)\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1] * (obstacleGrid[i][j] == 0)\n        # return obstacleGrid[-1][-1]\n        \n        # Time: O(mn), space: O(1)\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        if obstacleGrid[-1][-1] == 1 or"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if obstacleGrid[-1][-1] == 1: return 0\n        M, N = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0 for _ in range(N)] for _ in range(M)]\n        dp[-1][-1] = 1\n        for i in range(M - 1, -1, -1):\n            for j in range(N - 1, -1, -1):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                    continue\n                if i == M - 1 and j == N - 1: continue\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\n        return dp[0][0]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # init\n        row, col = len(obstacleGrid), len(obstacleGrid[0])\n        if row == 0 or col == 0: return 0"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        # dp[i][j] stands for the unique path numbers for (i, j)\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                # if the current cell is an obstacle, the number of paths is 0\n                if obstacleGrid[i][j] == 1:\n                    continue\n                \n                # the number of paths is equal to the sum of the number of paths of the four neighbors\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                \n        return dp[-1][-1]<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # m,n = len(grid), len(grid[0])\n        # # if m == 1 or n == 1: return 0\n        #\n        # grid.append([0] * n)\n        # for row in grid: row.append(0)\n        #\n        # grid[0][0] = 1 - grid[0][0]\n        #\n        # for i in range(1, m):\n        #     if not grid[i][0]:\n        #         grid[i][0] = grid[i-1][0]\n        #     else:\n        #         break\n        #\n        # for i in range(1, n):\n        #     if not grid[0][i]:\n        #         grid[0][i] = grid[0][i-1]\n        #     else:\n        #         break\n        #\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         if not grid[i][j]:\n        #             grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        #\n        # return grid[-1][-1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "prompt": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        \"\"\"\n        You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n        An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\n        Return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n        The testcases are generated so that the answer will be less than or equal to 2 * 109.\n        Example 1:\n        Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n        Output: 2\n        Explanation: There is one obstacle in the middle of the 3x3 grid above.\n        There are two ways to reach the bottom-right corner:\n        1. Right -> Right -> Down -> Down\n        2. Down -> Down -> Right -> Right\n        Example 2:\n        Input: obstacleGrid = [[0,1],[0,0]]\n        Output: 1\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i == 0 and j == 0:\n                        dp[i][j] = 1\n                    else:\n                        if i > 0:\n                            dp[i][j] += dp[i - 1][j]\n                        if j > 0:\n                            dp[i][j] += dp[i][j - 1]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # 1. dp\n        # dp[i][j] is the min_path to get to [i, j]\n        # i is row\n        # j is col\n        # e.g., dp[0][0] is the min_path to get to top_left\n        # dp[0][1] is the min_path to get to top_right\n        # dp[1][0] is the min_path to get to bottom_left\n        # dp[1][1] is the min_path to get to bottom_right\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[0][i] = dp[0][i-1] + grid[0][i]\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0 and j!= 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif i!= 0 and j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        return grid[-1][-1]\n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        self.m, self.n = len(grid), len(grid[0])\n        self.grid = grid\n        self.dp = [[-1 for _ in range(self.n)] for _ in range(self.m)]\n        return self.solve(0, 0, self.m - 1, self.n - 1)"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = grid[i][0] + dp[i - 1][0]\n        for j in range(1, n):\n            dp[0][j] = grid[0][j] + dp[0][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[m - 1][n - 1]<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        # bottom up approach\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for j in range(1, n):\n            grid[0][j] += grid[0][j-1]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]\n        <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        dp = [[0 for i in range(n)] for i in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                dp[i][j] = grid[i][j] + min(dp[i][j - 1], dp[i - 1][j])\n        return dp[m - 1][n - 1]<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # Dynamic Programming\n        # Time complexity: O(m*n)\n        # Space complexity: O(m*n)\n        row, col = len(grid), len(grid[0])\n        dp = [[0 for _ in range(col+1)] for _ in range(row+1)]\n        for i in range(row):\n            for j in range(col):\n                dp[i+1][j+1] = grid[i][j] + min(dp[i][j+1], dp[i+1][j])\n        return dp[-1][-1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        if m == 1 and n == 1:\n            return grid[0][0]\n        elif m == 1:\n            for i in range(n):\n                grid[0][i] += grid[0][i-1]\n            return grid[0][-1]\n        elif n == 1:\n            for i in range(m):\n                grid[i][0] += grid[i-1][0]\n            return grid[-1][0]\n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        for j in range(1,n):\n            grid[0][j] += grid[0][j-1]\n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        return grid[-1][-1]\n    \n    \n    def minPathSum1(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        n, m = len(grid), len(grid[0])\n        dp = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]\n        dp[1][1] = grid[0][0]"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "prompt": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        \"\"\"\n        Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n        Note: You can only move either down or right at any point in time.\n        Example 1:\n        Input: grid = [[1,3,1],[1,5,1],[4,2,1]]\n        Output: 7\n        Explanation: Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.\n        Example 2:\n        Input: grid = [[1,2,3],[4,5,6]]\n        Output: 12\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        m, n = len(grid), len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if len(s) == 0: return False\n        if len(s) == 1 and s[0] in '+-' and s[1] in '+-' or s[0] in '+-' and s[1] not in 'eE' and s[0] not in 'eE' and s[1] not in 'eE':\n            return False\n        for i,c in enumerate(s):\n            if c == 'e' or c == 'E':\n                if i!= 0 and i!= len(s)-1 and i!= len(s)-1 and (s[i-1] in '+-' and s[i+1] in '+-' or s[i-1] not in '+-' and s[i+1] not in '+-'):\n                    return False\n            elif c == '.':\n                if i!= 0 and i!= len(s)-1 and (s[i-1] in 'eE' or s[i-1] in '+-' or s[i-1] in '+-' and s[i+1] not in 'eE'):\n                    return False\n            elif c not in '+-0123456789eE.':\n                return False\n        return True\n        \n    def isNumber(self, s: str"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \"\"\"\n        Time Complexity: O(n)\n        Space Complexity: O(n)\n        \"\"\"\n        def is_integer(s):\n            return s.isdigit()\n        \n        def is_float(s):\n            if s.isdigit():\n                return False\n            if s.count('.') > 1:\n                return False\n            if s.count('e') == 2:\n                return False\n            if s.count('E') == 2:\n                return False\n            return True\n        \n        n = len(s)\n        if n == 0:\n            return False\n        i = 0\n        while i < n and s[i] =='':\n            i += 1\n        \n        if i == n:\n            return False\n        \n        sign = None\n        if s[i] == '+' or s[i] == '-':\n            sign = s[i]\n            i += 1\n        \n        if i == n or is_float(s[i:]) or is_integer(s[i:]):\n            return False\n        \n        if sign is None:\n            return is_float(s[i:])\n        else:\n            return is_integer(s[i:])"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # https://leetcode.com/problems/valid-number/discuss/1461/Share-my-simple-solution-(with-Explanation)"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # if len(s) == 0 or len(s) == 1 and s[0] == '+' or s[0] == '-' or s[0] == '.':\n        #     return False\n        #\n        # # pattern: match the first part, which is the positive or negative sign\n        # pattern = r'[+-]?\\d+\\.?\\d*|[+-]?\\.?\\d+|[+-]?\\d+'\n        #\n        # match = re.match(pattern, s)\n        # if match is None:\n        #     return False\n        #\n        # # check if the rest is valid\n        # return self.isNumberHelper(match.group(0), 0)"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # s = \"01\"\n        # s = \"e\"\n        # s = \".\"\n        # s = \"+.\"\n        # s = \"12e\"\n        # s = \"12e+4\"\n        # s = \"e+3\"\n        # s = \"+6e-1\"\n        # s = \"-1E-16\"\n        # s = \"12e+4.5\"\n        # s = \"12e+45.6\"\n        # s = \"--6\"\n        # s = \"95a54e53\""
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        def is_number_1(s):\n            try:\n                float(s)\n                return True\n            except ValueError:\n                return False"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # white_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '.', 'e', 'E']\n        # s = s.strip()\n        # if not s: return False\n        # if s[0] in ['+', '-']:\n        #     s = s[1:]\n        # if not s: return False\n        # if s[0] in ['.']:\n        #     s = s[1:]\n        # if not s: return False\n        # if s[0] in ['e', 'E']:\n        #     s = s[1:]\n        # if not s: return False\n        # i = 0\n        # while i < len(s) and s[i] in white_list:\n        #     i += 1\n        # if i == 0 or i == len(s): return False\n        # if s[0] in ['+', '-']:\n        #     return self.isNumber(s[1:])\n        # if s[0] in ['.']:\n        #     return self.isNumber(s[1:])\n        # if s[0] in ['e', 'E']:\n        #     return self.isNumber(s[1:]) and self.isNumber(s[2"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        s = s.strip()\n        if len(s) == 0:\n            return False\n        elif s[0] == \"+\" or s[0] == \"-\":\n            return self.isNumber(s[1:])\n        elif s[0] == \".\":\n            return self.isFloat(s[1:])\n        else:\n            return self.isInt(s)\n    \n    def isInt(self, s: str) -> bool:\n        if len(s) == 0:\n            return False\n        return self.isDigit(s) or self.isIntExponent(s)\n    \n    def isFloat(self, s: str) -> bool:\n        if len(s) == 0:\n            return False\n        elif s[0] == \".\":\n            return self.isDigit(s[1:]) or self.isFloatExponent(s)\n        else:\n            return self.isDigit(s) or self.isFloatExponent(s)\n        \n    def isIntExponent(self, s: str) -> bool:\n        if len(s) == 0:\n            return False\n        elif s[0] == \"e\" or s[0] == \"E\":\n            return self.isInt(s["
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        s = s.strip()\n        s = s.replace('.','')\n        s = s.replace('+','')\n        s = s.replace('-','')\n        s = s.replace('e','')\n        s = s.replace('E','')\n        s = s.replace('.','')\n        return s.isdigit()"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "prompt": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        A valid number can be split up into these components (in order):\n            A decimal number or an integer.\n            (Optional) An 'e' or 'E', followed by an integer.\n        A decimal number can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One of the following formats:\n                One or more digits, followed by a dot '.'.\n                One or more digits, followed by a dot '.', followed by one or more digits.\n                A dot '.', followed by one or more digits.\n        An integer can be split up into these components (in order):\n            (Optional) A sign character (either '+' or '-').\n            One or more digits.\n        For example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n        Given a string s, return true if s is a valid number.\n        Example 1:\n        Input: s = \"0\"\n        Output: true\n        Example 2:\n        Input: s = \"e\"\n        Output: false\n        Example 3:\n        Input: s = \".\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        met_dot = False\n        met_e = False\n        met_digit = False\n        met_int = False\n        met_sign = False\n        met_exponent = False\n        for i,c in enumerate(s):\n            if c in \"0123456789\":\n                met_digit = True\n            elif c == '.':\n                if met_dot or met_exponent:\n                    return False\n                else:\n                    met_dot = True\n            elif c in \"eE\":\n                if met_e or met_exponent:\n                    return False\n                else:\n                    met_e = True\n                    met_sign = False\n            elif c in \"+-\":\n                if met_sign or met_exponent:\n                    return False\n                else:\n                    met_sign = True\n            elif c in \" \":\n                if met_digit or met_int or met_sign:\n                    pass\n                else:\n                    return False\n            elif ord('0') <= ord(c) <= ord('9'):\n                if met_int or met_digit or met_exponent:\n                    return False\n                else:\n                    met_int = True\n                    met_sign = False\n                    met_digit = False\n            elif ord('a') <= ord(c"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        len_digits = len(digits)\n        for i in range(len_digits-1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + [0]*len_digits"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        n = len(digits)\n        # digits = [9,9,9,9]\n        # n = 4\n        # n = 3\n        # n = 1\n        for i in range(n-1, -1, -1):\n            if digits[i] + 1 == 10:\n                digits[i] = 0\n                if i == 0:\n                    digits.insert(0, 1)\n            else:\n                digits[i] += 1\n                return digits\n        return digits\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        n = len(digits)\n        if n == 1 and digits[0] == 9:\n            return [1, 0]"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        \n        for i in range(len(digits)):\n            digits[i] += 1\n            if digits[i] >= 10:\n                digits[i] -= 10\n            else:\n                break\n            \n        while digits and digits[-1] == 0:\n            digits.pop()\n        return digits\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Solution 1:\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] == 9:\n                digits[i] = 0\n                if i == 0:\n                    digits = [1] + digits\n            else:\n                digits[i] += 1\n                break"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(1)\n        i = len(digits) - 1\n        while i >= 0 and digits[i] == 9:\n            digits[i] = 0\n            i -= 1"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        n = len(digits)\n        if n == 0: return [1]\n        carry = 1\n        for i in range(n-1, -1, -1):\n            if digits[i] + carry < 10:\n                digits[i] += carry\n                return digits\n            else:\n                digits[i] = 0\n                carry = 1"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        n = len(digits)\n        res = [0] * n\n        c = 1\n        for i in range(n - 1, -1, -1):\n            c = c + digits[i] + res[i]\n            if c > 9:\n                res[i] = c - 10\n                c = 1\n            else:\n                res[i] = c\n                c = 0\n        if c!= 0:\n            res[0] = c\n        return res"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        \n        # Solution 1: loop and add one\n        # O(n) time\n        # O(n) space\n        # i = len(digits) - 1\n        # while i >= 0:\n        #     if digits[i] == 9:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0, 1)\n        #     else:\n        #         digits[i] += 1\n        #         break\n        #     i -= 1\n        \n        # Solution 2: add one and store the carry\n        # O(n) time\n        # O(1) space\n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] + carry < 10:\n                digits[i] += carry\n                return digits\n            else:\n                digits[i] = 0\n                carry = 1\n        \n        if carry == 1:\n            digits.insert(0, 1)\n        return digits\n        \n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "prompt": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.\n        Example 1:\n        Input: digits = [1,2,3]\n        Output: [1,2,4]\n        Explanation: The array represents the integer 123.\n        Incrementing by one gives 123 + 1 = 124.\n        Thus, the result should be [1,2,4].\n        Example 2:\n        Input: digits = [4,3,2,1]\n        Output: [4,3,2,2]\n        Explanation: The array represents the integer 4321.\n        Incrementing by one gives 4321 + 1 = 4322.\n        Thus, the result should be [4,3,2,2].\n        Example 3:\n        Input: digits = [9]\n        Output: [1,0]\n        Explanation: The array represents the integer 9.\n        Incrementing by one gives 9 + 1 = 10.\n        Thus, the result should be [1,0].\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        for i in range(len(digits)-1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0, 1)\n        return digits\n        \"\"\"\n        The idea is to start from the end of the array and work your way forward. You can represent an integer as a series of digits like so:"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        # Solution 1:\n        # a, b = a[::-1], b[::-1]\n        # max_len = max(len(a), len(b))\n        # a, b = a.zfill(max_len), b.zfill(max_len)\n        # res = ''\n        # carry = 0\n        # for i in range(max_len):\n        #     res_i = int(a[i]) + int(b[i]) + carry\n        #     if res_i == 3:\n        #         res = '1' + res\n        #         carry = 1\n        #     elif res_i == 2:\n        #         res = '0' + res\n        #         carry = 1\n        #     elif res_i == 1:\n        #         res = '1' + res\n        #         carry = 0\n        #     elif res_i == 0:\n        #         res = '0' + res\n        #         carry = 0\n        # if carry == 1:\n        #     res = '1' + res\n        # return res[::-1]"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        n = max(len(a), len(b))\n        a, b = a.zfill(n), b.zfill(n)\n        carry = 0\n        res = []\n        for i in range(n - 1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if b[i] == '1':\n                carry += 1\n            if carry % 2 == 1:\n                res.append('1')\n            else:\n                res.append('0')\n            carry //= 2\n        if carry == 1:\n            res.append('1')\n        return ''.join(res[::-1])\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        # \ubb38\uc790\uc5f4 \uc778\ub371\uc2a4 \uac12\uc744 \ud65c\uc6a9\ud558\uc5ec \ub450 \ubb38\uc790\uc5f4\uc758 \ube44\ud2b8 \uc5f0\uc0b0\uc744 \uc9c4\ud589\ud55c\ub2e4\n        a_idx = len(a) - 1\n        b_idx = len(b) - 1\n        carry = 0\n        result = \"\"\n        while a_idx >= 0 or b_idx >= 0:\n            a_bit = int(a[a_idx]) if a_idx >= 0 else 0\n            b_bit = int(b[b_idx]) if b_idx >= 0 else 0\n            bit = a_bit + b_bit + carry\n            if bit < 2:\n                carry = 0\n                result = str(bit) + result\n            else:\n                carry = 1\n                result = str(bit % 2) + result\n            a_idx -= 1\n            b_idx -= 1"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not a or not b:\n            return a or b\n        len_a = len(a)\n        len_b = len(b)\n        if len_a < len_b:\n            a = '0'*(len_b-len_a) + a\n        else:\n            b = '0'*(len_a-len_b) + b\n        carry, res = 0, []\n        for i in range(len(a)-1, -1, -1):\n            if carry == 0:\n                res.append(a[i] + b[i])\n            else:\n                res.append(a[i] + b[i] + str(carry))\n                carry = 0 if a[i] + b[i] == '10' else 1\n        if carry == 1:\n            res.append('1')\n        res.reverse()\n        return ''.join(res)"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # \u601d\u8def\uff1a\u4f9d\u6b21\u5c06\u4e24\u4e2a\u5b57\u7b26\u4e32\u7ffb\u8f6c\uff0c\u7136\u540e\u6c42\u548c\uff0c\u518d\u7ffb\u8f6c\u62fc\u63a5\n        return bin(int(a, 2) + int(b, 2))[2:]"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \n        # solution 1: convert into integers, then convert into binary\n        # return bin(int(a, 2) + int(b, 2))[2:]\n        \n        # solution 2: let's use a, b as integers, and do calculations\n        # iterate through the two strings, add them together, and turn into binary\n        # after we've added, convert to binary and return\n        # we use a set of zeros and ones to represent the binary\n        # if adding zeros to the end of a or b, we're going to have a carry\n        # we add zeros to the end of the string if we have a carry, and otherwise\n        # we add one to the end of the string\n        \n        # Solution 3: Let's use binary addition\n        # if a + b = 2^n, then a + b = b + a\n        # if a + b = 2^n + 1, then a + b = a + b\n        # so the bit we want to add to the end is the xor of a and b\n        \n        # Sol 4:\n        # let's do the binary addition, and then add the carry if we need to\n        # then iterate through the binary addition, and if the number is a 1, add a 1 to the end\n        # if not, add a 0 to the end\n"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not a or not b:\n            return a or b\n        if a[-1] == \"1\" and b[-1] == \"1\":\n            return self.addBinary(self.addBinary(a[:-1], b[:-1]), \"1\") + \"0\"\n        elif a[-1] == \"0\" and b[-1] == \"0\":\n            return self.addBinary(a[:-1], b[:-1]) + \"0\"\n        else:\n            return self.addBinary(a[:-1], b[:-1]) + \"1\""
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        x, y = int(a, 2), int(b, 2)\n        while y:\n            x, y = x ^ y, (x & y) << 1\n        return bin(x)[2:]\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # make a and b equal length by adding '0' at the end of shorter string\n        if len(a) < len(b):\n            a = '0' * (len(b) - len(a)) + a\n        elif len(b) < len(a):\n            b = '0' * (len(a) - len(b)) + b\n        result = ''\n        i = len(a) - 1\n        carry = 0\n        while i >= 0:\n            # add carry to the result\n            s = int(a[i]) + int(b[i]) + carry\n            if s >= 2:\n                s -= 2\n                carry = 1\n            else:\n                carry = 0\n            result = str(s) + result\n            i -= 1\n        if carry == 1:\n            result = '1' + result\n        return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "prompt": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"\n        Given two binary strings a and b, return their sum as a binary string.\n        Example 1:\n        Input: a = \"11\", b = \"1\"\n        Output: \"100\"\n        Example 2:\n        Input: a = \"1010\", b = \"1011\"\n        Output: \"10101\"\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        \"\"\"\n        Time complexity: O(max(m,n))\n        Space complexity: O(max(m,n))\n        \"\"\"\n        if not a and not b:\n            return \"\"\n        if not a:\n            return b\n        if not b:\n            return a\n        res = []\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        while i >= 0 or j >= 0:\n            tmp = carry\n            if i >= 0:\n                tmp += int(a[i])\n            if j >= 0:\n                tmp += int(b[j])\n            res.append(str(tmp % 2))\n            carry = tmp // 2\n            i -= 1\n            j -= 1\n        if carry:\n            res.append(str(carry))\n        return ''.join(res[::-1])"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        def get_line_length(line):\n            line_length = len(line)\n            num_spaces = maxWidth - line_length\n            num_spaces_of_each_word = num_spaces // (len(line) - 1)\n            num_spaces_left = num_spaces % (len(line) - 1)"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # If we have only one word in the list, we have nothing to justify.\n        if len(words) == 1:\n            return [words[0]]\n        else:\n            # Initialize lists and variables to store result.\n            result = []\n            word_list = []\n            current_line = []\n            current_line_len = 0\n            current_line_char_count = 0\n            # Iterate over words.\n            for word in words:\n                # If the word length is greater than the allowed max width, we cannot fit it into the current line, so we should break it into multiple lines.\n                if len(word) > maxWidth:\n                    # If the current line is not empty, we need to justify it.\n                    if current_line:\n                        word_list = []\n                        # Iterate over the words in the current line, justifying them.\n                        for i in range(len(current_line)):\n                            # If we have space to fill on the left, we should fill it.\n                            if current_line_len > current_line_char_count:\n                                word_list.append(\" \" * (current_line_len - current_line_char_count))\n                                word_list.append(current_line[i])\n                                current_line_char_count = current_line_len"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        def get_width(words):\n            total_len = 0\n            for i in range(len(words)):\n                total_len += len(words[i])\n            return total_len"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        ans = []\n        curr_width = 0\n        curr_line = []\n        for word in words:\n            if curr_width + len(word) + len(curr_line) - 1 <= maxWidth:\n                curr_width += len(word)\n                curr_line.append(word)\n            else:\n                ans.append(self.justify(curr_line, maxWidth, curr_width))\n                curr_line = [word]\n                curr_width = len(word)\n        ans.append(self.justify(curr_line, maxWidth, curr_width))\n        return ans"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        res = []\n        words_len = len(words)\n        cur_line = []\n        cur_len = 0\n        for i in range(words_len):\n            if cur_len + len(words[i]) <= maxWidth:\n                cur_line.append(words[i])\n                cur_len += len(words[i]) + 1\n                if i == words_len - 1:\n                    res.append(self.justify(cur_line, maxWidth))\n            else:\n                cur_line = [words[i]]\n                cur_len = len(words[i])\n                res.append(self.justify(cur_line, maxWidth))\n        return res"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Greedy algorithm\n        words.sort(key=lambda x: len(x))\n        res, n, length = [], len(words), 0\n        for i in range(n):\n            length += len(words[i]) + 1\n            if i == n - 1 or length + 1 <= maxWidth:\n                # if i == n - 1 or length + 1 <= maxWidth:\n                #     res.append(words[i] + \" \" * (maxWidth - length))\n                res.append(words[i] + \" \" * (maxWidth - length))\n            else:\n                res.append(words[i] + \" \" * (maxWidth - length + 1))\n                length = len(words[i]) + 1\n        return res"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        res = []\n        lst = []\n        n = len(words)\n        # add first word\n        lst.append(words[0])\n        # add last word\n        if n > 1:\n            last_word = words[-1]\n            if len(last_word) > maxWidth:\n                lst.append(last_word[0:maxWidth])\n                words[-1] = last_word[maxWidth:]\n            else:\n                lst.append(last_word)\n        # for the remaining words\n        for i in range(1, n):\n            if len(words[i]) + len(lst) < maxWidth:\n                lst.append(words[i])\n            else:\n                if len(lst) == 1:\n                    res.append(lst[0] +'' * (maxWidth - len(lst[0])))\n                else:\n                    spaces_between_words = maxWidth - len(''.join(lst))\n                    words_to_be_justified = spaces_between_words % (len(lst) - 1)\n                    if words_to_be_justified:\n                        extra_spaces = spaces_between_words // (len(lst) - 1)\n                        for j in range(len"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        res = []\n        i = 0\n        while i < len(words):\n            s = \"\"\n            j = i\n            cnt = 0\n            while j < len(words) and cnt + len(words[j]) + 1 <= maxWidth:\n                s += words[j] + \" \"\n                j += 1\n                cnt += len(words[j - 1]) + 1\n            k = j\n            if k == len(words):\n                res.append(s.ljust(maxWidth))\n            else:\n                remain = maxWidth - cnt\n                if k - i == 1:\n                    s += \" \" * remain\n                    res.append(s)\n                else:\n                    remain_spaces = remain // (k - i - 1)\n                    remain_remain = remain % (k - i - 1)\n                    for j in range(i, k):\n                        if j == i:\n                            s += \" \" * remain_spaces\n                        else:\n                            s += \" \" * remain_spaces + \" \" * remain_remain\n                        if j!= k - 1:\n                            s += words[j] + \" \"\n                    s = s[:-1]\n                    res.append(s)\n                i = k\n        return res"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # \u5148\u628a\u6bcf\u4e00\u884c\u7b2c\u4e00\u4e2a\u5355\u8bcd\u7684\u957f\u5ea6\u7b97\u51fa\u6765\n        # \u7136\u540e\u628a\u5269\u4e0b\u7684\u5355\u8bcd\u653e\u8fdb\u4e00\u4e2ares\u91cc\u9762\n        # \u4ee5max_line_len\u4e3a\u57fa\u7840\uff0c\n        # \u6bcf\u6b21\u628aword_count + max_line_len + len(word) + word_count - 1\u4e2a\u7a7a\u683c\u653e\u8fdb\u53bb\uff0cword_count\u4e3a\u4e00\u884c\u7b2c\u4e00\u4e2aword\u5230\u7b2c\u4e8c\u4e2aword\u7684\u7a7a\u683c\u6570\uff0cword\u4e3a\u7b2c\u4e8c\u4e2aword\n        # \u6bcf\u6b21\u628a\u7b2c\u4e00\u4e2aword\u7b97\u51fa\u6765\u4e4b\u540e\uff0cword_count\u5c31\u662f\u7b2c\u4e8c\u4e2aword\u5230\u6700\u540e\u4e00\u4e2aword\u7684\u7a7a\u683c\u6570\uff0c\u7136\u540eword_count = word_count + max_line_len - len(word)\n        # \u8fd9\u6837\u4e00\u4e2a\u4e00\u884c\u4e00\u884c\u7684\u653e\ufffd"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "prompt": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        \"\"\"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n        You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces'' when necessary so that each line has exactly maxWidth characters.\n        Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n        For the last line of text, it should be left-justified, and no extra space is inserted between words.\n        Note:\n            A word is defined as a character sequence consisting of non-space characters only.\n            Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n            The input array words contains at least one word.\n        Example 1:\n        Input: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n        Output:\n        [\n           \"This    is    an\",\n           \"example  of text\",\n           \"justification.  \"\n        ]\n        Example 2:\n        Input: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n        Output:\n        [\n          \"What   must   be\",\n          \"acknowledgment  \",\n          \"shall be        \"\n        ]\n        Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\n        Note that the second line is also left-justified because it contains only one word.\n        Example 3:\n        Input: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n        Output:\n        [\n          \"Science  is  what we\",\n          \"understand      well\",\n          \"enough to explain to\",\n          \"a  computer.  Art is\",\n          \"everything  else  we\",\n          \"do                  \"\n        ]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if not words:\n            return []"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if x == 1:\n            return 1\n        if x == 0:\n            return 0\n        left, right = 0, x // 2 + 1\n        while left < right:\n            mid = left + (right - left + 1) // 2\n            if mid ** 2 <= x:\n                left = mid\n            else:\n                right = mid - 1\n        return left"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if x == 1:\n            return 1\n        elif x <= 3:\n            return 1\n        elif x == 4:\n            return 2\n        else:\n            left = 0\n            right = x // 2\n            while left <= right:\n                mid = (left + right) // 2\n                mid_sqrt = mid * mid\n                if mid_sqrt == x:\n                    return mid\n                elif mid_sqrt < x:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left - 1"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if x == 1:\n            return 1\n        left, right = 0, x\n        # move right to mid position\n        while left <= right:\n            mid = left + (right - left) // 2\n            # if mid is a perfect square, return it\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # check if solution is positive integer\n        return left - 1 if left * left > x else left"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if x < 2: return x\n        # binary search\n        left, right = 0, x\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif x < mid * mid:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n        \n        # Newton\n        # if x == 0: return 0\n        # if x == 1: return 1\n        # k = 1\n        # while True:\n        #     k *= 2\n        #     if k > x:\n        #         break\n        # y = x / k\n        # while y ** 2 > x:\n        #     k //= 2\n        #     y = x / k\n        # return int(y)\n        \n        \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # runtime: O(log(n))\n        # memory: O(1)\n        left, right = 0, x\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif x < mid * mid:\n                right = mid - 1\n            else:\n                left = mid + 1"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if x <= 1:\n            return x\n        left, right = 0, x\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if mid ** 2 <= x:\n                left = mid\n            else:\n                right = mid\n        return right"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # newton's method\n        # if x == 0:\n        #     return 0\n        # if x == 1:\n        #     return 1\n        # f = lambda x: x * x - x - 1\n        # fp = lambda x: 2 * x\n        # x1 = x / 2 + 1\n        # while abs(f(x1)) > 0.0001:\n        #     x1 = x1 - f(x1) / fp(x1)\n        # return int(x1)"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        if x <= 1:\n            return x\n        i, j = 1, x\n        # \u4e8c\u5206\u67e5\u627e\u7684\u65f6\u5019\uff0c\u8981\u786e\u5b9a\u5de6\u53f3\u8fb9\u754c\u7684\u503c\uff0c\u8fd9\u91cc\u4e24\u8fb9\u90fd\u53d6\u6574\u6570\n        while i <= j:\n            m = (i + j) >> 1  # \u53d6\u6574\u6570\n            if m * m <= x < (m + 1) * (m + 1):\n                return m\n            if m * m > x:\n                j = m\n            elif m * m < x:\n                i = m\n        return j"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        l, r = 0, x\n        while l <= r:\n            m = (l + r) // 2\n            if m * m <= x < (m + 1) * (m + 1):\n                return m\n            elif m * m > x:\n                r = m - 1\n            else:\n                l = m + 1"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "prompt": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n        You must not use any built-in exponent function or operator.\n            For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n        Example 1:\n        Input: x = 4\n        Output: 2\n        Explanation: The square root of 4 is 2, so we return 2.\n        Example 2:\n        Input: x = 8\n        Output: 2\n        Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        l = 1\n        h = x\n        while l < h:\n            m = (l + h) >> 1\n            if m * m > x:\n                h = m\n            else:\n                l = m + 1\n        return l - 1"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if n == 1:\n            return 1\n        a, b = 1, 1\n        for i in range(n-1):\n            a, b = b, a+b\n        return b"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        a, b = 1, 2\n        for i in range(3, n + 1):\n            a, b = b, a + b\n        return b"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        if n < 3:\n            return n\n        ways = [1, 2]\n        for i in range(2, n):\n            ways.append(ways[i - 1] + ways[i - 2])\n        return ways[n - 1]"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if n < 3:\n            return n\n        f = [1, 2]\n        for i in range(2, n):\n            f.append(f[i - 1] + f[i - 2])\n        return f[n - 1]"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if n == 0 or n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # dynamic programming\n        # keep track of the number of ways to get to the current step\n        ways_to_1 = 1\n        ways_to_2 = 1"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if n < 3:\n            return n\n        a, b = 1, 2\n        for _ in range(3, n + 1):\n            a, b = b, a + b\n        return b"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "prompt": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"\n        You are climbing a staircase. It takes n steps to reach the top.\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n        Example 1:\n        Input: n = 2\n        Output: 2\n        Explanation: There are two ways to climb to the top.\n        1. 1 step + 1 step\n        2. 2 steps\n        Example 2:\n        Input: n = 3\n        Output: 3\n        Explanation: There are three ways to climb to the top.\n        1. 1 step + 1 step + 1 step\n        2. 1 step + 2 steps\n        3. 2 steps + 1 step\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        dirs = path.split(\"/\")"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        path = path.strip('/')\n        stack = []\n        for token in path.split('/'):\n            if token == '..':\n                if stack:\n                    stack.pop()\n            elif token!= '.' and token:\n                stack.append(token)\n        return '/' + '/'.join(stack)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if not path:\n            return path\n        \n        # Use stack to record the directory path\n        stack = []\n        \n        # Use hash to record the directory mapping\n        dir_mapping = {'/':'','/home/':'','/home/..':'','/home/foo':'','/home/foo/../':''}\n        \n        # Use index to record the directory path\n        index = 0\n        \n        while index < len(path):\n            if path[index] == '/':\n                # If the character is '/',\n                # pop the last directory path if possible\n                if stack:\n                    stack.pop()\n                # If the last character is '/',\n                # skip the current character\n                elif index < len(path) - 1 and path[index+1] == '/':\n                    index += 1\n                # If the last character is not '/',\n                # it means this is a directory path\n                # so append the directory to stack\n                else:\n                    stack.append(path[index])\n            # If the character is '.',\n            # skip the current character\n            elif path[index] == '.':\n                index += 1\n            # If the character is '..',\n            # pop the last directory path if possible\n            elif path[index] == '.."
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        import os\n        paths = [item for item in path.split(\"/\") if item]\n        stack = []\n        for p in paths:\n            if p == \".\":\n                continue\n            elif p == \"..\":\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # \u89e3\u9898\u601d\u8def\uff1a\u9996\u5148\u628a\u6839\u76ee\u5f55/\u8def\u5f84\u66ff\u6362\u4e3a\u7a7a\n        # \u518d\u7528split\u5c06\u7ed3\u679c\u5206\u5272\u4e3a\u5404\u4e2a\u8def\u5f84\n        # \u518d\u7528is_dot\u5224\u65ad\u662f\u5426\u4e3a\u6839\u76ee\u5f55\n        # \u6700\u540e\u628a\u5206\u5272\u7ed3\u679c\u4e2d\u7684\u7a7a\u503c\u8fc7\u6ee4\u6389\n        s = path.split('/')\n        stack = []\n        for p in s:\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p!= '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        path = path.split(\"/\")\n        ans = []\n        for s in path:\n            if s == \"..\":\n                if ans:\n                    ans.pop()\n            elif s and s!= \".\":\n                ans.append(s)\n        return \"/\" + \"/\".join(ans)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # split path into list, remove empty string at end\n        path = path.split(\"/\")\n        path.remove(\"\")"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        stack = []\n        path = path.split('/')\n        for el in path:\n            if el == '.':\n                continue\n            elif el == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(el)\n        return '/' + '/'.join(stack)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        result = []\n        i = 0\n        while i < len(path):\n            if path[i] == '/':\n                if i < len(path) - 1 and path[i + 1] == '/':\n                    i += 1\n                elif i < len(path) - 1 and path[i + 1] == '.':\n                    i += 2\n                elif i < len(path) - 1 and path[i + 1] == '..':\n                    i += 3\n                else:\n                    result.append(path[i])\n                    i += 1\n            else:\n                i += 1\n        if result == []:\n            return '/'\n        return '/' + '/'.join(result)"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "prompt": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        \"\"\"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n        In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n        The canonical path should have the following format:\n            The path starts with a single slash '/'.\n            Any two directories are separated by a single slash '/'.\n            The path does not end with a trailing '/'.\n            The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n        Return the simplified canonical path.\n        Example 1:\n        Input: path = \"/home/\"\n        Output: \"/home\"\n        Explanation: Note that there is no trailing slash after the last directory name.\n        Example 2:\n        Input: path = \"/../\"\n        Output: \"/\"\n        Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n        Example 3:\n        Input: path = \"/home//foo/\"\n        Output: \"/home/foo\"\n        Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # Split the path into directories\n        path = path.split(\"/\")"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        dp = [[0 for i in range(len(word2)+1)] for j in range(len(word1)+1)]\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        for j in range(len(word2)+1):\n            dp[0][j] = j\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1)\n        return dp[-1][-1]\n    \n    def minDistance_2(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input:"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        m = len(word1)\n        n = len(word2)"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                left = dp[i-1][j] + 1\n                down = dp[i][j-1] + 1\n                left_down = dp[i-1][j-1]\n                if word1[i-1]!= word2[j-1]:\n                    left_down += 1\n                dp[i][j] = min(left, down, left_down)\n        return dp[m][n]\n    \n    def minDistance1(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Levenshtein distance: https://en.wikipedia.org/wiki/Levenshtein_distance\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        m = len(word1)\n        n = len(word2)"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(word1) == 0:\n            return len(word2)\n        if len(word2) == 0:\n            return len(word1)\n        self.memo = {}\n        return self.dfs(word1, word2, 0, 0)"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # # dp[i][j]\u8868\u793aword1\u524di\u4e2a\u5b57\u6bcd\u8f6c\u5316\u4e3aword2\u524dj\u4e2a\u5b57\u6bcd\u6240\u9700\u6b65\u9aa4\n        # # dp[i][j] = dp[i - 1][j - 1] + 1 if word1[i - 1]!= word2[j - 1]\n        # # dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i - 1][j] + 1)\n        # m, n = len(word1), len(word2)\n        # dp = [[0] * (n + 1) for _ in range(m + 1)]\n        # for i in range(m + 1):\n        #     dp[i][0] = i\n        # for j in range(n + 1):\n        #     dp[0][j] = j\n        # for i in range(1, m + 1):\n        #     for j in range(1, n + 1):\n        #         if word1[i - 1] == word2[j - 1]:\n        #             dp[i][j] = dp["
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        n = len(word1)\n        m = len(word2)\n        \n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        \n        for i in range(n + 1):\n            dp[i][0] = i\n        for j in range(m + 1):\n            dp[0][j] = j\n            \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n                    \n        return dp[n][m]\n    \n    \"\"\"\n    Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n    Note:\n    The solution set must not contain duplicate triplets.\n    Example:\n    Given array nums = [-1, 0, 1, 2, -1, -"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # dp[i][j] = word1[:i] ~= word2[:j]\n        m, n = len(word1), len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(m+1):\n            dp[i][0] = i\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1\n        return dp[m][n]"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n        You have the following three operations permitted on a word:\n            Insert a character\n            Delete a character\n            Replace a character\n        Example 1:\n        Input: word1 = \"horse\", word2 = \"ros\"\n        Output: 3\n        Explanation: \n        horse -> rorse (replace 'h' with 'r')\n        rorse -> rose (remove 'r')\n        rose -> ros (remove 'e')\n        Example 2:\n        Input: word1 = \"intention\", word2 = \"execution\"\n        Output: 5\n        Explanation: \n        intention -> inention (remove 't')\n        inention -> enention (replace 'i' with 'e')\n        enention -> exention (replace 'n' with 'x')\n        exention -> exection (replace 'n' with 'c')\n        exection -> execution (insert 'u')\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # dp[i][j] = min number of steps to convert word1[:i] to word2[:j]\n        # dp[i][j] = min(dp[i-1][j-1] + 1 if word1[i]!= word2[j] else 0, dp[i-1][j]+1, dp[i][j-1]+1)\n        # if word1[i]!= word2[j], the cost of step is 1, which is same with replace.\n        # if word1[i] == word2[j], the cost of step is 0, which is same with remove.\n        # we can not only use dp[i-1][j], which is same with previous character, but dp[i][j-1], which is same with next character, to avoid repeated calculation.\n        m, n = len(word1), len(word2)\n        if m * n == 0:\n            return m + n\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        \n        zero_row = set()\n        zero_col = set()\n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if matrix[row][col] == 0:\n                    zero_row.add(row)\n                    zero_col.add(col)\n        \n        for row in range(len(matrix)):\n            for col in range(len(matrix[0])):\n                if row in zero_row or col in zero_col:\n                    matrix[row][col] = 0\n                    \n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not matrix or not matrix[0]:\n            return matrix\n        row_set = set()\n        column_set = set()\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row_set.add(i)\n                    column_set.add(j)\n        for i in range(m):\n            for j in range(n):\n                if i in row_set or j in column_set:\n                    matrix[i][j] = 0\n        return matrix"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        rows = len(matrix)\n        cols = len(matrix[0])\n        rowZero = False\n        colZero = False\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        rowZero = True\n                    if j == 0:\n                        colZero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(1, rows):\n            if matrix[i][0] == 0:\n                for j in range(cols):\n                    matrix[i][j] = 0\n        for j in range(1, cols):\n            if matrix[0][j] == 0:\n                for i in range(rows):\n                    matrix[i][j] = 0\n        if rowZero:\n            for i in range(rows):\n                matrix[i][0] = 0\n        if colZero:\n            for j in range(cols):\n                matrix[0][j] = 0\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        row_set = set()\n        col_set = set()\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    row_set.add(i)\n                    col_set.add(j)\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i in row_set or j in col_set:\n                    matrix[i][j] = 0"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        row = set()\n        col = set()"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # O(1) time\n        # O(mn) space\n        row = [False for _ in range(len(matrix))]\n        column = [False for _ in range(len(matrix[0]))]\n        \n        # find 0 in each row\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    row[i] = True\n                    column[j] = True\n                    \n        # set row and column to 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if row[i] or column[j]:\n                    matrix[i][j] = 0\n                <|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # rows, cols = [], []\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 0:\n        #             rows.append(i)\n        #             cols.append(j)\n        # for row in rows:\n        #     for col in range(len(matrix[0])):\n        #         matrix[row][col] = 0\n        # for col in cols:\n        #     for row in range(len(matrix)):\n        #         matrix[row][col] = 0\n        # print(matrix)\n        # rows, cols = set(), set()\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 0:\n        #             rows.add(i)\n        #             cols.add(j)\n        # for row in rows:\n        #     for col in range(len(matrix[0])):\n        #         matrix[row][col] = 0\n        # for col in cols:\n        #     for row in range(len(matrix)):\n"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        rows, cols = set(), set()\n        m = len(matrix)\n        n = len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        for i in range(m):\n            for j in range(n):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        rows, cols = len(matrix), len(matrix[0])\n        row_set, col_set = set(), set()"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "prompt": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n        You must do it in place.\n        Example 1:\n        Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]\n        Output: [[1,0,1],[0,0,0],[1,0,1]]\n        Example 2:\n        Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n        Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        rows = set()\n        cols = set()\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        for i in rows:\n            for j in range(len(matrix[i])):\n                matrix[i][j] = 0\n        for i in range(len(matrix)):\n            for j in cols:\n                matrix[i][j] = 0\n        return None"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not matrix:\n            return False\n        # search in the first row\n        m, n = len(matrix), len(matrix[0])\n        low, high = 0, m * n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            elif matrix[mid // n][mid % n] > target:\n                high = mid - 1\n            else:\n                return True\n        return False\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        if not matrix or not matrix[0]: return False\n        m, n = len(matrix), len(matrix[0])\n        if n == 1:\n            for i in range(m):\n                if target == matrix[i][0]:\n                    return True\n            return False\n        lo, hi = 0, m * n - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            # find the row where mid is located\n            r, c = mid // n, mid % n\n            if matrix[r][c] == target:\n                return True\n            elif matrix[r][c] > target:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return False\n    \n    def searchMatrix2(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        \u7d22\u5f15\u4ece0\u5f00\u59cb\uff0c\u90a3\u4e48\u7b2c\u4e00\u884c\u7b2c\u4e00\u5217\u7684\u7d22\u5f15\u4e3a\uff080\uff0c0\uff09\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        lo, hi = 0, m * n - 1\n        while lo <= hi:\n            mid = (lo"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return False\n        i, j = 0, len(matrix[0]) - 1\n        while i < len(matrix) and j >= 0:\n            if target == matrix[i][j]:\n                return True\n            elif target < matrix[i][j]:\n                j -= 1\n            else:\n                i += 1\n        return False\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # binary search solution\n        if not matrix or not matrix[0]:\n            return False\n        n, m = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if target < matrix[mid // m][mid % m]:\n                right = mid - 1\n            elif target > matrix[mid // m][mid % m]:\n                left = mid + 1\n            else:\n                return True\n        return False"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        m = len(matrix)\n        if m == 0:\n            return False\n        n = len(matrix[0])\n        if n == 0:\n            return False\n        # binary search\n        # time O(log(mn))\n        # space O(1)\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            r, c = mid // n, mid % n\n            if matrix[r][c] == target:\n                return True\n            elif matrix[r][c] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        i, j = 0, n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] > target:\n                j -= 1\n            elif matrix[i][j] < target:\n                i += 1\n            else:\n                return True\n        return False"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # binary search\n        # time complexity O(log(m*n))\n        # space complexity O(1)\n        if not matrix:\n            return False\n        m, n = len(matrix), len(matrix[0])\n        row, col = m-1, 0\n        while row >= 0 and col < n:\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] > target:\n                row -= 1\n            else:\n                col += 1\n        return False\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # Traverse through rows, find the index of row with smallest num > target\n        # Use bisect_left() in bisect_left(a, x) to find the index\n        # Time complexity O(log(m * n))\n        # Space complexity O(1)\n        if not matrix:\n            return False\n        row = 0\n        col = len(matrix[0]) - 1\n        while row < len(matrix) and col >= 0:\n            if matrix[row][0] <= target <= matrix[row][-1]:\n                break\n            elif target < matrix[row][0]:\n                col -= 1\n            else:\n                row += 1\n        if col < 0 or row >= len(matrix):\n            return False"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        if not matrix: return False\n        # binary search\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            num = matrix[mid // n][mid % n]\n            if num == target:\n                return True\n            elif num < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "prompt": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        You are given an m x n integer matrix matrix with the following two properties:\n            Each row is sorted in non-decreasing order.\n            The first integer of each row is greater than the last integer of the previous row.\n        Given an integer target, return true if target is in matrix or false otherwise.\n        You must write a solution in O(log(m * n)) time complexity.\n        Example 1:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n        Output: true\n        Example 2:\n        Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        i = 0\n        j = len(matrix) - 1\n        while i <= j:\n            k = (i + j) // 2\n            if matrix[k][0] == target:\n                return True\n            elif matrix[k][0] < target:\n                i = k + 1\n            else:\n                j = k - 1\n        i = 0\n        j = len(matrix[0]) - 1\n        while i <= j:\n            k = (i + j) // 2\n            if matrix[0][k] == target:\n                return True\n            elif matrix[0][k] < target:\n                i = k + 1\n            else:\n                j = k - 1\n        return False"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        red, white, blue = 0, 0, 0\n        for i in nums:\n            if i == 0:\n                red += 1\n            elif i == 1:\n                white += 1\n            elif i == 2:\n                blue += 1\n        for i in range(red):\n            nums[i] = 0\n        for i in range(red, red+white):\n            nums[i] = 1\n        for i in range(red+white, red+white+blue):\n            nums[i] = 2\n        \n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        n=len(nums)\n        if n==0:\n            return nums\n        if n==1:\n            return nums\n        zero=0\n        two=n-1\n        one=0\n        while one<=two:\n            if nums[one]==0:\n                nums[one],nums[zero]=nums[zero],nums[one]\n                zero+=1\n                one+=1\n            elif nums[one]==1:\n                one+=1\n            else:\n                nums[one],nums[two]=nums[two],nums[one]\n                two-=1\n        return nums<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        ### SOLUTION 1 ###\n        # for i in range(len(nums)):\n        #     nums[i] = 0\n        #     if i == nums.count(0):\n        #         nums[i] = 1\n        #     if i == nums.count(1):\n        #         nums[i] = 2"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        red = 0\n        white = 0\n        blue = 0\n        for i in nums:\n            if i == 0:\n                red += 1\n            elif i == 1:\n                white += 1\n            else:\n                blue += 1"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # 3 pointers, left, right, sort\n        left, right = 0, len(nums)-1\n        # use left, right, and curr index\n        # to track the current color\n        # curr index points at the current color to swap\n        curr = 0\n        # loop while left is less than right\n        while left < right:\n            # if left == right, then all the colors are sorted, return\n            if left == right:\n                return\n            # if curr index == 0, curr color = red\n            elif curr == 0:\n                # swap curr index with left index\n                nums[curr], nums[left] = nums[left], nums[curr]\n                left += 1\n                # update curr index\n                curr += 1\n            # if curr index == 1, curr color = white\n            elif curr == 1:\n                # loop while left is less than or equal to right\n                # swap nums[left] and nums[right] and increment left and decrement right\n                while left <= right:\n                    # swap nums[left] and nums[right]\n                    nums[left], nums[right] = nums[right], nums[left]\n                    # decrement left and increment right\n                    left +="
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if len(nums) == 0:\n            return nums\n        low = 0\n        high = len(nums) - 1\n        mid = 0\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n        return nums"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        #   1.\u628a0\u53d8\u6210red\uff0c\u5c06\u6240\u67091\u53d8\u6210white\uff0c\u5c062\u53d8\u6210blue\n        #   2.\u628ared\u4e0ewhite\u4e92\u6362\n        #   3.\u628a\u975ered\u7684\u5143\u7d20\u5206\u522b\u63d2\u5165red\u548cwhite\uff0c\u5f97\u5230\u7ed3\u679c\n        red, white, blue = 0, 0, len(nums)\n        while white < blue:\n            if nums[white] < 1:\n                nums[red], nums[white] = nums[white], nums[red]\n                white += 1\n                red += 1\n            elif nums[white] > 1:\n                blue -= 1\n                nums[white], nums[blue] = nums[blue], nums[white]\n            else:\n                white += 1\n        # [red, white, blue]\n        red, white = 0, red\n        while white < blue:\n            if nums[white] < 1:\n                nums[red], nums[white] = nums[white], nums[red]\n                white += 1\n                red += 1\n            elif nums[white] > 1"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Solution:\n        # Time complexity: O(n)\n        # Space complexity: O(1)"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "prompt": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n        We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n        You must solve this problem without using the library's sort function.\n        Example 1:\n        Input: nums = [2,0,2,1,1,0]\n        Output: [0,0,1,1,2,2]\n        Example 2:\n        Input: nums = [2,0,1]\n        Output: [0,1,2]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # count the number of 0, 1, and 2\n        num_0 = nums.count(0)\n        num_1 = nums.count(1)\n        num_2 = nums.count(2)\n        \n        # iterate the list and assign\n        j = 0\n        for i in range(0, num_0):\n            nums[j] = 0\n            j += 1\n        for i in range(0, num_1):\n            nums[j] = 1\n            j += 1\n        for i in range(0, num_2):\n            nums[j] = 2\n            j += 1\n        \n        # return\n        return nums"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if len(t) == 0:\n            return \"\"\n        if len(t) > len(s):\n            return \"\"\n        t_freq = collections.defaultdict(int)\n        s_freq = collections.defaultdict(int)\n        for ch in t:\n            t_freq[ch] += 1\n        l, r, valid_count, res = 0, 0, 0, float(\"inf\")\n        while r < len(s):\n            t_ch = s[r]\n            s_freq[t_ch] += 1\n            r += 1\n            if t_ch in t_freq and s_freq[t_ch] == t_freq[t_ch]:\n                valid_count += 1\n            while l <= r and valid_count == len(t_freq):\n                if r - l < res:\n                    res = r - l\n                    res_s = s[l:r]\n                t_ch = s[l]\n                s_freq[t_ch] -= 1\n                if t_ch in t_freq and s_freq[t_ch] < t_freq[t_ch]:\n                    valid_count -= 1\n                l += 1\n        return res_s if res < float(\"inf\") else \"\""
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        # Attempt 2: 32 ms\n        \"\"\"\n        if not t or not s:\n            return \"\""
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        window = {}\n        for char in t:\n            window[char] = window.get(char, 0) + 1\n        t_len = len(t)\n        current_len = t_len\n        # a is the char that we want to fill in the window\n        a = '$'\n        # the index of a in window\n        start = 0\n        # the index of end\n        end = 0\n        while end < len(s):\n            # when s[start] is equal to a, we fill in the window\n            if s[start] == a:\n                # when we are not sure whether the window is full, we do nothing,\n                # since it's only for initialization\n                if window.get(s[start], 0) > 0:\n                    window[s[start]] -= 1\n                    current_len -= 1\n            # if the window is full, we start to move it\n            if current_len == t_len:\n                # if the start index is not moving forward, we need to move it\n                if start > end:\n                    if window.get(s[start], 0) > 0:\n                        window[s[start]] -= 1\n                        current_len -= 1\n                    start += 1\n                    continue\n                # if the start index is moving forward, we check if it's a candidate"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        if not t or not s: return \"\""
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        # Approach 1: Brute Force\n        # Time complexity: O(n^2)\n        # Space complexity: O(n^2)\n        # O(n) + O(n) = O(n)\n        if not s or not t or len(t) > len(s):\n            return ''\n        if len(s) == len(t):\n            return s\n        min_window = ''.join(['0'] * len(s))\n        for start in range(len(s) - len(t) + 1):\n            for end in range(start, len(s)):\n                window = s[start:end+1]\n                if all(x in window for x in t):\n                    if len(window) < len(min_window):\n                        min_window = window\n        return min_window"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        if len(s) < len(t) or not t:\n            return \"\"\n        cnt, ans, counter, left, right = 0, \"\", Counter(t), 0, 0\n        while right < len(s):\n            if s[right] in counter:\n                counter[s[right]] -= 1\n                if counter[s[right]] >= 0:\n                    cnt += 1\n            right += 1\n            while cnt == len(t):\n                if ans == \"\" or len(ans) > right - left:\n                    ans = s[left:right]\n                if s[left] in counter:\n                    counter[s[left]] += 1\n                    if counter[s[left]] > 0:\n                        cnt -= 1\n                left += 1\n        return ans"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        char_map, need_map = {}, {}\n        for char in t:\n            if char not in char_map:\n                char_map[char] = 0\n            char_map[char] += 1\n            if char not in need_map:\n                need_map[char] = 0\n            need_map[char] += 1\n        start = 0\n        end = len(s)\n        min_len = len(s) + 1\n        min_str = \"\"\n        left = 0\n        for right in range(len(s)):\n            if s[right] in need_map:\n                char_map[s[right]] -= 1\n                need_map[s[right]] -= 1\n                while left < right and need_map[s[right]] < 0:\n                    if s[left] in need_map:\n                        need_map[s[left]] += 1\n                    char_map[s[left]] += 1\n                    left += 1\n                if min_len > right - left + 1:\n                    min_len = right - left + 1\n                    min_str = s[left:right+1]\n        return min_str\n    \n    \n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        if not s or not t:\n            return ''\n        if set(t) <= set(s):\n            return s\n        for i in range(len(s)-len(t)+1):\n            if set(t) <= set(s[i:i+len(t)]):\n                return s[i:i+len(t)]\n        return ''"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        import collections\n        m, n = len(s), len(t)\n        if m < n: return \"\"\n        t_cnt = collections.Counter(t)\n        start, end = 0, 0\n        t_found = 0\n        res = (0, m+1)\n        while end < m:\n            # s[end] not in t_cnt, just go forward\n            if s[end] not in t_cnt:\n                end += 1\n            # s[end] in t_cnt, now try to find all chars in t\n            else:\n                # in case where s[start] not in t_cnt, we keep s[start]\n                if s[start] not in t_cnt:\n                    t_cnt[s[start]] -= 1\n                    start += 1\n                # if all chars in t found, shrink window\n                else:\n                    while t_cnt[s[end]] <= 0:\n                        if s[start] not in t_cnt:\n                            t_cnt[s[start]] -= 1\n                            start += 1\n                        else:\n                            t_cnt[s[start]] -= 1\n                            start += 1\n                            end += 1\n                    # shrink window by the chars not in t\n                    while t_cnt[s["
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "prompt": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        \"\"\"\n        Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n        The testcases will be generated such that the answer is unique.\n        Example 1:\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n        Explanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n        Example 2:\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n        Explanation: The entire string s is the minimum window.\n        Example 3:\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n        Explanation: Both 'a's from t must be included in the window.\n        Since the largest window of s only has one 'a', return empty string.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # mapping the letters in the t to a hashmap\n        d = {}\n        for i in t:\n            if i in d.keys():\n                d[i] += 1\n            else:\n                d[i] = 1"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if n == 0:\n            return []\n        elif n < k:\n            return []\n        elif k == 1:\n            return [[i] for i in range(1, n+1)]\n        else:\n            r = []\n            for i in range(1, n+1):\n                if i == 1:\n                    r.append([i])\n                else:\n                    r = self.combine_helper(i, k, r)\n        return r"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        res = []"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        if k == 0 or k == n:\n            return [[]]\n        # we use binary search to find the n^k root of n\n        nums = list(range(1, n + 1))\n        self.root = n ** k\n        self.t = [None for _ in range(k)]\n        # self.t = self.root\n        self.t[0] = n\n        self.t[1] = self.root // n\n        for i in range(2, k):\n            # divide the last number\n            self.t[i] = self.root // self.t[i - 1]"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        result = []\n        def backtrack(result, nums, start, k):\n            if k == 0:\n                result.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[i], nums[start] = nums[start], nums[i]\n                backtrack(result, nums, i+1, k-1)\n                nums[i], nums[start] = nums[start], nums[i]"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        return self.combine_recursive(1, n, k)"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        \n        def dfs(n, k, start, current, res):\n            if len(current) == k:\n                res.append(current[:])\n                return\n            \n            for i in range(start, n+1):\n                current.append(i)\n                dfs(n, k, i+1, current, res)\n                current.pop()\n                \n        res = []\n        dfs(n, k, 1, [], res)\n        return res\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        # https://leetcode.com/problems/combinations/discuss/307950/Java-solution-with-explanation\n        # n\u4e3a1\u7684\u65f6\u5019\uff0c\u53ea\u6709\u4e00\u79cd\u60c5\u51b5\n        # n\u4e3a2\u7684\u65f6\u5019\uff0c\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff1a[1,2],[2,1]\n        # n\u4e3a3\u7684\u65f6\u5019\uff0c\u53ea\u6709\u4e09\u79cd\u60c5\u51b5\uff1a[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]\n        # n\u4e3a4\u7684\u65f6\u5019\uff0c\u53ea\u6709\u56db\u79cd\u60c5\u51b5\uff1a[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,4,1],[2,4,1,3],[2,4,3,1],[3"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        #DFS\n        #  time complexity: O(C^n)\n        # space complexity: O(n)\n        self.res = []\n        self.dfs(list(range(1, n+1)), 0, k, [])\n        return self.res"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        # Backtracking\n        # if n==0 or k==0:\n        #     return []\n        # return [i for i in range(1,n+1) for j in self.combine(n-i,k-1)]\n        \n        # Runtime: O(nk)\n        # Space: O(nk)\n        \n        # Recursion + DFS\n        res = []\n        self.dfs(n,k,[],res)\n        return res\n    \n    def dfs(self,n,k,path,res):\n        # Base case\n        if len(path) == k:\n            res.append(path)\n            return\n        # Recursion\n        for i in range(n):\n            if len(path) == 0 or path[-1] <= i:\n                self.dfs(n,k,path + [i+1],res)\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "prompt": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        \"\"\"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n        You may return the answer in any order.\n        Example 1:\n        Input: n = 4, k = 2\n        Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n        Explanation: There are 4 choose 2 = 6 total combinations.\n        Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n        Example 2:\n        Input: n = 1, k = 1\n        Output: [[1]]\n        Explanation: There is 1 choose 1 = 1 total combination.\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        if k == 0:\n            return [[]]\n        if n == 0:\n            return [[]]\n        return self.helper(1, n, k)"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        ans = [[]]\n        for num in nums:\n            ans += [subset + [num] for subset in ans]\n        return ans\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        self.result = []\n        self.dfs(nums, 0, [])\n        return self.result"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        self.result = []\n        self.backtrack(nums, 0, [])\n        return self.result"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        # backtracking, use set to avoid duplicates\n        res = []\n        self.dfs(sorted(nums), 0, [], res)\n        return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        res = []\n        def backtrack(start, path):\n            if start == len(nums):\n                res.append(path[:])\n            else:\n                for i in range(start, len(nums)):\n                    path.append(nums[i])\n                    backtrack(i+1, path)\n                    path.pop()\n        backtrack(0, [])\n        return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        # Time: O(2^N)\n        # Space: O(2^N)\n        result = [[]]\n        for num in nums:\n            result += [curr + [num] for curr in result]\n        return result\n<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        if not nums:\n            return [[]]\n        else:\n            res = []\n            self.dfs(nums, 0, [], res)\n            return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        res = [[]]\n        for num in nums:\n            res += [i + [num] for i in res]\n        return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        res = []\n        if not nums:\n            return res\n        self.helper(nums, 0, [], res)\n        return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "prompt": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"\n        Given an integer array nums of unique elements, return all possible subsets (the power set).\n        The solution set must not contain duplicate subsets. Return the solution in any order.\n        Example 1:\n        Input: nums = [1,2,3]\n        Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n        Example 2:\n        Input: nums = [0]\n        Output: [[],[0]]\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        # res = []\n        # for n in nums:\n        #     tmp = self.recursive(nums, [], [n])\n        #     res += tmp\n        # return res\n        # # return self.recursive(nums, [], [])\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        # res = []\n        # for n in nums:\n        #     res += self.recursive(nums, n, [])\n        # return res\n        # # return self.recursive(nums, [], [])\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        self.recursive(nums, 0, [], res)\n        return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 1,
        "answer": "        if not board or not board[0]:\n            return False"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 2,
        "answer": "        \n        if len(word)==0: return True\n        \n        def dfs(board, r, c, index, visited):\n            if index==len(word): return True\n            \n            if r<0 or c<0 or r>=len(board) or c>=len(board[0]) or visited[r][c]==True or word[index]!=board[r][c]: return False\n            \n            visited[r][c] = True\n            \n            if dfs(board, r+1, c, index+1, visited) or dfs(board, r, c+1, index+1, visited) or dfs(board, r-1, c, index+1, visited) or dfs(board, r, c-1, index+1, visited): return True\n            \n            visited[r][c] = False\n            return False\n        \n        m, n = len(board), len(board[0])\n        \n        visited = [[False for _ in range(n)] for _ in range(m)]\n        \n        for r in range(m):\n            for c in range(n):\n                if dfs(board, r, c, 0, visited): return True\n        \n        return False\n    \n    def exist(self, board,"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 3,
        "answer": "        m = len(board)\n        n = len(board[0])\n        visited = [[False]*n for _ in range(m)]\n        def isValid(row, col):\n            if row >= 0 and row < m and col >= 0 and col < n:\n                return True\n            return False\n        \n        def dfs(row, col, index):\n            if index == len(word):\n                return True\n            \n            if not isValid(row, col) or visited[row][col] or board[row][col]!= word[index]:\n                return False\n            \n            visited[row][col] = True\n            found = (dfs(row+1, col, index+1) or dfs(row-1, col, index+1) or dfs(row, col+1, index+1) or dfs(row, col-1, index+1))\n            visited[row][col] = False\n            return found\n        \n        for row in range(m):\n            for col in range(n):\n                if dfs(row, col, 0):\n                    return True\n        return False\n    \n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n board and a"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 4,
        "answer": "        m, n = len(board), len(board[0])\n        def dfs(i, j, k):\n            if not 0 <= i < m or not 0 <= j < n or board[i][j]!= word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            tmp, board[i][j] = board[i][j], '/'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = tmp\n            return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 5,
        "answer": "        def dfs(i, j, k):\n            if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j]!= word[k]:\n                return False\n            if k == len(word) - 1:\n                return True\n            board[i][j] = ''  # avoid visit the same cell\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 6,
        "answer": "        self.board = board\n        self.word = word\n        self.m = len(board)\n        self.n = len(board[0])\n        self.row = []\n        for i in range(self.m):\n            self.row.append((i,j) for j in range(self.n))\n        self.col = []\n        for j in range(self.n):\n            self.col.append((i,j) for i in range(self.m))\n        self.diag = []\n        for i in range(self.m):\n            for j in range(self.n):\n                self.diag.append((i,j))\n        self.anti_diag = []\n        for i in range(self.m):\n            for j in range(self.n):\n                self.anti_diag.append((i,self.n-1-j))\n        return self.dfs(0,0)"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 7,
        "answer": "        def dfs(x, y, word):\n            if len(word) == 0:\n                return True\n            if x < 0 or x >= m or y < 0 or y >= n:\n                return False\n            if board[x][y]!= word[0]:\n                return False\n            temp = board[x][y]\n            board[x][y] = \"#\"\n            res = dfs(x+1, y, word[1:]) or dfs(x-1, y, word[1:]) or dfs(x, y+1, word[1:]) or dfs(x, y-1, word[1:])\n            board[x][y] = temp\n            return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 8,
        "answer": "        # DFS\n        # Time: O(m^2 * n^2), space: O(m * n)\n        # m = len(board)\n        # n = len(board[0])\n        # valid = lambda i, j: 0 <= i < m and 0 <= j < n\n        # if m == 0 or n == 0:\n        #     return False\n        # for i in range(m):\n        #     for j in range(n):\n        #         if board[i][j] == word[0]:\n        #             for k in range(1, len(word)):\n        #                 if valid(i + k, j) and board[i + k][j] == word[k]:\n        #                     if not dfs(i, j, k, word):\n        #                         return False\n        #                 if valid(i, j + k) and board[i][j + k] == word[k]:\n        #                     if not dfs(i, j, k, word):\n        #                         return False\n        # return True"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 9,
        "answer": "        self.board = board\n        self.m = len(board)\n        self.n = len(board[0])\n        self.visited = set()\n        self.directions = [[-1,0],[1,0],[0,1],[0,-1]]\n        self.word = word\n        for i in range(self.m):\n            for j in range(self.n):\n                if self.dfs(i,j,0):\n                    return True\n        return False"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "prompt": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        \"\"\"\n        Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n        The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n        Example 1:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n        Output: true\n        Example 2:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n        Output: true\n        Example 3:\n        Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n        Output: false\n        \"\"\"\n",
        "checkpoint": "16B",
        "pass": 10,
        "answer": "        self.visited = []\n        self.height = len(board)\n        self.width = len(board[0])\n        self.board = board\n        self.word = word\n        for row in range(self.height):\n            for col in range(self.width):\n                if self.backtrack(row, col):\n                    return True\n        return False"
    }
]