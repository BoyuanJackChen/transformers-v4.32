[
    {
        "library_id": 0,
        "source_id": 0,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have a set of data and I want to compare which line describes it best (polynomials of different orders, exponential or logarithmic).\nI use Python and Numpy and for polynomial fitting there is a function polyfit(). \nHow do I fit y = Alogx + B using polyfit()? The result should be an np.array of [A, B]\nA:\n<code>\nimport numpy as np\nimport scipy\nx = np.array([1, 7, 20, 50, 79])\ny = np.array([10, 19, 30, 35, 51])\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def polyfit(x, y, degree):\n    return np.polyfit(x, y, degree)\n</code>"
    },
    {
        "library_id": 1,
        "source_id": 0,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have a set of data and I want to compare which line describes it best (polynomials of different orders, exponential or logarithmic).\nI use Python and Numpy and for polynomial fitting there is a function polyfit(). \nHow do I fit y = A + Blogx using polyfit()? The result should be an np.array of [A, B]\nA:\n<code>\nimport numpy as np\nimport scipy\nx = np.array([1, 7, 20, 50, 79])\ny = np.array([10, 19, 30, 35, 51])\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def polyfit(x, y, degree):\n    return np.polyfit(x, y, degree)\n</code>"
    },
    {
        "library_id": 2,
        "source_id": 0,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have a set of data and I want to compare which line describes it best (polynomials of different orders, exponential or logarithmic).\nI use Python and Numpy and for polynomial fitting there is a function polyfit(). But I found no such functions for exponential and logarithmic fitting.\nHow do I fit y = A*exp(Bx) + C? The result should be an np.array of [A, B, C]. I know that polyfit performs bad for this function, so I would like to use curve_fit to solve the problem, and it should start from initial guess p0.\nA:\n<code>\nimport numpy as np\nimport scipy.optimize\ny = np.array([1, 7, 20, 50, 79])\nx = np.array([10, 19, 30, 35, 51])\np0 = (4, 0.1, 1)\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def func(x, a, b, c):\n    return a * np.exp(b * x) + c"
    },
    {
        "library_id": 3,
        "source_id": 3,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI can't figure out how to do a Two-sample KS test in Scipy.\nAfter reading the documentation scipy kstest\nI can see how to test where a distribution is identical to standard normal distribution\nfrom scipy.stats import kstest\nimport numpy as np\nx = np.random.normal(0,1,1000)\ntest_stat = kstest(x, 'norm')\n#>>> test_stat\n#(0.021080234718821145, 0.76584491300591395)\nWhich means that at p-value of 0.76 we can not reject the null hypothesis that the two distributions are identical.\nHowever, I want to compare two distributions and see if I can reject the null hypothesis that they are identical, something like:\nfrom scipy.stats import kstest\nimport numpy as np\nx = np.random.normal(0,1,1000)\nz = np.random.normal(1.1,0.9, 1000)\nand test whether x and z are identical\nI tried the naive:\ntest_stat = kstest(x, z)\nand got the following error:\nTypeError: 'numpy.ndarray' object is not callable\nIs there a way to do a two-sample KS test in Python? If so, how should I do it?\nThank You in Advance\nA:\n<code>\nfrom scipy import stats\nimport numpy as np\nnp.random.seed(42)\nx = np.random.normal(0, 1, 1000)\ny = np.random.normal(0, 1, 1000)\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(statistic, p_value)\n</code>\n\n\ndef",
        "answer": "def two_sample_ks_test(x, y):\n    \"\"\"\n    Compute the Kolmogorov-Smirnov statistic on 2 samples."
    },
    {
        "library_id": 4,
        "source_id": 3,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI can't figure out how to do a Two-sample KS test in Scipy.\nAfter reading the documentation scipy kstest\nI can see how to test where a distribution is identical to standard normal distribution\nfrom scipy.stats import kstest\nimport numpy as np\nx = np.random.normal(0,1,1000)\ntest_stat = kstest(x, 'norm')\n#>>> test_stat\n#(0.021080234718821145, 0.76584491300591395)\nWhich means that at p-value of 0.76 we can not reject the null hypothesis that the two distributions are identical.\nHowever, I want to compare two distributions and see if I can reject the null hypothesis that they are identical, something like:\nfrom scipy.stats import kstest\nimport numpy as np\nx = np.random.normal(0,1,1000)\nz = np.random.normal(1.1,0.9, 1000)\nand test whether x and z are identical\nI tried the naive:\ntest_stat = kstest(x, z)\nand got the following error:\nTypeError: 'numpy.ndarray' object is not callable\nIs there a way to do a two-sample KS test in Python, then test whether I can reject the null hypothesis that the two distributions are identical(result=True means able to reject, and the vice versa) based on alpha? If so, how should I do it?\nThank You in Advance\nA:\n<code>\nfrom scipy import stats\nimport numpy as np\nnp.random.seed(42)\nx = np.random.normal(0, 1, 1000)\ny = np.random.normal(0, 1, 1000)\nalpha = 0.01\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def two_sample_ks_test(x, y, alpha=0.01):\n    \"\"\"\n    Test whether two samples are drawn from the same distribution.\n    :param x:\n    :param y:\n    :param alpha:\n    :return:\n    \"\"\"\n    test_stat = stats.ks_2samp(x, y)\n    result = test_stat.pvalue < alpha\n    return result\n</code>"
    },
    {
        "library_id": 5,
        "source_id": 5,
        "prompt": "Complete the Python function given the prompt below:Problem:\nAccording to the SciPy documentation it is possible to minimize functions with multiple variables, yet it doesn't tell how to optimize on such functions.\nfrom scipy.optimize import minimize\nfrom math import *\ndef f(c):\n  return sqrt((sin(pi/2) + sin(0) + sin(c) - 2)**2 + (cos(pi/2) + cos(0) + cos(c) - 1)**2)\nprint minimize(f, 3.14/2 + 3.14/7)\nThe above code does try to minimize the function f, but for my task I need to minimize with respect to three variables, starting from `initial_guess`.\nSimply introducing a second argument and adjusting minimize accordingly yields an error (TypeError: f() takes exactly 2 arguments (1 given)).\nHow does minimize work when minimizing with multiple variables.\nI need to minimize f(a,b,c)=((a+b-c)-2)**2 + ((3*a-b-c))**2 + sin(b) + cos(b) + 4.\nResult should be a list=[a,b,c], the parameters of minimized function.\nA:\n<code>\nimport scipy.optimize as optimize\nfrom math import *\ninitial_guess = [-1, 0, -3]\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def f(a,b,c):\n  return ((a+b-c)-2)**2 + ((3*a-b-c))**2 + sin(b) + cos(b) + 4\nprint(optimize.minimize(f, initial_guess))\nResult should be a list=[a,b,c], the parameters of minimized function.\nA:\n<code>\nimport scipy.optimize as optimize\nfrom math import *\ninitial_guess = [-1, 0, -3]\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>"
    },
    {
        "library_id": 6,
        "source_id": 6,
        "prompt": "Complete the Python function given the prompt below:Problem:\nHow does one convert a list of Z-scores from the Z-distribution (standard normal distribution, Gaussian distribution) to left-tailed p-values? I have yet to find the magical function in Scipy's stats module to do this, but one must be there.\nA:\n<code>\nimport numpy as np\nimport scipy.stats\nz_scores = np.array([-3, -2, 0, 2, 2.5])\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(p_values)\n</code>\n\n\ndef",
        "answer": "def p_values(z_scores):\n    \"\"\"\n    Convert z-scores to p-values.\n    \"\"\"\n    p_values = []\n    for z in z_scores:\n        p_values.append(scipy.stats.norm.sf(z))\n    return p_values\n</code>\n\"\"\""
    },
    {
        "library_id": 7,
        "source_id": 6,
        "prompt": "Complete the Python function given the prompt below:Problem:\nHow does one convert a list of Z-scores from the Z-distribution (standard normal distribution, Gaussian distribution) to left-tailed p-values? Original data is sampled from X ~ N(mu, sigma). I have yet to find the magical function in Scipy's stats module to do this, but one must be there.\nA:\n<code>\nimport scipy.stats\nimport numpy as np\nz_scores = [-3, -2, 0, 2, 2.5]\nmu = 3\nsigma = 4\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(p_values)\n</code>\n\n\ndef",
        "answer": "def z_to_p(z_scores, mu=0, sigma=1):\n    \"\"\"\n    Convert a list of z-scores to p-values.\n    \"\"\"\n    return [2 * scipy.stats.norm.cdf(-z) for z in z_scores]\n</code>\n\"\"\""
    },
    {
        "library_id": 8,
        "source_id": 6,
        "prompt": "Complete the Python function given the prompt below:Problem:\nHow does one convert a left-tailed p-value to a z_score from the Z-distribution (standard normal distribution, Gaussian distribution)? I have yet to find the magical function in Scipy's stats module to do this, but one must be there.\nA:\n<code>\nimport numpy as np\nimport scipy.stats\np_values = [0.1, 0.225, 0.5, 0.75, 0.925, 0.95]\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(z_scores)\n</code>\n\n\ndef",
        "answer": "def p_to_z(p_value):\n    return scipy.stats.norm.ppf(p_value)\n</code>\nC:\n<code>\nz_scores = [p_to_z(p_value) for p_value in p_values]\n</code>\nD:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nE:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nF:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nG:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nH:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nI:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nJ:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nK:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nL:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nM:\n<code>\nz_scores = [scipy.stats.norm.ppf(p_value) for p_value in p_values]\n</code>\nN:\n<code>\nz_sc"
    },
    {
        "library_id": 9,
        "source_id": 9,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have been trying to get the result of a lognormal distribution using Scipy. I already have the Mu and Sigma, so I don't need to do any other prep work. If I need to be more specific (and I am trying to be with my limited knowledge of stats), I would say that I am looking for the cumulative function (cdf under Scipy). The problem is that I can't figure out how to do this with just the mean and standard deviation on a scale of 0-1 (ie the answer returned should be something from 0-1). I'm also not sure which method from dist, I should be using to get the answer. I've tried reading the documentation and looking through SO, but the relevant questions (like this and this) didn't seem to provide the answers I was looking for.\nHere is a code sample of what I am working with. Thanks. Here mu and stddev stands for mu and sigma in probability density function of lognorm.\nfrom scipy.stats import lognorm\nstddev = 0.859455801705594\nmu = 0.418749176686875\ntotal = 37\ndist = lognorm.cdf(total,mu,stddev)\nUPDATE:\nSo after a bit of work and a little research, I got a little further. But I still am getting the wrong answer. The new code is below. According to R and Excel, the result should be.7434, but that's clearly not what is happening. Is there a logic flaw I am missing?\nstddev = 2.0785\nmu = 1.744\nx = 25\ndist = lognorm([mu],loc=stddev)\ndist.cdf(x)  # yields=0.96374596, expected=0.7434\nA:\n<code>\nimport numpy as np\nfrom scipy import stats\nstddev = 2.0785\nmu = 1.744\nx = 25\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def lognorm_cdf(x, mu, sigma):\n    return stats.lognorm.cdf(x, s=sigma, scale=np.exp(mu))\n</code>\nC:\n<code>\nimport numpy as np\nfrom scipy import stats\nstddev = 2.0785\nmu = 1.744\nx = 25\n</code>\nD:\n<code>\nprint(lognorm_cdf(x, mu, stddev))\n</code>\nE:\n<code>\n0.7434\n</code>\nF:\n<code>\n0.7434\n</code>\nG:\n<code>\n0.7434\n</code>\nH:\n<code>\n0.7434\n</code>\nI:\n<code>\n0.7434\n</code>\nJ:\n<code>\n0.7434\n</code>\nK:\n<code>\n0.7434\n</code>\nL:\n<code>\n0.7434\n</code>\nM:\n<code>\n0.7434\n</code>\nN:\n<code>\n0.7434\n</code>\nO:\n<code>\n0.7434\n</code>\nP:\n<code>\n0.7434\n</code>\nQ:\n<code>\n0.7434\n</code>\nR:\n<code>\n0.7434\n</code>\nS:\n<code>\n0.7434\n</code>\nT:\n<code>\n0.7434\n</code>\nU:\n<code>\n0.7434\n</code>\nV:\n<code>\n0.7434\n</code>\nW:\n<code>\n0.7434\n</code>\nX:\n<code>\n0.7434\n</code>\nY:\n<code>\n0.7434\n</code>\nZ:\n<code>\n0.7434\n</code>\nAA:\n<code>\n0.7434\n</code>\nAB:\n<code>\n0.7434\n</"
    },
    {
        "library_id": 10,
        "source_id": 9,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have been trying to get the arithmetic result of a lognormal distribution using Scipy. I already have the Mu and Sigma, so I don't need to do any other prep work. If I need to be more specific (and I am trying to be with my limited knowledge of stats), I would say that I am looking for the expected value and median of the distribution. The problem is that I can't figure out how to do this with just the mean and standard deviation. I'm also not sure which method from dist, I should be using to get the answer. I've tried reading the documentation and looking through SO, but the relevant questions (like this and this) didn't seem to provide the answers I was looking for.\nHere is a code sample of what I am working with. Thanks. Here mu and stddev stands for mu and sigma in probability density function of lognorm.\nfrom scipy.stats import lognorm\nstddev = 0.859455801705594\nmu = 0.418749176686875\ntotal = 37\ndist = lognorm(total,mu,stddev)\nWhat should I do next?\nA:\n<code>\nimport numpy as np\nfrom scipy import stats\nstddev = 2.0785\nmu = 1.744\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(expected_value, median)\n</code>\n\n\ndef",
        "answer": "def lognorm_dist(total,mu,stddev):\n    dist = lognorm(total,mu,stddev)\n    expected_value = dist.mean()\n    median = dist.median()\n    return expected_value, median"
    },
    {
        "library_id": 11,
        "source_id": 11,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have this example of matrix by matrix multiplication using numpy arrays:\nimport numpy as np\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nc = np.array([0,1,2])\nm * c\narray([[ 0,  2,  6],\n       [ 0,  5, 12],\n       [ 0,  8, 18]])\nHow can i do the same thing if m is scipy sparse CSR matrix? The result should be csr_matrix as well.\nThis gives dimension mismatch:\nsp.sparse.csr_matrix(m)*sp.sparse.csr_matrix(c)\nA:\n<code>\nfrom scipy import sparse\nimport numpy as np\nsa = sparse.csr_matrix(np.array([[1,2,3],[4,5,6],[7,8,9]]))\nsb = sparse.csr_matrix(np.array([0,1,2]))\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def multiply_matrix(m, c):\n    return m*c\n</code>"
    },
    {
        "library_id": 12,
        "source_id": 11,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have this example of matrix by matrix multiplication using numpy arrays:\nimport numpy as np\nm = np.array([[1,2,3],[4,5,6],[7,8,9]])\nc = np.array([0,1,2])\nm * c\narray([[ 0,  2,  6],\n       [ 0,  5, 12],\n       [ 0,  8, 18]])\nHow can i do the same thing if m is scipy sparse CSR matrix? The result should be csr_matrix as well.\nThis gives dimension mismatch:\nsp.sparse.csr_matrix(m)*sp.sparse.csr_matrix(c)\nA:\n<code>\nfrom scipy import sparse\nimport numpy as np\nexample_sA = sparse.csr_matrix(np.array([[1,2,3],[4,5,6],[7,8,9]]))\nexample_sB = sparse.csr_matrix(np.array([0,1,2]))\ndef f(sA = example_sA, sB = example_sB):\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\n    return result\n</code>\n\n\ndef",
        "answer": "def f(sA = example_sA, sB = example_sB):\n    return result\n</code>"
    },
    {
        "library_id": 13,
        "source_id": 13,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have some data that comes in the form (x, y, z, V) where x,y,z are distances, and V is the moisture. I read a lot on StackOverflow about interpolation by python like this and this valuable posts, but all of them were about regular grids of x, y, z. i.e. every value of x contributes equally with every point of y, and every point of z. On the other hand, my points came from 3D finite element grid (as below), where the grid is not regular. \nThe two mentioned posts 1 and 2, defined each of x, y, z as a separate numpy array then they used something like cartcoord = zip(x, y) then scipy.interpolate.LinearNDInterpolator(cartcoord, z) (in a 3D example). I can not do the same as my 3D grid is not regular, thus not each point has a contribution to other points, so if when I repeated these approaches I found many null values, and I got many errors.\nHere are 10 sample points in the form of [x, y, z, V]\ndata = [[27.827, 18.530, -30.417, 0.205], [24.002, 17.759, -24.782, 0.197], \n[22.145, 13.687, -33.282, 0.204], [17.627, 18.224, -25.197, 0.197], \n[29.018, 18.841, -38.761, 0.212], [24.834, 20.538, -33.012, 0.208], \n[26.232, 22.327, -27.735, 0.204], [23.017, 23.037, -29.230, 0.205], \n[28.761, 21.565, -31.586, 0.211], [26.263, 23.686, -32.766, 0.215]]\nI want to get the interpolated value V of the point (25, 20, -30).\nHow can I get it?\nA:\n<code>\nimport numpy as np\nimport scipy.interpolate\npoints = np.array([\n        [ 27.827,  18.53, -30.417], [ 24.002,  17.759, -24.782],\n        [ 22.145,  13.687, -33.282], [ 17.627,  18.224, -25.197],\n        [ 29.018,  18.841, -38.761], [ 24.834,  20.538, -33.012],\n        [ 26.232,  22.327, -27.735], [ 23.017,  23.037, -29.23 ],\n        [ 28.761,  21.565, -31.586], [ 26.263,  23.686, -32.766]])\nV = np.array([0.205,  0.197,  0.204,  0.197,  0.212,\n                   0.208,  0.204,  0.205, 0.211,  0.215])\nrequest = np.array([[25, 20, -30]])\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def interpolate(points, request):\n    # Write your code here\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point\n    # return the value of the point"
    },
    {
        "library_id": 14,
        "source_id": 13,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have some data that comes in the form (x, y, z, V) where x,y,z are distances, and V is the moisture. I read a lot on StackOverflow about interpolation by python like this and this valuable posts, but all of them were about regular grids of x, y, z. i.e. every value of x contributes equally with every point of y, and every point of z. On the other hand, my points came from 3D finite element grid (as below), where the grid is not regular. \nThe two mentioned posts 1 and 2, defined each of x, y, z as a separate numpy array then they used something like cartcoord = zip(x, y) then scipy.interpolate.LinearNDInterpolator(cartcoord, z) (in a 3D example). I can not do the same as my 3D grid is not regular, thus not each point has a contribution to other points, so if when I repeated these approaches I found many null values, and I got many errors.\nHere are 10 sample points in the form of [x, y, z, V]\ndata = [[27.827, 18.530, -30.417, 0.205], [24.002, 17.759, -24.782, 0.197], \n[22.145, 13.687, -33.282, 0.204], [17.627, 18.224, -25.197, 0.197], \n[29.018, 18.841, -38.761, 0.212], [24.834, 20.538, -33.012, 0.208], \n[26.232, 22.327, -27.735, 0.204], [23.017, 23.037, -29.230, 0.205], \n[28.761, 21.565, -31.586, 0.211], [26.263, 23.686, -32.766, 0.215]]\nI want to get the interpolated value V of the point (25, 20, -30) and (27, 20, -32) as a list.\nHow can I get it?\nA:\n<code>\nimport numpy as np\nimport scipy.interpolate\npoints = np.array([\n        [ 27.827,  18.53, -30.417], [ 24.002,  17.759, -24.782],\n        [ 22.145,  13.687, -33.282], [ 17.627,  18.224, -25.197],\n        [ 29.018,  18.841, -38.761], [ 24.834,  20.538, -33.012],\n        [ 26.232,  22.327, -27.735], [ 23.017,  23.037, -29.23 ],\n        [ 28.761,  21.565, -31.586], [ 26.263,  23.686, -32.766]])\nV = np.array([0.205,  0.197,  0.204,  0.197,  0.212,\n                   0.208,  0.204,  0.205, 0.211,  0.215])\nrequest = np.array([[25, 20, -30], [27, 20, -32]])\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(result)\n</code>\n\n\ndef",
        "answer": "def interpolate(points, request):\n    cartcoord = zip(points[:,0], points[:,1])\n    return scipy.interpolate.LinearNDInterpolator(cartcoord, points[:,3])\n</code>"
    },
    {
        "library_id": 15,
        "source_id": 15,
        "prompt": "Complete the Python function given the prompt below:Problem:\nI have a numpy array for an image that I read in from a FITS file. I rotated it by N degrees using scipy.ndimage.interpolation.rotate. Then I want to figure out where some point (x,y) in the original non-rotated frame ends up in the rotated image -- i.e., what are the rotated frame coordinates (x',y')?\nThis should be a very simple rotation matrix problem but if I do the usual mathematical or programming based rotation equations, the new (x',y') do not end up where they originally were. I suspect this has something to do with needing a translation matrix as well because the scipy rotate function is based on the origin (0,0) rather than the actual center of the image array.\nCan someone please tell me how to get the rotated frame (x',y')? As an example, you could use\nfrom scipy import misc\nfrom scipy.ndimage import rotate\ndata_orig = misc.face()\ndata_rot = rotate(data_orig,66) # data array\nx0,y0 = 580,300 # left eye; (xrot,yrot) should point there\nA:\n<code>\nfrom scipy import misc\nfrom scipy.ndimage import rotate\nimport numpy as np\ndata_orig = misc.face()\nx0,y0 = 580,300 # left eye; (xrot,yrot) should point there\nangle = np.random.randint(1, 360)\n</code>\nBEGIN SOLUTION\n<code>\n[insert]\n</code>\nEND SOLUTION\n<code>\nprint(data_rot, (xrot, yrot))\n</code>\n\n\ndef",
        "answer": "def rotate_image(data, angle):\n    \"\"\"\n    Rotates an image by the given angle.\n    \"\"\"\n    # Get the dimensions of the image\n    (h, w) = data.shape[:2]\n    (cX, cY) = (w // 2, h // 2)\n    # Get the rotation matrix\n    M = cv2.getRotationMatrix2D((cX, cY), angle, 1.0)\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n    # Compute the new bounding dimensions of the image\n    nW = int((h * sin) + (w * cos))\n    nH = int((h * cos) + (w * sin))\n    # Adjust the rotation matrix to take into account translation\n    M[0, 2] += (nW / 2) - cX\n    M[1, 2] += (nH / 2) - cY\n    # Perform the actual rotation and return the image\n    return cv2.warpAffine(data, M, (nW, nH))"
    }
]