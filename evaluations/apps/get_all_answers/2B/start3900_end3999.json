[
   {
      "task_id": 3900,
      "prompt": "Complete the Python function given the prompt below:\nRecently a serious bug has been found in the FOS code. The head of the F company wants to find the culprit and punish him. For that, he set up an organizational meeting, the issue is: who's bugged the code? Each of the n coders on the meeting said: 'I know for sure that either x or y did it!'\nThe head of the company decided to choose two suspects and invite them to his office. Naturally, he should consider the coders' opinions. That's why the head wants to make such a choice that at least p of n coders agreed with it. A coder agrees with the choice of two suspects if at least one of the two people that he named at the meeting was chosen as a suspect. In how many ways can the head of F choose two suspects?\nNote that even if some coder was chosen as a suspect, he can agree with the head's choice if he named the other chosen coder at the meeting.\n-----Input-----\nThe first line contains integers n and p (3 \u2264 n \u2264 3\u00b710^5;\u00a00 \u2264 p \u2264 n) \u2014 the number of coders in the F company and the minimum number of agreed people.\nEach of the next n lines contains two integers x_{i}, y_{i} (1 \u2264 x_{i}, y_{i} \u2264 n) \u2014 the numbers of coders named by the i-th coder. It is guaranteed that x_{i} \u2260 i, \u00a0y_{i} \u2260 i, \u00a0x_{i} \u2260 y_{i}.\n-----Output-----\nPrint a single integer \u2013\u2013 the number of possible two-suspect sets. Note that the order of the suspects doesn't matter, that is, sets (1, 2) \u0438 (2, 1) are considered identical.\n-----Examples-----\nInput\n4 2\n2 3\n1 4\n1 4\n2 1\nOutput\n6\nInput\n8 6\n5 6\n5 7\n5 8\n6 2\n2 1\n7 3\n1 3\n1 4\nOutput\n1\n\ndef",
      "answer": "def solve(n, p, coders):\n    coders.sort()\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])\n    coders.sort(key=lambda x: x[1])\n    coders.sort(key=lambda x: x[0])",
      "difficulty": "competition",
      "split": "test"
   },
   {
      "task_id": 3901,
      "prompt": "Complete the Python function given the prompt below:\nYou have an array a with length n, you can perform operations. Each operation is like this: choose two adjacent elements from a, say x and y, and replace one of them with gcd(x, y), where gcd denotes the greatest common divisor.\nWhat is the minimum number of operations you need to make all of the elements equal to 1?\n-----Input-----\nThe first line of the input contains one integer n (1 \u2264 n \u2264 2000) \u2014 the number of elements in the array.\nThe second line contains n space separated integers a_1, a_2,..., a_{n} (1 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the elements of the array.\n-----Output-----\nPrint -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.\n-----Examples-----\nInput\n5\n2 2 3 4 6\nOutput\n5\nInput\n4\n2 4 6 8\nOutput\n-1\nInput\n3\n2 6 9\nOutput\n4\n-----Note-----\nIn the first sample you can turn all numbers to 1 using the following 5 moves:\n  [2, 2, 3, 4, 6].  [2, 1, 3, 4, 6]  [2, 1, 3, 1, 6]  [2, 1, 1, 1, 6]  [1, 1, 1, 1, 6]  [1, 1, 1, 1, 1] \nWe can prove that in this case it is not possible to make all numbers one using less than 5 moves.\n\ndef",
      "answer": "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\n",
      "difficulty": "competition",
      "split": "test"
   },
   {
      "task_id": 3902,
      "prompt": "Complete the Python function given the prompt below:\nFirst-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. \nFor example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the \"root\" of the word \u2014 some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction \u2014  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word \"suffix\" to describe a morpheme but not the few last characters of the string as you may used to). \nHere is one exercise that you have found in your task list. You are given the word s. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. \nTwo strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. \nLet's look at the example: the word abacabaca is given. This word can be obtained in the following ways: [Image], where the root of the word is overlined, and suffixes are marked by \"corners\". Thus, the set of possible suffixes for this word is {aca, ba, ca}. \n-----Input-----\nThe only line contains a string s (5 \u2264 |s| \u2264 10^4) consisting of lowercase English letters.\n-----Output-----\nOn the first line print integer k \u2014 a number of distinct possible suffixes. On the next k lines print suffixes. \nPrint suffixes in lexicographical (alphabetical) order. \n-----Examples-----\nInput\nabacabaca\nOutput\n3\naca\nba\nca\nInput\nabaca\nOutput\n0\n-----Note-----\nThe first test was analysed in the problem statement. \nIn the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix.\n\ndef",
      "answer": "def suffixes(s):\n    result = set()\n    for i in range(len(s)):\n        if len(s) == 1:\n            result.add(s)\n        else:\n            result.add(s[:i] + s[i+1:])\n    return result\n\n",
      "difficulty": "competition",
      "split": "test"
   },
   {
      "task_id": 3903,
      "prompt": "Complete the Python function given the prompt below:\nThe famous global economic crisis is approaching rapidly, so the states of Berman, Berance and Bertaly formed an alliance and allowed the residents of all member states to freely pass through the territory of any of them. In addition, it was decided that a road between the states should be built to guarantee so that one could any point of any country can be reached from any point of any other State.\nSince roads are always expensive, the governments of the states of the newly formed alliance asked you to help them assess the costs. To do this, you have been issued a map that can be represented as a rectangle table consisting of n rows and m columns. Any cell of the map either belongs to one of three states, or is an area where it is allowed to build a road, or is an area where the construction of the road is not allowed. A cell is called passable, if it belongs to one of the states, or the road was built in this cell. From any passable cells you can move up, down, right and left, if the cell that corresponds to the movement exists and is passable.\nYour task is to construct a road inside a minimum number of cells, so that it would be possible to get from any cell of any state to any cell of any other state using only passable cells.\nIt is guaranteed that initially it is possible to reach any cell of any state from any cell of this state, moving only along its cells. It is also guaranteed that for any state there is at least one cell that belongs to it.\n-----Input-----\nThe first line of the input contains the dimensions of the map n and m (1 \u2264 n, m \u2264 1000)\u00a0\u2014 the number of rows and columns respectively.\nEach of the next n lines contain m characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.\n-----Output-----\nPrint a single integer\u00a0\u2014 the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.\n-----Examples-----\nInput\n4 5\n11..2\n#..22\n#.323\n.#333\nOutput\n2\nInput\n1 5\n1#2#3\nOutput\n-1\n\ndef",
      "answer": "def find_min_cells(n, m, map):\n    # Write your code here\n    if n == 1 and m == 1:\n        return 0\n    if n == 1:\n        return m\n    if m == 1:\n        return n\n    if n == m:\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#':\n        return -1\n    if map[0][0] == '.':\n        return 1\n    if map[0][0] == '#",
      "difficulty": "competition",
      "split": "test"
   },
   {
      "task_id": 3904,
      "prompt": "Complete the Python function given the prompt below:\nA bracketed sequence is called correct (regular) if by inserting \"+\" and \"1\" you can get a well-formed mathematical expression from it. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are correct, while \")(\", \"(()\" and \"(()))(\" are not.\nThe teacher gave Dmitry's class a very strange task\u00a0\u2014 she asked every student to come up with a sequence of arbitrary length, consisting only of opening and closing brackets. After that all the students took turns naming the sequences they had invented. When Dima's turn came, he suddenly realized that all his classmates got the correct bracketed sequence, and whether he got the correct bracketed sequence, he did not know.\nDima suspects now that he simply missed the word \"correct\" in the task statement, so now he wants to save the situation by modifying his sequence slightly. More precisely, he can the arbitrary number of times (possibly zero) perform the reorder operation.\nThe reorder operation consists of choosing an arbitrary consecutive subsegment (substring) of the sequence and then reordering all the characters in it in an arbitrary way. Such operation takes $l$ nanoseconds, where $l$ is the length of the subsegment being reordered. It's easy to see that reorder operation doesn't change the number of opening and closing brackets. For example for \"))((\" he can choose the substring \")(\" and do reorder \")()(\" (this operation will take $2$ nanoseconds).\nSince Dima will soon have to answer, he wants to make his sequence correct as fast as possible. Help him to do this, or determine that it's impossible.\n-----Input-----\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^6$)\u00a0\u2014 the length of Dima's sequence.\nThe second line contains string of length $n$, consisting of characters \"(\" and \")\" only.\n-----Output-----\nPrint a single integer\u00a0\u2014 the minimum number of nanoseconds to make the sequence correct or \"-1\" if it is impossible to do so.\n-----Examples-----\nInput\n8\n))((())(\nOutput\n6\nInput\n3\n(()\nOutput\n-1\n-----Note-----\nIn the first example we can firstly reorder the segment from first to the fourth character, replacing it with \"()()\", the whole sequence will be \"()()())(\". And then reorder the segment from the seventh to eighth character, replacing it with \"()\". In the end the sequence will be \"()()()()\", while the total time spent is $4 + 2 = 6$ nanoseconds.\n\ndef",
      "answer": "def reorder(s):\n    if len(s) < 2:\n        return -1\n    if len(s) == 2:\n        if s[0] == ')' and s[1] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 3:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 4:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')':\n            return 0\n        else:\n            return -1\n    if len(s) == 5:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 6:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')':\n            return 0\n        else:\n            return -1\n    if len(s) == 7:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 8:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')':\n            return 0\n        else:\n            return -1\n    if len(s) == 9:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')' and s[8] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 10:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')' and s[8] == '(' and s[9] == ')':\n            return 0\n        else:\n            return -1\n    if len(s) == 11:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')' and s[8] == '(' and s[9] == ')' and s[10] == '(':\n            return 0\n        else:\n            return -1\n    if len(s) == 12:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')' and s[8] == '(' and s[9] == ')' and s[10] == '(' and s[11] == ')':\n            return 0\n        else:\n            return -1\n    if len(s) == 13:\n        if s[0] == ')' and s[1] == '(' and s[2] == '(' and s[3] == ')' and s[4] == '(' and s[5] == ')' and s[6] == '(' and s[7] == ')' and s[8] == '(' and s[9] == ')' and s[10] == '(' and s[11] == ')'",
      "difficulty": "competition",
      "split": "test"
   }
]