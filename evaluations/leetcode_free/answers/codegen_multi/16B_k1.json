[
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "answer": "        nums.sort()\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] + nums[j] == target:\n                return [i, j]\n            elif nums[i] + nums[j] < target:\n                i += 1\n            else:\n                j -= 1\n        return [i, j]"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "answer": "        def add(l1, l2):\n            if l1 is None and l2 is None:\n                return None\n            elif l1 is None:\n                return l2\n            elif l2 is None:\n                return l1\n            else:\n                return ListNode(l1.val + l2.val)"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [0] * len(s)\n        max_len = 0\n        for i in range(len(s)):\n            if dp[i] == 0:\n                dp[i] = 1\n                max_len = max(max_len, i - dp[i])\n            else:\n                dp[i] = dp[i - 1] + 1\n                max_len = max(max_len, i - dp[i])\n        return max_len\n"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        m, n = len(nums1), len(nums2)\n        if m + n == 0:\n            return 0\n        if m + n == 1:\n            return max(nums1[0], nums2[0])\n        if m == 0:\n            return nums2[0]\n        if n == 0:\n            return nums1[0]\n        if m > n:\n            return self.findMedianSortedArrays(nums2, nums1)\n        if m < n:\n            return self.findMedianSortedArrays(nums1, nums2)\n        mid = (m + n) // 2\n        left = self.findMedianSortedArrays(nums1[:mid], nums2[:mid])\n        right = self.findMedianSortedArrays(nums1[mid:], nums2[mid:])\n        return (left + right) / 2.0"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        dp = [[False] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n        ans = \"\"\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if dp[i][j]:\n                    ans = s[i:j + 1]\n                    break\n        return ans\n"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "answer": "        if numRows == 1:\n            return s\n        if numRows == 2:\n            return self.convert2(s)\n        if numRows == 3:\n            return self.convert3(s)\n        if numRows == 4:\n            return self.convert4(s)\n        if numRows == 5:\n            return self.convert5(s)\n        if numRows == 6:\n            return self.convert6(s)\n        if numRows == 7:\n            return self.convert7(s)\n        if numRows == 8:\n            return self.convert8(s)\n        if numRows == 9:\n            return self.convert9(s)\n        if numRows == 10:\n            return self.convert10(s)\n        if numRows == 11:\n            return self.convert11(s)\n        if numRows == 12:\n            return self.convert12(s)\n        if numRows == 13:\n            return self.convert13("
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "answer": "        if x < 0:\n            return 0\n        if x == 0:\n            return 0\n        if x > 0:\n            return self.reverse_helper(x)\n        else:\n            return -self.reverse_helper(-x)"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "answer": "        # read in and ignore any leading whitespace\n        s = s.strip()\n        # check if the next character (if not already at the end of the string) is '-' or '+'\n        if s[0] in ['+', '-']:\n            # read in the next character if it is either\n            s = s[1:]\n            # assume the result is positive\n            sign = 1 if s[0] == '+' else -1\n            # read in next the characters until the next non-digit character or the end of the input is reached\n            s = s[1:]\n            # convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32)\n            result = int(s)\n            # if no digits were read, then the integer is 0\n            if len(s) == 0:\n                result = 0\n            # change the sign as necessary (from step 2)\n            result *= sign\n            # if the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "answer": "        if x < 0:\n            return False\n        if x < 10:\n            return True\n        if x % 10 == 0:\n            return False\n        return x == int(str(x)[::-1])\n"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "answer": "        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            if p[i - 1] == '*':\n                dp[i][0] = True\n            else:\n                dp[i][0] = False\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = True\n            else:\n                dp[0][j] = False\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '.' or s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "answer": "        if not height:\n            return 0\n        n = len(height)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = height[i]\n            dp[i][i + 1] = max(height[i], height[i + 1])\n        for i in range(n - 1):\n            dp[i][i + 2] = max(dp[i + 1][i + 2], dp[i + 2][i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(dp[i + 1][i + 2], dp[i + 2][i + 1])\n        return max(dp[0][1], dp[n][0])"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "answer": "        if num < 0:\n            return \"\"\n        if num == 0:\n            return \"0\"\n        result = \"\"\n        while num > 0:\n            if num >= 1000:\n                result += \"M\"\n                num -= 1000\n            elif num >= 900:\n                result += \"CM\"\n                num -= 900\n            elif num >= 500:\n                result += \"D\"\n                num -= 500\n            elif num >= 400:\n                result += \"CD\"\n                num -= 400\n            elif num >= 100:\n                result += \"C\"\n                num -= 100\n            elif num >= 90:\n                result += \"XC\"\n                num -= 90\n            elif num >= 50:\n                result += \"L\"\n                num -= 50\n            elif num >= 40:\n                result += \"XL\"\n                num -= 40\n            elif num >= 10:\n                result += \"X\"\n                num -= 10\n            elif num >= 9:\n                result += \"IX\"\n                num -= 9\n            elif num >= 5:\n                result += \"V\""
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        \n        result = 0\n        for i in range(n):\n            if s[i] == 'I':\n                result += 1\n            elif s[i] == 'V':\n                result += 5\n            elif s[i] == 'X':\n                result += 10\n            elif s[i] == 'L':\n                result += 50\n            elif s[i] == 'C':\n                result += 100\n            elif s[i] == 'D':\n                result += 500\n            elif s[i] == 'M':\n                result += 1000\n        return result"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "answer": "        if not strs:\n            return \"\"\n        if len(strs) == 1:\n            return strs[0]\n        if len(strs) == 2:\n            return self.longestCommonPrefix(strs[0], strs[1])\n        prefix = \"\"\n        for i in range(len(strs[0])):\n            if all(s[i] == strs[0][i] for s in strs[1:]):\n                prefix += strs[0][i]\n            else:\n                break\n        return prefix\n"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                if nums[i] + nums[j] + nums[k] == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif nums[i] + nums[j] + nums[k] < 0:\n                    j += 1\n                else:\n                    k -= 1\n        return result\n"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        n = len(nums)\n        if n < 3:\n            return 0\n        if n == 3:\n            return nums[0] + nums[1] + nums[2]\n        if n == 4:\n            return nums[0] + nums[1] + nums[2] + nums[3]\n        if n == 5:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4]\n        if n == 6:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]\n        if n == 7:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]\n        if n == 8:\n            return nums[0] + nums[1] + nums[2"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "answer": "        if not digits:\n            return []\n        mapping = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\"\n        }\n        result = []\n        self.helper(mapping, digits, result, [], 0)\n        return result"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        result = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                for k in range(j + 1, len(nums) - 1):\n                    if k > j + 1 and nums[k] == nums[k - 1]:\n                        continue\n                    for l in range(k + 1, len(nums)):\n                        if l > k + 1 and nums[l] == nums[l - 1]:\n                            continue\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                            result.append([nums[i], nums[j], nums[k], nums[l]])\n        return result"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "answer": "        if head is None:\n            return None\n        if n == 1:\n            return head.next\n        if n == 2:\n            return head.next.next\n        if n == 3:\n            return head.next.next.next\n        if n == 4:\n            return head.next.next.next.next\n        if n == 5:\n            return head.next.next.next.next.next\n        if n == 6:\n            return head.next.next.next.next.next.next.next\n        if n == 7:\n            return head.next.next.next.next.next.next.next.next.next\n        if n == 8:\n            return head.next.next.next.next.next.next.next.next.next.next.next\n        if n == 9:\n            return head.next.next.next.next.next.next.next.next.next.next.next.next.next\n        if n == 10:\n            return head.next.next.next.next.next.next.next.next.next.next"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "answer": "        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                if stack[-1]!= '(':\n                    return False\n                stack.pop()\n            elif c == '{':\n                stack.append(c)\n            elif c == '}':\n                if len(stack) == 0:\n                    return False\n                if stack[-1]!= '{':\n                    return False\n                stack.pop()\n            elif c == '[':\n                stack.append(c)\n            elif c == ']':\n                if len(stack) == 0:\n                    return False\n                if stack[-1]!= '[':\n                    return False\n                stack.pop()\n        return len(stack) == 0\n"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "answer": "        if not list1:\n            return list2\n        if not list2:\n            return list1\n        head = ListNode(0)\n        head.next = list1\n        cur = head\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n            cur = cur.next\n        if list1:\n            cur.next = list1\n        if list2:\n            cur.next = list2\n        return head.next"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        res = []\n        self.dfs(n, 0, \"\", res)\n        return res"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "answer": "        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        head = ListNode(0)\n        head.next = lists[0]\n        prev = head\n        for i in range(1, len(lists)):\n            curr = lists[i]\n            if curr:\n                prev.next = curr.next\n                curr.next = head.next\n                head.next = curr\n                prev = curr\n        return head.next"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "answer": "        if head is None:\n            return None\n        if head.next is None:\n            return head\n        prev = head\n        curr = head.next\n        while curr is not None and curr.next is not None:\n            prev.next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = curr.next.next\n        return head\n"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "answer": "        if not head:\n            return None\n        if not k:\n            return head\n        if k == 1:\n            return self.reverse(head)\n        if k == 2:\n            return self.reverse2(head)\n        if k == 3:\n            return self.reverse3(head)\n        if k == 4:\n            return self.reverse4(head)\n        if k == 5:\n            return self.reverse5(head)\n        if k == 6:\n            return self.reverse6(head)\n        if k == 7:\n            return self.reverse7(head)\n        if k == 8:\n            return self.reverse8(head)\n        if k == 9:\n            return self.reverse9(head)\n        if k == 10:\n            return self.reverse10(head)\n        if k == 11:\n            return self.reverse11(head)\n        if k == 12:\n            return self.reverse12(head)\n        if k == 13:\n            return self.reverse13(head)\n        if k == 14:\n            return self"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if nums[0] == nums[1]:\n            nums[0] = nums[2]\n            nums[1] = nums[3]\n            nums[2] = nums[4]\n            nums[3] = nums[5]\n            nums[4] = nums[6]\n            nums[5] = nums[7]\n            nums[6] = nums[8]\n            nums[7] = nums[9]\n            nums[8] = nums[10]\n            nums[9] = nums[11]\n            nums[10] = nums[12]\n            nums[11] = nums[13]\n            nums[12] = nums[14]\n            nums[13] = nums[15]\n            nums[14] = nums[16]\n            nums[15] = nums[17"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "answer": "        i = 0\n        j = 0\n        while j < len(nums):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n            j += 1\n        return i"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "answer": "        if not needle:\n            return 0\n        if not haystack:\n            return -1\n        if len(needle) > len(haystack):\n            return -1\n        if len(needle) == 1:\n            return haystack.find(needle)\n        if len(needle) == 2:\n            return haystack.find(needle, haystack.find(needle[0]))\n        if len(needle) == 3:\n            return haystack.find(needle, haystack.find(needle[0]), haystack.find(needle[1]))\n        if len(needle) == 4:\n            return haystack.find(needle, haystack.find(needle[0]), haystack.find(needle[1]), haystack.find(needle[2]))\n        if len(needle) == 5:\n            return haystack.find(needle, haystack.find(needle[0]), haystack.find(needle[1]), haystack.find(needle[2]), haystack.find(need"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod-2/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod-3/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod-4/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod-5/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-and-mod-6/\n        # https://www.geeksforgeeks.org/divide-two-integers-without-using-multiplication-division-"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "answer": "        n = len(words)\n        if n == 0:\n            return []\n        if n == 1:\n            return [s.index(words[0])]\n        if n == 2:\n            return [s.index(words[0]), s.index(words[1])]\n        if n == 3:\n            return [s.index(words[0]), s.index(words[1]), s.index(words[2])]\n        if n == 4:\n            return [s.index(words[0]), s.index(words[1]), s.index(words[2]), s.index(words[3])]\n        if n == 5:\n            return [s.index(words[0]), s.index(words[1]), s.index(words[2]), s.index(words[3]), s.index(words[4])]\n        if n == 6:\n            return [s.index(words[0]), s.index(words[1]), s.index(words[2]), s.index(words[3]), s.index(words[4]), s"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "answer": "        nums.sort()\n        i = len(nums) - 1\n        while i > 0 and nums[i - 1] >= nums[i]:\n            i -= 1\n        nums[i], nums[-1] = nums[-1], nums[i]\n        nums.pop()\n        nums.reverse()"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "answer": "        stack = []\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    max_len = max(max_len, i - stack[-1])\n                else:\n                    max_len = max(max_len, i - stack[-1] - 1)\n                stack.pop()\n        return max_len\n"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "answer": "        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return [left, right]\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return [-1, -1]"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "answer": "        lo, hi = 0, len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return lo"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "answer": "        if not board:\n            return True\n        \n        def is_valid_row(row):\n            for i in range(9):\n                if row[i] not in '123456789':\n                    return False\n            return True\n        \n        def is_valid_col(col):\n            for i in range(9):\n                if col[i] not in '123456789':\n                    return False\n            return True\n        \n        def is_valid_box(box):\n            for i in range(3):\n                for j in range(3):\n                    if box[i][j] not in '123456789':\n                        return False\n            return True\n        \n        for i in range(9):\n            if not is_valid_row(board[i]):\n                return False\n        \n        for j in range(9):\n            if not is_valid_col(board[j]):\n                return False\n        \n        for i in range(3):\n            for j in range(3):\n                if not is_valid_box(board[i*3"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "answer": "        def dfs(board, i, j):\n            if i < 0 or i >= 9 or j < 0 or j >= 9:\n                return\n            if board[i][j]!= '.':\n                return\n            board[i][j] = str(i * 9 + j + 1)\n            for k in range(9):\n                dfs(board, i, k)\n                dfs(board, k, j)\n            for k in range(3):\n                for l in range(3):\n                    dfs(board, i * 3 + k, j * 3 + l)"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"1\"\n        return self.count_and_say(n - 1)"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "answer": "        candidates.sort()\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n        candidates.append(0)\n"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "answer": "        candidates.sort()\n        result = []\n        self.dfs(candidates, target, [], result)\n        return result"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] <= len(nums) and nums[i]!= nums[nums[i] - 1]:\n                return nums[i]\n        return 1"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "answer": "        if not height:\n            return 0\n        n = len(height)\n        dp = [0] * n\n        dp[0] = height[0]\n        for i in range(1, n):\n            dp[i] = max(height[i], dp[i - 1])\n        return sum(dp) - height[-1]"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/discuss/\n        # https://leetcode.com/problems/multiply-strings/disc"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "answer": "        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            if p[i - 1] == '*':\n                dp[i][0] = True\n            elif p[i - 1] == '?' or s[i - 1] == p[i - 1]:\n                dp[i][0] = dp[i - 1][0]\n            else:\n                dp[i][0] = False\n        for i in range(1, n + 1):\n            if p[0] == '*':\n                dp[0][i] = True\n            elif p[0] == '?' or s[0] == p[0]:\n                dp[0][i] = dp[0][i - 1]\n            else:\n                dp[0][i] = False\n        for i in range(1, m + 1):\n            for j in range(1, n"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return 0\n        if len(nums) == 2:\n            return 1\n        if nums[0] == 0:\n            return 0\n        if nums[0] == 1:\n            return 1\n        if nums[0] == 2:\n            return 2\n        if nums[0] == 3:\n            return 3\n        if nums[0] == 4:\n            return 4\n        if nums[0] == 5:\n            return 5\n        if nums[0] == 6:\n            return 6\n        if nums[0] == 7:\n            return 7\n        if nums[0] == 8:\n            return 8\n        if nums[0] == 9:\n            return 9\n        if nums[0] == 10:\n            return 10\n        if nums[0] == 11:\n            return 11\n        if nums[0] == 12:\n            return 12\n        if nums[0] == 13:\n            return 13\n        if nums[0] == 14:"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        nums.sort()\n        ans = []\n        self.dfs(nums, ans, [], 0)\n        return ans"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [[nums]]\n        result = []\n        self.dfs(nums, result, [], 0)\n        return result"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "answer": "        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j], matrix[len(matrix) - 1 - j][i] = matrix[len(matrix) - 1 - j][i], matrix[i][j]\n        for i in range(len(matrix) // 2):\n            for j in range(len(matrix[0])):\n                matrix[i][j], matrix[len(matrix) - 1 - i][j] = matrix[len(matrix) - 1 - i][j], matrix[i][j]\n        for i in range(len(matrix) // 2, len(matrix)):\n            for j in range(len(matrix[0])):\n                matrix[i][j], matrix[j][len(matrix[0]) - 1 - i] = matrix[j][len(matrix[0]) - 1 - i], matrix[i][j]"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "answer": "        if not strs:\n            return []\n        d = {}\n        for s in strs:\n            key = ''.join(sorted(s))\n            if key not in d:\n                d[key] = []\n            d[key].append(s)\n        return [d[k] for k in sorted(d)]"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        if n == 1:\n            return x\n        if n == 2:\n            return x * x\n        if n % 2 == 0:\n            return self.myPow(x * x, n // 2)\n        else:\n            return x * self.myPow(x * x, n // 2)"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [['Q']]\n        if n == 2:\n            return [['.', 'Q'], ['Q', '.']]\n        if n == 3:\n            return [['.', '.', 'Q'], ['.', 'Q', '.'], ['Q', '.', '.']]\n        if n == 4:\n            return [['.', '.', '.', 'Q'], ['.', '.', 'Q', '.'], ['.', 'Q', '.', '.'], ['Q', '.', '.', '.']]\n        if n == 5:\n            return [['.', '.', '.', '.', 'Q'], ['.', '.', '.', 'Q', '.'], ['.', '.', 'Q', '.', '.'], ['.', 'Q', '.', '.', '.'], ['Q', '.', '.', '.', '.']]\n        if n == 6:\n            return [['.', '"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n        if n == 22:\n            "
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] + nums[i], nums[i])\n        return max(dp)"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return []\n        m, n = len(matrix), len(matrix[0])\n        if m == 1 or n == 1:\n            return matrix\n        if m > n:\n            return self.spiralOrder(matrix[:n]) + self.spiralOrder(matrix[n:])\n        if m < n:\n            return self.spiralOrder(matrix[:m]) + self.spiralOrder(matrix[m:])\n        \n        result = []\n        i, j = 0, 0\n        while i < m and j < n:\n            result.append(matrix[i][j])\n            i += 1\n            j += 1\n        while i < m:\n            result.append(matrix[i][j])\n            i += 1\n        while j < n:\n            result.append(matrix[i][j])\n            j += 1\n        return result\n"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return nums[0] >= nums[1]\n        if n == 3:\n            return nums[0] >= nums[1] and nums[1] >= nums[2]\n        if n == 4:\n            return nums[0] >= nums[1] and nums[1] >= nums[2] and nums[2] >= nums[3]\n        if n == 5:\n            return nums[0] >= nums[1] and nums[1] >= nums[2] and nums[2] >= nums[3] and nums[3] >= nums[4]\n        if n == 6:\n            return nums[0] >= nums[1] and nums[1] >= nums[2] and nums[2] >= nums[3] and nums[3] >= nums[4] and nums[4] >="
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        result = []\n        for i in range(len(intervals)):\n            if i > 0 and intervals[i][0] <= intervals[i - 1][1]:\n                intervals[i - 1][1] = max(intervals[i - 1][1], intervals[i][1])\n            else:\n                result.append(intervals[i])\n        return result\n"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "answer": "        intervals.append(newInterval)\n        i = 0\n        j = 0\n        while i < len(intervals) - 1:\n            if intervals[i][1] < intervals[i + 1][0]:\n                intervals[i + 1][0] = max(intervals[i + 1][0], intervals[i][1])\n                intervals[i][1] = max(intervals[i][1], intervals[i + 1][1])\n                intervals[i + 1][1] = min(intervals[i + 1][1], intervals[i][0])\n                intervals[i][0] = min(intervals[i][0], intervals[i + 1][0])\n            else:\n                i += 1\n        while j < len(intervals) - 1:\n            if intervals[j][1] < intervals[j + 1][0]:\n                intervals[j + 1][0] = max(intervals[j + 1][0], intervals[j][1])\n                intervals[j][1] = max(intervals[j][1"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "answer": "        i = len(s) - 1\n        while i >= 0 and s[i] =='':\n            i -= 1\n        return i + 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [[1]]\n        if n == 2:\n            return [[1, 2], [2, 1]]\n        if n == 3:\n            return [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n        if n == 4:\n            return [[1, 2, 3, 4], [8, 9, 4, 5], [7, 6, 5, 4], [6, 7, 8, 9]]\n        if n == 5:\n            return [[1, 2, 3, 4, 5], [8, 9, 4, 5, 6], [7, 6, 5, 4, 7], [6, 7, 8, 9, 4], [5, 6, 7, 8, 9]]\n        if n == 6:\n            return [[1, 2, 3, 4, 5, 6], [8, 9, 4, 5, 6, 7], [7, 6, 5, 4, 7, 8], [6, 7, 8, 9, 4, 5], [5,"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "answer": "        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_II\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_III\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_IV\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_V\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_VI\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_VII\n        # https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order_VIII\n        # https://en.wikipedia.org/wiki/Permutation#Generation_"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        if not k:\n            return head\n        if k == 1:\n            return head.next\n        if k == 2:\n            return head.next.next\n        if k == 3:\n            return head.next.next.next\n        if k == 4:\n            return head.next.next.next.next\n        if k == 5:\n            return head.next.next.next.next.next\n        return head\n"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "answer": "        if m == 0 or n == 0:\n            return 0\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(1, m):\n            dp[i][0] = 1\n        for j in range(1, n):\n            dp[0][j] = 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "answer": "        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "answer": "        # if len(s) == 0:\n        #     return False\n        # if s[0] in \"+-\":\n        #     return self.isNumber(s[1:])\n        # if s[0] == '0':\n        #     return len(s) == 1 or self.isNumber(s[1:])\n        # if s[0] == '.':\n        #     return self.isNumber(s[1:]) or self.isNumber(s[2:])\n        # if s[0] == 'e' or s[0] == 'E':\n        #     return self.isNumber(s[1:])\n        # return False"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "answer": "        n = len(digits)\n        carry = 1\n        for i in range(n - 1, -1, -1):\n            digits[i] += carry\n            carry = digits[i] / 10\n            digits[i] %= 10\n        if carry:\n            digits.insert(0, carry)\n        return digits\n"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/add-binary/discuss/\n        # https://leetcode.com/articles/add-binary/\n        # https://leetcode.com/articles/add-binary-2/\n        # https://leetcode.com/articles/add-binary-3/\n        # https://leetcode.com/articles/add-binary-4/\n        # https://leetcode.com/articles/add-binary-5/\n        # https://leetcode.com/articles/add-binary-6/\n        # https://leetcode.com/articles/add-binary-7/\n        # https://leetcode.com/articles/add-binary-8/\n        # https://leetcode.com/articles/add-binary-9/\n        # https://leetcode.com/articles/add-binary-10/\n        # https://leetcode.com/articles/add-binary-11/\n        # https://leetcode.com/articles/add-binary-12/\n        # https"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "answer": "        result = []\n        line = []\n        for word in words:\n            line.append(word)\n            if len(line) == maxWidth:\n                result.append(' '.join(line))\n                line = []\n        if len(line) > 0:\n            result.append(' '.join(line))\n        return result"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "answer": "        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 2\n        if x == 3:\n            return 2\n        if x == 4:\n            return 2\n        if x == 5:\n            return 3\n        if x == 6:\n            return 3\n        if x == 7:\n            return 3\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 4\n        if x == 12:\n            return 4\n        if x == 13:\n            return 4\n        if x == 14:\n            return 4\n        if x == 15:\n            return 5\n        if x == 16:\n            return 5\n        if x == 17:\n            return 5\n        if x == 18:\n            return 5\n        if x == 19:\n            return 6\n        if x == 20:\n            return 6\n        if x == 21:\n            return 6\n        if x == 22:\n            "
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "answer": "        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner cases\n        # TODO: add corner"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "answer": "        # DP\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = matrix[0][j] = 0\n                    matrix[0][i] = matrix[i][0] = 0"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        i, j = 0, n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] < target:\n                i += 1\n            else:\n                j -= 1\n        return False\n"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "answer": "        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                j -= 1\n            elif nums[i] == 2:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n            else:\n                i += 1\n        return"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "answer": "        m, n = len(s), len(t)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if s[i] == t[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        ans = \"\"\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == n:\n                    ans = s[i:i + dp[i][j]]\n                    break\n        return ans if ans else \"\""
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "answer": "        if n < k:\n            return []\n        if k == 1:\n            return [[i] for i in range(1, n + 1)]\n        if k == 2:\n            return [[i, j] for i in range(1, n + 1) for j in range(i + 1, n + 1)]\n        if k == 3:\n            return [[i, j, k] for i in range(1, n + 1) for j in range(i + 1, n + 1) for k in range(j + 1, n + 1)]\n        if k == 4:\n            return [[i, j, k, l] for i in range(1, n + 1) for j in range(i + 1, n + 1) for k in range(j + 1, n + 1) for l in range(k + 1, n + 1)]\n        if k == 5:\n            return [[i, j, k, l, m] for i in range(1, n + 1) for j in range(i + 1, n + 1) for k in range(j + 1,"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        result = []\n        for i in range(2 ** len(nums)):\n            subset = []\n            for j in range(len(nums)):\n                if i & (1 << j):\n                    subset.append(nums[j])\n            result.append(subset)\n        return result"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "answer": "        if not board or not board[0]:\n            return False\n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, i, j, visited):\n                        return True\n        return False"
    },
    {
        "number": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if nums[0] == nums[1]:\n            nums[0] = nums[2]\n            nums[1] = nums[3]\n            nums[2] = nums[4]\n            nums[3] = nums[5]\n            nums[4] = nums[6]\n            nums[5] = nums[7]\n            nums[6] = nums[8]\n            nums[7] = nums[9]\n            nums[8] = nums[10]\n            nums[9] = nums[11]\n            nums[10] = nums[12]\n            nums[11] = nums[13]\n            nums[12] = nums[14]\n            nums[13] = nums[15]\n            nums[14] = nums[16]\n            nums[15] = nums[17"
    },
    {
        "number": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": 1,
        "answer": "        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n"
    },
    {
        "number": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        pre = head\n        cur = head.next\n        while cur:\n            if cur.val == pre.val:\n                pre.next = cur.next\n                cur = cur.next\n            else:\n                pre = cur\n                cur = cur.next\n        return head\n"
    },
    {
        "number": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        pre = head\n        cur = head.next\n        while cur:\n            if cur.val == pre.val:\n                pre.next = cur.next\n                cur = cur.next\n            else:\n                pre = cur\n                cur = cur.next\n        return head\n"
    },
    {
        "number": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": 2,
        "answer": "        heights.append(0)\n        heights.sort()\n        stack = []\n        area = 0\n        for i in range(len(heights)):\n            while len(stack) > 1 and heights[i] >= heights[stack[-1]]:\n                area = max(area, heights[stack.pop()] * (i - stack[-1] - 1))\n            stack.append(i)\n        while len(stack) > 1:\n            area = max(area, heights[stack.pop()] * (len(heights) - stack[-1] - 1))\n        return area\n"
    },
    {
        "number": 85,
        "title": "Maximal Rectangle",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == \"1\":\n                    dp[i][j] = 1 + max(dp[i][j - 1], dp[i - 1][j])\n        return max(max(dp[i][j] for i in range(m)), max(dp[i][j] for j in range(n)))"
    },
    {
        "number": 86,
        "title": "Partition List",
        "difficulty": 1,
        "answer": "        if head is None:\n            return None\n        if head.val < x:\n            return head\n        pre = head\n        cur = head.next\n        while cur is not None:\n            if cur.val < x:\n                pre.next = cur.next\n                cur.next = head\n                head = cur\n            else:\n                pre = cur\n            cur = cur.next\n        return head\n"
    },
    {
        "number": 87,
        "title": "Scramble String",
        "difficulty": 2,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if len(s1) == 1:\n            return True\n        if s1 == s2:\n            return True\n        if s1 == s2[::-1]:\n            return True\n        if s1[0] == s2[0] and s1[1:] == s2[1:]:\n            return True\n        if s1[0] == s2[-1] and s1[1:] == s2[:-1]:\n            return True\n        if s1[0] == s2[-2] and s1[1:] == s2[:-2]:\n            return True\n        if s1[0] == s2[-3] and s1[1:] == s2[:-3]:\n            return True\n        if s1[0] == s2[-4] and s1[1:] == s2[:-4]:\n            return True\n        if s1[0] == s2[-5] and s1[1:] == s2[:-5]:\n"
    },
    {
        "number": 88,
        "title": "Merge Sorted Array",
        "difficulty": 0,
        "answer": "        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while i >= 0:\n            nums1[k] = nums1[i]\n            i -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n"
    },
    {
        "number": 89,
        "title": "Gray Code",
        "difficulty": 1,
        "answer": "        result = []\n        for i in range(2 ** n):\n            result.append(i ^ (i >> 1))\n        return result"
    },
    {
        "number": 90,
        "title": "Subsets II",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        ans = []\n        for i in range(2 ** len(nums)):\n            subset = []\n            for j in range(len(nums)):\n                if i & (1 << j):\n                    subset.append(nums[j])\n            ans.append(subset)\n        return ans\n"
    },
    {
        "number": 91,
        "title": "Decode Ways",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [0] * len(s)\n        dp[0] = 1\n        for i in range(1, len(s)):\n            if s[i] == '0':\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1]\n                if i - 2 >= 0 and s[i - 2] == '1' and s[i - 1] == s[i]:\n                    dp[i] += dp[i - 2]\n        return dp[-1]"
    },
    {
        "number": 92,
        "title": "Reverse Linked List II",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if left > right:\n            return head\n        if left == right:\n            return head\n        if left == 0:\n            return self.reverseList(head)\n        if right == len(head) - 1:\n            return self.reverseList(head)\n        pre = head\n        cur = head\n        for i in range(left - 1, right):\n            cur = cur.next\n        pre.next = self.reverseList(cur.next)\n        cur.next = None\n        return head"
    },
    {
        "number": 93,
        "title": "Restore IP Addresses",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return []\n        if n == 1:\n            return [s]\n        if n == 2:\n            return [s[0] + \".\" + s[1]]\n        if n == 3:\n            return [s[0] + \".\" + s[1] + \".\" + s[2]]\n        if n == 4:\n            return [s[0] + \".\" + s[1] + \".\" + s[2] + \".\" + s[3]]\n        if n == 5:\n            return [s[0] + \".\" + s[1] + \".\" + s[2] + \".\" + s[3] + \".\" + s[4]]\n        if n == 6:\n            return [s[0] + \".\" + s[1] + \".\" + s[2] + \".\" + s[3] + \".\" + s[4] + \".\" + s[5]]\n        if n == 7:\n            return [s[0] + \".\" + s[1] +"
    },
    {
        "number": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        result = []\n        stack = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            result.append(root.val)\n            root = root.right\n        return result"
    },
    {
        "number": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": 1,
        "answer": "        def dfs(start, end):\n            if start > end:\n                return\n            if start == end:\n                yield TreeNode(start)\n            for i in range(start, end + 1):\n                for left in dfs(start, i - 1):\n                    for right in dfs(i + 1, end):\n                        yield TreeNode(i, left, right)"
    },
    {
        "number": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[n]\n"
    },
    {
        "number": 97,
        "title": "Interleaving String",
        "difficulty": 1,
        "answer": "        n1, n2, n3 = len(s1), len(s2), len(s3)\n        if n3 == 0:\n            return True\n        if n1 + n2!= n3:\n            return False\n        dp = [[False] * (n3 + 1) for _ in range(n1 + 1)]\n        dp[0][0] = True\n        for i in range(1, n1 + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in range(1, n2 + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]\n                dp"
    },
    {
        "number": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": 1,
        "answer": "        def is_valid_bst(node, min_val, max_val):\n            if node is None:\n                return True\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            return is_valid_bst(node.left, min_val, node.val) and is_valid_bst(node.right, node.val, max_val)\n        return is_valid_bst(root, float('-inf'), float('inf'))"
    },
    {
        "number": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": 1,
        "answer": "        self.helper(root)"
    },
    {
        "number": 100,
        "title": "Same Tree",
        "difficulty": 0,
        "answer": "        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
    },
    {
        "number": 101,
        "title": "Symmetric Tree",
        "difficulty": 0,
        "answer": "        def is_symmetric(node, l, r):\n            if not node:\n                return True\n            if l is None and r is None:\n                return True\n            if l is None or r is None:\n                return False\n            if node.val!= node.left.val and node.val!= node.right.val:\n                return False\n            return is_symmetric(node.left, l, node.right) and is_symmetric(node.right, node.left, r)\n        return is_symmetric(root, None, None)"
    },
    {
        "number": 102,
        "title": "Binary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        if root is None:\n            return []\n        result = []\n        queue = [root]\n        while queue:\n            level = []\n            while queue:\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"
    },
    {
        "number": 103,
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        result = []\n        queue = [root]\n        while queue:\n            level = []\n            while queue:\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if len(level) > 1:\n                result.append(level)\n        return result"
    },
    {
        "number": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"
    },
    {
        "number": 105,
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "difficulty": 1,
        "answer": "        if not preorder or not inorder:\n            return None\n        return self.buildTreeRecu(preorder, inorder, 0, len(preorder) - 1, 0, len(inorder) - 1)"
    },
    {
        "number": 106,
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        if not inorder or not postorder:\n            return None\n        return self.buildTreeRecu(inorder, postorder, 0, len(inorder) - 1, 0, len(postorder) - 1)"
    },
    {
        "number": 107,
        "title": "Binary Tree Level Order Traversal II",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        result = []\n        queue = [root]\n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n            queue = queue[::-1]\n        return result\n"
    },
    {
        "number": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not nums:\n            return None\n        root = TreeNode(nums[0])\n        stack = [root]\n        for num in nums[1:]:\n            while stack and num > stack[-1].val:\n                stack.pop()\n            node = TreeNode(num)\n            node.left = stack[-1]\n            stack[-1].right = node\n            stack.append(node)\n        return root"
    },
    {
        "number": 109,
        "title": "Convert Sorted List to Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n"
    },
    {
        "number": 110,
        "title": "Balanced Binary Tree",
        "difficulty": 0,
        "answer": "        def dfs(root):\n            if not root:\n                return True\n            if not root.left and not root.right:\n                return True\n            if not root.left or not root.right:\n                return False\n            return dfs(root.left) and dfs(root.right)"
    },
    {
        "number": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
    },
    {
        "number": 112,
        "title": "Path Sum",
        "difficulty": 0,
        "answer": "        if root is None:\n            return False\n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"
    },
    {
        "number": 113,
        "title": "Path Sum II",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        if not root.left and not root.right and root.val == targetSum:\n            return [[root.val]]\n        return self.pathSumHelper(root, targetSum)"
    },
    {
        "number": 114,
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": 1,
        "answer": "        if root is None:\n            return\n        self.flattenHelper(root)"
    },
    {
        "number": 115,
        "title": "Distinct Subsequences",
        "difficulty": 2,
        "answer": "        if len(s) < len(t):\n            return 0\n        if len(s) == len(t):\n            return 1\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        for j in range(1, len(t) + 1):\n            dp[0][j] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[len(s)][len(t)]\n"
    },
    {
        "number": 116,
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next"
    },
    {
        "number": 117,
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": 1,
        "answer": "        self.next = None\n        self.left = None\n        self.right = None\n        self.val = val\n        if left:\n            left.next = self\n        if right:\n            right.next = self\n        self.next = next\n        self.left = left\n        self.right = right\n        self.val = val\n        self.next = None\n        self.left = None\n        self.right = None\n        self.val = val\n        if left:\n            left.next = self\n        if right:\n            right.next = self\n        self.next = next\n        self.left = left\n        self.right = right\n        self.val = val\n        self.next = None\n        self.left = None\n        self.right = None\n        self.val = val\n        if left:\n            left.next = self\n        if right:\n            right.next = self\n        self.next = next\n        self.left = left\n        self.right = right\n        self.val = val\n        self.next = None\n        self."
    },
    {
        "number": 118,
        "title": "Pascal\"s Triangle",
        "difficulty": 0,
        "answer": "        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        result = [[1]]\n        for i in range(2, numRows + 1):\n            result.append([1] + [0] * i)\n            for j in range(1, i):\n                result[i][j] = result[i - 1][j - 1] + result[i - 1][j]\n        return result\n"
    },
    {
        "number": 119,
        "title": "Pascal\"s Triangle II",
        "difficulty": 0,
        "answer": "        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1, 1]\n        if rowIndex == 2:\n            return [1, 1, 1]\n        if rowIndex == 3:\n            return [1, 3, 3, 1]\n        if rowIndex == 4:\n            return [1, 3, 6, 4]\n        if rowIndex == 5:\n            return [1, 4, 10, 6, 1]\n        if rowIndex == 6:\n            return [1, 4, 15, 11, 6, 1]\n        if rowIndex == 7:\n            return [1, 5, 21, 16, 12, 1]\n        if rowIndex == 8:\n            return [1, 5, 28, 22, 17, 1]\n        if rowIndex == 9:\n            return [1, 6, 36, 29, 23, 1]\n        if rowIndex == 10:\n            return [1, 6, 45, 35, 30, 1]\n        if rowIndex == 11:\n            return [1, 7, 55, 44, 36"
    },
    {
        "number": 120,
        "title": "Triangle",
        "difficulty": 1,
        "answer": "        n = len(triangle)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1):\n                dp[i][j] = triangle[i][j] + min(dp[i][j - 1], dp[i - 1][j])\n        return dp[n - 1][n - 1]"
    },
    {
        "number": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": 0,
        "answer": "        if not prices:\n            return 0\n        n = len(prices)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = prices[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + prices[i] - dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": 1,
        "answer": "        n = len(prices)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = prices[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], dp[i + 1][i + 1] - prices[i])\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 123,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": 2,
        "answer": "        if not prices:\n            return 0\n        n = len(prices)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = prices[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(prices[i + 1] - dp[i + 2][i + 1], dp[i + 1][i + 2] - prices[i])\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": 2,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return root.val\n        return max(self.maxPathSum(root.left), self.maxPathSum(root.right)) + root.val"
    },
    {
        "number": 125,
        "title": "Valid Palindrome",
        "difficulty": 0,
        "answer": "        return s == s.lower()"
    },
    {
        "number": 126,
        "title": "Word Ladder II",
        "difficulty": 2,
        "answer": "        # dic: word -> [word, next word]\n        dic = {}\n        for word in wordList:\n            dic[word] = [word, None]\n        # dic: word -> [word, next word]\n        dic[beginWord] = [beginWord, None]\n        # dic: word -> [word, next word]\n        dic[endWord] = [endWord, None]\n        # dic: word -> [word, next word]\n        dic[endWord] = [endWord, None]\n        # dic: word -> [word, next word]\n        dic[beginWord] = [beginWord, None]\n        # dic: word -> [word, next word]\n        dic[beginWord] = [beginWord, None]\n        # dic: word -> [word, next word]\n        dic[endWord] = [endWord, None]\n        # dic: word -> [word, next word]\n        dic[endWord] = [endWord, None]\n        # dic: word"
    },
    {
        "number": 127,
        "title": "Word Ladder",
        "difficulty": 2,
        "answer": "        if not wordList:\n            return 0\n        if beginWord == endWord:\n            return 1\n        if beginWord not in wordList or endWord not in wordList:\n            return 0\n        wordList.append(beginWord)\n        wordList.append(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove(endWord)\n        wordList.sort()\n        wordList.remove(beginWord)\n        wordList.remove("
    },
    {
        "number": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n):\n            if nums[i] == nums[i - 1] + 1:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n        max_len = 0\n        for i in range(n):\n            if dp[i] > max_len:\n                max_len = dp[i]\n        return max_len\n"
    },
    {
        "number": 129,
        "title": "Sum Root to Leaf Numbers",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        return self.helper(root, 0)"
    },
    {
        "number": 130,
        "title": "Surrounded Regions",
        "difficulty": 1,
        "answer": "        if not board:\n            return\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    self.dfs(board, i, j)"
    },
    {
        "number": 131,
        "title": "Palindrome Partitioning",
        "difficulty": 1,
        "answer": "        def dfs(s, start, end):\n            if start > end:\n                return\n            if start == end:\n                result.append([s[start]])\n            else:\n                for i in range(start, end):\n                    dfs(s, start, i)\n                    dfs(s, i + 1, end)\n        result = []\n        dfs(s, 0, len(s) - 1)\n        return result"
    },
    {
        "number": 132,
        "title": "Palindrome Partitioning II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 3\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 4\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 5\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 6\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 7\n        for i in range(n - 8,"
    },
    {
        "number": 133,
        "title": "Clone Graph",
        "difficulty": 1,
        "answer": "        # Your Node object will be instantiated and called as such:\n        # obj = Node(val, neighbors)\n        # param_1 = obj.val\n        # param_2 = obj.neighbors\n        # return obj\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj.val\n        # return obj.neighbors\n        # return obj."
    },
    {
        "number": 134,
        "title": "Gas Station",
        "difficulty": 1,
        "answer": "        n = len(gas)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0\n        if n == 2:\n            return gas[0] == gas[1] and cost[0] == cost[1] and gas[0] == cost[0]\n        if n == 3:\n            return gas[0] == gas[1] and gas[0] == gas[2] and cost[0] == cost[1] and cost[0] == cost[2]\n        if n == 4:\n            return gas[0] == gas[1] and gas[0] == gas[2] and gas[0] == gas[3] and cost[0] == cost[1] and cost[0] == cost[2] and cost[0] == cost[3]\n        if n == 5:\n            return gas[0] == gas[1] and gas[0] == gas[2] and gas[0] == gas[3] and gas[0] == gas[4] and cost[0] == cost[1] and cost[0"
    },
    {
        "number": 135,
        "title": "Candy",
        "difficulty": 2,
        "answer": "        n = len(ratings)\n        if n == 0:\n            return 0\n        candy = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candy[i] = candy[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candy[i] = max(candy[i], candy[i + 1] + 1)\n        return sum(candy)\n"
    },
    {
        "number": 136,
        "title": "Single Number",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        return nums[-1] if len(nums) % 2 == 0 else nums[len(nums) // 2]"
    },
    {
        "number": 137,
        "title": "Single Number II",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(1) space\n        # nums.count(x) == 3\n        # nums.count(x) == 1\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count(x) == 0\n        # nums.count"
    },
    {
        "number": 138,
        "title": "Copy List with Random Pointer",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        #     def __str__(self):\n        #         return str(self.val)\n        #\n        #     def __repr__(self):\n        #         return str(self.val)\n        #\n        # class Solution:\n        #     def copyRandomList(self, head: ListNode) -> ListNode:\n        #         if not head:\n        #             return None\n        #         dummy = ListNode(0)\n        #         dummy.next = head\n        #         cur = dummy\n        #         while cur.next:\n        #             cur = cur.next\n        #             new_node = ListNode(cur.val)\n        #             new_node.next = cur.next\n        #             cur.next = new_node\n        #             if cur.random:\n        #                 new_node.random = cur.random"
    },
    {
        "number": 139,
        "title": "Word Break",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = True\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if dp[i][j - 1] and wordDict[i] in wordDict[j - 1]:\n                    dp[i][j] = True\n        return dp[0][n]"
    },
    {
        "number": 140,
        "title": "Word Break II",
        "difficulty": 2,
        "answer": "        if not s:\n            return []\n        if not wordDict:\n            return []\n        dp = [[False] * (len(s) + 1) for _ in range(len(wordDict) + 1)]\n        dp[0][0] = True\n        for i in range(1, len(wordDict) + 1):\n            for j in range(1, len(s) + 1):\n                if dp[i - 1][j - 1] and wordDict[i - 1] == s[j - 1]:\n                    dp[i][j] = True\n        return [s[:i] + \" \" + s[i:] for i in range(len(s)) if dp[len(wordDict)][i]]\n"
    },
    {
        "number": 141,
        "title": "Linked List Cycle",
        "difficulty": 0,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        #\n        # class Solution:\n        #     def hasCycle(self, head: Optional[ListNode]) -> bool:\n        #         \"\"\"\n        #         Given head, the head of a linked list, determine if the linked list has a cycle in it.\n        #         There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n        #         Return true if there is a cycle in the linked list. Otherwise,"
    },
    {
        "number": 142,
        "title": "Linked List Cycle II",
        "difficulty": 1,
        "answer": "        if head is None:\n            return None\n        if head.next is None:\n            return None\n        pos = -1\n        while head is not None:\n            pos += 1\n            head = head.next\n        return pos"
    },
    {
        "number": 143,
        "title": "Reorder List",
        "difficulty": 1,
        "answer": "        if not head:\n            return"
    },
    {
        "number": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        result = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result"
    },
    {
        "number": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        result = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            result.append(node.val)\n        return result"
    },
    {
        "number": 146,
        "title": "LRU Cache",
        "difficulty": 1,
        "answer": "        self.cache = {}\n        self.capacity = capacity\n        self.head = 0\n        self.tail = 0\n        self.size = 0"
    },
    {
        "number": 147,
        "title": "Insertion Sort List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        prev = head\n        curr = head.next\n        while curr:\n            if curr.val < prev.val:\n                prev.next = curr.next\n                curr.next = prev\n                prev = curr\n            curr = curr.next\n        return head\n"
    },
    {
        "number": 148,
        "title": "Sort List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        if not head.next:\n            return head\n        if not head.next.next:\n            return head\n        \n        # find the middle node\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        slow.next = None\n        reverse = self.sortList(head)\n        \n        # merge the two halves\n        head = self.merge(reverse, head)\n        \n        return head"
    },
    {
        "number": 149,
        "title": "Max Points on a Line",
        "difficulty": 2,
        "answer": "        if not points:\n            return 0"
    },
    {
        "number": 150,
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": 1,
        "answer": "        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(a / b)\n            else:\n                stack.append(int(token))\n        return stack.pop()"
    },
    {
        "number": 151,
        "title": "Reverse Words in a String",
        "difficulty": 1,
        "answer": "        s = s.strip()\n        s = s.replace('  ','')\n        s = s.replace('\\n','')\n        s = s.replace('\\t','')\n        s = s.replace('\\r','')\n        s = s.replace('\\f','')\n        s = s.replace('\\v','')\n        s = s.replace('\\a','')\n        s = s.replace('\\b','')\n        s = s.replace('\\e','')\n        s = s.replace('\\c','')\n        s = s.replace('\\n','')\n        s = s.replace('\\r','')\n        s = s.replace('\\f','')\n        s = s.replace('\\v','')\n        s = s.replace('\\a','')\n        s = s.replace('\\b','')\n        s = s.replace('\\e','')\n        s = s."
    },
    {
        "number": 152,
        "title": "Maximum Product Subarray",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0] * nums[1], nums[1] * nums[2], nums[0] * nums[2])\n        if n == 4:\n            return max(nums[0] * nums[1] * nums[2], nums[1] * nums[2] * nums[3], nums[0] * nums[1] * nums[3], nums[0] * nums[2] * nums[3], nums[1] * nums[2] * nums[3], nums[0] * nums[1] * nums[2])\n        if n == 5:\n            return max(nums[0] * nums[1] * nums[2] * nums[3],"
    },
    {
        "number": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        if n == 3:\n            return min(nums[0], min(nums[1], nums[2]))\n        if n == 4:\n            return min(nums[0], min(nums[1], min(nums[2], nums[3])))\n        if n == 5:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], nums[4]))))\n        if n == 6:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], min(nums[4], nums[5])))))\n        if n == 7:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], min(nums"
    },
    {
        "number": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        if n == 3:\n            return min(nums[0], min(nums[1], nums[2]))\n        if n == 4:\n            return min(nums[0], min(nums[1], min(nums[2], nums[3])))\n        if n == 5:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], nums[4]))))\n        if n == 6:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], min(nums[4], nums[5])))))\n        if n == 7:\n            return min(nums[0], min(nums[1], min(nums[2], min(nums[3], min(nums"
    },
    {
        "number": 155,
        "title": "Min Stack",
        "difficulty": 1,
        "answer": "        self.stack = []\n        self.min = None\n        self.min_stack = []\n        self.min_stack.append(val)\n        self.min = val\n        self.stack.append(val)\n        while len(self.stack) > 0:\n            if self.min == None or self.min > self.stack[-1]:\n                self.min = self.stack[-1]\n            self.stack.pop()\n            self.min_stack.pop()\n            if len(self.stack) > 0:\n                self.stack.append(self.stack[-1])\n                self.min_stack.append(self.min_stack[-1])\n        return"
    },
    {
        "number": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": 0,
        "answer": "        if headA is None or headB is None:\n            return None\n        if headA == headB:\n            return headA\n        if headA.next is None or headB.next is None:\n            return None\n        if headA.next == headB:\n            return headA\n        if headA.next.next is None or headB.next.next is None:\n            return None\n        if headA.next.next == headB:\n            return headA.next\n        if headA.next.next.next is None or headB.next.next.next is None:\n            return None\n        if headA.next.next.next == headB:\n            return headA.next.next\n        if headA.next.next.next.next is None or headB.next.next.next is None:\n            return None\n        if headA.next.next.next.next == headB:\n            return headA.next.next.next\n        if headA.next.next.next.next.next is None or headB.next.next.next"
    },
    {
        "number": 162,
        "title": "Find Peak Element",
        "difficulty": 1,
        "answer": "        if not nums:\n            return -1\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"
    },
    {
        "number": 164,
        "title": "Maximum Gap",
        "difficulty": 2,
        "answer": "        if len(nums) < 2:\n            return 0\n        nums.sort()\n        return nums[1] - nums[0]"
    },
    {
        "number": 165,
        "title": "Compare Version Numbers",
        "difficulty": 1,
        "answer": "        def compare(v1, v2):\n            if v1 == v2:\n                return 0\n            if v1 == '0' and v2 == '0':\n                return 0\n            if v1 == '0' and v2!= '0':\n                return -1\n            if v1!= '0' and v2 == '0':\n                return 1\n            v1 = v1.split('.')\n            v2 = v2.split('.')\n            for i in range(min(len(v1), len(v2))):\n                if int(v1[i]) < int(v2[i]):\n                    return -1\n                if int(v1[i]) > int(v2[i]):\n                    return 1\n            if len(v1) < len(v2):\n                return -1\n            if len(v1) > len(v2):\n                return 1\n            return 0"
    },
    {
        "number": 166,
        "title": "Fraction to Recurring Decimal",
        "difficulty": 1,
        "answer": "        if numerator == 0:\n            return \"0\"\n        if denominator == 0:\n            return \"NaN\"\n        if numerator == denominator:\n            return str(numerator)\n        if numerator < 0 and denominator > 0:\n            return \"-\" + self.fractionToDecimal(numerator * -1, denominator * -1)\n        if numerator > 0 and denominator < 0:\n            return \"-\" + self.fractionToDecimal(numerator, denominator * -1)\n        if numerator < 0 and denominator < 0:\n            return \"-\" + self.fractionToDecimal(numerator * -1, denominator)\n        if numerator > 0 and denominator > 0:\n            return self.fractionToDecimal(numerator, denominator)\n        if numerator == denominator:\n            return str(numerator)\n        if numerator < denominator:\n            return self.fractionToDecimal(numerator, denominator - numerator)\n        if numerator > denominator:\n            "
    },
    {
        "number": 167,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": 1,
        "answer": "        n = len(numbers)\n        if n < 2:\n            return []\n        if n == 2:\n            if numbers[0] + numbers[1] == target:\n                return [0, 1]\n            else:\n                return []\n        if n == 3:\n            if numbers[0] + numbers[1] == target:\n                return [0, 1]\n            elif numbers[1] + numbers[2] == target:\n                return [1, 2]\n            else:\n                return []\n        if n == 4:\n            if numbers[0] + numbers[1] == target:\n                return [0, 1]\n            elif numbers[1] + numbers[2] == target:\n                return [1, 2]\n            elif numbers[2] + numbers[3] == target:\n                return [2, 3]\n            else:\n                return []\n        if n == 5:\n            if numbers[0] + numbers[1] == target:\n                return [0, 1]\n            elif numbers[1] + numbers[2] == target"
    },
    {
        "number": 168,
        "title": "Excel Sheet Column Title",
        "difficulty": 0,
        "answer": "        if columnNumber < 1:\n            return \"\"\n        if columnNumber == 1:\n            return \"A\"\n        if columnNumber == 26:\n            return \"Z\"\n        if columnNumber % 26 == 0:\n            return chr(ord(\"A\") + columnNumber / 26 - 1)\n        return chr(ord(\"A\") + columnNumber / 26) + chr(ord(\"A\") + columnNumber % 26)"
    },
    {
        "number": 169,
        "title": "Majority Element",
        "difficulty": 0,
        "answer": "        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        return max(count, key=count.get)\n"
    },
    {
        "number": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-binary-representation/\n        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-decimal-representation/\n        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-octal-representation/\n        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-hexadecimal-representation/\n        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-decimal-representation-using-only-addition-subtraction-and-multiplication/\n        # https://www.geeksforgeeks.org/convert-a-string-representation-of-a-number-to-its-"
    },
    {
        "number": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 0\n        if n == 4:\n            return 1\n        if n == 5:\n            return 1\n        if n == 6:\n            return 2\n        if n == 7:\n            return 1\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 3\n        if n == 11:\n            return 2\n        if n == 12:\n            return 3\n        if n == 13:\n            return 3\n        if n == 14:\n            return 4\n        if n == 15:\n            return 3\n        if n == 16:\n            return 4\n        if n == 17:\n            return 4\n        if n == 18:\n            return 5\n        if n == 19:\n            return 4\n        if n == 20:\n            return 5\n        if n == 21:\n            return 5\n        if n == 22:\n            "
    },
    {
        "number": 173,
        "title": "Binary Search Tree Iterator",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 174,
        "title": "Dungeon Game",
        "difficulty": 2,
        "answer": "        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = dungeon[0][0]\n        for i in range(1, m):\n            dp[i][0] = max(0, dp[i - 1][0] - dungeon[i][0])\n        for j in range(1, n):\n            dp[0][j] = max(0, dp[0][j - 1] - dungeon[0][j])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(0, min(dp[i - 1][j], dp[i][j - 1]) - dungeon[i][j])\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 179,
        "title": "Largest Number",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        result = \"\"\n        for i in range(len(nums)):\n            result += str(nums[i])\n            if i!= len(nums) - 1:\n                result += str(nums[i + 1])\n        return result\n"
    },
    {
        "number": 187,
        "title": "Repeated DNA Sequences",
        "difficulty": 1,
        "answer": "        # dic = {}\n        # for i in range(len(s) - 10 + 1):\n        #     sub = s[i:i + 10]\n        #     if sub in dic:\n        #         dic[sub] += 1\n        #     else:\n        #         dic[sub] = 1\n        # return [k for k, v in dic.items() if v > 1]\n        # dic = {}\n        # for i in range(len(s) - 10 + 1):\n        #     sub = s[i:i + 10]\n        #     if sub in dic:\n        #         dic[sub] += 1\n        #     else:\n        #         dic[sub] = 1\n        # return [k for k, v in dic.items() if v > 1]\n        # dic = {}\n        # for i in range(len(s) - 10 + 1):\n        #     sub = s[i:i + 10]\n        #     if sub in dic:\n        #         dic[sub]"
    },
    {
        "number": 188,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": 2,
        "answer": "        if not prices:\n            return 0\n        if k == 1:\n            return max(prices)\n        dp = [0] * len(prices)\n        dp[0] = prices[0]\n        for i in range(1, len(prices)):\n            dp[i] = max(prices[i] - dp[i - 1], dp[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 189,
        "title": "Rotate Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        k %= n\n        if k == 0:\n            return\n        for i in range(n - k, n):\n            nums[i], nums[i - k] = nums[i - k], nums[i]\n        for i in range(n - k, 0, -1):\n            nums[i], nums[i + k] = nums[i + k], nums[i]\n        "
    },
    {
        "number": 190,
        "title": "Reverse Bits",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n        if n == 5:\n            return 16\n        if n == 6:\n            return 32\n        if n == 7:\n            return 64\n        if n == 8:\n            return 128\n        if n == 9:\n            return 256\n        if n == 10:\n            return 512\n        if n == 11:\n            return 1024\n        if n == 12:\n            return 2048\n        if n == 13:\n            return 4096\n        if n == 14:\n            return 8192\n        if n == 15:\n            return 16384\n        if n == 16:\n            return 32768\n        if n == 17:\n            return 65536\n        if n == 18:\n            return 131072\n        if n == 19:\n            return 262144\n        if n == 20:\n            return 524288\n        if n == 21:\n            return 10"
    },
    {
        "number": 191,
        "title": "Number of 1 Bits",
        "difficulty": 0,
        "answer": "        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/8"
    },
    {
        "number": 198,
        "title": "House Robber",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])\n        return dp[-1]"
    },
    {
        "number": 199,
        "title": "Binary Tree Right Side View",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        result = []\n        self.dfs(root, result)\n        return result"
    },
    {
        "number": 200,
        "title": "Number of Islands",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    count += 1\n                    self.dfs(grid, visited, i, j)\n        return count"
    },
    {
        "number": 201,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": 1,
        "answer": "        if left > right:\n            return 0\n        if left == right:\n            return left\n        if left == 0:\n            return 0\n        if right == 0:\n            return 0\n        if left == 1:\n            return right\n        if right == 2147483647:\n            return 0\n        if left == 2147483647:\n            return right\n        if right - left == 1:\n            return left\n        if right - left == 2:\n            return left\n        if right - left == 3:\n            return left\n        if right - left == 4:\n            return left\n        if right - left == 5:\n            return left\n        if right - left == 6:\n            return left\n        if right - left == 7:\n            return left\n        if right - left == 8:\n            return left\n        if right - left == 9:\n            return left\n        if right - left == 10:\n            return left\n        if right - left == 11:\n            return left\n        if right - left == 12:\n            return left\n        if right - left == 13:\n"
    },
    {
        "number": 202,
        "title": "Happy Number",
        "difficulty": 0,
        "answer": "        if n < 0:\n            return False\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n == 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return False\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return False\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return False\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return False\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            "
    },
    {
        "number": 203,
        "title": "Remove Linked List Elements",
        "difficulty": 0,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n"
    },
    {
        "number": 204,
        "title": "Count Primes",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n % 2 == 0:\n            return 0\n        if n % 3 == 0:\n            return 0\n        if n < 4:\n            return 1\n        if n < 9:\n            return 2\n        if n < 25:\n            return 3\n        if n < 100:\n            return 5\n        if n < 1000:\n            return 7\n        if n < 10000:\n            return 11\n        if n < 100000:\n            return 17\n        if n < 1000000:\n            return 23\n        if n < 10000000:\n            return 29\n        if n < 100000000:\n            return 31\n        if n < 1000000000:\n            return 37\n        if n < 10000000000:\n            return 41\n        if n < 100000000000:\n            return 43\n        if n < 1000000000000:\n            return 47\n        if n < 10000000000000:\n            return 53\n        if n < 100000000000000:\n            return 59\n        "
    },
    {
        "number": 205,
        "title": "Isomorphic Strings",
        "difficulty": 0,
        "answer": "        if len(s)!= len(t):\n            return False\n        if len(s) == 0:\n            return True\n        if s == t:\n            return True\n        if s[0]!= t[0]:\n            return False\n        if self.isIsomorphic(s[1:], t[1:]):\n            return True\n        return False"
    },
    {
        "number": 206,
        "title": "Reverse Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev\n"
    },
    {
        "number": 207,
        "title": "Course Schedule",
        "difficulty": 1,
        "answer": "        graph = [[] for _ in range(numCourses)]\n        for pre in prerequisites:\n            graph[pre[1]].append(pre[0])\n        \n        def dfs(i):\n            if i in visited:\n                return False\n            visited.add(i)\n            for j in graph[i]:\n                if not dfs(j):\n                    return False\n            return True\n        \n        visited = set()\n        for i in range(numCourses):\n            if dfs(i):\n                return True\n        return False\n"
    },
    {
        "number": 208,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": 1,
        "answer": "        self.root = TrieNode(0)\n        for i in range(len(word)):\n            self.insert(word[i], i, self.root)\n        return self.search(word)"
    },
    {
        "number": 209,
        "title": "Minimum Size Subarray Sum",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            return 0\n        if not nums:\n            "
    },
    {
        "number": 210,
        "title": "Course Schedule II",
        "difficulty": 1,
        "answer": "        # dfs\n        graph = [[] for _ in range(numCourses)]\n        for i, j in prerequisites:\n            graph[i].append(j)\n        \n        def dfs(i):\n            if i in visited:\n                return\n            visited.add(i)\n            for j in graph[i]:\n                dfs(j)\n            res.append(i)\n        \n        res = []\n        visited = set()\n        for i in range(numCourses):\n            dfs(i)\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 211,
        "title": "Design Add and Search Words Data Structure",
        "difficulty": 1,
        "answer": "        # Your WordDictionary object will be instantiated and called as such:\n        # obj = WordDictionary()\n        # obj.addWord(word)\n        # param_2 = obj.search(word)\n        self.words = {}\n        for word in word.split():\n            self.words[word] = True\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in word.split():\n            self.words[word] = False\n        for word in"
    },
    {
        "number": 212,
        "title": "Word Search II",
        "difficulty": 2,
        "answer": "        def dfs(board, words, i, j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] not in words:\n                return\n            board[i][j] = '#'\n            words.append(board[i][j])\n            for di in [-1, 0, 1]:\n                for dj in [-1, 0, 1]:\n                    dfs(board, words, i + di, j + dj)"
    },
    {
        "number": 213,
        "title": "House Robber II",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        return dp[-1]"
    },
    {
        "number": 214,
        "title": "Shortest Palindrome",
        "difficulty": 2,
        "answer": "        def is_palindrome(s):\n            return s == s[::-1]"
    },
    {
        "number": 215,
        "title": "Kth Largest Element in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 1:\n            return max(nums)\n        if k > n:\n            return nums[-1]\n        if k == n:\n            return nums[0]\n        pivot = self.partition(nums, 0, n - 1)\n        if pivot == k - 1:\n            return nums[pivot]\n        if pivot > k - 1:\n            return self.findKthLargest(nums[:pivot], k)\n        return self.findKthLargest(nums[pivot + 1:], k - pivot - 1)"
    },
    {
        "number": 216,
        "title": "Combination Sum III",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return []\n        if k == 1:\n            return [[i] for i in range(1, n + 1)]\n        if n == 0:\n            return []\n        if n == 1:\n            return [[i] for i in range(1, k + 1)]\n        if k == 2:\n            return [[i, i + 1] for i in range(1, n + 1)]\n        if n == 2:\n            return [[i, i + 1] for i in range(1, k + 1)]\n        if k == 3:\n            return [[i, i + 1, i + 2] for i in range(1, n + 1)]\n        if n == 3:\n            return [[i, i + 1, i + 2] for i in range(1, k + 1)]\n        if k == 4:\n            return [[i, i + 1, i + 2, i + 3] for i in range(1, n + 1)]\n        if n == 4:\n            return [[i, i + 1, i + 2, i + 3]"
    },
    {
        "number": 217,
        "title": "Contains Duplicate",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return True\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]\n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[1] == nums[2] or nums[1] == nums[3] or nums[2] == nums[3]\n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or"
    },
    {
        "number": 218,
        "title": "The Skyline Problem",
        "difficulty": 2,
        "answer": "        heights = [0] * len(buildings)\n        for i in range(len(buildings)):\n            heights[i] = buildings[i][2]\n        heights.sort()\n        result = []\n        for i in range(len(heights)):\n            if i == 0 or heights[i]!= heights[i - 1]:\n                result.append([buildings[i][0], heights[i]])\n        return result\n"
    },
    {
        "number": 219,
        "title": "Contains Duplicate II",
        "difficulty": 0,
        "answer": "        if len(nums) < 2:\n            return False\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if k == 0:\n            return False\n        if k > len(nums) / 2:\n            k = len(nums) - k\n        if k == 1:\n            return nums[0] == nums[1]\n        if k == 2:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]\n        if k == 3:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2] or nums[0] == nums[3] or nums[1] == nums[3] or nums[2] == nums[3]\n        if k == 4:\n            return nums[0] == nums[1] or nums[0] == num"
    },
    {
        "number": 220,
        "title": "Contains Duplicate III",
        "difficulty": 2,
        "answer": "        if not nums:\n            return False\n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        if indexDiff > len(nums) or valueDiff > len(nums):\n            return False\n        if indexDiff == 0 and valueDiff == 0:\n            return True\n        if indexDiff == 0:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n        if valueDiff == 0:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n        if indexDiff == 1:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n        if valueDiff == 1:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n        if indexDiff == 2:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n        if valueDiff == 2:\n            return self.containsNearbyAlmostDuplicate(nums, indexDiff"
    },
    {
        "number": 221,
        "title": "Maximal Square",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = 1\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and dp[k][l] == 1:\n                                dp[i][j] = max(dp[i][j], dp[k][l] + 1)\n        return max(dp[i][j] for i in range(m) for j in range(n)) ** 2"
    },
    {
        "number": 222,
        "title": "Count Complete Tree Nodes",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        return self.helper(root, 1)"
    },
    {
        "number": 223,
        "title": "Rectangle Area",
        "difficulty": 1,
        "answer": "        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1)"
    },
    {
        "number": 224,
        "title": "Basic Calculator",
        "difficulty": 2,
        "answer": "        stack = []\n        for i in s:\n            if i.isdigit():\n                stack.append(int(i))\n            elif i == '+':\n                a, b = stack.pop(), stack.pop()\n                stack.append(a + b)\n            elif i == '-':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif i == '*':\n                a, b = stack.pop(), stack.pop()\n                stack.append(a * b)\n            elif i == '/':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b / a)\n            elif i == '(':\n                stack.append(stack.pop())\n            elif i == ')':\n                a = stack.pop()\n                b = stack.pop()\n                stack.append(b)\n                stack.append(a)\n        return stack.pop()\n"
    },
    {
        "number": 225,
        "title": "Implement Stack using Queues",
        "difficulty": 0,
        "answer": "        self.q1 = []\n        self.q2 = []\n        self.q1.append(x)\n        while len(self.q1) > 0:\n            self.q2.append(self.q1.pop())\n        return self.q2.pop()"
    },
    {
        "number": 226,
        "title": "Invert Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return None\n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        root.left, root.right = right, left\n        return root\n"
    },
    {
        "number": 227,
        "title": "Basic Calculator II",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in s:\n            if c.isdigit():\n                stack.append(int(c))\n            elif c == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif c == '-':\n                stack.append(-stack.pop() + stack.pop())\n            elif c == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif c == '/':\n                a, b = stack.pop(), stack.pop()\n                stack.append(b // a)\n            elif c == '(':\n                stack.append(stack.pop())\n            elif c == ')':\n                stack.append(stack.pop())\n        return stack.pop()\n"
    },
    {
        "number": 228,
        "title": "Summary Ranges",
        "difficulty": 0,
        "answer": "        if not nums:\n            return []\n        n = len(nums)\n        if n == 1:\n            return [str(nums[0])]\n        if n == 2:\n            return [str(nums[0]), str(nums[1])]\n        if n == 3:\n            return [str(nums[0]), str(nums[1]), str(nums[2])]\n        if n == 4:\n            return [str(nums[0]), str(nums[1]), str(nums[2]), str(nums[3])]\n        if n == 5:\n            return [str(nums[0]), str(nums[1]), str(nums[2]), str(nums[3]), str(nums[4])]\n        if n == 6:\n            return [str(nums[0]), str(nums[1]), str(nums[2]), str(nums[3]), str(nums[4]), str(nums[5])]\n        if n == 7:\n            return [str"
    },
    {
        "number": 229,
        "title": "Majority Element II",
        "difficulty": 1,
        "answer": "        count = collections.Counter(nums)\n        return [x for x, c in count.items() if c > len(nums) / 3]\n"
    },
    {
        "number": 230,
        "title": "Kth Smallest Element in a BST",
        "difficulty": 1,
        "answer": "        if not root:\n            return -1\n        if not root.left and not root.right:\n            return root.val\n        if not root.left:\n            return self.kthSmallest(root.right, k)\n        if not root.right:\n            return self.kthSmallest(root.left, k)\n        return self.kthSmallest(root.left, k) + self.kthSmallest(root.right, k) + 1"
    },
    {
        "number": 231,
        "title": "Power of Two",
        "difficulty": 0,
        "answer": "        if n < 0:\n            return False\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 2 == 0:\n            return False\n        return True\n"
    },
    {
        "number": 232,
        "title": "Implement Queue using Stacks",
        "difficulty": 0,
        "answer": "        self.stack1 = []\n        self.stack2 = []\n        self.stack3 = []\n        self.stack4 = []\n        self.stack5 = []\n        self.stack6 = []\n        self.stack7 = []\n        self.stack8 = []\n        self.stack9 = []\n        self.stack10 = []\n        self.stack11 = []\n        self.stack12 = []\n        self.stack13 = []\n        self.stack14 = []\n        self.stack15 = []\n        self.stack16 = []\n        self.stack17 = []\n        self.stack18 = []\n        self.stack19 = []\n        self.stack20 = []\n        self.stack21 = []\n        self.stack22 = []\n        self.stack23 = []\n        self.stack24 = []\n        self.stack25 = []\n        self.stack26 = []\n        self.stack27 = []\n        self.stack28 = []\n        self.stack29 = []\n        self.stack30 = []\n        self.stack31 = []\n        self"
    },
    {
        "number": 233,
        "title": "Number of Digit One",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        dp = [0] * 10\n        for i in range(1, n + 1):\n            dp[i % 10] += 1\n        return sum(dp)\n"
    },
    {
        "number": 234,
        "title": "Palindrome Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return True\n        slow = head\n        fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        if not fast:\n            return True\n        slow = head\n        while slow and fast:\n            if slow.val!= fast.val:\n                return False\n            slow = slow.next\n            fast = fast.next\n        return True\n"
    },
    {
        "number": 235,
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if root is None or p is None or q is None:\n            return None\n        if root == p or root == q:\n            return root\n        if p.val > q.val:\n            p, q = q, p\n        if p.val < root.val and q.val < root.val:\n            return root\n        if p.val < root.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        if q.val > root.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        return root"
    },
    {
        "number": 236,
        "title": "Lowest Common Ancestor of a Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right"
    },
    {
        "number": 237,
        "title": "Delete Node in a Linked List",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        #\n        # class Solution:\n        #     def deleteNode(self, node):\n        #         \"\"\"\n        #         :type node: ListNode\n        #         :rtype: void Do not return anything, modify node in-place instead.\n        #         There is a singly-linked list head and we want to delete a node node in it.\n        #         You are given the node to be deleted node. You will not be given access to the first node of head.\n        #         All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n"
    },
    {
        "number": 238,
        "title": "Product of Array Except Self",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0] * nums[1]]\n        if n == 3:\n            return [nums[0] * nums[1] * nums[2]]\n        if n == 4:\n            return [nums[0] * nums[1] * nums[2] * nums[3]]\n        if n == 5:\n            return [nums[0] * nums[1] * nums[2] * nums[3] * nums[4]]\n        if n == 6:\n            return [nums[0] * nums[1] * nums[2] * nums[3] * nums[4] * nums[5]]\n        if n == 7:\n            return [nums[0] * nums[1] * nums[2] * nums[3] * nums[4] * nums[5"
    },
    {
        "number": 239,
        "title": "Sliding Window Maximum",
        "difficulty": 2,
        "answer": "        if len(nums) == 0:\n            return []\n        if k == 1:\n            return nums\n        if k == 2:\n            return [max(nums[0], nums[1])]\n        if k == 3:\n            return [max(nums[0], nums[1]), max(nums[1], nums[2])]\n        if k == 4:\n            return [max(nums[0], nums[1]), max(nums[1], nums[2]), max(nums[2], nums[3])]\n        if k == 5:\n            return [max(nums[0], nums[1]), max(nums[1], nums[2]), max(nums[2], nums[3]), max(nums[3], nums[4])]\n        if k == 6:\n            return [max(nums[0], nums[1]), max(nums[1], nums[2]), max(nums[2], nums[3]), max(nums[3], nums"
    },
    {
        "number": 240,
        "title": "Search a 2D Matrix II",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        i, j = 0, n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] < target:\n                i += 1\n            else:\n                j -= 1\n        return False\n"
    },
    {
        "number": 241,
        "title": "Different Ways to Add Parentheses",
        "difficulty": 1,
        "answer": "        def dfs(expression, result, curr_val, curr_op):\n            if not expression:\n                result.append(curr_val)\n                return\n            if curr_op == '+':\n                dfs(expression[1:], result, curr_val + curr_val, curr_op)\n            elif curr_op == '-':\n                dfs(expression[1:], result, curr_val - curr_val, curr_op)\n            elif curr_op == '*':\n                dfs(expression[1:], result, curr_val * curr_val, curr_op)\n            elif curr_op == '/':\n                dfs(expression[1:], result, curr_val / curr_val, curr_op)\n            elif curr_op == '^':\n                dfs(expression[1:], result, curr_val ** curr_val, curr_op)\n            else:\n                raise Exception('Invalid operator')"
    },
    {
        "number": 242,
        "title": "Valid Anagram",
        "difficulty": 0,
        "answer": "        return sorted(s) == sorted(t)"
    },
    {
        "number": 257,
        "title": "Binary Tree Paths",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        if not root.left and not root.right:\n            return [str(root.val)]\n        paths = []\n        self.dfs(root, paths)\n        return paths"
    },
    {
        "number": 258,
        "title": "Add Digits",
        "difficulty": 0,
        "answer": "        if num < 10:\n            return num\n        \n        result = 0\n        while num > 0:\n            result += num % 10\n            num /= 10\n        return result\n"
    },
    {
        "number": 260,
        "title": "Single Number III",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if len(nums) == 2:\n            return nums\n        if len(nums) == 1:\n            return [nums[0]]\n        if len(nums) == 0:\n            return []\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i]!= nums[j]:\n                return [nums[i], nums[j]]\n            i += 1\n            j -= 1\n        return [nums[i]]\n"
    },
    {
        "number": 263,
        "title": "Ugly Number",
        "difficulty": 0,
        "answer": "        if n < 1:\n            return False\n        if n == 1:\n            return True\n        if n % 2 == 0:\n            return False\n        if n % 3 == 0:\n            return False\n        if n % 5 == 0:\n            return False\n        return True\n"
    },
    {
        "number": 264,
        "title": "Ugly Number II",
        "difficulty": 1,
        "answer": "        if n < 1:\n            return 0\n        ugly = [1]\n        for i in range(1, n):\n            ugly.append(min(ugly[-1] * 2, ugly[-1] * 3, ugly[-1] * 5))\n        return ugly[-1]\n"
    },
    {
        "number": 268,
        "title": "Missing Number",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1 - nums[0]\n        if n == 2:\n            return 1 - nums[0] - nums[1]\n        if n == 3:\n            return 1 - nums[0] - nums[1] - nums[2]\n        if n == 4:\n            return 1 - nums[0] - nums[1] - nums[2] - nums[3]\n        if n == 5:\n            return 1 - nums[0] - nums[1] - nums[2] - nums[3] - nums[4]\n        if n == 6:\n            return 1 - nums[0] - nums[1] - nums[2] - nums[3] - nums[4] - nums[5]\n        if n == 7:\n            return 1 - nums[0] - nums[1] - nums[2] - nums[3] - nums["
    },
    {
        "number": 273,
        "title": "Integer to English Words",
        "difficulty": 2,
        "answer": "        words = []\n        if num == 0:\n            return \"Zero\"\n        if num < 0:\n            return \"Negative \" + self.numberToWords(-num)\n        if num < 10:\n            return self.numberToWords_1_10(num)\n        if num < 100:\n            return self.numberToWords_11_99(num)\n        if num < 1000:\n            return self.numberToWords_100_999(num)\n        if num < 1000000:\n            return self.numberToWords_1000_9999(num)\n        if num < 1000000000:\n            return self.numberToWords_1000000_9999999(num)\n        if num < 1000000000000:\n            return self.numberToWords_1000000000_999999999(num)\n        if num < 1000000000000000:\n            return self.numberToWords_10000000000_9999999999(num)\n        if num < 10000000000000000:\n            return self.numberToWords_100000000000_999999999999(num)\n        if num < 100000000000000000:\n            return"
    },
    {
        "number": 274,
        "title": "H-Index",
        "difficulty": 1,
        "answer": "        n = len(citations)\n        if n == 0:\n            return 0\n        citations.sort()\n        h = 0\n        for i in range(n):\n            if citations[i] >= h:\n                h += 1\n            else:\n                break\n        return h\n"
    },
    {
        "number": 275,
        "title": "H-Index II",
        "difficulty": 1,
        "answer": "        citations.sort()\n        n = len(citations)\n        if n == 0:\n            return 0\n        if n == 1:\n            return citations[0]\n        h = 0\n        for i in range(n):\n            if citations[i] >= n - h:\n                h += 1\n        return h\n"
    },
    {
        "number": 278,
        "title": "First Bad Version",
        "difficulty": 0,
        "answer": "        # binary search\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"
    },
    {
        "number": 279,
        "title": "Perfect Squares",
        "difficulty": 1,
        "answer": "        if n < 0:\n            return 0\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 3\n        if n == 7:\n            return 4\n        if n == 8:\n            return 4\n        if n == 9:\n            return 4\n        if n == 10:\n            return 5\n        if n == 11:\n            return 5\n        if n == 12:\n            return 5\n        if n == 13:\n            return 6\n        if n == 14:\n            return 6\n        if n == 15:\n            return 7\n        if n == 16:\n            return 7\n        if n == 17:\n            return 8\n        if n == 18:\n            return 8\n        if n == 19:\n            return 9\n        if n == 20:\n            return 9\n        if n == 21:\n            "
    },
    {
        "number": 282,
        "title": "Expression Add Operators",
        "difficulty": 2,
        "answer": "        res = []\n        self.dfs(num, target, 0, [], res)\n        return res"
    },
    {
        "number": 283,
        "title": "Move Zeroes",
        "difficulty": 0,
        "answer": "        i = 0\n        while i < len(nums) and nums[i] == 0:\n            i += 1\n        if i == len(nums):\n            return\n        j = len(nums) - 1\n        while j > i and nums[j]!= 0:\n            j -= 1\n        nums[i:j+1] = nums[i:j+1][::-1]\n        nums[i] = 0"
    },
    {
        "number": 284,
        "title": "Peeking Iterator",
        "difficulty": 1,
        "answer": "        class PeekingIterator:\n            def __init__(self, nums):\n                self.nums = nums\n                self.index = 0"
    },
    {
        "number": 287,
        "title": "Find the Duplicate Number",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n <= 2:\n            return -1\n        # sort the array\n        nums.sort()\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element\n        mid = n // 2\n        # find the middle element"
    },
    {
        "number": 289,
        "title": "Game of Life",
        "difficulty": 1,
        "answer": "        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 1:\n                    count = 0\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and board[k][l] == 1:\n                                count += 1\n                    if count < 2:\n                        board[i][j] = 0\n                    elif count == 2 or count == 3:\n                        board[i][j] = 1\n                else:\n                    count = 0\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and board[k][l] == 1:\n                                count += 1\n                    if count == 3:\n                        board[i][j] = 1\n        for i in range(m):"
    },
    {
        "number": 290,
        "title": "Word Pattern",
        "difficulty": 0,
        "answer": "        if not pattern:\n            return True\n        if not s:\n            return False\n        if len(pattern)!= len(s):\n            return False\n        if len(pattern) == 1:\n            return pattern[0] == s[0]\n        if len(pattern) == 2:\n            return pattern[0] == s[0] and pattern[1] == s[1]\n        if len(pattern) == 3:\n            return pattern[0] == s[0] and pattern[1] == s[1] and pattern[2] == s[2]\n        if len(pattern) == 4:\n            return pattern[0] == s[0] and pattern[1] == s[1] and pattern[2] == s[2] and pattern[3] == s[3]\n        if len(pattern) == 5:\n            return pattern[0] == s[0] and pattern[1] == s[1] and pattern[2] == s[2] and pattern[3] == s[3] and pattern[4] == s[4]\n        if len("
    },
    {
        "number": 292,
        "title": "Nim Game",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/nim-game-2/\n        # https://www.geeksforgeeks.org/nim-game-1/\n        # https://www.geeksforgeeks.org/nim-game-3/\n        # https://www.geeksforgeeks.org/nim-game-4/\n        # https://www.geeksforgeeks.org/nim-game-5/\n        # https://www.geeksforgeeks.org/nim-game-6/\n        # https://www.geeksforgeeks.org/nim-game-7/\n        # https://www.geeksforgeeks.org/nim-game-8/\n        # https://www.geeksforgeeks.org/nim-game-9/\n        # https://www.geeksforgeeks.org/nim-game-10/\n        # https://www.geeksforgeeks.org/nim-game-11/\n        # https://www.geeksforgeeks.org/nim-game-12"
    },
    {
        "number": 295,
        "title": "Find Median from Data Stream",
        "difficulty": 2,
        "answer": "        # Your MedianFinder object will be instantiated and called as such:\n        # obj = MedianFinder()\n        # obj.addNum(num)\n        # param_2 = obj.findMedian()\n        # obj = MedianFinder()\n        # obj.addNum(num)\n        # param_3 = obj.findMedian()\n        self.nums = []\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append(0)\n        self.nums.append"
    },
    {
        "number": 297,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": 2,
        "answer": "        if root is None:\n            return \"\"\n        return self.serialize(root.left) + str(root.val) + self.serialize(root.right)"
    },
    {
        "number": 299,
        "title": "Bulls and Cows",
        "difficulty": 1,
        "answer": "        bulls = 0\n        cows = 0\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                if secret[i] in guess[i]:\n                    cows += 1\n        return str(bulls) + 'A' + str(cows) + 'B'\n"
    },
    {
        "number": 300,
        "title": "Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 301,
        "title": "Remove Invalid Parentheses",
        "difficulty": 2,
        "answer": "        # DP\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp"
    },
    {
        "number": 303,
        "title": "Range Sum Query - Immutable",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return 0\n        if left == right:\n            return nums[left]\n        if left > right:\n            return 0\n        if left == right - 1:\n            return nums[left] + nums[right]\n        if left + 1 == right:\n            return nums[left] + nums[right]\n        if left + 2 == right:\n            return nums[left] + nums[right]\n        if left + 3 == right:\n            return nums[left] + nums[right]\n        if left + 4 == right:\n            return nums[left] + nums[right]\n        if left + 5 == right:\n            return nums[left] + nums[right]\n        if left + 6 == right:\n            return nums[left] + nums[right]\n        if left + 7 == right:\n            return nums[left] + nums[right]\n        if left + 8 == right:\n            return nums[left] + nums[right]\n        if"
    },
    {
        "number": 304,
        "title": "Range Sum Query 2D - Immutable",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 306,
        "title": "Additive Number",
        "difficulty": 1,
        "answer": "        if len(num) < 3:\n            return False\n        if num[0] == '0':\n            return False\n        if num[0] == '1' and num[1] == '0':\n            return False\n        if num[0] == '1' and num[1] == '1':\n            return True\n        if num[0] == '1' and num[1] == '2':\n            return True\n        if num[0] == '2' and num[1] == '3':\n            return True\n        if num[0] == '3' and num[1] == '5':\n            return True\n        if num[0] == '5' and num[1] == '8':\n            return True\n        if num[0] == '8' and num[1] == '9':\n            return True\n        if num[0] == '9' and num[1] == '0':\n            return True\n        if num[0] == '0' and num[1] == '0':\n            return False\n        if num[0"
    },
    {
        "number": 307,
        "title": "Range Sum Query - Mutable",
        "difficulty": 1,
        "answer": "        if left > right:\n            return 0\n        if left == right:\n            return nums[left]\n        if left == right - 1:\n            return nums[left] + nums[right]\n        if left == right - 2:\n            return nums[left] + nums[right] - nums[left + 1]\n        if left == right - 3:\n            return nums[left] + nums[right] - nums[left + 1] - nums[left + 2]\n        if left == right - 4:\n            return nums[left] + nums[right] - nums[left + 1] - nums[left + 2] - nums[left + 3]\n        if left == right - 5:\n            return nums[left] + nums[right] - nums[left + 1] - nums[left + 2] - nums[left + 3] - nums[left + 4]\n        if left == right - 6:\n            return nums[left] + nums[right] - nums[left + 1"
    },
    {
        "number": 309,
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": 1,
        "answer": "        n = len(prices)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = prices[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(prices[i] - dp[i + 1][i], 0)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + prices[i] - dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 310,
        "title": "Minimum Height Trees",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [0]\n        if n == 2:\n            return [0, 1]\n        if n == 3:\n            return [0, 1, 2]\n        if n == 4:\n            return [0, 1, 2, 3]\n        if n == 5:\n            return [0, 1, 2, 3, 4]\n        if n == 6:\n            return [0, 1, 2, 3, 4, 5]\n        if n == 7:\n            return [0, 1, 2, 3, 4, 5, 6]\n        if n == 8:\n            return [0, 1, 2, 3, 4, 5, 6, 7]\n        if n == 9:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 10:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        if n == 11:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,"
    },
    {
        "number": 312,
        "title": "Burst Balloons",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + nums[i] * nums[j]\n        return max(dp[0][n], dp[n][0])\n"
    },
    {
        "number": 313,
        "title": "Super Ugly Number",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        ugly = [1]\n        for i in range(1, n):\n            ugly.append(min(ugly[-1] * primes[0], ugly[-1] * primes[1], ugly[-1] * primes[2]))\n        return ugly[-1]\n"
    },
    {
        "number": 315,
        "title": "Count of Smaller Numbers After Self",
        "difficulty": 2,
        "answer": "        counts = [0] * len(nums)\n        for i in range(len(nums)):\n            counts[i] = i\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j]:\n                    counts[j] = i\n        return counts"
    },
    {
        "number": 316,
        "title": "Remove Duplicate Letters",
        "difficulty": 1,
        "answer": "        if not s: return \"\"\n        count = {}\n        for c in s:\n            count[c] = count.get(c, 0) + 1\n        for c in count:\n            if count[c] == 1:\n                s = s.replace(c, \"\")\n        return s\n"
    },
    {
        "number": 318,
        "title": "Maximum Product of Word Lengths",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) * len(words[i]) * len(words[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) * len(words[i]) * len(words[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) * len(words[i]) * len(words[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) * len(words[i]) * len(words[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) * len(words[i]) * len(words[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) *"
    },
    {
        "number": 319,
        "title": "Bulb Switcher",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 321,
        "title": "Create Maximum Number",
        "difficulty": 2,
        "answer": "        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        n = len(nums1)\n        m = len(nums2)\n        if k > m + n:\n            return []\n        if k == 1:\n            return [max(nums1[-1], nums2[-1])]\n        if k == 2:\n            return [nums1[-1], nums2[-1]]\n        if k == 3:\n            return [nums1[-1], nums2[-1], nums1[-2], nums2[-2]]\n        if k == 4:\n            return [nums1[-1], nums2[-1], nums1[-2], nums2[-2], nums1[-3], nums2[-3]]\n        if k == 5:\n            return [nums1[-1], nums2[-1], nums1[-2], nums2[-2], nums1[-3], nums2"
    },
    {
        "number": 322,
        "title": "Coin Change",
        "difficulty": 1,
        "answer": "        coins.sort()\n        dp = [0] * (amount + 1)\n        dp[0] = 0\n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if i >= coins[j]:\n                    dp[i] = max(dp[i], dp[i - coins[j]] + 1)\n        return dp[amount] if dp[amount]!= 0 else -1\n"
    },
    {
        "number": 324,
        "title": "Wiggle Sort II",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return\n        for i in range(1, n):\n            if nums[i] > nums[i - 1]:\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n        for i in range(n - 2, -1, -1):\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        for i in range(n - 1, 0, -1):\n            if nums[i] > nums[i - 1]:\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n"
    },
    {
        "number": 326,
        "title": "Power of Three",
        "difficulty": 0,
        "answer": "        if n < 0:\n            return False\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 == 0:\n            return True\n        return False\n"
    },
    {
        "number": 327,
        "title": "Count of Range Sum",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        if lower == upper:\n            return 1\n        if lower > upper:\n            return 0\n        if lower == 0:\n            return self.countRangeSum(nums, 0, upper)\n        if upper == 0:\n            return self.countRangeSum(nums, lower, 0)\n        if lower == upper:\n            return self.countRangeSum(nums, lower, upper)\n        if lower == 1:\n            return self.countRangeSum(nums, lower, upper)\n        if upper == 1:\n            return self.countRangeSum(nums, lower, upper)\n        if lower == 2:\n            return self.countRangeSum(nums, lower, upper)\n        if upper == 2:\n            return self.countRangeSum(nums, lower, upper)\n        if lower == 3:\n            return self.countRangeSum(nums, lower, upper)\n        if upper == 3:\n            return self.countRangeSum(nums, lower, upper)\n        if lower == 4:\n            return self"
    },
    {
        "number": 328,
        "title": "Odd Even Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        odd = head\n        even = head\n        while odd and even:\n            odd = odd.next\n            even = even.next\n        odd.next = even\n        return head\n"
    },
    {
        "number": 329,
        "title": "Longest Increasing Path in a Matrix",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return max(dp[m - 1][n - 1], max(dp[m - 1][n - 2], max(dp[m - 2][n - 1], dp[m - 2][n - 2])))\n"
    },
    {
        "number": 330,
        "title": "Patching Array",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        n = min(n, len(nums))\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j] + 1\n        for i in range(n + 1):\n            dp[i][i] = 0\n        for i in range(n + 1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j])\n        return dp[n][n]\n"
    },
    {
        "number": 331,
        "title": "Verify Preorder Serialization of a Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(preorder, i, j):\n            if i >= len(preorder) or j >= len(preorder):\n                return False\n            if preorder[i] == '#' and preorder[j] == '#':\n                return True\n            if preorder[i] == '#':\n                return dfs(preorder, i + 1, j)\n            if preorder[j] == '#':\n                return dfs(preorder, i, j + 1)\n            if preorder[i]!= '#' and preorder[j]!= '#':\n                return preorder[i] == preorder[j] and dfs(preorder, i + 1, j + 1)\n            return False"
    },
    {
        "number": 332,
        "title": "Reconstruct Itinerary",
        "difficulty": 2,
        "answer": "        tickets = sorted(tickets, key=lambda x: (x[0], x[1]))\n        n = len(tickets)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if tickets[i][0] == tickets[j][0]:\n                    dp[i][j] = dp[j][i]\n                else:\n                    dp[i][j] = dp[j][i] + dp[j][i - 1]\n        ans = []\n        for i in range(n):\n            ans.append(tickets[i][0])\n            for j in range(i + 1, n):\n                if dp[i][j] == dp[i][j - 1]:\n                    ans.append(tickets[i][1])\n                    break\n        return ans\n"
    },
    {
        "number": 334,
        "title": "Increasing Triplet Subsequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return False\n        for i in range(n - 2):\n            if nums[i] > nums[i + 1]:\n                for j in range(i + 2, n):\n                    if nums[j] > nums[i + 1] and nums[j] < nums[i]:\n                        return True\n        return False\n"
    },
    {
        "number": 335,
        "title": "Self Crossing",
        "difficulty": 2,
        "answer": "        n = len(distance)\n        if n < 4:\n            return False\n        if n == 4:\n            return distance[0]!= distance[3] and distance[1]!= distance[2]\n        if n == 5:\n            return distance[0]!= distance[3] and distance[1]!= distance[4]\n        if n == 6:\n            return distance[0]!= distance[3] and distance[1]!= distance[4] and distance[2]!= distance[5]\n        if n == 7:\n            return distance[0]!= distance[3] and distance[1]!= distance[4] and distance[2]!= distance[6]\n        if n == 8:\n            return distance[0]!= distance[3] and distance[1]!= distance[4] and distance[2]!= distance[5] and distance[6]!= distance[7]\n        if n == 9:\n            return distance[0]!= distance[3] and distance[1]!= distance[4] and distance[2]!= distance[5] and distance[6]!= distance["
    },
    {
        "number": 336,
        "title": "Palindrome Pairs",
        "difficulty": 2,
        "answer": "        result = []\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i] + words[j] == words[j] + words[i]:\n                    result.append([i, j])\n        return result"
    },
    {
        "number": 337,
        "title": "House Robber III",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        if not root.left:\n            return self.rob(root.right)\n        if not root.right:\n            return self.rob(root.left)\n        return max(self.rob(root.left), self.rob(root.right)) + max(self.rob(root.left.left), self.rob(root.left.right)) + max(self.rob(root.right.left), self.rob(root.right.right))"
    },
    {
        "number": 338,
        "title": "Counting Bits",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return [0]\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans"
    },
    {
        "number": 341,
        "title": "Flatten Nested List Iterator",
        "difficulty": 1,
        "answer": "        class NestedIterator(object):\n            def __init__(self, nestedList):\n                self.nestedList = nestedList\n                self.index = 0"
    },
    {
        "number": 342,
        "title": "Power of Four",
        "difficulty": 0,
        "answer": "        if n < 1:\n            return False\n        if n == 1:\n            return True\n        if n % 4!= 0:\n            return False\n        return self.isPowerOfFour(n // 4)"
    },
    {
        "number": 343,
        "title": "Integer Break",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return max(dp)"
    },
    {
        "number": 344,
        "title": "Reverse String",
        "difficulty": 0,
        "answer": "        for i in range(len(s) // 2):\n            s[i], s[-i - 1] = s[-i - 1], s[i]"
    },
    {
        "number": 345,
        "title": "Reverse Vowels of a String",
        "difficulty": 0,
        "answer": "        vowels = \"aeiou\"\n        return \"\".join(reversed(list(filter(lambda x: x in vowels, s))))\n"
    },
    {
        "number": 347,
        "title": "Top K Frequent Elements",
        "difficulty": 1,
        "answer": "        count = {}\n        for num in nums:\n            count[num] = count.get(num, 0) + 1\n        \n        result = []\n        for key in sorted(count.keys(), key=count.get, reverse=True):\n            if len(result) < k:\n                result.append(key)\n            else:\n                break\n        return result\n"
    },
    {
        "number": 349,
        "title": "Intersection of Two Arrays",
        "difficulty": 0,
        "answer": "        if not nums1 or not nums2:\n            return []\n        nums1.sort()\n        nums2.sort()\n        i = j = 0\n        result = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return result\n"
    },
    {
        "number": 350,
        "title": "Intersection of Two Arrays II",
        "difficulty": 0,
        "answer": "        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        result = []\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return result\n"
    },
    {
        "number": 352,
        "title": "Data Stream as Disjoint Intervals",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 354,
        "title": "Russian Doll Envelopes",
        "difficulty": 2,
        "answer": "        if not envelopes:\n            return 0\n        n = len(envelopes)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i][j] = dp[j][i] + 1\n        return max(max(dp[i]) for i in range(n))\n"
    },
    {
        "number": 355,
        "title": "Design Twitter",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 357,
        "title": "Count Numbers with Unique Digits",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return 10\n        dp = [0] * (10 * n + 1)\n        dp[0] = 1\n        for i in range(1, 10 * n + 1):\n            for j in range(1, 10):\n                dp[i] += dp[i - j]\n        return dp[-1]\n"
    },
    {
        "number": 363,
        "title": "Max Sum of Rectangle No Larger Than K",
        "difficulty": 2,
        "answer": "        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = matrix[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], matrix[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], matrix[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], matrix[i][j])\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j], dp[i][j + 1])\n"
    },
    {
        "number": 365,
        "title": "Water and Jug Problem",
        "difficulty": 1,
        "answer": "        if jug1Capacity + jug2Capacity < targetCapacity:\n            return False\n        if jug1Capacity == 0 or jug2Capacity == 0:\n            return True\n        if jug1Capacity == 1 and jug2Capacity == 1:\n            return True\n        if jug1Capacity == 1 and jug2Capacity == 2:\n            return True\n        if jug1Capacity == 2 and jug2Capacity == 1:\n            return True\n        if jug1Capacity == 2 and jug2Capacity == 2:\n            return True\n        if jug1Capacity == 3 and jug2Capacity == 1:\n            return True\n        if jug1Capacity == 3 and jug2Capacity == 2:\n            return True\n        if jug1Capacity == 3 and jug2Capacity == 3:\n            return True\n        if jug1Capacity == 4 and jug2Capacity == 2:\n            return True\n        if jug1Capacity == 4 and jug2Capacity == 3:\n            return True\n        if jug1Capacity == 4 and jug2Capacity == 4:\n            return"
    },
    {
        "number": 367,
        "title": "Valid Perfect Square",
        "difficulty": 0,
        "answer": "        if num < 0:\n            return False\n        if num == 0:\n            return True\n        if num == 1:\n            return True\n        if num % 2 == 0:\n            return False\n        if num % 3 == 0:\n            return False\n        if num % 5 == 0:\n            return False\n        if num % 7 == 0:\n            return False\n        if num % 11 == 0:\n            return False\n        if num % 13 == 0:\n            return False\n        if num % 17 == 0:\n            return False\n        if num % 19 == 0:\n            return False\n        if num % 23 == 0:\n            return False\n        if num % 29 == 0:\n            return False\n        if num % 31 == 0:\n            return False\n        if num % 37 == 0:\n            return False\n        if num % 41 == 0:\n            return False\n        if num % 43 == 0:\n            return False\n        if num % 47 == 0:\n            return False\n        if num % 53 == 0:\n            return False\n        if num % 59 == 0:\n"
    },
    {
        "number": 368,
        "title": "Largest Divisible Subset",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        for i in range(len(nums)):\n            dp[i][i] = 1\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    dp[i][j] = max(dp[i][j], dp[i][i] + dp[j][j])\n                    dp[i][j] = max(dp[i][j], dp[i][j] + dp[i][i])\n                    dp[i][j] = max(dp[i][j], dp[i][j] + dp[j][j])\n        return dp[0][-1]\n"
    },
    {
        "number": 371,
        "title": "Sum of Two Integers",
        "difficulty": 1,
        "answer": "        if a < 0:\n            a = -a\n        if b < 0:\n            b = -b\n        if a > b:\n            return self.getSum(b, a)\n        if a == 0:\n            return b\n        if b == 0:\n            return a\n        if a == 1:\n            return b + a\n        if b == 1:\n            return a + b\n        if a == 2:\n            return b + a\n        if b == 2:\n            return a + b\n        if a == 3:\n            return b + a\n        if b == 3:\n            return a + b\n        if a == 4:\n            return b + a\n        if b == 4:\n            return a + b\n        if a == 5:\n            return b + a\n        if b == 5:\n            return a + b\n        if a == 6:\n            return b + a\n        if b == 6:\n            return a + b\n        if a == 7:\n            return b + a\n        if b == 7:\n            return a + b\n        "
    },
    {
        "number": 372,
        "title": "Super Pow",
        "difficulty": 1,
        "answer": "        if not b:\n            return 1\n        if a == 1:\n            return self.superPow(b[0], b[1:])\n        if a == 2:\n            return self.superPow(b[0], b[1:]) * self.superPow(b[1], b[2:])\n        if a == 3:\n            return self.superPow(b[0], b[1:]) * self.superPow(b[1], b[2:]) * self.superPow(b[2], b[3:])\n        if a == 4:\n            return self.superPow(b[0], b[1:]) * self.superPow(b[1], b[2:]) * self.superPow(b[2], b[3:]) * self.superPow(b[3], b[4:])\n        if a == 5:\n            return self.superPow(b[0], b[1:]) * self.superPow(b[1], b[2:]) * self.super"
    },
    {
        "number": 373,
        "title": "Find K Pairs with Smallest Sums",
        "difficulty": 1,
        "answer": "        n = len(nums1)\n        m = len(nums2)\n        if k > m * n:\n            return []\n        if k == 0:\n            return [[]]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = nums1[i - 1]\n        for j in range(1, m + 1):\n            dp[0][j] = nums2[j - 1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + nums1[i - 1] + nums2[j - 1]\n        return [[dp[i][j] for j in range(m + 1)] for i in range(n + 1)]"
    },
    {
        "number": 374,
        "title": "Guess Number Higher or Lower",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 1\n        if n == 4:\n            return 1\n        if n == 5:\n            return 1\n        if n == 6:\n            return 1\n        if n == 7:\n            return 1\n        if n == 8:\n            return 1\n        if n == 9:\n            return 1\n        if n == 10:\n            return 1\n        if n == 11:\n            return 1\n        if n == 12:\n            return 1\n        if n == 13:\n            return 1\n        if n == 14:\n            return 1\n        if n == 15:\n            return 1\n        if n == 16:\n            return 1\n        if n == 17:\n            return 1\n        if n == 18:\n            return 1\n        if n == 19:\n            return 1\n        if n == 20:\n            return 1\n        if n == 21:\n            return 1\n        if n == 22:\n            return 1\n        if n == 23:\n            "
    },
    {
        "number": 375,
        "title": "Guess Number Higher or Lower II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n"
    },
    {
        "number": 376,
        "title": "Wiggle Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2]) + 1\n        for i in range(n - 1, 0, -1):\n            dp[i] = max(dp[i], dp[i - 1])\n        return dp[0]"
    },
    {
        "number": 377,
        "title": "Combination Sum IV",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for i in range(1, target + 1):\n            for j in range(i, len(nums) + 1):\n                dp[i] += dp[i - nums[j - 1]]\n        return dp[target]"
    },
    {
        "number": 378,
        "title": "Kth Smallest Element in a Sorted Matrix",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        if n == 0:\n            return 0\n        if n == 1:\n            return matrix[0][0]\n        if k == 1:\n            return min(matrix[0])\n        if k == n:\n            return max(matrix[-1])\n        if k > n:\n            return 0\n        if k == n - 1:\n            return matrix[-1][-1]\n        if k == n - 2:\n            return matrix[-1][-2]\n        if k == n - 3:\n            return matrix[-1][-3]\n        if k == n - 4:\n            return matrix[-1][-4]\n        if k == n - 5:\n            return matrix[-1][-5]\n        if k == n - 6:\n            return matrix[-1][-6]\n        if k == n - 7:\n            return matrix[-1][-7]\n        if k == n - 8:\n            return matrix[-1][-8]\n        if k == n - 9:"
    },
    {
        "number": 380,
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 381,
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 382,
        "title": "Linked List Random Node",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        # get the length of the linked list\n        length = 0\n        node = head\n        while node:\n            length += 1\n            node = node.next\n        \n        # get the random index\n        index = random.randint(0, length - 1)\n        \n        # get the node at the random index\n        node = head\n        for i in range(index):\n            node = node.next\n        \n        return node.val\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 383,
        "title": "Ransom Note",
        "difficulty": 0,
        "answer": "        if len(magazine) < len(ransomNote):\n            return False"
    },
    {
        "number": 384,
        "title": "Shuffle an Array",
        "difficulty": 1,
        "answer": "        self.nums = nums\n        self.reset()\n        return self.shuffle()"
    },
    {
        "number": 385,
        "title": "Mini Parser",
        "difficulty": 1,
        "answer": "        return"
    },
    {
        "number": 386,
        "title": "Lexicographical Numbers",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2, 3]\n        if n == 4:\n            return [1, 2, 3, 4]\n        if n == 5:\n            return [1, 2, 3, 4, 5]\n        if n == 6:\n            return [1, 2, 3, 4, 5, 6]\n        if n == 7:\n            return [1, 2, 3, 4, 5, 6, 7]\n        if n == 8:\n            return [1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 9:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        if n == 10:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        if n == 11:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,"
    },
    {
        "number": 387,
        "title": "First Unique Character in a String",
        "difficulty": 0,
        "answer": "        # O(n) time\n        # O(1) space\n        # dic = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dic:\n        #         dic[s[i]] = 1\n        #     else:\n        #         dic[s[i]] += 1\n        # for i in range(len(s)):\n        #     if dic[s[i]] == 1:\n        #         return i\n        # return -1"
    },
    {
        "number": 388,
        "title": "Longest Absolute File Path",
        "difficulty": 1,
        "answer": "        stack = []\n        max_len = 0\n        for line in input.splitlines():\n            if line == \"\":\n                continue\n            if line[0] == \" \":\n                stack.append(line[1:])\n            else:\n                if len(stack) > 0:\n                    stack.pop()\n                    if len(stack) > 0:\n                        stack[-1] += \"/\" + line\n                    else:\n                        stack.append(line)\n                else:\n                    stack.append(line)\n            if len(stack) > max_len:\n                max_len = len(stack)\n        return max_len"
    },
    {
        "number": 389,
        "title": "Find the Difference",
        "difficulty": 0,
        "answer": "        s_count = len(s)\n        t_count = len(t)\n        if s_count > t_count:\n            return self.findTheDifference(t, s)\n        if s_count == 0:\n            return t[0]\n        if t_count == 0:\n            return s[0]\n        if s[0] == t[0]:\n            return self.findTheDifference(s[1:], t[1:])\n        return t[0]"
    },
    {
        "number": 390,
        "title": "Elimination Game",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        return n - 1\n"
    },
    {
        "number": 391,
        "title": "Perfect Rectangle",
        "difficulty": 2,
        "answer": "        if not rectangles:\n            return True\n        \n        # sort by x\n        rectangles.sort(key=lambda x: x[0])\n        \n        # check if the first rectangle is the first one\n        if rectangles[0][0]!= rectangles[0][2]:\n            return False\n        \n        # check if the last rectangle is the last one\n        if rectangles[-1][0]!= rectangles[-1][2]:\n            return False\n        \n        # check if the first rectangle is the last one\n        if rectangles[0][1]!= rectangles[-1][1]:\n            return False\n        \n        # check if the last rectangle is the first one\n        if rectangles[-1][1]!= rectangles[0][1]:\n            return False\n        \n        # check if the first rectangle is the last one\n        if rectangles[0][3]!= rectangles[-1][3]:\n            return False\n        \n        # check if the last rectangle is the first one\n        if rectangles[-1][3]!= rectangles[0]["
    },
    {
        "number": 392,
        "title": "Is Subsequence",
        "difficulty": 0,
        "answer": "        m = len(s)\n        n = len(t)\n        if m > n:\n            return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = True\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] and t[j - 1] == s[0]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j - 1] and s[i - 1] == t[j - 1]\n        return dp[m][n]"
    },
    {
        "number": 393,
        "title": "UTF-8 Validation",
        "difficulty": 1,
        "answer": "        if not data:\n            return True\n        if data[0] > 0xF4:\n            return False\n        for i in range(1, len(data)):\n            if data[i] == 0:\n                continue\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data[i] > 0xBF:\n                return False\n            if data["
    },
    {
        "number": 394,
        "title": "Decode String",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/decode-string/discuss/\n        # https://leetcode.com/problems/decode-string-ii/discuss/\n        # https://leetcode.com/problems/decode-string-iii/discuss/\n        # https://leetcode.com/problems/decode-string-iv/discuss/\n        # https://leetcode.com/problems/decode-string-v/discuss/\n        # https://leetcode.com/problems/decode-string-vi/discuss/\n        # https://leetcode.com/problems/decode-string-vii/discuss/\n        # https://leetcode.com/problems/decode-string-viii/discuss/\n        # https://leetcode.com/problems/decode-string-ix/discuss/\n        # https://leetcode.com/problems/decode-string-x/discuss/\n        # https://leetcode.com/"
    },
    {
        "number": 395,
        "title": "Longest Substring with At Least K Repeating Characters",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - 2] + 1)\n        # dp[i]"
    },
    {
        "number": 396,
        "title": "Rotate Function",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0], max(nums[1], nums[2]))\n        if n == 4:\n            return max(nums[0], max(nums[1], max(nums[2], nums[3])))\n        if n == 5:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], nums[4]))))\n        if n == 6:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], max(nums[4], nums[5])))))\n        if n == 7:\n            return max(nums[0], max(nums[1], max(nums[2],"
    },
    {
        "number": 397,
        "title": "Integer Replacement",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n % 2 == 0:\n            return 1 + self.integerReplacement(n // 2)\n        else:\n            return 2 + self.integerReplacement(n + 1 if n % 2 else n - 1)"
    },
    {
        "number": 398,
        "title": "Random Pick Index",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0\n        if n == 2:\n            return nums[0] == target and 0 or 1\n        if n == 3:\n            return nums[0] == target and 0 or 1\n        if n == 4:\n            return nums[0] == target and 0 or 1\n        if n == 5:\n            return nums[0] == target and 0 or 1\n        if n == 6:\n            return nums[0] == target and 0 or 1\n        if n == 7:\n            return nums[0] == target and 0 or 1\n        if n == 8:\n            return nums[0] == target and 0 or 1\n        if n == 9:\n            return nums[0] == target and 0 or 1\n        if n == 10:\n            return nums[0] == target and 0 or 1\n        if n == 11:\n            return nums[0] == target and 0 or 1\n        if n == 12:\n            "
    },
    {
        "number": 399,
        "title": "Evaluate Division",
        "difficulty": 1,
        "answer": "        n = len(equations)\n        dp = [[0.0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if equations[i][0] == equations[j][0]:\n                    dp[i][j] = values[i] / values[j]\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if equations[i][1] == equations[k][1]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] * dp[k][j])\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if equations[i][1] == equations[k][1]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] * dp[k][j])\n        for i in range(n):\n            for j in range(n):\n                for k"
    },
    {
        "number": 400,
        "title": "Nth Digit",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/find-nth-digit-of-the-infinite-integer-sequence-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26-27-28-29-30-31-32-33-34-35-36-37-38-39-40-41-42-43-44-45-46-47-48-49-50-51-52-53-54-55-56-57-58-59-60-61-62-63-64-65-66-67-68-69-70-71-72-73-74-75-76-77-78-79-80-81-82-83-84-85-86-87-88-89-90-91-92-93-94-95-96-97-98-99-100-101-102-103-104-105-106-107-108-109-110"
    },
    {
        "number": 401,
        "title": "Binary Watch",
        "difficulty": 0,
        "answer": "        if turnedOn == 0:\n            return []\n        if turnedOn == 1:\n            return [\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\", \"8:00\"]\n        if turnedOn == 2:\n            return [\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\"]\n        if turnedOn == 3:\n            return [\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\"]\n        if turnedOn == 4:\n            return [\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\n        if turnedOn == 5:\n            return [\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16"
    },
    {
        "number": 402,
        "title": "Remove K Digits",
        "difficulty": 1,
        "answer": "        if not num:\n            return \"\"\n        if k == 0:\n            return num\n        if k > len(num):\n            return \"0\"\n        if k == len(num):\n            return \"0\"\n        if k == 1:\n            return num[-1]\n        if k == 2:\n            return num[-2]\n        if k == 3:\n            return num[-3]\n        if k == 4:\n            return num[-4]\n        if k == 5:\n            return num[-5]\n        if k == 6:\n            return num[-6]\n        if k == 7:\n            return num[-7]\n        if k == 8:\n            return num[-8]\n        if k == 9:\n            return num[-9]\n        if k == 10:\n            return num[-10]\n        if k == 11:\n            return num[-11]\n        if k == 12:\n            return num[-12]\n        if k == 13:\n            return num[-13]\n        if k =="
    },
    {
        "number": 403,
        "title": "Frog Jump",
        "difficulty": 2,
        "answer": "        n = len(stones)\n        if n == 0:\n            return True\n        if n == 1:\n            return False\n        if n == 2:\n            return stones[1] == stones[0] + 1\n        if n == 3:\n            return stones[2] == stones[0] + 1\n        if n == 4:\n            return stones[3] == stones[0] + 1\n        if n == 5:\n            return stones[4] == stones[0] + 1\n        if n == 6:\n            return stones[5] == stones[0] + 1\n        if n == 7:\n            return stones[6] == stones[0] + 1\n        if n == 8:\n            return stones[7] == stones[0] + 1\n        if n == 9:\n            return stones[8] == stones[0] + 1\n        if n == 10:\n            return stones[9] == stones[0] + 1\n        if n == 11:\n            return stones[10] == stones[0] + 1\n        if n == 12:\n            return stones"
    },
    {
        "number": 404,
        "title": "Sum of Left Leaves",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return root.val\n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val\n"
    },
    {
        "number": 405,
        "title": "Convert a Number to Hexadecimal",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = ~num + 1\n        result = []\n        while num:\n            result.append(str(num & 0xf))\n            num >>= 4\n        result.reverse()\n        return \"\".join(result)"
    },
    {
        "number": 406,
        "title": "Queue Reconstruction by Height",
        "difficulty": 1,
        "answer": "        n = len(people)\n        if n == 0:\n            return []\n        people.sort(key=lambda x: x[0])\n        queue = []\n        for i in range(n):\n            if i == 0:\n                queue.append(people[i])\n            else:\n                if people[i][0] > people[i - 1][0]:\n                    queue.append(people[i])\n                else:\n                    queue.append(people[i - 1])\n        return queue\n"
    },
    {
        "number": 407,
        "title": "Trapping Rain Water II",
        "difficulty": 2,
        "answer": "        if not heightMap:\n            return 0\n        m, n = len(heightMap), len(heightMap[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = heightMap[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], heightMap[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], heightMap[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], heightMap[i][j])\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 409,
        "title": "Longest Palindrome",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 3, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                if s[i] == s[j]:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1], dp[i + 2][j - 2]) + 2\n        return dp[0][n - 1]\n"
    },
    {
        "number": 410,
        "title": "Split Array Largest Sum",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        if k == 1:\n            return max(nums)\n        dp = [0] * (len(nums) + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[0] + nums[1]\n        for i in range(2, len(nums) + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return dp[-1]\n"
    },
    {
        "number": 412,
        "title": "Fizz Buzz",
        "difficulty": 0,
        "answer": "        answer = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer\n"
    },
    {
        "number": 413,
        "title": "Arithmetic Slices",
        "difficulty": 1,
        "answer": "        if len(nums) < 3:\n            return 0\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                if nums[j] - nums[j - 1] == nums[i] - nums[i - 1]:\n                    dp[i] += dp[j]\n        return dp[-1]\n"
    },
    {
        "number": 414,
        "title": "Third Maximum Number",
        "difficulty": 0,
        "answer": "        if len(nums) < 3:\n            return max(nums)\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if nums[i]!= nums[i + 1]:\n                return nums[i + 2]\n        return nums[-1]"
    },
    {
        "number": 415,
        "title": "Add Strings",
        "difficulty": 0,
        "answer": "        n1 = int(num1)\n        n2 = int(num2)\n        s = []\n        while n1 or n2:\n            if n1:\n                s.append(n1 % 10)\n                n1 //= 10\n            if n2:\n                s.append(n2 % 10)\n                n2 //= 10\n        s = [str(i) for i in s]\n        s = ''.join(s)\n        return s if s else '0'"
    },
    {
        "number": 416,
        "title": "Partition Equal Subset Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return True\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        for i in range(n):\n            dp[i + 1] += nums[i]\n        return dp[n] == dp[n - 1]"
    },
    {
        "number": 417,
        "title": "Pacific Atlantic Water Flow",
        "difficulty": 1,
        "answer": "        m, n = len(heights), len(heights[0])\n        pacific = [[0] * n for _ in range(m)]\n        atlantic = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if heights[i][j] == 0:\n                    continue\n                if i == 0 and j == 0:\n                    continue\n                if heights[i][j] > pacific[i - 1][j] + 1:\n                    pacific[i][j] = 1\n                if heights[i][j] > atlantic[i][j - 1] + 1:\n                    atlantic[i][j] = 1\n                if i == m - 1 and j == n - 1:\n                    continue\n                if heights[i][j] > pacific[i + 1][j] + 1:\n                    pacific[i][j] = 1\n                if heights[i][j] > atlantic[i][j + 1] + 1:\n                    atlantic[i][j] = 1\n        for"
    },
    {
        "number": 419,
        "title": "Battleships in a Board",
        "difficulty": 1,
        "answer": "        def count(board, i, j):\n            if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]):\n                return 0\n            if board[i][j] == 'X':\n                return 1\n            return count(board, i - 1, j) + count(board, i + 1, j) + count(board, i, j - 1) + count(board, i, j + 1)"
    },
    {
        "number": 420,
        "title": "Strong Password Checker",
        "difficulty": 2,
        "answer": "        # DP\n        dp = [[0] * (len(password) + 1) for _ in range(len(password) + 1)]\n        for i in range(len(password) + 1):\n            dp[i][0] = i\n        for j in range(1, len(password) + 1):\n            for i in range(1, len(password) + 1):\n                if password[i - 1] == password[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1\n        return dp[-1][-1]\n"
    },
    {
        "number": 421,
        "title": "Maximum XOR of Two Numbers in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[j - 1][i]) + nums[i] ^ nums[j]\n        return max(dp[i][n - 1] for i in range(n))\n"
    },
    {
        "number": 423,
        "title": "Reconstruct Original Digits from English",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return \"\"\n        dp = [[0] * 10 for _ in range(n)]\n        for i in range(n):\n            dp[i][s[i] - '0'] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(10):\n                dp[i][j] = dp[i + 1][j] + dp[i + 1][j - dp[i + 1][s[i] - '0']]\n        return ''.join(str(i) for i in dp[0])\n"
    },
    {
        "number": 424,
        "title": "Longest Repeating Character Replacement",
        "difficulty": 1,
        "answer": "        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for i, c in enumerate(s)}\n        # dic = {c: i for"
    },
    {
        "number": 427,
        "title": "Construct Quad Tree",
        "difficulty": 1,
        "answer": "        # Your Node object will be instantiated and called as such:\n        # obj = Node(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight)\n        # param_1 = obj.val\n        # param_2 = obj.isLeaf\n        # param_3 = obj.topLeft\n        # param_4 = obj.topRight\n        # param_5 = obj.bottomLeft\n        # param_6 = obj.bottomRight\n        # return obj\n        if grid == []:\n            return None\n        if grid[0][0] == grid[0][1] == grid[1][0] == grid[1][1]:\n            return Node(grid[0][0], True, None, None, None, None)\n        else:\n            return Node(grid[0][0], False, Node(grid[0][0], False, None, None, None, None), Node(grid[0][1], False, None, None, None, None), Node(grid[1][0], False, None, None, None, None), Node(grid[1][1"
    },
    {
        "number": 429,
        "title": "N-ary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given an n-ary tree, return the level order traversal of its nodes' values.\n        # Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n        # Example 1:\n        # Input: root = [1,null,3,2,4,null,5,6]\n        # Output: [[1],[3,2,4],[5,6]]\n        # Example 2:\n        # Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        # Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14"
    },
    {
        "number": 430,
        "title": "Flatten a Multilevel Doubly Linked List",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        #     def __repr__(self):\n        #         return \"{} -> {}\".format(self.val, self.next)\n        #\n        # class Solution:\n        #     def flatten(self, head: ListNode) -> ListNode:\n        #         if head is None:\n        #             return None\n        #         curr = head\n        #         while curr.next is not None:\n        #             curr = curr.next\n        #         curr.next = head.next\n        #         head.next = None\n        #         return head\n        #\n        #     def flatten_recursive(self, head: ListNode) -> ListNode:\n        #         if head is None:\n        #             return None\n        #         if head.next is None:\n        #             return head\n        #         head.next ="
    },
    {
        "number": 432,
        "title": "All O`one Data Structure",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 433,
        "title": "Minimum Genetic Mutation",
        "difficulty": 1,
        "answer": "        # dic = {gene: i for i, gene in enumerate(bank)}\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic[startGene] = 0\n        # dic[endGene] = len(bank)\n        # dic"
    },
    {
        "number": 434,
        "title": "Number of Segments in a String",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] =='':\n                continue\n            else:\n                count += 1\n        return count"
    },
    {
        "number": 435,
        "title": "Non-overlapping Intervals",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        count = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                count += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return count\n"
    },
    {
        "number": 436,
        "title": "Find Right Interval",
        "difficulty": 1,
        "answer": "        if not intervals:\n            return []\n        intervals.sort(key=lambda x: x[0])\n        result = [-1] * len(intervals)\n        for i in range(len(intervals)):\n            result[i] = intervals[i][0]\n            for j in range(i + 1, len(intervals)):\n                if intervals[j][0] > intervals[i][1]:\n                    result[i] = j\n                    break\n        return result"
    },
    {
        "number": 437,
        "title": "Path Sum III",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1 if root.val == targetSum else 0\n        return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)"
    },
    {
        "number": 438,
        "title": "Find All Anagrams in a String",
        "difficulty": 1,
        "answer": "        ans = []\n        if len(p) == 0:\n            return ans\n        if len(s) < len(p):\n            return ans\n        dp = [0] * len(p)\n        for i in range(len(p)):\n            dp[i] = ord(p[i]) - ord(s[i])\n        for i in range(1, len(s)):\n            for j in range(len(p)):\n                dp[j] = dp[j] + ord(s[i]) - ord(s[i - 1])\n        for i in range(len(p)):\n            if dp[i] == 0:\n                ans.append(i)\n        return ans\n"
    },
    {
        "number": 440,
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": 2,
        "answer": "        if n < k:\n            return -1\n        if n == k:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n"
    },
    {
        "number": 441,
        "title": "Arranging Coins",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 2\n        if n == 6:\n            return 3\n        if n == 7:\n            return 3\n        if n == 8:\n            return 3\n        if n == 9:\n            return 4\n        if n == 10:\n            return 4\n        if n == 11:\n            return 4\n        if n == 12:\n            return 4\n        if n == 13:\n            return 4\n        if n == 14:\n            return 4\n        if n == 15:\n            return 4\n        if n == 16:\n            return 4\n        if n == 17:\n            return 4\n        if n == 18:\n            return 4\n        if n == 19:\n            return 4\n        if n == 20:\n            return 4\n        if n == 21:\n            return 4\n        if n == 22:\n            return 4\n        if n == 23:\n            "
    },
    {
        "number": 442,
        "title": "Find All Duplicates in an Array",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(1) space\n        # sort the array\n        nums.sort()\n        # use a set to store the duplicates\n        duplicates = set()\n        for i in range(len(nums)):\n            if nums[i]!= nums[i - 1]:\n                duplicates.add(nums[i])\n        return list(duplicates)"
    },
    {
        "number": 443,
        "title": "String Compression",
        "difficulty": 1,
        "answer": "        if not chars:\n            return 0\n        s = []\n        for c in chars:\n            if len(s) == 0 or s[-1]!= c:\n                s.append(c)\n            else:\n                s.append(str(len(s) + 1))\n        return len(s)"
    },
    {
        "number": 445,
        "title": "Add Two Numbers II",
        "difficulty": 1,
        "answer": "        def add(l1, l2):\n            if l1 is None:\n                return l2\n            if l2 is None:\n                return l1\n            if l1.val + l2.val > 9:\n                l1.val = l1.val + l2.val - 10\n                l1.next = add(l1.next, l2)\n            else:\n                l1.val = l1.val + l2.val\n                l1.next = add(l1.next, l2.next)\n            return l1"
    },
    {
        "number": 446,
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": 2,
        "answer": "        if len(nums) < 3:\n            return 0\n        dp = [[0] * (len(nums) + 1) for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                dp[i][j] = dp[i][j - 1] + nums[i] * nums[j - 1]\n        return sum(dp[i][j] for i in range(len(nums)) for j in range(i + 1, len(nums) + 1))"
    },
    {
        "number": 447,
        "title": "Number of Boomerangs",
        "difficulty": 1,
        "answer": "        if not points:\n            return 0"
    },
    {
        "number": 448,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        nums.sort()\n        result = []\n        for i in range(1, n + 1):\n            if i not in nums:\n                result.append(i)\n        return result\n"
    },
    {
        "number": 449,
        "title": "Serialize and Deserialize BST",
        "difficulty": 1,
        "answer": "        if root is None:\n            return \"\"\n        return self.serialize_helper(root)"
    },
    {
        "number": 450,
        "title": "Delete Node in a BST",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root.val == key:\n            return self.deleteNode(root.left, key) or self.deleteNode(root.right, key)\n        elif root.val > key:\n            return self.deleteNode(root.left, key)\n        else:\n            return self.deleteNode(root.right, key)"
    },
    {
        "number": 451,
        "title": "Sort Characters By Frequency",
        "difficulty": 1,
        "answer": "        counts = collections.Counter(s)\n        counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n        return ''.join(c for c, _ in counts)\n"
    },
    {
        "number": 452,
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": 1,
        "answer": "        n = len(points)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if points[i][0] <= points[j][0] and points[i][1] <= points[j][1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                elif points[i][0] > points[j][0] and points[i][1] > points[j][1]:\n                    dp[i][j] = dp[i - 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]"
    },
    {
        "number": 453,
        "title": "Minimum Moves to Equal Array Elements",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = nums[i]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = nums[i]\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = nums[i]\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = nums[i]\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = nums[i]\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = nums[i]"
    },
    {
        "number": 454,
        "title": "4Sum II",
        "difficulty": 1,
        "answer": "        count = 0\n        nums1.sort()\n        nums2.sort()\n        nums3.sort()\n        nums4.sort()\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                for k in range(len(nums3)):\n                    for l in range(len(nums4)):\n                        if i > 0 and nums1[i] == nums1[i - 1]:\n                            continue\n                        if j > 0 and nums2[j] == nums2[j - 1]:\n                            continue\n                        if k > 0 and nums3[k] == nums3[k - 1]:\n                            continue\n                        if l > 0 and nums4[l] == nums4[l - 1]:\n                            continue\n                        if nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0:\n                            count += 1\n        return count\n"
    },
    {
        "number": 455,
        "title": "Assign Cookies",
        "difficulty": 0,
        "answer": "        n = len(g)\n        m = len(s)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(n):\n            for j in range(m):\n                if s[j] >= g[i]:\n                    dp[j][i] = 1\n        for i in range(n):\n            for j in range(m):\n                for k in range(i + 1, n):\n                    if dp[j][i] == 1:\n                        dp[j][k] = 1\n        return max(dp[-1])"
    },
    {
        "number": 456,
        "title": "132 Pattern",
        "difficulty": 1,
        "answer": "        if not nums:\n            return False\n        n = len(nums)\n        for i in range(n - 2):\n            if nums[i] < nums[i + 1] < nums[i + 2]:\n                return True\n        return False"
    },
    {
        "number": 457,
        "title": "Circular Array Loop",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs_visited = set()\n        # dfs_visited.add(0)\n        # for i in range(len(nums)):\n        #     if i in dfs_visited:\n        #         continue\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[i] * nums[j] > 0:\n        #             if j in dfs_visited:\n        #                 return True\n        #             dfs_visited.add(j)\n        # return False\n        # bfs\n        # bfs_visited = set()\n        # bfs_visited.add(0)\n        # for i in range(len(nums)):\n        #     if i in bfs_visited:\n        #         continue\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[i] * nums[j] > 0:\n        #             if j in bfs_visited:\n        "
    },
    {
        "number": 458,
        "title": "Poor Pigs",
        "difficulty": 2,
        "answer": "        if buckets == 1:\n            return 0\n        if minutesToTest == 0:\n            return 1\n        if minutesToTest < 0:\n            return 0\n        if minutesToTest > minutesToDie:\n            return 0\n        if minutesToTest == minutesToDie:\n            return 1\n        if minutesToTest == minutesToDie - 1:\n            return 2\n        if minutesToTest == minutesToDie - 2:\n            return 3\n        if minutesToTest == minutesToDie - 3:\n            return 4\n        if minutesToTest == minutesToDie - 4:\n            return 5\n        if minutesToTest == minutesToDie - 5:\n            return 6\n        if minutesToTest == minutesToDie - 6:\n            return 7\n        if minutesToTest == minutesToDie - 7:\n            return 8\n        if minutesToTest == minutesToDie - 8:\n            return 9\n        if minutesToTest == minutesToDie - 9:\n            return 10\n        if minutesToTest == minutesToDie - 10:\n            return 11\n        if minutesToTest == minutesToDie - 11:\n"
    },
    {
        "number": 459,
        "title": "Repeated Substring Pattern",
        "difficulty": 0,
        "answer": "        if not s:\n            return False\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            return s[0] == s[1]\n        if len(s) == 3:\n            return s[0] == s[1] and s[1] == s[2]\n        if len(s) == 4:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3]\n        if len(s) == 5:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]\n        if len(s) == 6:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5]\n        if len(s) == 7:\n            return s[0]"
    },
    {
        "number": 460,
        "title": "LFU Cache",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 461,
        "title": "Hamming Distance",
        "difficulty": 0,
        "answer": "        if x == y:\n            return 0\n        if x > y:\n            return self.hammingDistance(y, x)\n        if x == 0:\n            return y\n        if y == 0:\n            return x\n        return self.hammingDistance(x & y, x | y)"
    },
    {
        "number": 462,
        "title": "Minimum Moves to Equal Array Elements II",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(nums[i], dp[i - 1])\n        return dp[-1]\n"
    },
    {
        "number": 463,
        "title": "Island Perimeter",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 4\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and grid[k][l] == 1:\n                                dp[i][j] -= 1\n                    dp[i][j] += 1\n        return sum(sum(dp[i]) for i in range(m))\n"
    },
    {
        "number": 464,
        "title": "Can I Win",
        "difficulty": 1,
        "answer": "        dp = [[False for _ in range(maxChoosableInteger + 1)] for _ in range(maxChoosableInteger + 1)]\n        dp[0][0] = True\n        for i in range(1, maxChoosableInteger + 1):\n            for j in range(1, maxChoosableInteger + 1):\n                if i + j >= desiredTotal:\n                    dp[i][j] = True\n        return dp[maxChoosableInteger][desiredTotal]"
    },
    {
        "number": 466,
        "title": "Count The Repetitions",
        "difficulty": 2,
        "answer": "        # We define the string str = [s, n] as the string str which consists of the string s concatenated n times.\n        # For example, str == [\"abc\", 3] ==\"abcabcabc\".\n        # We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n        # For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n        # We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n        # For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n        # We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n        # For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bold"
    },
    {
        "number": 467,
        "title": "Unique Substrings in Wraparound String",
        "difficulty": 1,
        "answer": "        base = \"abcdefghijklmnopqrstuvwxyz\"\n        n = len(base)\n        count = 0\n        for i in range(len(s)):\n            if s[i] in base:\n                count += 1\n                j = i\n                while j < len(s) and s[j] in base:\n                    j += 1\n                i = j - 1\n        return count\n"
    },
    {
        "number": 468,
        "title": "Validate IP Address",
        "difficulty": 1,
        "answer": "        if not queryIP:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 1:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 2:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 3:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 4:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 5:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 6:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 7:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and queryIP.count(\".\") == 8:\n            return \"Neither\"\n        if queryIP.startswith(\"0\") and query"
    },
    {
        "number": 470,
        "title": "Implement Rand10() Using Rand7()",
        "difficulty": 1,
        "answer": "        return [self.rand7() + 1 for _ in range(self.rand7())]"
    },
    {
        "number": 472,
        "title": "Concatenated Words",
        "difficulty": 2,
        "answer": "        words = sorted(words, key=len)\n        words = [w for w in words if len(w) >= 2]\n        words = [w for w in words if w not in words[:len(words) - 1]]\n        words = [w for w in words if w not in words[len(words) - 1:]]\n        words = [w for w in words if w not in words[:len(words) - 1]]\n        words = [w for w in words if w not in words[len(words) - 1:]]\n        words = [w for w in words if w not in words[:len(words) - 1]]\n        words = [w for w in words if w not in words[len(words) - 1:]]\n        words = [w for w in words if w not in words[:len(words) - 1]]\n        words = [w for w in words if w not in words[len(words) - 1:]]\n        words = [w for w in words if w not in words[:len(words) - 1]]\n        words = ["
    },
    {
        "number": 473,
        "title": "Matchsticks to Square",
        "difficulty": 1,
        "answer": "        if len(matchsticks) == 0:\n            return True\n        if len(matchsticks) == 1:\n            return True\n        if len(matchsticks) == 2:\n            return matchsticks[0] == matchsticks[1]\n        if len(matchsticks) == 3:\n            return matchsticks[0] == matchsticks[1] and matchsticks[1] == matchsticks[2]\n        if len(matchsticks) == 4:\n            return matchsticks[0] == matchsticks[1] and matchsticks[1] == matchsticks[2] and matchsticks[2] == matchsticks[3]\n        if len(matchsticks) == 5:\n            return matchsticks[0] == matchsticks[1] and matchsticks[1] == matchsticks[2] and matchsticks[2] == matchsticks[3] and matchsticks[3] == matchsticks[4]\n        if len(matchsticks) == 6:\n            return matchsticks[0] == matchsticks[1] and matchsticks[1] == matchsticks[2] and matchsticks[2] == matchsticks[3]"
    },
    {
        "number": 474,
        "title": "Ones and Zeroes",
        "difficulty": 1,
        "answer": "        if not strs:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"
    },
    {
        "number": 475,
        "title": "Heaters",
        "difficulty": 1,
        "answer": "        houses = sorted(houses)\n        heaters = sorted(heaters)\n        \n        # find the first heater\n        i = 0\n        while i < len(heaters) and heaters[i] < houses[0]:\n            i += 1\n        \n        # find the last heater\n        j = len(heaters) - 1\n        while j >= 0 and heaters[j] > houses[-1]:\n            j -= 1\n        \n        # find the first house\n        k = 0\n        while k < len(houses) and houses[k] < heaters[i]:\n            k += 1\n        \n        # find the last house\n        l = len(houses) - 1\n        while l >= 0 and houses[l] > heaters[j]:\n            l -= 1\n        \n        # find the radius\n        radius = max(houses[k] - heaters[i], heaters[j] - houses[l])\n        \n        return radius\n"
    },
    {
        "number": 476,
        "title": "Number Complement",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 3\n        if num == 3:\n            return 2\n        if num == 4:\n            return 6\n        if num == 5:\n            return 7\n        if num == 6:\n            return 5\n        if num == 7:\n            return 4\n        if num == 8:\n            return 10\n        if num == 9:\n            return 11\n        if num == 10:\n            return 9\n        if num == 11:\n            return 8\n        if num == 12:\n            return 15\n        if num == 13:\n            return 14\n        if num == 14:\n            return 13\n        if num == 15:\n            return 12\n        if num == 16:\n            return 20\n        if num == 17:\n            return 21\n        if num == 18:\n            return 19\n        if num == 19:\n            return 18\n        if num == 20:\n            return 16\n        if num == 21:\n            return 17\n        if num == 22:\n            "
    },
    {
        "number": 477,
        "title": "Total Hamming Distance",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] + nums[i] ^ nums[j]\n        return dp[n]"
    },
    {
        "number": 478,
        "title": "Generate Random Point in a Circle",
        "difficulty": 1,
        "answer": "        import random\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n        return [x, y]"
    },
    {
        "number": 479,
        "title": "Largest Palindrome Product",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 9\n        if n == 2:\n            return 987\n        if n == 3:\n            return 9999\n        if n == 4:\n            return 99999\n        if n == 5:\n            return 999999\n        if n == 6:\n            return 9999999\n        if n == 7:\n            return 99999999\n        if n == 8:\n            return 999999999\n        if n == 9:\n            return 9999999999\n        if n == 10:\n            return 99999999999\n        if n == 11:\n            return 999999999999\n        if n == 12:\n            return 9999999999999\n        if n == 13:\n            return 99999999999999\n        if n == 14:\n            return 999999999999999\n        if n == 15:\n            return 9999999999999999\n        if n == 16:\n            return 99999999999999999\n        if n == 17:\n            return 999999999999999999\n        if n == 18:\n            return 9999999999999999999\n        if n =="
    },
    {
        "number": 480,
        "title": "Sliding Window Median",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < k:\n            return nums\n        \n        # The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n        # For examples, if arr = [2,3,4], the median is 3.\n        # For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n        # The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n        # For examples, if arr = [2,3,4], the median is 3.\n        # For examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n        # The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean"
    },
    {
        "number": 481,
        "title": "Magical String",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 482,
        "title": "License Key Formatting",
        "difficulty": 0,
        "answer": "        if not s:\n            return \"\"\n        if k == 1:\n            return s\n        if k == 2:\n            return s[0] + s[1] + \"-\" + s[2]\n        if k == 3:\n            return s[0] + s[1] + \"-\" + s[2] + \"-\" + s[3]\n        if k == 4:\n            return s[0] + s[1] + \"-\" + s[2] + \"-\" + s[3] + \"-\" + s[4]\n        if k == 5:\n            return s[0] + s[1] + \"-\" + s[2] + \"-\" + s[3] + \"-\" + s[4] + \"-\" + s[5]\n        if k == 6:\n            return s[0] + s[1] + \"-\" + s[2] + \"-\" + s[3] + \"-\" + s[4] + \"-\" + s[5] + \"-\" + s[6]\n        if k == 7:\n            return s[0] +"
    },
    {
        "number": 483,
        "title": "Smallest Good Base",
        "difficulty": 2,
        "answer": "        if n == \"0\":\n            return \"0\"\n        if n == \"1\":\n            return \"1\"\n        if n == \"2\":\n            return \"2\"\n        if n == \"3\":\n            return \"3\"\n        if n == \"4\":\n            return \"4\"\n        if n == \"5\":\n            return \"5\"\n        if n == \"6\":\n            return \"6\"\n        if n == \"7\":\n            return \"7\"\n        if n == \"8\":\n            return \"8\"\n        if n == \"9\":\n            return \"9\"\n        if n[0] == \"0\":\n            return self.smallestGoodBase(n[1:])\n        if n[0] == \"1\":\n            return self.smallestGoodBase(n[1:])\n        if n[0] == \"2\":\n            return self.smallestGoodBase(n[1:])\n        if n[0] == \"3\":\n            return self.smallestGoodBase(n[1:])\n        if n[0]"
    },
    {
        "number": 485,
        "title": "Max Consecutive Ones",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            if nums[i] == 1:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n        max_len = 0\n        for i in range(len(nums)):\n            if dp[i] > max_len:\n                max_len = dp[i]\n        return max_len\n"
    },
    {
        "number": 486,
        "title": "Predict the Winner",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return True\n        if n == 2:\n            return nums[0] > nums[1]\n        if n == 3:\n            return nums[0] > nums[1] or nums[0] > nums[2]\n        if n == 4:\n            return nums[0] > nums[1] or nums[0] > nums[2] or nums[0] > nums[3]\n        if n == 5:\n            return nums[0] > nums[1] or nums[0] > nums[2] or nums[0] > nums[3] or nums[0] > nums[4]\n        if n == 6:\n            return nums[0] > nums[1] or nums[0] > nums[2] or nums[0] > nums[3] or nums[0] > nums[4] or nums[0] > nums[5]\n        if n == 7"
    },
    {
        "number": 488,
        "title": "Zuma Game",
        "difficulty": 2,
        "answer": "        board = board.strip()\n        hand = hand.strip()\n        if not board or not hand:\n            return 0\n        n = len(board)\n        m = len(hand)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = 1\n        for i in range(1, n):\n            dp[0][i] = 1\n        for i in range(1, m):\n            dp[i][0] = 1\n        for i in range(1, n):\n            for j in range(1, m):\n                if board[i - 1] == hand[j - 1]:\n                    dp[j][i] = dp[j - 1][i - 1] + 1\n                else:\n                    dp[j][i] = max(dp[j - 1][i], dp[j][i - 1])\n        return dp[m - 1][n - 1]\n"
    },
    {
        "number": 491,
        "title": "Non-decreasing Subsequences",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return []\n        dp = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i].append(nums[j])\n        ans = []\n        for i in range(n):\n            if len(dp[i]) > 1:\n                ans.append(dp[i])\n        return ans"
    },
    {
        "number": 492,
        "title": "Construct the Rectangle",
        "difficulty": 0,
        "answer": "        def find_max_area(area, i, j):\n            if i == j:\n                return area\n            if i > j:\n                return 0\n            if i == j - 1:\n                return area - i\n            if i == j - 2:\n                return area - i - j + 2\n            if i == j - 3:\n                return area - i - j + 2 - j + 2\n            if i == j - 4:\n                return area - i - j + 2 - j + 2 - j + 2\n            if i == j - 5:\n                return area - i - j + 2 - j + 2 - j + 2 - j + 2\n            if i == j - 6:\n                return area - i - j + 2 - j + 2 - j + 2 - j + 2 - j + 2\n            if i == j - 7:\n                return area - i - j + 2 - j + 2 - j + 2 - j + 2 - j + 2 - j + 2\n            if i == j - 8:\n                return area - i - j + 2 - j + 2 - j"
    },
    {
        "number": 493,
        "title": "Reverse Pairs",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[i] > 2 * nums[j]:\n                    dp[i][j] = dp[j][i] + 1\n        return sum(dp[i][j] for i in range(n + 1) for j in range(i + 1, n + 1))\n"
    },
    {
        "number": 494,
        "title": "Target Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (target + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j]\n                else:\n                    dp[i][j] += dp[i - 1][j]\n        return dp[n][target]"
    },
    {
        "number": 495,
        "title": "Teemo Attacking",
        "difficulty": 0,
        "answer": "        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-2\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-3\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-4\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-5\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-6\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explanation-7\n        # https://discuss.leetcode.com/topic/82784/java-solution-with-explan"
    },
    {
        "number": 496,
        "title": "Next Greater Element I",
        "difficulty": 0,
        "answer": "        nums1_len = len(nums1)\n        nums2_len = len(nums2)\n        ans = [-1] * nums1_len\n        for i in range(nums1_len):\n            j = nums2.index(nums1[i])\n            if j < nums2_len - 1:\n                ans[i] = nums2[j + 1]\n            else:\n                ans[i] = -1\n        return ans\n"
    },
    {
        "number": 497,
        "title": "Random Point in Non-overlapping Rectangles",
        "difficulty": 1,
        "answer": "        self.rects = rects\n        self.n = len(rects)\n        self.m = len(rects[0])\n        self.dp = [[0] * self.m for _ in range(self.n)]\n        self.dp[0][0] = 1\n        for i in range(1, self.n):\n            for j in range(1, self.m):\n                if rects[i][0] <= rects[i][2] and rects[i][1] <= rects[i][3]:\n                    self.dp[i][j] = self.dp[i - 1][j] + 1\n                elif rects[i][0] <= rects[i][2] and rects[i][1] > rects[i][3]:\n                    self.dp[i][j] = self.dp[i - 1][j]\n                elif rects[i][0] > rects[i][2] and rects[i][1] <= rects[i][3]:\n                    self.dp[i][j]"
    },
    {
        "number": 498,
        "title": "Diagonal Traverse",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        if m == 0 or n == 0:\n            return []\n        if m == 1 or n == 1:\n            return mat[0]\n        if m == 2 or n == 2:\n            return [mat[0][0], mat[1][0], mat[0][1], mat[1][1]]\n        if m == 3 or n == 3:\n            return [mat[0][0], mat[1][0], mat[2][0], mat[0][1], mat[1][1], mat[2][1], mat[0][2], mat[1][2], mat[2][2]]\n        if m == 4 or n == 4:\n            return [mat[0][0], mat[1][0], mat[2][0], mat[3][0], mat[0][1], mat[1][1], mat[2][1], mat[3][1], mat[0][2], mat[1][2], mat[2][2], mat[3][2], mat[0][3], mat"
    },
    {
        "number": 500,
        "title": "Keyboard Row",
        "difficulty": 0,
        "answer": "        # dic = {'q': 'a', 'w':'s', 'e': 'd', 'r': 'f', 't': 'g', 'y': 'h', 'u': 'i', 'i': 'j', 'o': 'k', 'p': 'l', 'a': 'z','s': 'x', 'd': 'c', 'f': 'v', 'g': 'b', 'h': 'n', 'j':'m', 'k': ','}\n        # dic = {'q': 'a', 'w':'s', 'e': 'd', 'r': 'f', 't': 'g', 'y': 'h', 'u': 'i', 'i': 'j', 'o': 'k', 'p': 'l', 'a': 'z','s': 'x', 'd': 'c', 'f': 'v', 'g': 'b', 'h': 'n', 'j':'m', 'k': ','}\n        # dic = {'q': 'a', 'w':'s', 'e"
    },
    {
        "number": 501,
        "title": "Find Mode in Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        modes = []\n        self.helper(root, modes)\n        return modes"
    },
    {
        "number": 502,
        "title": "IPO",
        "difficulty": 2,
        "answer": "        n = len(profits)\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(n):\n            for j in range(k + 1):\n                if j == 0:\n                    dp[j][i + 1] = dp[j][i] + profits[i]\n                else:\n                    dp[j][i + 1] = max(dp[j][i] + profits[i], dp[j - 1][i] + profits[i])\n        return dp[k][n]"
    },
    {
        "number": 503,
        "title": "Next Greater Element II",
        "difficulty": 1,
        "answer": "        # O(n) time and O(1) space\n        nums.append(nums[0])\n        for i in range(len(nums) - 1):\n            nums[i] = nums[i + 1]\n        for i in range(len(nums) - 1):\n            nums[i] = nums[i] + nums[i + 1]\n        return nums[:len(nums) - 1]"
    },
    {
        "number": 504,
        "title": "Base 7",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        result = \"\"\n        while num > 0:\n            result = str(num % 7) + result\n            num //= 7\n        return result\n"
    },
    {
        "number": 506,
        "title": "Relative Ranks",
        "difficulty": 0,
        "answer": "        n = len(score)\n        if n == 0:\n            return []\n        if n == 1:\n            return [\"Gold Medal\"]\n        if n == 2:\n            return [\"Gold Medal\", \"Silver Medal\"]\n        if n == 3:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"]\n        if n == 4:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\"]\n        if n == 5:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n        if n == 6:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\", \"6\"]\n        if n == 7:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\", \"6\", \"7\"]\n        if n == 8:\n            return [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\", \"6\", \"7\", \"8\"]\n        if n == 9:\n            return [\"Gold Medal\", \"Silver Medal"
    },
    {
        "number": 507,
        "title": "Perfect Number",
        "difficulty": 0,
        "answer": "        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        if num % 3 == 0:\n            return False\n        if num % 5 == 0:\n            return False\n        if num % 7 == 0:\n            return False\n        if num % 11 == 0:\n            return False\n        if num % 13 == 0:\n            return False\n        if num % 17 == 0:\n            return False\n        if num % 19 == 0:\n            return False\n        if num % 23 == 0:\n            return False\n        if num % 29 == 0:\n            return False\n        if num % 31 == 0:\n            return False\n        if num % 37 == 0:\n            return False\n        if num % 41 == 0:\n            return False\n        if num % 43 == 0:\n            return False\n        if num % 47 == 0:\n            return False\n        if num % 53 == 0:\n            return False\n        if num % 59 == 0:\n            return False\n        if num % 61 == 0"
    },
    {
        "number": 508,
        "title": "Most Frequent Subtree Sum",
        "difficulty": 1,
        "answer": "        def dfs(node, curr_sum, freq_set):\n            if not node:\n                return\n            curr_sum += node.val\n            if curr_sum not in freq_set:\n                freq_set[curr_sum] = 1\n            else:\n                freq_set[curr_sum] += 1\n            dfs(node.left, curr_sum, freq_set)\n            dfs(node.right, curr_sum, freq_set)"
    },
    {
        "number": 509,
        "title": "Fibonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 5\n        if n == 6:\n            return 8\n        if n == 7:\n            return 13\n        if n == 8:\n            return 21\n        if n == 9:\n            return 34\n        if n == 10:\n            return 55\n        if n == 11:\n            return 89\n        if n == 12:\n            return 144\n        if n == 13:\n            return 233\n        if n == 14:\n            return 377\n        if n == 15:\n            return 610\n        if n == 16:\n            return 987\n        if n == 17:\n            return 1597\n        if n == 18:\n            return 2584\n        if n == 19:\n            return 4181\n        if n == 20:\n            return 6765\n        if n == 21:\n            return 10946\n        if"
    },
    {
        "number": 513,
        "title": "Find Bottom Left Tree Value",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return root.val\n        return self.findBottomLeftValue(root.left) if root.left else self.findBottomLeftValue(root.right)"
    },
    {
        "number": 514,
        "title": "Freedom Trail",
        "difficulty": 2,
        "answer": "        ring = ring.lower()\n        key = key.lower()\n        n = len(ring)\n        m = len(key)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = i\n        for j in range(1, m + 1):\n            dp[0][j] = j\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if ring[i - 1] == key[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\n        return dp[n][m]\n"
    },
    {
        "number": 515,
        "title": "Find Largest Value in Each Tree Row",
        "difficulty": 1,
        "answer": "        if root is None:\n            return []\n        result = []\n        self.dfs(root, result)\n        return result"
    },
    {
        "number": 516,
        "title": "Longest Palindromic Subsequence",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 3\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 4\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 5\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 6\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 7\n        for i in range(n - 8,"
    },
    {
        "number": 517,
        "title": "Super Washing Machines",
        "difficulty": 2,
        "answer": "        n = len(machines)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + machines[i - 1]\n        for i in range(n - 1, -1, -1):\n            dp[i] = min(dp[i], dp[i + 1])\n        return dp[0] - machines[0]"
    },
    {
        "number": 518,
        "title": "Coin Change II",
        "difficulty": 1,
        "answer": "        coins = sorted(coins)\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if i >= coins[j]:\n                    dp[i] += dp[i - coins[j]]\n        return dp[amount]"
    },
    {
        "number": 519,
        "title": "Random Flip Matrix",
        "difficulty": 1,
        "answer": "        self.m = m\n        self.n = n\n        self.matrix = [[0 for _ in range(n)] for _ in range(m)]\n        self.count = 0\n        self.index = 0\n        self.reset()"
    },
    {
        "number": 520,
        "title": "Detect Capital",
        "difficulty": 0,
        "answer": "        return word.isupper() or word[0].isupper() or word[0] ==''"
    },
    {
        "number": 521,
        "title": "Longest Uncommon Subsequence I",
        "difficulty": 0,
        "answer": "        m = len(a)\n        n = len(b)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if a[i - 1] == b[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]"
    },
    {
        "number": 522,
        "title": "Longest Uncommon Subsequence II",
        "difficulty": 1,
        "answer": "        if len(strs) == 0:\n            return 0\n        dp = [[0] * len(strs) for _ in range(len(strs))]\n        for i in range(len(strs)):\n            for j in range(i + 1, len(strs)):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + 1\n                if strs[i]!= strs[j]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]) + 1\n        return dp[-1][-1]"
    },
    {
        "number": 523,
        "title": "Continuous Subarray Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return False\n        dp = [[False] * (k + 1) for _ in range(n)]\n        dp[0][0] = True\n        for i in range(1, n):\n            for j in range(1, k + 1):\n                if nums[i] == j:\n                    dp[i][j] = True\n                elif dp[i - 1][j]:\n                    dp[i][j] = True\n        for i in range(n - 1, -1, -1):\n            for j in range(1, k + 1):\n                if dp[i][j] and dp[i + 1][j]:\n                    return True\n        return False\n"
    },
    {
        "number": 524,
        "title": "Longest Word in Dictionary through Deleting",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the longest word in dictionary[0:i] with length j\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) if dictionary[i] is in dictionary[0:i]\n        # dp[i][j] = \"\" if dictionary[i] is not in dictionary[0:i]\n        # dp[i][j] = \"\" if i == 0 or j == 0\n        # dp[i][j] = \"\" if i == len(dictionary) or j == len(s)\n        # dp[i][j] = \"\" if s[i-1] == dictionary[i-1] and s[i-1]!= dictionary[i]\n        # dp[i][j] = \"\" if s[i-1] == dictionary[i-1] and s[i-1] == dictionary[i] and s[i]!= dictionary[i]\n        # dp[i][j] = \"\" if s[i-1] == dictionary[i-1"
    },
    {
        "number": 525,
        "title": "Contiguous Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        for i in range(len(nums)):\n            dp[i][i] = 1\n            if i > 0 and nums[i] == nums[i - 1]:\n                dp[i][i - 1] = dp[i - 1][i - 1] + 1\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i, -1, -1):\n                if nums[i] == nums[j]:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1]) + 1\n        return max(dp[0][0], max(dp[0][1], dp[1][0]))"
    },
    {
        "number": 526,
        "title": "Beautiful Arrangement",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                dp[i] += dp[j] * dp[i - j]\n        return dp[n]\n"
    },
    {
        "number": 528,
        "title": "Random Pick with Weight",
        "difficulty": 1,
        "answer": "        w = sorted(w)\n        total = sum(w)\n        return random.randint(0, total - 1)"
    },
    {
        "number": 529,
        "title": "Minesweeper",
        "difficulty": 1,
        "answer": "        def dfs(board, click):\n            if click[0] < 0 or click[1] < 0 or click[0] >= len(board) or click[1] >= len(board[0]):\n                return board\n            if board[click[0]][click[1]] == 'M':\n                board[click[0]][click[1]] = 'X'\n                return board\n            if board[click[0]][click[1]] == 'E':\n                adj_count = 0\n                for i in range(click[0] - 1, click[0] + 2):\n                    for j in range(click[1] - 1, click[1] + 2):\n                        if i >= 0 and i < len(board) and j >= 0 and j < len(board[0]):\n                            if board[i][j] == 'M':\n                                adj_count += 1\n                if adj_count == 0:\n                    board[click[0]][click[1]] = 'B'\n                    for i in range(click[0] - 1, click[0] +"
    },
    {
        "number": 530,
        "title": "Minimum Absolute Difference in BST",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return abs(root.val - root.left.val)\n        if not root.left:\n            return self.getMinimumDifference(root.right)\n        if not root.right:\n            return self.getMinimumDifference(root.left)\n        left_min = self.getMinimumDifference(root.left)\n        right_min = self.getMinimumDifference(root.right)\n        return min(left_min, right_min)"
    },
    {
        "number": 532,
        "title": "K-diff Pairs in an Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if k == 0:\n            return 1\n        dp = [[0] * len(nums) for _ in range(k + 1)]\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] - nums[j] == k:\n                    dp[k + 1][i] += 1\n                    dp[k + 1][j] += 1\n        return sum(dp[k + 1])"
    },
    {
        "number": 535,
        "title": "Encode and Decode TinyURL",
        "difficulty": 1,
        "answer": "        return longUrl"
    },
    {
        "number": 537,
        "title": "Complex Number Multiplication",
        "difficulty": 1,
        "answer": "        n1 = num1.split('+')\n        n2 = num2.split('+')\n        real = int(n1[0]) * int(n2[0])\n        imaginary = int(n1[1]) * int(n2[1])\n        return str(real) + '+' + str(imaginary) + 'i'"
    },
    {
        "number": 538,
        "title": "Convert BST to Greater Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if not root.left and not root.right:\n            return root\n        return self.convertBST(root.left) + self.convertBST(root.right)"
    },
    {
        "number": 539,
        "title": "Minimum Time Difference",
        "difficulty": 1,
        "answer": "        if not timePoints:\n            return 0"
    },
    {
        "number": 540,
        "title": "Single Element in a Sorted Array",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return nums[0] if nums[0]!= nums[1] else nums[1]\n        if len(nums) == 3:\n            return nums[0] if nums[0]!= nums[1] and nums[0]!= nums[2] else nums[1] if nums[1]!= nums[2] else nums[2]\n        if len(nums) == 4:\n            return nums[0] if nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!= nums[3] else nums[1] if nums[1]!= nums[2] and nums[1]!= nums[3] else nums[2] if nums[2]!= nums[3] else nums[3]\n        if len"
    },
    {
        "number": 541,
        "title": "Reverse String II",
        "difficulty": 0,
        "answer": "        if len(s) < k:\n            return s\n        if len(s) % 2 == 0:\n            return self.reverseStr(s[:k] + s[k:], k)\n        else:\n            return self.reverseStr(s[:k], k) + s[k:]"
    },
    {
        "number": 542,
        "title": "01 Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = mat[i][j] + 1\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and mat[k][l] == 1:\n                                mat[i][j] = min(mat[i][j], mat[k][l] + 1)\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and mat[k][l] == 0:\n                                mat[i][j] = min(mat[i][j], mat[k][l])\n        return mat"
    },
    {
        "number": 543,
        "title": "Diameter of Binary Tree",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        left_diameter = self.diameterOfBinaryTree(root.left)\n        right_diameter = self.diameterOfBinaryTree(root.right)\n        return max(left_diameter, right_diameter) + 1\n"
    },
    {
        "number": 546,
        "title": "Remove Boxes",
        "difficulty": 2,
        "answer": "        n = len(boxes)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = boxes[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], boxes[i])\n        for j in range(1, n):\n            dp[0][j] = max(dp[0][j - 1], boxes[j])\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + boxes[i] * boxes[j]\n        return max(dp[n - 1][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 547,
        "title": "Number of Provinces",
        "difficulty": 1,
        "answer": "        n = len(isConnected)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if isConnected[i][j]:\n                    dp[i][j] = 1\n                    for k in range(n):\n                        if i!= k and j!= k and isConnected[i][k] and isConnected[j][k]:\n                            dp[i][j] += dp[i][k] + dp[k][j]\n        return sum(dp)"
    },
    {
        "number": 551,
        "title": "Student Attendance Record I",
        "difficulty": 0,
        "answer": "        absent = 0\n        late = 0\n        for i in range(len(s)):\n            if s[i] == 'A':\n                absent += 1\n            elif s[i] == 'L':\n                late += 1\n            else:\n                absent = 0\n                late = 0\n        return absent < 2 and late < 3"
    },
    {
        "number": 552,
        "title": "Student Attendance Record II",
        "difficulty": 2,
        "answer": "        MOD = 10 ** 9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if i >= 2:\n                dp[i] += dp[i - 2]\n            if i >= 3:\n                dp[i] += dp[i - 3]\n            if i >= 4:\n                dp[i] += dp[i - 4]\n            if i >= 5:\n                dp[i] += dp[i - 5]\n            if i >= 6:\n                dp[i] += dp[i - 6]\n            if i >= 7:\n                dp[i] += dp[i - 7]\n            if i >= 8:\n                dp[i] += dp[i - 8]\n            if i >= 9:\n                dp[i] += dp[i - 9]\n            if i >= 10:\n                dp[i] += dp[i - 10]\n            if i >="
    },
    {
        "number": 553,
        "title": "Optimal Division",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return str(nums[0])\n        if n == 2:\n            return str(nums[0]) + '/' + str(nums[1])\n        if n == 3:\n            return str(nums[0]) + '/' + str(nums[1]) + '/' + str(nums[2])\n        if n == 4:\n            return str(nums[0]) + '/' + str(nums[1]) + '/' + str(nums[2]) + '/' + str(nums[3])\n        if n == 5:\n            return str(nums[0]) + '/' + str(nums[1]) + '/' + str(nums[2]) + '/' + str(nums[3]) + '/' + str(nums[4])\n        if n == 6:\n            return str(nums[0]) + '/' + str(nums[1]) + '/' + str(nums[2]) + '/' + str(nums"
    },
    {
        "number": 554,
        "title": "Brick Wall",
        "difficulty": 1,
        "answer": "        n = len(wall)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if wall[i][j] == 1:\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return min(dp[-1])\n"
    },
    {
        "number": 556,
        "title": "Next Greater Element III",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-2/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-3/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-4/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-5/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-6/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-7/\n        # https://www.geeksforgeeks.org/next-greater-element-in-a-given-array-8/\n        # https://"
    },
    {
        "number": 557,
        "title": "Reverse Words in a String III",
        "difficulty": 0,
        "answer": "        s_list = s.split()\n        s_list.reverse()\n        return \" \".join(s_list)\n"
    },
    {
        "number": 558,
        "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
        "difficulty": 1,
        "answer": "        # Your Node object will be instantiated and called as such:\n        # obj = Node(val, isLeaf, topLeft, topRight, bottomLeft, bottomRight)\n        # param_1 = obj.val\n        # param_2 = obj.isLeaf\n        # param_3 = obj.topLeft\n        # param_4 = obj.topRight\n        # param_5 = obj.bottomLeft\n        # param_6 = obj.bottomRight\n        # return param_1, param_2, param_3, param_4, param_5, param_6\n        return 0\n"
    },
    {
        "number": 559,
        "title": "Maximum Depth of N-ary Tree",
        "difficulty": 0,
        "answer": "        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given a n-ary tree, find its maximum depth.\n        # The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n        # Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).\n        # Example 1:\n        # Input: root = [1,null,3,2,4,null,5,6]\n        # Output: 3\n        # Example 2:\n        # Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n        # Output: 5\n        # Note:\n        # The depth of the tree is at most 1000.\n"
    },
    {
        "number": 560,
        "title": "Subarray Sum Equals K",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the number of subarrays whose sum equals to k with the first i elements\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n        # dp[i][j] = dp["
    },
    {
        "number": 561,
        "title": "Array Partition",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n + 1):\n            dp[i] = max(nums[i - 2] + dp[i - 1], nums[i - 1] + dp[i - 2])\n        return dp[n]\n"
    },
    {
        "number": 563,
        "title": "Binary Tree Tilt",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        return abs(sum(self.findTilt(node) for node in self.traverse(root)))"
    },
    {
        "number": 564,
        "title": "Find the Closest Palindrome",
        "difficulty": 2,
        "answer": "        n = int(n)\n        if n < 0:\n            return -1\n        if n == 0:\n            return 0\n        if n == 1:\n            return 2\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19"
    },
    {
        "number": 565,
        "title": "Array Nesting",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22"
    },
    {
        "number": 566,
        "title": "Reshape the Matrix",
        "difficulty": 0,
        "answer": "        if r * c!= mat[0][0]:\n            return mat\n        if r * c < mat[0][0]:\n            return mat\n        if r * c > mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:\n            return mat\n        if r * c == mat[0][0]:"
    },
    {
        "number": 567,
        "title": "Permutation in String",
        "difficulty": 1,
        "answer": "        if len(s1) > len(s2):\n            return False\n        if len(s1) == len(s2):\n            return s1 == s2\n        if len(s1) == 1:\n            return s1 == s2[:len(s1)]\n        if len(s2) == 1:\n            return s1[:len(s2)] == s2\n        if s1[0] == s2[0]:\n            return self.checkInclusion(s1[1:], s2[1:])\n        return self.checkInclusion(s1, s2[1:]) or self.checkInclusion(s1[1:], s2)"
    },
    {
        "number": 572,
        "title": "Subtree of Another Tree",
        "difficulty": 0,
        "answer": "        if root is None and subRoot is None:\n            return True\n        if root is None or subRoot is None:\n            return False\n        if root.val == subRoot.val:\n            return self.isSubtree(root.left, subRoot) and self.isSubtree(root.right, subRoot)\n        return False\n"
    },
    {
        "number": 575,
        "title": "Distribute Candies",
        "difficulty": 0,
        "answer": "        n = len(candyType)\n        if n % 2 == 1:\n            return n // 2\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + candyType[i - 1]\n        return dp[n - 1] // 2\n"
    },
    {
        "number": 576,
        "title": "Out of Boundary Paths",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[startRow][startColumn] = 1\n        for _ in range(maxMove):\n            for i in range(m):\n                for j in range(n):\n                    if i == 0 and j == 0:\n                        continue\n                    if i == 0:\n                        dp[i][j] += dp[i][j - 1]\n                    if j == 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if i == m - 1:\n                        dp[i][j] += dp[i][j + 1]\n                    if j == n - 1:\n                        dp[i][j] += dp[i + 1][j]\n                    if i > 0 and j > 0:\n                        dp[i][j] += dp[i - 1][j - 1]\n                    if i > 0 and j < n - 1:\n                        dp[i][j] += dp[i - 1][j + 1]\n                    if i < m -"
    },
    {
        "number": 581,
        "title": "Shortest Unsorted Continuous Subarray",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if nums[0] < nums[1] else 0\n        if n == 3:\n            return 1 if nums[0] < nums[1] and nums[1] < nums[2] else 0\n        if n == 4:\n            return 1 if nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3] else 0\n        if n == 5:\n            return 1 if nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3] and nums[3] < nums[4] else 0\n        if n == 6:\n            return 1 if nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3] and"
    },
    {
        "number": 583,
        "title": "Delete Operation for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\n        return dp[m][n]\n"
    },
    {
        "number": 587,
        "title": "Erect the Fence",
        "difficulty": 2,
        "answer": "        if not trees:\n            return []\n        n = len(trees)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if trees[i][0] == trees[j][0] and trees[i][1] == trees[j][1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    dp[j][i] = dp[i][j]\n                elif trees[i][0] == trees[j][0] and trees[i][1]!= trees[j][1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    dp[j][i] = dp[i][j] + 1\n                elif trees[i][0]!= trees[j][0] and trees[i][1] == trees[j][1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    dp[j][i]"
    },
    {
        "number": 589,
        "title": "N-ary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given a root node of a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n        # For example:\n        # Given binary tree {3,9,20,#,#,15,7},\n        #     3\n        #    / \\\n        #   9  20\n        #     /  \\\n        #    15   7\n        # return its level order traversal as:\n        # [\n        #   [3],\n        #   [9,20],\n        #   [15,7]\n        # ]\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, val=None, left=None, right=None):\n        #         self.val = val\n        #         self.left = left\n        #"
    },
    {
        "number": 590,
        "title": "N-ary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given a node, return the level order traversal of its nodes.\n        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given a node, return the level order traversal of its nodes.\n        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self.children = children\n        # Given a node, return the level order traversal of its nodes.\n        # Definition for a Node.\n        # class Node:\n        #     def __init__(self, val=None, children=None):\n        #         self.val = val\n        #         self"
    },
    {
        "number": 591,
        "title": "Tag Validator",
        "difficulty": 2,
        "answer": "        stack = []\n        for c in code:\n            if c == '<':\n                if stack:\n                    if stack[-1] == '<':\n                        stack.pop()\n                    else:\n                        stack.append('<')\n                else:\n                    stack.append('<')\n            elif c == '>':\n                if stack:\n                    if stack[-1] == '<':\n                        stack.pop()\n                    elif stack[-1] == '>':\n                        stack.pop()\n                    else:\n                        stack.append('>')\n                else:\n                    stack.append('>')\n            elif c == ']':\n                if stack and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    stack.append(']')\n            elif c == '[':\n                stack.append('[')\n            elif c == ']':\n                if stack and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    stack.append(']')\n            elif c == '\"':\n                stack."
    },
    {
        "number": 592,
        "title": "Fraction Addition and Subtraction",
        "difficulty": 1,
        "answer": "        def fraction_add(a, b):\n            if a.denominator == b.denominator:\n                return Fraction(a.numerator + b.numerator, a.denominator)\n            else:\n                return Fraction(a.numerator * b.denominator + b.numerator * a.denominator, a.denominator * b.denominator)"
    },
    {
        "number": 593,
        "title": "Valid Square",
        "difficulty": 1,
        "answer": "        def is_square(p1, p2, p3, p4):\n            return (p1[0] - p2[0]) * (p3[1] - p4[1]) == (p1[1] - p2[1]) * (p3[0] - p4[0])"
    },
    {
        "number": 594,
        "title": "Longest Harmonious Subsequence",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2: return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0][n - 1], dp[n - 1][0])\n\r\n\r\nclass Solution2:\r\n    def findLHS(self, nums: List[int]) -> int:\r\n        \"\"\"\r\n        We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\r\n        Given an integer array nums, return the length of its longest harmonious subsequence among all its possible"
    },
    {
        "number": 598,
        "title": "Range Addition II",
        "difficulty": 0,
        "answer": "        m, n = len(m), len(n)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 599,
        "title": "Minimum Index Sum of Two Lists",
        "difficulty": 0,
        "answer": "        if not list1 or not list2:\n            return []\n        if len(list1) > len(list2):\n            list1, list2 = list2, list1\n        dict1 = {x: i for i, x in enumerate(list1)}\n        dict2 = {x: i for i, x in enumerate(list2)}\n        ans = []\n        for x in list1:\n            if x in list2:\n                ans.append(x)\n        for x in list2:\n            if x in list1:\n                ans.append(x)\n        for x in list1:\n            if x in list2:\n                ans.append(x)\n        return ans"
    },
    {
        "number": 600,
        "title": "Non-negative Integers without Consecutive Ones",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 2\n        if n == 2:\n            return 3\n        if n == 3:\n            return 4\n        if n == 4:\n            return 5\n        if n == 5:\n            return 6\n        if n == 6:\n            return 7\n        if n == 7:\n            return 8\n        if n == 8:\n            return 9\n        if n == 9:\n            return 10\n        if n == 10:\n            return 11\n        if n == 11:\n            return 12\n        if n == 12:\n            return 13\n        if n == 13:\n            return 14\n        if n == 14:\n            return 15\n        if n == 15:\n            return 16\n        if n == 16:\n            return 17\n        if n == 17:\n            return 18\n        if n == 18:\n            return 19\n        if n == 19:\n            return 20\n        if n == 20:\n            return 21\n        if n == 21:\n            return 22\n        if n == 22:\n            return 23\n        if n == 23:\n            "
    },
    {
        "number": 605,
        "title": "Can Place Flowers",
        "difficulty": 0,
        "answer": "        if len(flowerbed) == 0:\n            return True\n        if len(flowerbed) == 1:\n            return False\n        if len(flowerbed) == 2:\n            return flowerbed[0] == 0 and flowerbed[1] == 0\n        if len(flowerbed) == 3:\n            return flowerbed[0] == 0 and flowerbed[1] == 0 and flowerbed[2] == 0\n        if len(flowerbed) == 4:\n            return flowerbed[0] == 0 and flowerbed[1] == 0 and flowerbed[2] == 0 and flowerbed[3] == 0\n        if len(flowerbed) == 5:\n            return flowerbed[0] == 0 and flowerbed[1] == 0 and flowerbed[2] == 0 and flowerbed[3] == 0 and flowerbed[4] == 0\n        if len(flowerbed) == 6:\n            return flowerbed[0] == 0 and flowerbed[1] == 0 and flowerbed[2] == 0 and flowerbed[3] == 0 and flowerbed[4] == 0 and flowerbed["
    },
    {
        "number": 606,
        "title": "Construct String from Binary Tree",
        "difficulty": 0,
        "answer": "        if root is None:\n            return \"\"\n        if root.left is None and root.right is None:\n            return str(root.val)\n        return \"({})\".format(self.tree2str(root.left)) + str(root.val) + \"({})\".format(self.tree2str(root.right))"
    },
    {
        "number": 609,
        "title": "Find Duplicate File in System",
        "difficulty": 1,
        "answer": "        result = []\n        for path in paths:\n            path = path.strip()\n            if not path:\n                continue\n            path_list = path.split(' ')\n            path_list = [p.strip() for p in path_list]\n            if len(path_list) < 2:\n                continue\n            path_list = [p for p in path_list if p]\n            if len(path_list) < 2:\n                continue\n            path_list = [p.split('(') for p in path_list]\n            path_list = [p[0] for p in path_list if len(p) > 1]\n            path_list = [p.strip() for p in path_list]\n            path_list = [p for p in path_list if p]\n            if len(path_list) < 2:\n                continue\n            path_list = [p.split('.') for p in path_list]\n            path_list = [p[0] for p in path_list if len(p) > 1]\n            path_list"
    },
    {
        "number": 611,
        "title": "Valid Triangle Number",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + nums[i] * nums[j]\n        return sum(sum(dp[i]) for i in range(n)) // 2\n"
    },
    {
        "number": 617,
        "title": "Merge Two Binary Trees",
        "difficulty": 0,
        "answer": "        if not root1:\n            return root2\n        if not root2:\n            return root1\n        if root1.val == root2.val:\n            root1.val += root2.val\n            return root1\n        return self.mergeTrees(root1.left, root2.left) or self.mergeTrees(root1.right, root2.right)"
    },
    {
        "number": 621,
        "title": "Task Scheduler",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j"
    },
    {
        "number": 622,
        "title": "Design Circular Queue",
        "difficulty": 1,
        "answer": "        # Your MyCircularQueue object will be instantiated and called as such:\n        # obj = MyCircularQueue(k)\n        # param_1 = obj.enQueue(value)\n        # param_2 = obj.deQueue()\n        # param_3 = obj.Front()\n        # param_4 = obj.Rear()\n        # param_5 = obj.isEmpty()\n        # param_6 = obj.isFull()\n        self.k = k\n        self.queue = []\n        self.front = 0\n        self.rear = 0\n        self.is_full = False\n        self.is_empty = True"
    },
    {
        "number": 623,
        "title": "Add One Row to Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if depth == 1:\n            return TreeNode(val)\n        left = self.addOneRow(root.left, val, depth - 1)\n        right = self.addOneRow(root.right, val, depth - 1)\n        root.left = left\n        root.right = right\n        return root\n"
    },
    {
        "number": 628,
        "title": "Maximum Product of Three Numbers",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            return max(nums[0] * nums[1] * nums[2], nums[0] * nums[1] * nums[2], nums[0] * nums[1] * nums[2])\n"
    },
    {
        "number": 629,
        "title": "K Inverse Pairs Array",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + dp[i - 1][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n        # dp[i][j"
    },
    {
        "number": 630,
        "title": "Course Schedule III",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] means the max number of courses that can be taken in the first i days\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-courses[i][0]] + courses[i][1])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-courses[i][0]])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-courses[i][0]] + courses[i][1])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-courses[i][0]])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-courses[i][0]] + courses[i][1])\n        # dp[i][j] = max(dp[i"
    },
    {
        "number": 632,
        "title": "Smallest Range Covering Elements from K Lists",
        "difficulty": 2,
        "answer": "        if not nums:\n            return []\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i][j] - nums[i][i] < nums[j][j] - nums[j][i]:\n                    dp[i][j] = nums[i][j] - nums[i][i]\n                else:\n                    dp[i][j] = nums[j][j] - nums[j][i]\n        ans = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dp[i][j] > 0:\n                    ans.append(nums[i][j] - dp[i][j])\n        return ans\n"
    },
    {
        "number": 633,
        "title": "Sum of Square Numbers",
        "difficulty": 1,
        "answer": "        if c < 0:\n            return False\n        if c == 0:\n            return True\n        if c % 2 == 0:\n            return False\n        if c % 3 == 0:\n            return False\n        if c % 4 == 0:\n            return False\n        if c % 5 == 0:\n            return False\n        if c % 6 == 0:\n            return False\n        if c % 7 == 0:\n            return False\n        if c % 8 == 0:\n            return False\n        if c % 9 == 0:\n            return False\n        if c % 10 == 0:\n            return False\n        if c % 11 == 0:\n            return False\n        if c % 12 == 0:\n            return False\n        if c % 13 == 0:\n            return False\n        if c % 14 == 0:\n            return False\n        if c % 15 == 0:\n            return False\n        if c % 16 == 0:\n            return False\n        if c % 17 == 0:\n            return False\n        if c % 18 == 0:\n            return False\n        if c % 19 == 0"
    },
    {
        "number": 636,
        "title": "Exclusive Time of Functions",
        "difficulty": 1,
        "answer": "        # stack: function_id, start_time, end_time\n        stack = []\n        for log in logs:\n            function_id, start_or_end, timestamp = log.split(':')\n            if start_or_end =='start':\n                stack.append((function_id, timestamp))\n            else:\n                function_id, start_time = stack.pop()\n                end_time = timestamp\n                exclusive_time = end_time - start_time\n                stack.append((function_id, exclusive_time))\n        return [x[1] for x in stack]"
    },
    {
        "number": 637,
        "title": "Average of Levels in Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        ans = []\n        self.helper(root, ans)\n        return ans"
    },
    {
        "number": 638,
        "title": "Shopping Offers",
        "difficulty": 1,
        "answer": "        n = len(price)\n        m = len(special)\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i])\n        dp = [[float('inf') for _ in range(n + 1)] for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 0\n        for i in range(n):\n            for j in range(n + 1):\n                if j >= needs[i]:\n                    dp[i][j] = min(dp[i][j], dp[i][j - needs[i]] + price[i])\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])\n        \n        # dp[i][n] = min(dp[i][n], dp[i - 1][n] + price[i])\n        dp[n][n] = float('inf')\n        for i in range"
    },
    {
        "number": 639,
        "title": "Decode Ways II",
        "difficulty": 2,
        "answer": "        dp = [0] * len(s)\n        dp[0] = 1\n        for i in range(1, len(s)):\n            if s[i] == '*':\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[-1] % MOD\n"
    },
    {
        "number": 640,
        "title": "Solve the Equation",
        "difficulty": 1,
        "answer": "        lhs, rhs = equation.split('=')\n        lhs = lhs.strip()\n        rhs = rhs.strip()\n        if not lhs or not rhs:\n            return 'No solution'\n        lhs_list = lhs.split('+')\n        rhs_list = rhs.split('+')\n        if len(lhs_list)!= len(rhs_list):\n            return 'No solution'\n        for i in range(len(lhs_list)):\n            lhs_list[i] = lhs_list[i].strip()\n            rhs_list[i] = rhs_list[i].strip()\n            if not lhs_list[i] or not rhs_list[i]:\n                return 'No solution'\n            if lhs_list[i][0] == '-':\n                lhs_list[i] = lhs_list[i][1:]\n                rhs_list[i] = '-' + rhs_list[i]\n            if rhs_list[i][0"
    },
    {
        "number": 641,
        "title": "Design Circular Deque",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 643,
        "title": "Maximum Average Subarray I",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < k:\n            return 0\n        if k == 1:\n            return max(nums)\n        if k == 2:\n            return (nums[0] + nums[1]) / 2\n        if k == 3:\n            return (nums[0] + nums[1] + nums[2]) / 3\n        if k == 4:\n            return (nums[0] + nums[1] + nums[2] + nums[3]) / 4\n        if k == 5:\n            return (nums[0] + nums[1] + nums[2] + nums[3] + nums[4]) / 5\n        if k == 6:\n            return (nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]) / 6\n        if k == 7:\n            return (nums[0] + nums[1] + nums[2] + nums[3] + num"
    },
    {
        "number": 645,
        "title": "Set Mismatch",
        "difficulty": 0,
        "answer": "        nums.sort()\n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] == nums[j]:\n                return [nums[i], nums[j]]\n            i += 1\n            j -= 1\n        return [nums[i], nums[j]]\n"
    },
    {
        "number": 646,
        "title": "Maximum Length of Pair Chain",
        "difficulty": 1,
        "answer": "        if not pairs:\n            return 0\n        pairs.sort(key=lambda x: x[0])\n        dp = [[0] * len(pairs) for _ in range(len(pairs))]\n        for i in range(len(pairs)):\n            for j in range(i + 1, len(pairs)):\n                if pairs[i][1] < pairs[j][0]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[j][j - 1])\n        return max(dp)\n"
    },
    {
        "number": 647,
        "title": "Palindromic Substrings",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s)):\n            dp[i][i] = 1\n        for i in range(len(s) - 1):\n            dp[i][i + 1] = 1\n        for i in range(len(s) - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(len(s) - 3, -1, -1):\n            for j in range(i + 3, len(s) + 1):\n                dp[i][j] = dp[i + 1][j - 1] + dp[i + 2][j - 2]\n        return dp[0][len(s)]"
    },
    {
        "number": 648,
        "title": "Replace Words",
        "difficulty": 1,
        "answer": "        d = {word: i for i, word in enumerate(dictionary)}\n        s = sentence.split()\n        for i in range(len(s)):\n            if s[i] in d:\n                s[i] = dictionary[d[s[i]]]\n        return''.join(s)\n"
    },
    {
        "number": 649,
        "title": "Dota2 Senate",
        "difficulty": 1,
        "answer": "        n = len(senate)\n        if n == 1:\n            return senate[0]\n        if n == 2:\n            return senate[0] if senate[0] == senate[1] else senate[1]\n        if n == 3:\n            return senate[0] if senate[0] == senate[1] else senate[1] if senate[1] == senate[2] else senate[2]\n        if n == 4:\n            return senate[0] if senate[0] == senate[1] else senate[1] if senate[1] == senate[2] else senate[2] if senate[2] == senate[3] else senate[3]\n        if n == 5:\n            return senate[0] if senate[0] == senate[1] else senate[1] if senate[1] == senate[2] else senate[2] if senate[2] == senate[3] else senate[3] if senate[3] == senate[4] else senate[4]\n        if n == 6:\n            return senate[0] if senate[0] == senate["
    },
    {
        "number": 650,
        "title": "2 Keys Keyboard",
        "difficulty": 1,
        "answer": "        dp = [[0] * 2 for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0] + 1\n            dp[i][1] = dp[i - 1][1] + 1\n        for i in range(n, 0, -1):\n            dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1)\n            dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1)\n        return dp[n][0]\n"
    },
    {
        "number": 652,
        "title": "Find Duplicate Subtrees",
        "difficulty": 1,
        "answer": "        def dfs(node, dups):\n            if not node:\n                return\n            if node.left:\n                dfs(node.left, dups)\n            if node.right:\n                dfs(node.right, dups)\n            if node.val in dups:\n                dups[node.val].append(node)\n            else:\n                dups[node.val] = [node]\n        dups = {}\n        dfs(root, dups)\n        return [dups[val] for val in dups]"
    },
    {
        "number": 653,
        "title": "Two Sum IV - Input is a BST",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right:\n            return k == root.val\n        return self.findTarget(root.left, k - root.val) or self.findTarget(root.right, k - root.val)"
    },
    {
        "number": 654,
        "title": "Maximum Binary Tree",
        "difficulty": 1,
        "answer": "        if not nums:\n            return None\n        if len(nums) == 1:\n            return TreeNode(nums[0])\n        max_val = max(nums)\n        left_nodes = self.constructMaximumBinaryTree(nums[:max_val])\n        right_nodes = self.constructMaximumBinaryTree(nums[max_val:])\n        if left_nodes is None:\n            return right_nodes\n        if right_nodes is None:\n            return left_nodes\n        return TreeNode(max_val, left_nodes, right_nodes)"
    },
    {
        "number": 655,
        "title": "Print Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(root, res, level):\n            if not root:\n                return\n            if not res:\n                res.append([])\n            if level == 0:\n                res[0].append(str(root.val))\n            else:\n                res[level].append(str(root.val))\n            dfs(root.left, res, level + 1)\n            dfs(root.right, res, level + 1)"
    },
    {
        "number": 657,
        "title": "Robot Return to Origin",
        "difficulty": 0,
        "answer": "        moves = moves.strip()\n        moves = moves.upper()\n        moves = moves.replace(' ', '')\n        moves = moves.replace('R', '0')\n        moves = moves.replace('L', '1')\n        moves = moves.replace('U', '2')\n        moves = moves.replace('D', '3')\n        moves = moves.replace('0', 'R')\n        moves = moves.replace('1', 'L')\n        moves = moves.replace('2', 'U')\n        moves = moves.replace('3', 'D')\n        moves = moves.replace('0', '0')\n        moves = moves.replace('1', '1')\n        moves = moves.replace('2', '2')\n        moves = moves.replace('3', '3')\n        moves = moves.replace('0', '0')\n        moves = moves.replace('1', '1')\n        moves = moves.replace('2', '2')\n        moves = moves.replace('3',"
    },
    {
        "number": 658,
        "title": "Find K Closest Elements",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return []\n        if k == 1:\n            return [x]\n        if k == 2:\n            return [x, arr[0]]\n        if k == 3:\n            return [x, arr[0], arr[1]]\n        if k == 4:\n            return [x, arr[0], arr[1], arr[2]]\n        if k == 5:\n            return [x, arr[0], arr[1], arr[2], arr[3]]\n        if k == 6:\n            return [x, arr[0], arr[1], arr[2], arr[3], arr[4]]\n        if k == 7:\n            return [x, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]]\n        if k == 8:\n            return [x, arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]]\n        if k == 9:\n            return [x, arr[0], arr[1], arr[2"
    },
    {
        "number": 659,
        "title": "Split Array into Consecutive Subsequences",
        "difficulty": 1,
        "answer": "        if len(nums) < 3:\n            return False\n        n = len(nums)\n        dp = [[False] * n for _ in range(n)]\n        dp[0][0] = True\n        for i in range(1, n):\n            dp[i][i] = True\n            for j in range(i - 1, -1, -1):\n                if nums[i] > nums[j] and dp[j + 1][i - 1]:\n                    dp[i][j] = True\n        return dp[n - 1][0]"
    },
    {
        "number": 661,
        "title": "Image Smoother",
        "difficulty": 0,
        "answer": "        m, n = len(img), len(img[0])\n        img = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                img[i][j] = int(round(sum(img[i - 1][j - 1:j + 1]) / 9))\n        return img"
    },
    {
        "number": 662,
        "title": "Maximum Width of Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        return max(self.widthOfBinaryTree(root.left), self.widthOfBinaryTree(root.right)) + 1"
    },
    {
        "number": 664,
        "title": "Strange Printer",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 2\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 3, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + 1\n        return dp[0][n - 1]\n"
    },
    {
        "number": 665,
        "title": "Non-decreasing Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return True\n        if nums[0] > nums[1]:\n            return False\n        for i in range(2, n):\n            if nums[i] > nums[i - 1]:\n                return False\n        return True\n"
    },
    {
        "number": 667,
        "title": "Beautiful Arrangement II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if k == 1:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 2:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 3:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 4:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 5:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 6:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 7:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 8:\n            return [1] + [i for i in range(2, n + 1)]\n        if k == 9:\n            return [1] + [i for i in range(2"
    },
    {
        "number": 668,
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": 2,
        "answer": "        if m == 1:\n            return n * k\n        if n == 1:\n            return m * k\n        if k == 1:\n            return m * n\n        if m == n:\n            return m * (k // 2)\n        if m > n:\n            return self.findKthNumber(n, m, k)\n        if m < n:\n            return self.findKthNumber(m, n, k)\n        if m == n:\n            return self.findKthNumber(m, m, k)\n        return self.findKthNumber(m, n, k)"
    },
    {
        "number": 669,
        "title": "Trim a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n        if root.val > high:\n            return self.trimBST(root.left, low, high)\n        root.left = self.trimBST(root.left, low, high)\n        root.right = self.trimBST(root.right, low, high)\n        return root\n"
    },
    {
        "number": 670,
        "title": "Maximum Swap",
        "difficulty": 1,
        "answer": "        n = len(str(num))\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + num[i] * 10 ** (n - j - 1)\n        return dp[0][n]\n"
    },
    {
        "number": 671,
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": 0,
        "answer": "        def dfs(node: Optional[TreeNode]) -> int:\n            if node is None:\n                return -1\n            if node.left is None and node.right is None:\n                return node.val\n            if node.left is None:\n                return dfs(node.right)\n            if node.right is None:\n                return dfs(node.left)\n            return min(dfs(node.left), dfs(node.right))"
    },
    {
        "number": 672,
        "title": "Bulb Switcher II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 2\n        if n == 2:\n            return 3\n        if n == 3:\n            return 4\n        if n == 4:\n            return 5\n        if n == 5:\n            return 6\n        if n == 6:\n            return 7\n        if n == 7:\n            return 8\n        if n == 8:\n            return 9\n        if n == 9:\n            return 10\n        if n == 10:\n            return 11\n        if n == 11:\n            return 12\n        if n == 12:\n            return 13\n        if n == 13:\n            return 14\n        if n == 14:\n            return 15\n        if n == 15:\n            return 16\n        if n == 16:\n            return 17\n        if n == 17:\n            return 18\n        if n == 18:\n            return 19\n        if n == 19:\n            return 20\n        if n == 20:\n            return 21\n        if n == 21:\n            return 22\n        if n == 22:\n            return 23\n        if n == 23:\n            "
    },
    {
        "number": 673,
        "title": "Number of Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 674,
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], dp[i - 1] + 1)\n        return max(dp)"
    },
    {
        "number": 675,
        "title": "Cut Off Trees for Golf Event",
        "difficulty": 2,
        "answer": "        def dfs(i, j, m, n):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if forest[i][j] == 0:\n                return 0\n            if forest[i][j] > 1:\n                return forest[i][j]\n            return max(dfs(i + 1, j, m, n), dfs(i, j + 1, m, n), dfs(i + 1, j + 1, m, n), dfs(i - 1, j, m, n), dfs(i, j - 1, m, n), dfs(i - 1, j - 1, m, n), dfs(i + 1, j - 1, m, n), dfs(i - 1, j + 1, m, n)) + 1"
    },
    {
        "number": 676,
        "title": "Implement Magic Dictionary",
        "difficulty": 1,
        "answer": "        self.dictionary = dictionary\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self.dictionary.sort()\n        self.dictionary.append('')\n        self"
    },
    {
        "number": 677,
        "title": "Map Sum Pairs",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 678,
        "title": "Valid Parenthesis String",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack.pop()!= '(':\n                    return False\n            elif c == '*':\n                if stack and stack[-1] == '(':\n                    stack.pop()\n                elif stack and stack[-1] == '*':\n                    stack.pop()\n                else:\n                    stack.append(c)\n        return not stack"
    },
    {
        "number": 679,
        "title": "24 Game",
        "difficulty": 2,
        "answer": "        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com/zuoyuan/p/3723982.html\n        # https://www.cnblogs.com"
    },
    {
        "number": 680,
        "title": "Valid Palindrome II",
        "difficulty": 0,
        "answer": "        if len(s) <= 1:\n            return True\n        if len(s) == 2:\n            return s[0] == s[1]\n        if s[0] == s[-1]:\n            return self.validPalindrome(s[1:-1])\n        return False\n"
    },
    {
        "number": 682,
        "title": "Baseball Game",
        "difficulty": 0,
        "answer": "        n = len(operations)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            if operations[i - 1] == 'C':\n                dp[i] = dp[i - 1]\n            elif operations[i - 1] == 'D':\n                dp[i] = dp[i - 1] * 2\n            elif operations[i - 1] == '+':\n                dp[i] = dp[i - 1] + dp[i - 2]\n            else:\n                dp[i] = dp[i - 1]\n        return dp[n]\n"
    },
    {
        "number": 684,
        "title": "Redundant Connection",
        "difficulty": 1,
        "answer": "        n = len(edges)\n        if n == 0:\n            return []\n        if n == 1:\n            return []\n        if n == 2:\n            return [0]\n        if n == 3:\n            return [0, 1]\n        if n == 4:\n            return [0, 1, 2]\n        if n == 5:\n            return [0, 1, 2, 3]\n        if n == 6:\n            return [0, 1, 2, 3, 4]\n        if n == 7:\n            return [0, 1, 2, 3, 4, 5]\n        if n == 8:\n            return [0, 1, 2, 3, 4, 5, 6]\n        if n == 9:\n            return [0, 1, 2, 3, 4, 5, 6, 7]\n        if n == 10:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 11:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
    },
    {
        "number": 685,
        "title": "Redundant Connection II",
        "difficulty": 2,
        "answer": "        def dfs(u, v):\n            if u == v:\n                return True\n            for _ in range(len(edges)):\n                if edges[_][0] == u and edges[_][1] == v:\n                    return True\n                if edges[_][0] == v and edges[_][1] == u:\n                    return True\n            return False"
    },
    {
        "number": 686,
        "title": "Repeated String Match",
        "difficulty": 1,
        "answer": "        n = len(a)\n        m = len(b)\n        if n > m:\n            return -1\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = i\n        for j in range(1, m + 1):\n            dp[0][j] = j\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if a[i - 1] == b[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[n][m]\n"
    },
    {
        "number": 687,
        "title": "Longest Univalue Path",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.longestUnivaluePath(root.right) + 1\n        if root.right is None:\n            return self.longestUnivaluePath(root.left) + 1\n        return max(self.longestUnivaluePath(root.left), self.longestUnivaluePath(root.right)) + 1"
    },
    {
        "number": 688,
        "title": "Knight Probability in Chessboard",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(n):\n                if i + 2 < n and j + 2 < n:\n                    dp[i + 2][j + 2] += dp[i][j]\n                if i + 2 < n and j - 2 >= 0:\n                    dp[i + 2][j - 2] += dp[i][j]\n                if i - 2 >= 0 and j + 2 < n:\n                    dp[i - 2][j + 2] += dp[i][j]\n                if i - 2 >= 0 and j - 2 >= 0:\n                    dp[i - 2][j - 2] += dp[i][j]\n                if i + 1 < n and j + 1 < n:\n                    dp[i + 1][j + 1] += dp[i][j]\n                if i + 1 < n and j - 1 >= 0:"
    },
    {
        "number": 689,
        "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return []\n        if k > n:\n            return []\n        if k == 1:\n            return [0]\n        if k == 2:\n            return [0, 1]\n        if k == 3:\n            return [0, 1, 2]\n        if k == 4:\n            return [0, 1, 2, 3]\n        if k == 5:\n            return [0, 1, 2, 3, 4]\n        if k == 6:\n            return [0, 1, 2, 3, 4, 5]\n        if k == 7:\n            return [0, 1, 2, 3, 4, 5, 6]\n        if k == 8:\n            return [0, 1, 2, 3, 4, 5, 6, 7]\n        if k == 9:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        if k == 10:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
    },
    {
        "number": 690,
        "title": "Employee Importance",
        "difficulty": 1,
        "answer": "        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n        self.total = 0\n        self.visited = set()\n        self.dfs(0)\n        return self.total"
    },
    {
        "number": 691,
        "title": "Stickers to Spell Word",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the minimum number of stickers to form target[0:i] with j stickers\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1"
    },
    {
        "number": 692,
        "title": "Top K Frequent Words",
        "difficulty": 1,
        "answer": "        count = {}\n        for word in words:\n            count[word] = count.get(word, 0) + 1\n        count = sorted(count.items(), key=lambda x: x[1], reverse=True)\n        return [x[0] for x in count[:k]]\n"
    },
    {
        "number": 693,
        "title": "Binary Number with Alternating Bits",
        "difficulty": 0,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/8"
    },
    {
        "number": 695,
        "title": "Max Area of Island",
        "difficulty": 1,
        "answer": "        def dfs(i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j]!= 1:\n                return 0\n            grid[i][j] = 0\n            count = 1\n            count += dfs(i - 1, j)\n            count += dfs(i + 1, j)\n            count += dfs(i, j - 1)\n            count += dfs(i, j + 1)\n            return count"
    },
    {
        "number": 696,
        "title": "Count Binary Substrings",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 1, 0, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n]\n"
    },
    {
        "number": 697,
        "title": "Degree of an Array",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        \n        # dp[i] means the length of the subarray with the degree i\n        dp = [0] * len(nums)\n        \n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2]"
    },
    {
        "number": 698,
        "title": "Partition to K Equal Sum Subsets",
        "difficulty": 1,
        "answer": "        nums.sort()\n        if k > len(nums) / 2:\n            return False\n        dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        for i in range(1, len(nums) + 1):\n            for j in range(1, k + 1):\n                if i - nums[j - 1] >= j:\n                    dp[i][j] = dp[i - nums[j - 1]][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return dp[len(nums)][k]"
    },
    {
        "number": 699,
        "title": "Falling Squares",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the height of the tallest stack of squares with left i and height j\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + positions[i][1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(positions[i][0], positions[i][1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(positions[i][0], max(positions[i][1], positions[i][2]))\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(positions[i][0], max(positions[i][1], max(positions[i][2"
    },
    {
        "number": 700,
        "title": "Search in a Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return None\n        if root.val == val:\n            return root\n        left = self.searchBST(root.left, val)\n        right = self.searchBST(root.right, val)\n        if left and right:\n            return root\n        return left or right\n"
    },
    {
        "number": 701,
        "title": "Insert into a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insertIntoBST(root.left, val)\n        elif val > root.val:\n            root.right = self.insertIntoBST(root.right, val)\n        else:\n            return root\n        return root"
    },
    {
        "number": 703,
        "title": "Kth Largest Element in a Stream",
        "difficulty": 0,
        "answer": "        self.nums = nums\n        self.k = k\n        self.n = len(nums)\n        self.heap = []\n        for i in range(k):\n            self.heap.append(0)\n        for i in range(k, self.n+1):\n            self.heap.append(0)\n        self.heapify()"
    },
    {
        "number": 704,
        "title": "Binary Search",
        "difficulty": 0,
        "answer": "        lo = 0\n        hi = len(nums) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        return -1\n"
    },
    {
        "number": 705,
        "title": "Design HashSet",
        "difficulty": 0,
        "answer": "        # Your MyHashSet object will be instantiated and called as such:\n        # obj = MyHashSet()\n        # obj.add(key)\n        # param_2 = obj.contains(key)\n        # obj.remove(key)\n        # param_3 = obj.contains(key)\n        self.dict = {}\n        self.dict[key] = True\n    def size(self) -> int:\n        \"\"\"\n        Returns the number of unique elements in the HashSet.\n        \"\"\"\n        return len(self.dict)"
    },
    {
        "number": 706,
        "title": "Design HashMap",
        "difficulty": 0,
        "answer": "        self.map = {}\n        for i in range(len(args)):\n            if args[i] == \"put\":\n                self.map[args[i+1][0]] = args[i+1][1]\n            elif args[i] == \"get\":\n                if args[i+1][0] in self.map:\n                    return self.map[args[i+1][0]]\n                else:\n                    return -1\n            elif args[i] == \"remove\":\n                if args[i+1][0] in self.map:\n                    del self.map[args[i+1][0]]\n            else:\n                raise Exception(\"Invalid command\")\n        return None"
    },
    {
        "number": 707,
        "title": "Design Linked List",
        "difficulty": 1,
        "answer": "        # Your MyLinkedList object will be instantiated and called as such:\n        # obj = MyLinkedList()\n        # param_1 = obj.get(index)\n        # obj.addAtHead(val)\n        # obj.addAtTail(val)\n        # obj.addAtIndex(index,val)\n        # obj.deleteAtIndex(index)\n        # param_4 = obj.get(index)\n        self.head = None\n        self.tail = None\n        self.length = 0"
    },
    {
        "number": 709,
        "title": "To Lower Case",
        "difficulty": 0,
        "answer": "        return s.lower()"
    },
    {
        "number": 710,
        "title": "Random Pick with Blacklist",
        "difficulty": 2,
        "answer": "        import random\n        import collections\n        blacklist = set(blacklist)\n        while True:\n            r = random.randint(0, n - 1)\n            if r not in blacklist:\n                return r\n            blacklist.add(r)\n            if len(blacklist) == n:\n                return random.randint(0, n - 1)"
    },
    {
        "number": 712,
        "title": "Minimum ASCII Delete Sum for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + ord(s1[i - 1]) - ord(s2[j - 1])\n        return dp[m][n]\n"
    },
    {
        "number": 713,
        "title": "Subarray Product Less Than K",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0]\n        for i in range(1, n):\n            dp[i][i] = 1\n        for i in range(2, n):\n            for j in range(1, i):\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        for i in range(2, n):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j]\n        for i in range(2, n):\n            for j in range(i):\n                dp[i][j] = dp[i][j] + dp[i - 1][j]\n        for i in range(2, n):\n            for j in range(i"
    },
    {
        "number": 714,
        "title": "Best Time to Buy and Sell Stock with Transaction Fee",
        "difficulty": 1,
        "answer": "        n = len(prices)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = prices[0] - fee\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], prices[i] - fee)\n        for j in range(1, n):\n            dp[0][j] = max(dp[0][j - 1], prices[j] - fee)\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], prices[j] - fee) + max(dp[i][j - 1], prices[j] - fee)\n        return max(dp[n - 1][n - 1], dp[n - 1][n - 2])\n"
    },
    {
        "number": 715,
        "title": "Range Module",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 717,
        "title": "1-bit and 2-bit Characters",
        "difficulty": 0,
        "answer": "        if not bits:\n            return False\n        if len(bits) == 1:\n            return False\n        if bits[-1] == 0:\n            return True\n        return bits[-2] == 1 and bits[-1] == 0"
    },
    {
        "number": 718,
        "title": "Maximum Length of Repeated Subarray",
        "difficulty": 1,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 == 0 or n2 == 0:\n            return 0\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return max(dp[n1][n2], dp[n1][n2 - 1])\n"
    },
    {
        "number": 719,
        "title": "Find K-th Smallest Pair Distance",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        if k > n // 2:\n            return n * (n - 1) // 2\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j - 1] + nums[i] - nums[j]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j])\n        return dp[0][k]\n"
    },
    {
        "number": 720,
        "title": "Longest Word in Dictionary",
        "difficulty": 1,
        "answer": "        if not words:\n            return \"\"\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = dp[i-1][j-1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i]["
    },
    {
        "number": 721,
        "title": "Accounts Merge",
        "difficulty": 1,
        "answer": "        # sort by name\n        accounts.sort(key=lambda x: x[0])\n        # merge\n        for i in range(len(accounts) - 1):\n            for j in range(i + 1, len(accounts)):\n                if accounts[i][1] == accounts[j][1]:\n                    accounts[i][1] = accounts[i][1] + accounts[j][1]\n                    accounts[j][1] = \"\"\n        # sort by name\n        accounts.sort(key=lambda x: x[0])\n        return accounts"
    },
    {
        "number": 722,
        "title": "Remove Comments",
        "difficulty": 1,
        "answer": "        result = []\n        for line in source:\n            if line.startswith('/'):\n                if line.startswith('/*'):\n                    result.append(line[2:])\n                else:\n                    result.append(line[1:])\n            else:\n                result.append(line)\n        return result\n"
    },
    {
        "number": 724,
        "title": "Find Pivot Index",
        "difficulty": 0,
        "answer": "        left_sum = 0\n        right_sum = 0\n        for i in range(len(nums)):\n            left_sum += nums[i]\n            right_sum += nums[i + 1] if i + 1 < len(nums) else 0\n            if left_sum == right_sum:\n                return i\n        return -1\n"
    },
    {
        "number": 725,
        "title": "Split Linked List in Parts",
        "difficulty": 1,
        "answer": "        if not head:\n            return []\n        if k == 1:\n            return [head]\n        if k == 2:\n            return [head, head]\n        if k == 3:\n            return [head, head, head]\n        if k == 4:\n            return [head, head, head, head]\n        if k == 5:\n            return [head, head, head, head, head]\n        if k == 6:\n            return [head, head, head, head, head, head]\n        if k == 7:\n            return [head, head, head, head, head, head, head]\n        if k == 8:\n            return [head, head, head, head, head, head, head, head]\n        if k == 9:\n            return [head, head, head, head, head, head, head, head, head]\n        if k == 10:\n            return [head, head, head, head, head, head, head, head, head, head]\n        if k == 11:\n            return [head, head, head, head, head,"
    },
    {
        "number": 726,
        "title": "Number of Atoms",
        "difficulty": 2,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://disc"
    },
    {
        "number": 728,
        "title": "Self Dividing Numbers",
        "difficulty": 0,
        "answer": "        result = []\n        for i in range(left, right + 1):\n            if self.is_self_dividing(i):\n                result.append(i)\n        return result"
    },
    {
        "number": 729,
        "title": "My Calendar I",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 730,
        "title": "Count Different Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 1, 0, -1):\n            for j in range(i, 0, -1):\n                dp[i][j] = dp[i + 1][j - 1] + dp[i][j + 1]\n        return dp[0][0] % (10 ** 9 + 7)\n"
    },
    {
        "number": 731,
        "title": "My Calendar II",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 732,
        "title": "My Calendar III",
        "difficulty": 2,
        "answer": "        self.events = []\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        self.events.append([startTime, endTime])\n        self.events.sort()\n        "
    },
    {
        "number": 733,
        "title": "Flood Fill",
        "difficulty": 0,
        "answer": "        if sr < 0 or sc < 0 or sr >= len(image) or sc >= len(image[0]):\n            return image\n        if image[sr][sc]!= color:\n            return image\n        queue = [(sr, sc)]\n        visited = set()\n        while queue:\n            r, c = queue.pop(0)\n            if r < 0 or c < 0 or r >= len(image) or c >= len(image[0]):\n                continue\n            if (r, c) in visited:\n                continue\n            visited.add((r, c))\n            queue.extend(self.get_neighbors(image, r, c))\n        for r, c in visited:\n            image[r][c] = color\n        return image"
    },
    {
        "number": 735,
        "title": "Asteroid Collision",
        "difficulty": 1,
        "answer": "        n = len(asteroids)\n        if n == 0:\n            return []\n        asteroids.sort()\n        res = []\n        for i in range(n):\n            if i == 0:\n                res.append(asteroids[i])\n            else:\n                res.append(asteroids[i] - res[-1])\n        return res\n"
    },
    {
        "number": 736,
        "title": "Parse Lisp Expression",
        "difficulty": 2,
        "answer": "        stack = []\n        for c in expression:\n            if c in '()+-*/':\n                stack.append(c)\n            elif c.isalpha():\n                if stack and stack[-1] == '(':\n                    stack.append(c)\n                else:\n                    stack.append(c)\n            elif c.isdigit():\n                stack.append(c)\n            else:\n                if stack and stack[-1] == '(':\n                    stack.append(c)\n                else:\n                    stack.append(c)\n        return eval(expression, {}, {'add': lambda x, y: x + y, 'let': lambda x, y: y,'mult': lambda x, y: x * y})"
    },
    {
        "number": 738,
        "title": "Monotone Increasing Digits",
        "difficulty": 1,
        "answer": "        if n < 10:\n            return n\n        if n < 100:\n            return n // 10 * 10 + 9\n        if n < 1000:\n            return n // 100 * 100 + 99\n        if n < 10000:\n            return n // 1000 * 1000 + 999\n        if n < 100000:\n            return n // 10000 * 10000 + 9999\n        if n < 1000000:\n            return n // 100000 * 100000 + 99999\n        if n < 10000000:\n            return n // 1000000 * 1000000 + 999999\n        if n < 100000000:\n            return n // 10000000 * 10000000 + 9999999\n        if n < 1000000000:\n            return n // 100000000 * 100000000 + 99999999\n        if n < 10000000000:\n            return n // 1000000000 * 1000000000 + 999999999\n        if n < 100000000000:\n            return n // 10000000000 * 10000000000 + 9999999999\n        if n < 1000000000000:\n            return n // 100000000000 * 100000000000 + 99999999999\n        if n < 10000000000000:\n            return"
    },
    {
        "number": 739,
        "title": "Daily Temperatures",
        "difficulty": 1,
        "answer": "        n = len(temperatures)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 3:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 4:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 5:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 6:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 7:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 8:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n        if n == 9:\n            return [1] if temperatures[0] < temperatures[1] else [0]\n"
    },
    {
        "number": 740,
        "title": "Delete and Earn",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(nums[i] + dp[i + 1][i], nums[i] + dp[i + 1][i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i - 1] = max(nums[i] + dp[i - 1][i], nums[i] + dp[i - 1][i - 1])\n        return max(dp[0][-1], dp[-1][0])\n"
    },
    {
        "number": 741,
        "title": "Cherry Pickup",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        if n == 0:\n            return 0\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], grid[i][0])\n        for j in range(1, m):\n            dp[0][j] = max(dp[0][j - 1], grid[0][j])\n        for i in range(1, n):\n            for j in range(1, m):\n                if grid[i][j] == 1:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n - 1][m - 1]\n"
    },
    {
        "number": 743,
        "title": "Network Delay Time",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + times[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + times[i][j]\n        # dp[i][j] = dp[i-1][j] + times[i][j]\n        # dp[i][j] = dp[i][j-1] + times[i][j]\n        # dp[i][j] = dp[i-1][j-1] + times[i][j]\n        # dp[i][j] = -1\n        # dp[i][j] = -1\n        # dp[i][j] = -1\n        # dp[i][j] = -1\n        # dp[i][j] = -1\n        # dp[i][j] = -1\n        # dp"
    },
    {
        "number": 744,
        "title": "Find Smallest Letter Greater Than Target",
        "difficulty": 0,
        "answer": "        # binary search\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if letters[mid] > target:\n                right = mid - 1\n            elif letters[mid] < target:\n                left = mid + 1\n            else:\n                return letters[mid]\n        return letters[left]\n"
    },
    {
        "number": 745,
        "title": "Prefix and Suffix Search",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 746,
        "title": "Min Cost Climbing Stairs",
        "difficulty": 0,
        "answer": "        n = len(cost)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = cost[i]\n            dp[i][i + 1] = cost[i] + cost[i + 1]\n        for i in range(n - 1):\n            dp[i][i + 2] = cost[i] + cost[i + 1] + cost[i + 2]\n        for i in range(n - 2):\n            dp[i][i + 3] = cost[i] + cost[i + 1] + cost[i + 2] + cost[i + 3]\n        for i in range(n - 3):\n            dp[i][i + 4] = cost[i] + cost[i + 1] + cost[i + 2] + cost[i + 3] + cost[i + 4]\n        for i in range(n - 4):\n            dp[i][i + 5] = cost[i] + cost[i + 1] + cost["
    },
    {
        "number": 747,
        "title": "Largest Number At Least Twice of Others",
        "difficulty": 0,
        "answer": "        if len(nums) == 1:\n            return 0\n        if len(nums) == 2:\n            return nums.index(max(nums))\n        if nums[0] > nums[1]:\n            return 0\n        if nums[0] < nums[1]:\n            return 1\n        if nums[0] == nums[1]:\n            return 2\n        if nums[0] == nums[2]:\n            return 3\n        if nums[0] == nums[3]:\n            return 4\n        if nums[1] == nums[2]:\n            return 5\n        if nums[1] == nums[3]:\n            return 6\n        if nums[2] == nums[3]:\n            return 7\n        if nums[0] == nums[4]:\n            return 8\n        if nums[1] == nums[4]:\n            return 9\n        if nums[2] == nums[4]:\n            return 10\n        if nums[3] == nums[4]:"
    },
    {
        "number": 748,
        "title": "Shortest Completing Word",
        "difficulty": 0,
        "answer": "        # dic = {c: 0 for c in licensePlate}\n        # for c in licensePlate:\n        #     dic[c] += 1\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        # dic = {c: dic[c] for c in licensePlate}\n        #"
    },
    {
        "number": 749,
        "title": "Contain Virus",
        "difficulty": 2,
        "answer": "        m, n = len(isInfected), len(isInfected[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j]:\n                    dp[i][j] = 1\n                    for k in range(4):\n                        if i + dp[i][j] < m and j + dp[i][j] < n and isInfected[i + dp[i][j]][j + dp[i][j]]:\n                            dp[i + dp[i][j]][j + dp[i][j]] += 1\n                        if i - dp[i][j] >= 0 and j - dp[i][j] >= 0 and isInfected[i - dp[i][j]][j - dp[i][j]]:\n                            dp[i - dp[i][j]][j - dp[i][j]] += 1\n                        if i + dp[i]["
    },
    {
        "number": 752,
        "title": "Open the Lock",
        "difficulty": 1,
        "answer": "        n = len(deadends)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1] + 1\n                if deadends[i] == deadends[j]:\n                    dp[i][j] = -1\n        return dp[0][n - 1]"
    },
    {
        "number": 753,
        "title": "Cracking the Safe",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = dp[i - 1][j]\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # d"
    },
    {
        "number": 754,
        "title": "Reach a Number",
        "difficulty": 1,
        "answer": "        def dfs(pos, target, numMoves):\n            if pos == target:\n                return numMoves\n            if pos < 0 or pos > target:\n                return -1\n            if numMoves == 0:\n                return -1\n            if pos == 0:\n                return 0\n            if pos == 1:\n                return 1\n            if pos == 2:\n                return 2\n            if pos == 3:\n                return 3\n            if pos == 4:\n                return 4\n            if pos == 5:\n                return 5\n            if pos == 6:\n                return 6\n            if pos == 7:\n                return 7\n            if pos == 8:\n                return 8\n            if pos == 9:\n                return 9\n            if pos == 10:\n                return 10\n            if pos == 11:\n                return 11\n            if pos == 12:\n                return 12\n            if pos == 13:\n                return 13\n            if pos == 14:\n                return 14\n            if pos == 15:\n                return 15\n            if pos == 16:\n                return 16\n            if pos == 17:"
    },
    {
        "number": 756,
        "title": "Pyramid Transition Matrix",
        "difficulty": 1,
        "answer": "        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n        if not allowed:\n            return False\n        if not allowed:\n            return False\n        if not bottom:\n            return True\n"
    },
    {
        "number": 757,
        "title": "Set Intersection Size At Least Two",
        "difficulty": 2,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        nums = []\n        for i in range(len(intervals)):\n            if i == 0 or intervals[i][0] > intervals[i - 1][1]:\n                nums.append(intervals[i][0])\n            if i == len(intervals) - 1 or intervals[i][1] < intervals[i + 1][0]:\n                nums.append(intervals[i][1])\n        return len(set(nums)) - 1"
    },
    {
        "number": 761,
        "title": "Special Binary String",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return s\n        if n == 2:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 3:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 4:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 5:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 6:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 7:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 8:\n            return s[1] if s[0] == s[1] else s[0]\n        if n == 9:\n            return s[1] if s[0"
    },
    {
        "number": 762,
        "title": "Prime Number of Set Bits in Binary Representation",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(left, right + 1):\n            count += self.countPrimeSetBits(i, right)\n        return count"
    },
    {
        "number": 763,
        "title": "Partition Labels",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return [dp[i][n - 1] for i in range(n)]"
    },
    {
        "number": 764,
        "title": "Largest Plus Sign",
        "difficulty": 1,
        "answer": "        def dfs(i, j, r, c):\n            if i < 0 or i >= n or j < 0 or j >= n or mines[i][j]!= 0:\n                return 0\n            if grid[i][j] == 1:\n                return 1\n            grid[i][j] = 1\n            count = 1\n            if i > 0 and grid[i - 1][j] == 1:\n                count += dfs(i - 1, j, r, c)\n            if i < n - 1 and grid[i + 1][j] == 1:\n                count += dfs(i + 1, j, r, c)\n            if j > 0 and grid[i][j - 1] == 1:\n                count += dfs(i, j - 1, r, c)\n            if j < n - 1 and grid[i][j + 1] == 1:\n                count += dfs(i, j + 1, r, c)\n            grid[i][j] = 0\n            return count"
    },
    {
        "number": 765,
        "title": "Couples Holding Hands",
        "difficulty": 2,
        "answer": "        n = len(row) // 2\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7]"
    },
    {
        "number": 766,
        "title": "Toeplitz Matrix",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return True\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            if matrix[i][0]!= matrix[i][n - 1]:\n                return False\n        for j in range(1, n - 1):\n            if matrix[0][j]!= matrix[m - 1][j]:\n                return False\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                if matrix[i][j]!= matrix[i - 1][j] and matrix[i][j]!= matrix[i][j - 1]:\n                    return False\n        return True\n"
    },
    {
        "number": 767,
        "title": "Reorganize String",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/reorganize-string/discuss/\n        # https://leetcode.com/articles/reorganize-string/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode.com/problems/reorganize-string-ii/discuss/\n        # https://leetcode."
    },
    {
        "number": 768,
        "title": "Max Chunks To Make Sorted II",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n"
    },
    {
        "number": 769,
        "title": "Max Chunks To Make Sorted",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n        if n == 22:\n            return 2\n"
    },
    {
        "number": 770,
        "title": "Basic Calculator IV",
        "difficulty": 2,
        "answer": "        stack = []\n        for i in range(len(expression)):\n            if expression[i] == '(':\n                stack.append(i)\n            elif expression[i] == ')':\n                if len(stack) == 0:\n                    return []\n                else:\n                    stack.pop()\n            elif expression[i] in evalvars:\n                if len(stack) == 0:\n                    return []\n                else:\n                    stack.append(i)\n            elif expression[i] in evalints:\n                if len(stack) == 0:\n                    return []\n                else:\n                    stack.append(i)\n            elif expression[i] == '*':\n                if len(stack) == 0:\n                    return []\n                else:\n                    stack.append(i)\n            elif expression[i] == '/':\n                if len(stack) == 0:\n                    return []\n                else:\n                    stack.append(i)\n            elif expression[i] == '+':\n                if len(stack) == 0:\n                    return []\n                "
    },
    {
        "number": 771,
        "title": "Jewels and Stones",
        "difficulty": 0,
        "answer": "        if not jewels:\n            return 0\n        if not stones:\n            return 0\n        if not jewels or not stones:\n            return 0\n        if len(jewels)!= len(stones):\n            return 0\n        if len(jewels) == 1:\n            return 1\n        if len(jewels) == 2:\n            if jewels[0] == jewels[1]:\n                return 2\n            else:\n                return 1\n        if len(jewels) == 3:\n            if jewels[0] == jewels[1] and jewels[1] == jewels[2]:\n                return 3\n            elif jewels[0] == jewels[1] or jewels[1] == jewels[2]:\n                return 2\n            else:\n                return 1\n        if len(jewels) == 4:\n            if jewels[0] == jewels[1] and jewels[1] == jewels[2] and jewels[2] == jewels[3]:\n                return 4\n            elif jewels[0] == jewels[1] or jewels[1] == jewels[2] or jewels[2] == jewels[3"
    },
    {
        "number": 773,
        "title": "Sliding Puzzle",
        "difficulty": 2,
        "answer": "        if not board or not board[0]:\n            return -1\n        m, n = len(board), len(board[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 0:\n                    dp[i][j] = -1\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j] + 1\n                    if j > 0 and board[i][j] == board[i][j - 1]:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n                    if i > 0 and board[i][j] == board[i - 1][j]:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n        return dp[m - 1][n -"
    },
    {
        "number": 775,
        "title": "Global and Local Inversions",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return True\n        if n == 2:\n            return nums[0] < nums[1]\n        if n == 3:\n            return nums[0] < nums[1] and nums[1] < nums[2]\n        if n == 4:\n            return nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3]\n        if n == 5:\n            return nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3] and nums[3] < nums[4]\n        if n == 6:\n            return nums[0] < nums[1] and nums[1] < nums[2] and nums[2] < nums[3] and nums[3] < nums[4] and nums[4] < nums[5]\n        if n == 7"
    },
    {
        "number": 777,
        "title": "Swap Adjacent in LR String",
        "difficulty": 1,
        "answer": "        if len(start)!= len(end):\n            return False\n        if start == end:\n            return True\n        if start == \"\":\n            return False\n        if end == \"\":\n            return True\n        if start[0]!= end[0]:\n            return False\n        if start[0] == \"X\" and end[0] == \"L\":\n            return True\n        if start[0] == \"R\" and end[0] == \"X\":\n            return True\n        if start[0] == \"L\" and end[0] == \"R\":\n            return True\n        if start[0] == \"X\" and end[0] == \"R\":\n            return True\n        if start[0] == \"R\" and end[0] == \"L\":\n            return True\n        if start[0] == \"L\" and end[0] == \"X\":\n            return True\n        if start[0] == \"X\" and end[0] == \"L\":\n            return True\n        if start[0] == \"R\" and end[0] == \""
    },
    {
        "number": 778,
        "title": "Swim in Rising Water",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], grid[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], grid[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], grid[i][j])\n        return dp[n - 1][n - 1]"
    },
    {
        "number": 779,
        "title": "K-th Symbol in Grammar",
        "difficulty": 1,
        "answer": "        table = [[0] * n for _ in range(n)]\n        for i in range(1, n):\n            for j in range(n - 1):\n                if table[i - 1][j] == 0:\n                    table[i][j] = 1\n                else:\n                    table[i][j] = 2\n        return table[n - 1][k - 1]\n"
    },
    {
        "number": 780,
        "title": "Reaching Points",
        "difficulty": 2,
        "answer": "        def dfs(x, y, dx, dy):\n            if x == tx and y == ty:\n                return True\n            if x < 0 or y < 0 or x >= dx or y >= dy:\n                return False\n            if sx == x and sy == y:\n                return False\n            if dx == 1 and dy == 1:\n                return False\n            if dx == 1 and dy == 2:\n                return dfs(x, y + 1, dx, dy) or dfs(x + 1, y, dx, dy)\n            if dx == 2 and dy == 1:\n                return dfs(x, y, dx, dy) or dfs(x, y + 1, dx, dy)\n            if dx == 2 and dy == 2:\n                return dfs(x, y, dx, dy) or dfs(x + 1, y, dx, dy) or dfs(x, y + 1, dx, dy) or dfs(x + 1, y + 1, dx, dy)\n            return False"
    },
    {
        "number": 781,
        "title": "Rabbits in Forest",
        "difficulty": 1,
        "answer": "        answers = sorted(answers)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0)\n        answers.append(0"
    },
    {
        "number": 782,
        "title": "Transform to Chessboard",
        "difficulty": 2,
        "answer": "        n = len(board)\n        if n == 0:\n            return 0\n        if n == 1:\n            return -1\n        if n == 2:\n            return 0\n        if n == 3:\n            return 1\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 4\n        if n == 7:\n            return 5\n        if n == 8:\n            return 6\n        if n == 9:\n            return 7\n        if n == 10:\n            return 8\n        if n == 11:\n            return 9\n        if n == 12:\n            return 10\n        if n == 13:\n            return 11\n        if n == 14:\n            return 12\n        if n == 15:\n            return 13\n        if n == 16:\n            return 14\n        if n == 17:\n            return 15\n        if n == 18:\n            return 16\n        if n == 19:\n            return 17\n        if n == 20:\n            return 18\n        if n == 21:\n            return 19"
    },
    {
        "number": 783,
        "title": "Minimum Distance Between BST Nodes",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return abs(root.val - root.left.val)\n        left_min = self.minDiffInBST(root.left)\n        right_min = self.minDiffInBST(root.right)\n        return min(left_min, right_min) + abs(root.val - root.left.val) + abs(root.val - root.right.val)"
    },
    {
        "number": 784,
        "title": "Letter Case Permutation",
        "difficulty": 1,
        "answer": "        ret = []\n        for i in range(len(s)):\n            if s[i].isalpha():\n                ret.append(s[:i] + s[i].lower() + s[i + 1:])\n                ret.append(s[:i] + s[i].upper() + s[i + 1:])\n        return ret"
    },
    {
        "number": 785,
        "title": "Is Graph Bipartite?",
        "difficulty": 1,
        "answer": "        n = len(graph)\n        if n == 0:\n            return True\n        if n == 1:\n            return False\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return True\n"
    },
    {
        "number": 786,
        "title": "K-th Smallest Prime Fraction",
        "difficulty": 1,
        "answer": "        if not arr:\n            return []\n        if k == 1:\n            return [arr[0], arr[-1]]\n        if k == 2:\n            return [arr[0], arr[-1]]\n        if k == 3:\n            return [arr[0], arr[-1]]\n        if k == 4:\n            return [arr[0], arr[-1]]\n        if k == 5:\n            return [arr[0], arr[-1]]\n        if k == 6:\n            return [arr[0], arr[-1]]\n        if k == 7:\n            return [arr[0], arr[-1]]\n        if k == 8:\n            return [arr[0], arr[-1]]\n        if k == 9:\n            return [arr[0], arr[-1]]\n        if k == 10:\n            return [arr[0], arr[-1]]\n        if k == 11:\n            return [arr[0], arr[-1]]\n        if k == 12:\n            return [arr[0], arr[-1]]\n"
    },
    {
        "number": 787,
        "title": "Cheapest Flights Within K Stops",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + flights[i][2]\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + max(flights[i][2], flights[j][2])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + max(flights[i][2], flights[j][2])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + max(flights[i][2], flights[j][2])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + max(flights[i][2], flights[j][2])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])"
    },
    {
        "number": 788,
        "title": "Rotated Digits",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/count-good-integers-between-1-n/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-2/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-3/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-4/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-5/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-6/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-7/\n        # https://www.geeksforgeeks.org/count-good-integers-between-1-n-8/\n        # https://www.geeksforgeeks.org/count-good-integers-"
    },
    {
        "number": 789,
        "title": "Escape The Ghosts",
        "difficulty": 1,
        "answer": "        n = len(ghosts)\n        m = len(ghosts[0])\n        dp = [[0] * m for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][0] = 1\n        for j in range(1, m):\n            dp[0][j] = 1\n        for i in range(1, n):\n            for j in range(1, m):\n                if ghosts[i][j] == target[0]:\n                    dp[i][j] = 1\n                elif ghosts[i][j] == target[1]:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n - 1][m - 1]\n"
    },
    {
        "number": 790,
        "title": "Domino and Tromino Tiling",
        "difficulty": 1,
        "answer": "        MOD = 10 ** 9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][n] % MOD\n"
    },
    {
        "number": 791,
        "title": "Custom Sort String",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/custom-sort-string/discuss/\n        # https://leetcode.com/problems/custom-sort-string-ii/discuss/\n        # https://leetcode.com/problems/custom-sort-string-iii/discuss/\n        # https://leetcode.com/problems/custom-sort-string-iv/discuss/\n        # https://leetcode.com/problems/custom-sort-string-v/discuss/\n        # https://leetcode.com/problems/custom-sort-string-vi/discuss/\n        # https://leetcode.com/problems/custom-sort-string-vii/discuss/\n        # https://leetcode.com/problems/custom-sort-string-viii/discuss/\n        # https://leetcode.com/problems/custom-sort-string-ix/discuss/\n        # https://leetcode.com/problems/custom-sort-string-x/discuss/\n"
    },
    {
        "number": 792,
        "title": "Number of Matching Subsequences",
        "difficulty": 1,
        "answer": "        if not words:\n            return 0\n        dp = [[0] * len(words) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            for j in range(len(words)):\n                if s[i - 1] == words[j][0]:\n                    dp[i][j] = dp[i - 1][j] + 1\n        return sum(dp[-1])\n"
    },
    {
        "number": 793,
        "title": "Preimage Size of Factorial Zeroes Function",
        "difficulty": 2,
        "answer": "        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! / (x - 1)!\n        # f(x) = x! /"
    },
    {
        "number": 794,
        "title": "Valid Tic-Tac-Toe State",
        "difficulty": 1,
        "answer": "        if len(board)!= 3 or len(board[0])!= 3:\n            return False\n        for i in range(3):\n            if board[i][0] == board[i][1] == board[i][2]!='':\n                return False\n        for i in range(3):\n            if board[0][i] == board[1][i] == board[2][i]!='':\n                return False\n        for i in range(3):\n            if board[i][0] == board[i][1] == board[i][2]!='':\n                return False\n        for i in range(3):\n            for j in range(3):\n                if board[i][j] == board[i][j+1] == board[i][j+2]!='':\n                    return False\n        return True\n"
    },
    {
        "number": 795,
        "title": "Number of Subarrays with Bounded Maximum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if left > right:\n            return 0\n        if left == right:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19"
    },
    {
        "number": 796,
        "title": "Rotate String",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return True\n        for i in range(len(s)):\n            if s[i]!= goal[i]:\n                return False\n        return True\n"
    },
    {
        "number": 797,
        "title": "All Paths From Source to Target",
        "difficulty": 1,
        "answer": "        if not graph:\n            return []\n        n = len(graph)\n        visited = [[False] * n for _ in range(n)]\n        paths = []\n        self.dfs(graph, 0, visited, paths)\n        return paths"
    },
    {
        "number": 798,
        "title": "Smallest Rotation with Highest Score",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(nums[i], nums[i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(nums[i], nums[i + 1], nums[i + 2])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(nums[i], nums[i + 1], nums[i + 2], nums[i + 3])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(nums[i], nums[i + 1], nums[i + 2], nums"
    },
    {
        "number": 799,
        "title": "Champagne Tower",
        "difficulty": 1,
        "answer": "        # DP\n        dp = [[0] * (query_row + 1) for _ in range(poured + 1)]\n        dp[0][0] = 1\n        for i in range(1, poured + 1):\n            for j in range(1, query_row + 1):\n                if i - 1 >= j:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[poured][query_row]"
    },
    {
        "number": 801,
        "title": "Minimum Swaps To Make Sequences Increasing",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 < n2:\n            return n1\n        if n1 > n2:\n            return n2\n        if nums1 == nums2:\n            return 0\n        \n        # sort nums1\n        i = 0\n        while i < n1:\n            if nums1[i] > nums2[i]:\n                nums1[i], nums1[n1 - 1] = nums1[n1 - 1], nums1[i]\n                nums2[i], nums2[n2 - 1] = nums2[n2 - 1], nums2[i]\n                n1 -= 1\n                n2 -= 1\n            else:\n                i += 1\n        \n        # sort nums2\n        i = 0\n        while i < n2:\n            if nums2[i] > nums1[i]:\n                nums1[i], nums1[n1 - 1] = nums1[n"
    },
    {
        "number": 802,
        "title": "Find Eventual Safe States",
        "difficulty": 1,
        "answer": "        n = len(graph)\n        if n == 0:\n            return []\n        graph = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                graph[i].append(graph[j][i])\n        visited = [False] * n\n        safe = []\n        for i in range(n):\n            if not visited[i]:\n                self.dfs(graph, i, visited, safe)\n        return safe"
    },
    {
        "number": 803,
        "title": "Bricks Falling When Hit",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        dp = [[0] * n for _ in range(m)]\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the ith erasure is applied\n        # dp[i][j] = number of bricks that will fall after the"
    },
    {
        "number": 804,
        "title": "Unique Morse Code Words",
        "difficulty": 0,
        "answer": "        morse_dict = {\n            \"a\": \".-\",\n            \"b\": \"-...\",\n            \"c\": \"-.-.\",\n            \"d\": \"-..\",\n            \"e\": \".\",\n            \"f\": \"..-.\",\n            \"g\": \"--.\",\n            \"h\": \"....\",\n            \"i\": \"..\",\n            \"j\": \".---\",\n            \"k\": \"-.-\",\n            \"l\": \".-..\",\n            \"m\": \"--\",\n            \"n\": \"-.\",\n            \"o\": \"---\",\n            \"p\": \".--.\",\n            \"q\": \"--.-\",\n            \"r\": \".-.\",\n            \"s\": \"...\",\n            \"t\": \"-\",\n            \"u\": \"..-\",\n            \"v\": \"...-\",\n            \"w\": \".--\",\n            \"x\": \"-..-\",\n            \"y\": \"-.--\",\n            \"z\": \"--..\",\n        }\n        morse_dict_inv = {v: k for k, v in morse_dict.items()}\n        mor"
    },
    {
        "number": 805,
        "title": "Split Array With Same Average",
        "difficulty": 2,
        "answer": "        if len(nums) == 0:\n            return True\n        if len(nums) == 1:\n            return True\n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]\n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[1] == nums[2] or nums[1] == nums[3] or nums[2] == nums[3]\n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or"
    },
    {
        "number": 806,
        "title": "Number of Lines To Write String",
        "difficulty": 0,
        "answer": "        result = [0, 0]\n        width = 0\n        for i in range(len(s)):\n            width += widths[i]\n            if width > 100:\n                result[0] += 1\n                width = widths[i]\n        result[1] = width\n        return result"
    },
    {
        "number": 807,
        "title": "Max Increase to Keep City Skyline",
        "difficulty": 1,
        "answer": "        def dfs(r, c, grid):\n            if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n                return 0\n            if grid[r][c] == 0:\n                return 0\n            if r == 0 and c == 0:\n                return grid[r][c]\n            if r == 0:\n                return max(dfs(r, c - 1, grid) + grid[r][c], dfs(r, c + 1, grid))\n            if c == 0:\n                return max(dfs(r - 1, c, grid) + grid[r][c], dfs(r + 1, c, grid))\n            return max(dfs(r - 1, c, grid) + grid[r][c], dfs(r + 1, c, grid), dfs(r, c - 1, grid) + grid[r][c], dfs(r, c + 1, grid))"
    },
    {
        "number": 808,
        "title": "Soup Servings",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0.0\n        if n == 1:\n            return 0.5\n        if n == 2:\n            return 0.75\n        if n == 3:\n            return 0.875\n        if n == 4:\n            return 0.9375\n        if n == 5:\n            return 0.96875\n        if n == 6:\n            return 0.984375\n        if n == 7:\n            return 0.9921875\n        if n == 8:\n            return 0.99609375\n        if n == 9:\n            return 0.998046875\n        if n == 10:\n            return 0.9990234375\n        if n == 11:\n            return 0.99951171875\n        if n == 12:\n            return 0.999755859375\n        if n == 13:\n            return 0.9998779296875\n        if n == 14:\n            return 0.99993896484375\n        if n == 15:\n            return 0.999969482421875\n        if n =="
    },
    {
        "number": 809,
        "title": "Expressive Words",
        "difficulty": 1,
        "answer": "        def is_stretchy(s, words):\n            if len(s) < len(words[0]):\n                return False\n            for i in range(len(words)):\n                if len(words[i]) > len(s):\n                    continue\n                if len(words[i]) == len(s):\n                    return True\n                if len(words[i]) < len(s):\n                    if s[:len(words[i])] == words[i]:\n                        return True\n            return False"
    },
    {
        "number": 810,
        "title": "Chalkboard XOR Game",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return True\n        if n == 1:\n            return False\n        if nums[0] == 0:\n            return True\n        if nums[0] == 1:\n            return False\n        if nums[0] == 2:\n            return True\n        if nums[0] == 3:\n            return False\n        if nums[0] == 4:\n            return True\n        if nums[0] == 5:\n            return False\n        if nums[0] == 6:\n            return True\n        if nums[0] == 7:\n            return False\n        if nums[0] == 8:\n            return True\n        if nums[0] == 9:\n            return False\n        if nums[0] == 10:\n            return True\n        if nums[0] == 11:\n            return False\n        if nums[0] == 12:\n            return True\n        if nums[0] == 13:\n            return False\n        if nums[0] == 14"
    },
    {
        "number": 811,
        "title": "Subdomain Visit Count",
        "difficulty": 1,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1] + dp[i-n-2]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1] + dp[i-n-2] + dp[i-n-3]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1] + dp[i-n-2] +"
    },
    {
        "number": 812,
        "title": "Largest Triangle Area",
        "difficulty": 0,
        "answer": "        if not points:\n            return 0\n        points.sort(key=lambda x: x[0])\n        points.sort(key=lambda x: x[1])\n        points.sort(key=lambda x: x[0] + x[1])\n        points.sort(key=lambda x: x[0])\n        points.sort(key=lambda x: x[1])\n        points.sort(key=lambda x: x[0] + x[1])\n        points.sort(key=lambda x: x[0])\n        points.sort(key=lambda x: x[1])\n        points.sort(key=lambda x: x[0] + x[1])\n        points.sort(key=lambda x: x[0])\n        points.sort(key=lambda x: x[1])\n        points.sort(key=lambda x: x[0] + x[1])\n        points.sort(key=lambda x: x[0])\n        points.sort(key=lambda x: x[1])\n        points.sort(key=lambda x:"
    },
    {
        "number": 813,
        "title": "Largest Sum of Averages",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if k == 1:\n            return sum(nums)\n        if k == 2:\n            return sum(nums[:3]) + sum(nums[3:])\n        if k == 3:\n            return sum(nums[:2]) + sum(nums[2:]) + sum(nums[-2:])\n        if k == 4:\n            return sum(nums[:2]) + sum(nums[2:]) + sum(nums[-2:]) + sum(nums[-4:])\n        if k == 5:\n            return sum(nums[:3]) + sum(nums[3:]) + sum(nums[-3:]) + sum(nums[-5:])\n        if k == 6:\n            return sum(nums[:4]) + sum(nums[4:]) + sum(nums[-4:]) + sum(nums[-6:])\n        if k == 7:\n            return sum(nums[:5]) + sum("
    },
    {
        "number": 814,
        "title": "Binary Tree Pruning",
        "difficulty": 1,
        "answer": "        if not root:\n            return root\n        if not root.left and not root.right:\n            return None\n        if not root.left:\n            return self.pruneTree(root.right)\n        if not root.right:\n            return self.pruneTree(root.left)\n        left = self.pruneTree(root.left)\n        right = self.pruneTree(root.right)\n        if left and right:\n            return root\n        if left:\n            return left\n        if right:\n            return right\n        return None\n"
    },
    {
        "number": 815,
        "title": "Bus Routes",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the minimum number of buses to reach target from source\n        # when i = 0, j = 0, dp[i][j] = 0\n        # when i = 0, j = 1, dp[i][j] = 1\n        # when i = 0, j = 2, dp[i][j] = 2\n        # when i = 0, j = 3, dp[i][j] = 3\n        # when i = 0, j = 4, dp[i][j] = 4\n        # when i = 0, j = 5, dp[i][j] = 5\n        # when i = 0, j = 6, dp[i][j] = 6\n        # when i = 0, j = 7, dp[i][j] = 7\n        # when i = 0, j = 8, dp[i][j] = 8\n        # when i = 0, j = 9, dp[i][j] = 9\n        # when i = 0, j = 10, dp[i][j] ="
    },
    {
        "number": 816,
        "title": "Ambiguous Coordinates",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(len(s)):\n            if s[i] == ',':\n                continue\n            if s[i] == '.':\n                continue\n            if s[i] =='':\n                continue\n            if s[i] == ')':\n                continue\n            if s[i] == '(':\n                continue\n            if s[i] == '0':\n                continue\n            if s[i] == '1':\n                continue\n            if s[i] == '2':\n                continue\n            if s[i] == '3':\n                continue\n            if s[i] == '4':\n                continue\n            if s[i] == '5':\n                continue\n            if s[i] == '6':\n                continue\n            if s[i] == '7':\n                continue\n            if s[i] == '8':\n                continue\n            if s[i] == '9':\n                continue\n            if s[i] == '0':\n                continue\n            if s[i] == '1':"
    },
    {
        "number": 817,
        "title": "Linked List Components",
        "difficulty": 1,
        "answer": "        if not head:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head or not nums:\n            return 0\n        if not nums:\n            return 0\n        if not head"
    },
    {
        "number": 818,
        "title": "Race Car",
        "difficulty": 2,
        "answer": "        def dfs(pos, speed, target):\n            if pos == target:\n                return 0\n            if pos < 0:\n                return -1\n            if speed < 0:\n                return -1\n            if speed == 0:\n                return -1\n            if pos == 0:\n                return 1\n            if pos == 1:\n                return 2\n            if pos == 2:\n                return 3\n            if pos == 3:\n                return 4\n            if pos == 4:\n                return 5\n            if pos == 5:\n                return 6\n            if pos == 6:\n                return 7\n            if pos == 7:\n                return 8\n            if pos == 8:\n                return 9\n            if pos == 9:\n                return 10\n            if pos == 10:\n                return 11\n            if pos == 11:\n                return 12\n            if pos == 12:\n                return 13\n            if pos == 13:\n                return 14\n            if pos == 14:\n                return 15\n            if pos == 15:\n                return 16\n            if pos == 16:\n                return 17\n            if pos =="
    },
    {
        "number": 819,
        "title": "Most Common Word",
        "difficulty": 0,
        "answer": "        words = paragraph.split()\n        word_count = {}\n        for word in words:\n            if word not in banned:\n                word_count[word] = word_count.get(word, 0) + 1\n        \n        max_count = max(word_count.values())\n        for word, count in word_count.items():\n            if count == max_count:\n                return word.lower()\n        return \"\"\n"
    },
    {
        "number": 820,
        "title": "Short Encoding of Words",
        "difficulty": 1,
        "answer": "        words = sorted(words, key=len)\n        n = len(words)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if words[i] == words[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n        return dp[0][n - 1]"
    },
    {
        "number": 821,
        "title": "Shortest Distance to a Character",
        "difficulty": 0,
        "answer": "        ans = [0] * len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                ans[i] = 0\n            else:\n                ans[i] = 1 + min(ans[i - 1], ans[i - 2])\n        return ans"
    },
    {
        "number": 822,
        "title": "Card Flipping Game",
        "difficulty": 1,
        "answer": "        # dp[i] = min good integer after flipping i cards\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + fronts[i-1] - backs[i-1])\n        # dp[i"
    },
    {
        "number": 823,
        "title": "Binary Trees With Factors",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + arr[i] * arr[j]\n        return sum(dp[i][n] for i in range(n)) % (10 ** 9 + 7)\n"
    },
    {
        "number": 824,
        "title": "Goat Latin",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        result = []\n        for i, word in enumerate(words):\n            if word[0].lower() in 'aeiou':\n                result.append(word +'ma')\n            else:\n                result.append(word[1:] + word[0] +'ma')\n            result.append('a' + str(i + 1))\n        return''.join(result)"
    },
    {
        "number": 825,
        "title": "Friends Of Appropriate Ages",
        "difficulty": 1,
        "answer": "        n = len(ages)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if ages[i] > 0.5 * ages[j] + 7:\n                    dp[i][j] = dp[j][i] = 0\n                elif ages[i] > ages[j]:\n                    dp[i][j] = dp[j][i] = 0\n                elif ages[i] > 100 and ages[j] < 100:\n                    dp[i][j] = dp[j][i] = 0\n                else:\n                    dp[i][j] = dp[j][i] = 1\n        return sum(sum(dp[i]) for i in range(n))\n"
    },
    {
        "number": 826,
        "title": "Most Profit Assigning Work",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max profit of assigning worker j to job i\n        dp = [[0] * len(worker) for _ in range(len(difficulty))]\n        for i in range(len(difficulty)):\n            for j in range(len(worker)):\n                if difficulty[i] <= worker[j]:\n                    dp[i][j] = max(dp[i][j], profit[i] + dp[i - 1][j - 1])\n        return max(dp[-1])"
    },
    {
        "number": 827,
        "title": "Making A Large Island",
        "difficulty": 2,
        "answer": "        def dfs(i, j, visited):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j]!= 1 or visited[i][j]:\n                return 0\n            visited[i][j] = 1\n            count = 1\n            count += dfs(i + 1, j, visited)\n            count += dfs(i - 1, j, visited)\n            count += dfs(i, j + 1, visited)\n            count += dfs(i, j - 1, visited)\n            return count"
    },
    {
        "number": 828,
        "title": "Count Unique Characters of All Substrings of a Given String",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        count = 0\n        for i in range(len(s)):\n            count += self.countUniqueChars(s[i:])\n        return count"
    },
    {
        "number": 829,
        "title": "Consecutive Numbers Sum",
        "difficulty": 2,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n"
    },
    {
        "number": 830,
        "title": "Positions of Large Groups",
        "difficulty": 0,
        "answer": "        groups = []\n        start = 0\n        for i in range(len(s)):\n            if s[i]!= s[start]:\n                groups.append([start, i])\n                start = i\n        groups.append([start, len(s)])\n        groups = sorted(groups, key=lambda x: x[0])\n        return [list(g) for g in zip(*groups)]"
    },
    {
        "number": 831,
        "title": "Masking Personal Information",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/mask-pii/#/description\n        # https://leetcode.com/problems/mask-pii/#/discuss\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com/problems/mask-pii/#/solution\n        # https://leetcode.com"
    },
    {
        "number": 832,
        "title": "Flipping an Image",
        "difficulty": 0,
        "answer": "        def flip(row):\n            return [1 - x for x in row]"
    },
    {
        "number": 833,
        "title": "Find And Replace in String",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss/\n        # https://leetcode.com/problems/replace-string/discuss"
    },
    {
        "number": 834,
        "title": "Sum of Distances in Tree",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return [0]\n        if n == 2:\n            return [1, 1]\n        if n == 3:\n            return [2, 2, 2]\n        if n == 4:\n            return [3, 3, 3, 3]\n        if n == 5:\n            return [4, 4, 4, 4, 4]\n        if n == 6:\n            return [5, 5, 5, 5, 5, 5]\n        if n == 7:\n            return [6, 6, 6, 6, 6, 6, 6]\n        if n == 8:\n            return [7, 7, 7, 7, 7, 7, 7, 7]\n        if n == 9:\n            return [8, 8, 8, 8, 8, 8, 8, 8, 8]\n        if n == 10:\n            return [9, 9, 9, 9, 9, 9, 9, 9, 9, 9]\n        if n == 11:\n            return [10, 10, 10, 10, 10, 10, 10, 10, 10, 10,"
    },
    {
        "number": 835,
        "title": "Image Overlap",
        "difficulty": 1,
        "answer": "        m, n = len(img1), len(img1[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if img1[i][j] == 1 and img2[i][j] == 1:\n                    dp[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == 1:\n                    for k in range(n):\n                        dp[i][k] = max(dp[i][k], dp[i + 1][k] + dp[i][j] + dp[i][j + 1])\n                    for k in range(n):\n                        dp[i][k] = max(dp[i][k], dp[i + 1][k] + dp[i][j] + dp[i][j + 1])\n                    for k in range(n):\n                        dp[i][k] = max(dp[i][k], dp["
    },
    {
        "number": 836,
        "title": "Rectangle Overlap",
        "difficulty": 0,
        "answer": "        x1, y1, x2, y2 = rec1\n        x3, y3, x4, y4 = rec2\n        if x1 > x2:\n            x1, x2 = x2, x1\n        if y1 > y2:\n            y1, y2 = y2, y1\n        if x3 > x4:\n            x3, x4 = x4, x3\n        if y3 > y4:\n            y3, y4 = y4, y3\n        if x1 > x3 or x2 < x4 or y1 > y3 or y2 < y4:\n            return False\n        return True"
    },
    {
        "number": 837,
        "title": "New 21 Game",
        "difficulty": 1,
        "answer": "        if n < k:\n            return 0.0\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return 1.0\n        if k == 2:\n            return 0.5\n        if k == 3:\n            return 0.5\n        if k == 4:\n            return 0.5\n        if k == 5:\n            return 0.5\n        if k == 6:\n            return 0.5\n        if k == 7:\n            return 0.5\n        if k == 8:\n            return 0.5\n        if k == 9:\n            return 0.5\n        if k == 10:\n            return 0.5\n        if k == 11:\n            return 0.5\n        if k == 12:\n            return 0.5\n        if k == 13:\n            return 0.5\n        if k == 14:\n            return 0.5\n        if k == 15:\n            return 0.5\n        if k == 16:\n            return 0.5\n        if k == 17:\n            return 0.5\n        if k"
    },
    {
        "number": 838,
        "title": "Push Dominoes",
        "difficulty": 1,
        "answer": "        n = len(dominoes)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return dominoes\n        if n == 2:\n            return dominoes[0] + dominoes[1]\n        if n == 3:\n            return dominoes[0] + dominoes[1] + dominoes[2]\n        if n == 4:\n            return dominoes[0] + dominoes[1] + dominoes[2] + dominoes[3]\n        if n == 5:\n            return dominoes[0] + dominoes[1] + dominoes[2] + dominoes[3] + dominoes[4]\n        if n == 6:\n            return dominoes[0] + dominoes[1] + dominoes[2] + dominoes[3] + dominoes[4] + dominoes[5]\n        if n == 7:\n            return dominoes[0] + dominoes[1] + dominoes[2] + dom"
    },
    {
        "number": 839,
        "title": "Similar String Groups",
        "difficulty": 2,
        "answer": "        # dic[str] = set(str)\n        dic = {}\n        for s in strs:\n            dic[s] = set(s)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # dic[str] = set(str)\n        # d"
    },
    {
        "number": 840,
        "title": "Magic Squares In Grid",
        "difficulty": 1,
        "answer": "        def dfs(grid, row, col, sum):\n            if row == 3 and col == 3 and sum == 45:\n                return 1\n            if row >= 4 or col >= 4:\n                return 0\n            if grid[row][col]!= 0:\n                return 0\n            grid[row][col] = sum\n            for i in range(row + 1, 4):\n                if grid[i][col] == 0:\n                    break\n                if grid[i][col] == sum:\n                    dfs(grid, i, col, sum + grid[i][col])\n            for i in range(col + 1, 4):\n                if grid[row][i] == 0:\n                    break\n                if grid[row][i] == sum:\n                    dfs(grid, row, i, sum + grid[row][i])\n            for i in range(row - 1, -1, -1):\n                if grid[i][col] == 0:\n                    break\n                if grid[i][col] == sum:\n                    dfs(grid, i, col, sum + grid["
    },
    {
        "number": 841,
        "title": "Keys and Rooms",
        "difficulty": 1,
        "answer": "        n = len(rooms)\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return rooms[0] == rooms[1]\n        if n == 3:\n            return rooms[0] == rooms[1] and rooms[1] == rooms[2]\n        if n == 4:\n            return rooms[0] == rooms[1] and rooms[1] == rooms[2] and rooms[2] == rooms[3]\n        if n == 5:\n            return rooms[0] == rooms[1] and rooms[1] == rooms[2] and rooms[2] == rooms[3] and rooms[3] == rooms[4]\n        if n == 6:\n            return rooms[0] == rooms[1] and rooms[1] == rooms[2] and rooms[2] == rooms[3] and rooms[3] == rooms[4] and rooms[4] == rooms[5]\n        if n == 7:\n            return rooms[0] == rooms[1] and rooms[1] == rooms"
    },
    {
        "number": 842,
        "title": "Split Array into Fibonacci Sequence",
        "difficulty": 1,
        "answer": "        def fib(n):\n            if n == 0:\n                return 0\n            if n == 1:\n                return 1\n            return fib(n - 1) + fib(n - 2)"
    },
    {
        "number": 843,
        "title": "Guess the Word",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 844,
        "title": "Backspace String Compare",
        "difficulty": 0,
        "answer": "        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == '#' and t[j] == '#':\n                i += 1\n                j += 1\n            elif s[i] == '#':\n                i += 1\n            elif t[j] == '#':\n                j += 1\n            else:\n                if s[i]!= t[j]:\n                    return False\n                i += 1\n                j += 1\n        return i == len(s) and j == len(t)\n"
    },
    {
        "number": 845,
        "title": "Longest Mountain in Array",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        if len(arr) == 1:\n            return 1\n        if arr[0] > arr[1]:\n            return 1\n        if arr[-1] < arr[-2]:\n            return 1\n        if arr[0] < arr[1]:\n            return 1\n        if arr[-1] > arr[-2]:\n            return 1\n        if arr[0] > arr[1]:\n            return 1\n        if arr[-1] < arr[-2]:\n            return 1\n        if arr[0] < arr[1]:\n            return 1\n        if arr[-1] > arr[-2]:\n            return 1\n        if arr[0] > arr[1]:\n            return 1\n        if arr[-1] < arr[-2]:\n            return 1\n        if arr[0] < arr[1]:\n            return 1\n        if arr[-1] > arr[-2]:\n            return 1\n        if arr[0] > arr[1]:\n            return 1\n        if arr[-1"
    },
    {
        "number": 846,
        "title": "Hand of Straights",
        "difficulty": 1,
        "answer": "        if len(hand) % groupSize!= 0:\n            return False\n        \n        # sort hand\n        hand.sort()\n        \n        # check if consecutive\n        for i in range(0, len(hand), groupSize):\n            if hand[i]!= hand[i + groupSize - 1]:\n                return False\n        \n        return True\n"
    },
    {
        "number": 847,
        "title": "Shortest Path Visiting All Nodes",
        "difficulty": 2,
        "answer": "        if not graph:\n            return 0\n        n = len(graph)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if graph[i][j] == 1:\n                    dp[i][j] = dp[i][j - 1] + 1\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if graph[i][j] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n        return dp[n - 1][n - 1]"
    },
    {
        "number": 848,
        "title": "Shifting Letters",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return s\n        if n == 2:\n            return s[1] if shifts[0] == 1 else s[0]\n        if n == 3:\n            return s[2] if shifts[0] == 1 else s[0]\n        if n == 4:\n            return s[3] if shifts[0] == 1 else s[0]\n        if n == 5:\n            return s[3] if shifts[0] == 1 else s[0]\n        if n == 6:\n            return s[4] if shifts[0] == 1 else s[0]\n        if n == 7:\n            return s[4] if shifts[0] == 1 else s[0]\n        if n == 8:\n            return s[5] if shifts[0] == 1 else s[0]\n        if n == 9:\n            return s[5] if shifts[0] == 1 else s[0]\n        if n == 10:\n            return s[6"
    },
    {
        "number": 849,
        "title": "Maximize Distance to Closest Person",
        "difficulty": 1,
        "answer": "        n = len(seats)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21"
    },
    {
        "number": 850,
        "title": "Rectangle Area II",
        "difficulty": 2,
        "answer": "        n = len(rectangles)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1):\n                if rectangles[i][0] <= rectangles[j][2] and rectangles[i][2] >= rectangles[j][0]:\n                    dp[i + 1][j + 1] = dp[i + 1][j] + rectangles[i][3] * (rectangles[i][2] - rectangles[i][0])\n                if rectangles[i][0] <= rectangles[j][1] and rectangles[i][1] >= rectangles[j][0]:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i + 1][j] + rectangles[i][3] * (rectangles[i][1] - rectangles[i][0]))\n        return sum(dp[n]) % (109 + 7)\n"
    },
    {
        "number": 851,
        "title": "Loud and Rich",
        "difficulty": 1,
        "answer": "        n = len(richer)\n        richer_sum = [0] * n\n        for i in range(n):\n            richer_sum[i] = sum(richer[i])\n        \n        n = len(quiet)\n        quiet_sum = [0] * n\n        for i in range(n):\n            quiet_sum[i] = sum(quiet[i])\n        \n        ans = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if richer_sum[i] >= richer_sum[j] and quiet_sum[i] >= quiet_sum[j]:\n                    ans[i] = j\n                    break\n        return ans\n"
    },
    {
        "number": 852,
        "title": "Peak Index in a Mountain Array",
        "difficulty": 1,
        "answer": "        left, right = 0, len(arr) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] > arr[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n"
    },
    {
        "number": 853,
        "title": "Car Fleet",
        "difficulty": 1,
        "answer": "        n = len(position)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n"
    },
    {
        "number": 854,
        "title": "K-Similar Strings",
        "difficulty": 2,
        "answer": "        if len(s1)!= len(s2):\n            return 0\n        if len(s1) == 1:\n            return 1\n        dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        for i in range(len(s1)):\n            for j in range(len(s2)):\n                if s1[i] == s2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n        return dp[-1][-1]\n"
    },
    {
        "number": 855,
        "title": "Exam Room",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 856,
        "title": "Score of Parentheses",
        "difficulty": 1,
        "answer": "        def score(s):\n            if not s:\n                return 0\n            if s[0] == ')':\n                return 2 * score(s[1:]) + 1\n            else:\n                return score(s[1:]) + 1"
    },
    {
        "number": 857,
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": 2,
        "answer": "        n = len(quality)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + wage[i - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + quality[i - 1]\n        return dp[n][k]\n"
    },
    {
        "number": 858,
        "title": "Mirror Reflection",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/mirror-reflection-problem/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-2/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-3/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-4/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-5/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-6/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-7/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-8/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-9/\n        # https://www.geeksforgeeks.org/mirror-reflection-problem-10/\n        # https://www.geeksforgeeks.org"
    },
    {
        "number": 859,
        "title": "Buddy Strings",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return True\n        if s == goal[::-1]:\n            return True\n        if s[0] == goal[0]:\n            return self.buddyStrings(s[1:], goal[1:])\n        if s[1] == goal[1]:\n            return self.buddyStrings(s[0:1] + s[2:], goal[0:1] + goal[2:])\n        return False"
    },
    {
        "number": 860,
        "title": "Lemonade Change",
        "difficulty": 0,
        "answer": "        n = len(bills)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if bills[i] == bills[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1] == 1"
    },
    {
        "number": 861,
        "title": "Score After Flipping Matrix",
        "difficulty": 1,
        "answer": "        def dfs(grid, m, n):\n            if m == 0 or n == 0:\n                return 0\n            if grid[m - 1][n - 1] == 1:\n                return dfs(grid, m - 1, n - 1)\n            else:\n                return dfs(grid, m - 1, n) + dfs(grid, m, n - 1)"
    },
    {
        "number": 862,
        "title": "Shortest Subarray with Sum at Least K",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i + 1] - nums[i], 0)\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if dp[j] - dp[i] >= k:\n                    return j - i\n        return -1\n"
    },
    {
        "number": 863,
        "title": "All Nodes Distance K in Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        if not target:\n            return []\n        if not k:\n            return []\n        if k == 1:\n            return [target.val]\n        if k == 2:\n            return [root.val, target.val]\n        if k == 3:\n            return [root.val, target.val, target.val]\n        return self.distanceK(root.left, target, k - 1) + self.distanceK(root.right, target, k - 1)"
    },
    {
        "number": 864,
        "title": "Shortest Path to Get All Keys",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    dp[i][j] = 1\n                elif grid[i][j] == '#':\n                    dp[i][j] = -1\n                elif grid[i][j] == '.':\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '.':\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n                    dp[i][j] = min(dp[i][j"
    },
    {
        "number": 865,
        "title": "Smallest Subtree with all the Deepest Nodes",
        "difficulty": 1,
        "answer": "        def dfs(node, depth):\n            if node is None:\n                return\n            if depth > max_depth:\n                max_depth = depth\n            if max_depth == depth:\n                result.append(node.val)\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)"
    },
    {
        "number": 866,
        "title": "Prime Palindrome",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return 2\n        if n == 2:\n            return 3\n        if n == 3:\n            return 5\n        if n % 2 == 0:\n            return 2 * n\n        if n % 3 == 0:\n            return 3 * n\n        if n % 5 == 0:\n            return 5 * n\n        if n % 7 == 0:\n            return 7 * n\n        if n % 11 == 0:\n            return 11 * n\n        if n % 13 == 0:\n            return 13 * n\n        if n % 17 == 0:\n            return 17 * n\n        if n % 19 == 0:\n            return 19 * n\n        if n % 23 == 0:\n            return 23 * n\n        if n % 29 == 0:\n            return 29 * n\n        if n % 31 == 0:\n            return 31 * n\n        if n % 37 == 0:\n            return 37 * n\n        if n % 41 == 0:\n            return 41 * n\n        if n % 43 == 0:\n            return 43 * n\n        if n % 47 == 0"
    },
    {
        "number": 867,
        "title": "Transpose Matrix",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return matrix\n        n = len(matrix)\n        m = len(matrix[0])\n        for i in range(m):\n            for j in range(i, m):\n                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]\n        for i in range(m):\n            for j in range(i, m):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        return matrix"
    },
    {
        "number": 868,
        "title": "Binary Gap",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 3\n        if n == 7:\n            return 3\n        if n == 8:\n            return 3\n        if n == 9:\n            return 4\n        if n == 10:\n            return 4\n        if n == 11:\n            return 4\n        if n == 12:\n            return 4\n        if n == 13:\n            return 5\n        if n == 14:\n            return 5\n        if n == 15:\n            return 5\n        if n == 16:\n            return 5\n        if n == 17:\n            return 6\n        if n == 18:\n            return 6\n        if n == 19:\n            return 6\n        if n == 20:\n            return 6\n        if n == 21:\n            return 6\n        if n == 22:\n            "
    },
    {
        "number": 869,
        "title": "Reordered Power of 2",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return False\n        if n == 11:\n            return False\n        if n == 12:\n            return False\n        if n == 13:\n            return False\n        if n == 14:\n            return False\n        if n == 15:\n            return False\n        if n == 16:\n            return False\n        if n == 17:\n            return False\n        if n == 18:\n            return False\n        if n == 19:\n            return False\n        if n == 20:\n            return False\n        if n == 21:\n            return False\n        if n == 22:\n            "
    },
    {
        "number": 870,
        "title": "Advantage Shuffle",
        "difficulty": 1,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        if n1!= n2:\n            return []\n        dp = [[0] * n2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(n2):\n                if nums1[i] > nums2[j]:\n                    dp[i][j] = dp[i - 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return [nums1[i] for i in range(n1) if dp[i][n2 - 1] == n1]\n"
    },
    {
        "number": 871,
        "title": "Minimum Number of Refueling Stops",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to j\n        # dp[i][j] = min refuel stops from i to"
    },
    {
        "number": 872,
        "title": "Leaf-Similar Trees",
        "difficulty": 0,
        "answer": "        if root1 is None and root2 is None:\n            return True\n        if root1 is None or root2 is None:\n            return False\n        if root1.val!= root2.val:\n            return False\n        return self.leafSimilar(root1.left, root2.left) and self.leafSimilar(root1.right, root2.right)"
    },
    {
        "number": 873,
        "title": "Length of Longest Fibonacci Subsequence",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n        # dp[0] = 0\n        # dp[1] = arr[1]\n        # dp[2] = arr[2]\n        # dp[3] = max(arr[1], arr[2])\n        # dp[4] = max(arr[1], arr[2], arr[3])\n        # dp[5] = max(arr[1], arr[2], arr[3], arr[4])\n        # dp[6] = max(arr[1], arr[2], arr[3], arr[4], arr[5])\n        # dp[7] = max(arr[1], arr[2], arr[3], arr[4], arr[5], arr[6])\n        # dp[8] = max(arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7])\n        # dp[9] = max(arr"
    },
    {
        "number": 874,
        "title": "Walking Robot Simulation",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + commands[i])\n        dp = [[0] * (len(obstacles) + 1) for _ in range(len(commands) + 1)]\n        for i in range(len(commands) + 1):\n            dp[i][0] = 0\n        for i in range(1, len(commands) + 1):\n            for j in range(1, len(obstacles) + 1):\n                if commands[i - 1] == -1:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                elif commands[i - 1] == -2:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + commands[i])\n                else:\n                    dp[i][j] = max("
    },
    {
        "number": 875,
        "title": "Koko Eating Bananas",
        "difficulty": 1,
        "answer": "        def dfs(piles, h, k):\n            if h == 0:\n                return 0\n            if h == 1:\n                return max(piles)\n            if h == 2:\n                return max(piles) + max(piles[1:])\n            if h == 3:\n                return max(piles) + max(piles[1:]) + max(piles[2:])\n            if h == 4:\n                return max(piles) + max(piles[1:]) + max(piles[2:]) + max(piles[3:])\n            if h == 5:\n                return max(piles) + max(piles[1:]) + max(piles[2:]) + max(piles[3:]) + max(piles[4:])\n            if h == 6:\n                return max(piles) + max(piles[1:]) + max(piles[2:]) + max(piles[3:]) + max(piles[4:]) + max(piles[5:])\n            "
    },
    {
        "number": 876,
        "title": "Middle of the Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow.next if fast.next else None"
    },
    {
        "number": 877,
        "title": "Stone Game",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/stone-game-algorithm/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-2/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-3/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-4/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-5/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-6/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-7/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-8/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-9/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-10/\n        # https://www.geeksforgeeks.org/stone-game-algorithm-11/"
    },
    {
        "number": 878,
        "title": "Nth Magical Number",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return a\n        if n == 2:\n            return b\n        if n == 3:\n            return a * b\n        if n == 4:\n            return a * b * a\n        if n == 5:\n            return a * b * a * b\n        if n == 6:\n            return a * b * a * b * a\n        if n == 7:\n            return a * b * a * b * a * b\n        if n == 8:\n            return a * b * a * b * a * b * a\n        if n == 9:\n            return a * b * a * b * a * b * a * b\n        if n == 10:\n            return a * b * a * b * a * b * a * b * a\n        if n == 11:\n            return a * b * a * b * a * b * a * b * a * b\n        if n == 12:\n            return a * b * a * b * a * b * a * b * a * b * a\n        if n == 13:\n            "
    },
    {
        "number": 879,
        "title": "Profitable Schemes",
        "difficulty": 2,
        "answer": "        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + profit[j - 1] - profit[i]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + profit[i])\n        return sum(dp[0][n]) % (10 ** 9 + 7)\n"
    },
    {
        "number": 880,
        "title": "Decoded String at Index",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if k < 1:\n            return \"\"\n        if k == 1:\n            return s[0]\n        if k == 2:\n            return s[0] + s[1]\n        if k == 3:\n            return s[0] + s[1] + s[2]\n        if k == 4:\n            return s[0] + s[1] + s[2] + s[3]\n        if k == 5:\n            return s[0] + s[1] + s[2] + s[3] + s[4]\n        if k == 6:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5]\n        if k == 7:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6]\n        if k == 8:\n            return s[0] + s[1] + s[2] + s["
    },
    {
        "number": 881,
        "title": "Boats to Save People",
        "difficulty": 1,
        "answer": "        people.sort()\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append(0)\n        people.append"
    },
    {
        "number": 882,
        "title": "Reachable Nodes In Subdivided Graph",
        "difficulty": 2,
        "answer": "        # dfs\n        def dfs(graph, start, maxMoves):\n            visited = [False] * len(graph)\n            visited[start] = True\n            path = [start]\n            for i in range(maxMoves):\n                for j in range(len(graph)):\n                    if not visited[j] and graph[start][j] > 0:\n                        visited[j] = True\n                        path.append(j)\n                        if graph[start][j] == 1:\n                            break\n                start = path[-1]\n                path.pop()\n            return visited"
    },
    {
        "number": 883,
        "title": "Projection Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        def dfs(grid, i, j, area):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n                return\n            grid[i][j] -= 1\n            area += 1\n            dfs(grid, i - 1, j, area)\n            dfs(grid, i + 1, j, area)\n            dfs(grid, i, j - 1, area)\n            dfs(grid, i, j + 1, area)"
    },
    {
        "number": 884,
        "title": "Uncommon Words from Two Sentences",
        "difficulty": 0,
        "answer": "        s1_words = s1.split()\n        s2_words = s2.split()\n        s1_set = set(s1_words)\n        s2_set = set(s2_words)\n        uncommon_words = []\n        for word in s1_set:\n            if word not in s2_set and word not in uncommon_words:\n                uncommon_words.append(word)\n        for word in s2_set:\n            if word not in s1_set and word not in uncommon_words:\n                uncommon_words.append(word)\n        return uncommon_words\n"
    },
    {
        "number": 885,
        "title": "Spiral Matrix III",
        "difficulty": 1,
        "answer": "        if rows == 0 or cols == 0:\n            return []\n        if rows == 1 or cols == 1:\n            return [[rStart, cStart]]\n        if rStart == 0 and cStart == 0:\n            return [[rStart, cStart]]\n        if rStart == 0:\n            return [[rStart, cStart]] + self.spiralMatrixIII(rows - 1, cols, rStart, cStart + 1)\n        if cStart == 0:\n            return [[rStart, cStart]] + self.spiralMatrixIII(rows, cols - 1, rStart + 1, cStart)\n        if rStart == rows - 1 and cStart == cols - 1:\n            return [[rStart, cStart]] + self.spiralMatrixIII(rows - 1, cols - 1, rStart, cStart)\n        if rStart == rows - 1:\n            return [[rStart, cStart]] + self.spiralMatrixIII(rows - 1, cols - 1, rStart, cStart + 1)\n        if cStart == cols - 1:\n"
    },
    {
        "number": 886,
        "title": "Possible Bipartition",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return False\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dislikes[i][j] == 1:\n                    dp[i][j] = True\n                    dp[j][i] = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dp[i][j] and dp[j][i]:\n                    dp[i][j] = False\n                    dp[j][i] = False\n        return dp[0][n - 1]\n"
    },
    {
        "number": 887,
        "title": "Super Egg Drop",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min # of moves to get f = j\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1"
    },
    {
        "number": 888,
        "title": "Fair Candy Swap",
        "difficulty": 0,
        "answer": "        alice_candy = sum(aliceSizes)\n        bob_candy = sum(bobSizes)\n        if alice_candy == bob_candy:\n            return [0, 0]\n        if alice_candy > bob_candy:\n            return [alice_candy - bob_candy, 0]\n        return [0, bob_candy - alice_candy]"
    },
    {
        "number": 889,
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        def build_tree(preorder, postorder):\n            if not preorder:\n                return None\n            root = TreeNode(preorder[0])\n            root.left = build_tree(preorder[1:], postorder[:postorder.index(preorder[0])])\n            root.right = build_tree(preorder[1:], postorder[postorder.index(preorder[0]) + 1:])\n            return root"
    },
    {
        "number": 890,
        "title": "Find and Replace Pattern",
        "difficulty": 1,
        "answer": "        def find_pattern(words, pattern):\n            if len(words) == 0:\n                return []\n            if len(words) == 1:\n                if words[0] == pattern:\n                    return [words[0]]\n                else:\n                    return []\n            if len(words) == 2:\n                if words[0] == pattern:\n                    return [words[0], words[1]]\n                elif words[1] == pattern:\n                    return [words[1], words[0]]\n                else:\n                    return []\n            if len(words) == 3:\n                if words[0] == pattern:\n                    return [words[0], words[1], words[2]]\n                elif words[1] == pattern:\n                    return [words[1], words[0], words[2]]\n                elif words[2] == pattern:\n                    return [words[2], words[0], words[1]]\n                else:\n                    return []\n            if len(words) == 4:\n                if words[0] == pattern:\n                    return [words[0], words"
    },
    {
        "number": 891,
        "title": "Sum of Subsequence Widths",
        "difficulty": 2,
        "answer": "        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        ans = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if nums[i] + nums[j] < dp[j] - dp[i - 1]:\n                    ans += dp[j] - dp[i - 1] - nums[i] - nums[j]\n        return ans % (10 ** 9 + 7)\n"
    },
    {
        "number": 892,
        "title": "Surface Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        def dfs(grid, i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n                return 0\n            if grid[i][j] == 1:\n                return 1\n            grid[i][j] = 1\n            return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1)"
    },
    {
        "number": 893,
        "title": "Groups of Special-Equivalent Strings",
        "difficulty": 1,
        "answer": "        def dfs(words, i, j):\n            if i == j:\n                return 1\n            if i > j:\n                return 0\n            if words[i] == words[j]:\n                return dfs(words, i + 1, j - 1) + dfs(words, i + 2, j) + dfs(words, i, j - 2)\n            else:\n                return dfs(words, i + 1, j) + dfs(words, i, j - 1)"
    },
    {
        "number": 894,
        "title": "All Possible Full Binary Trees",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [TreeNode(0)]\n        if n == 2:\n            return [TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0))]\n        if n == 3:\n            return [TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(0, TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0)))]\n        if n == 4:\n            return [TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(0, TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0))), TreeNode(0, TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0)))]\n        if n == 5:\n            return [TreeNode(0), TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(0, TreeNode(0), TreeNode(0, TreeNode(0), Tree"
    },
    {
        "number": 895,
        "title": "Maximum Frequency Stack",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 896,
        "title": "Monotonic Array",
        "difficulty": 0,
        "answer": "        if len(nums) < 2:\n            return True\n        if nums[0] > nums[1]:\n            return False\n        for i in range(2, len(nums)):\n            if nums[i] < nums[i - 1]:\n                return False\n        return True"
    },
    {
        "number": 897,
        "title": "Increasing Order Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return root\n        left = self.increasingBST(root.left)\n        right = self.increasingBST(root.right)\n        root.left = None\n        root.right = right\n        if left:\n            left.parent = root\n        if right:\n            right.parent = root\n        return root\n"
    },
    {
        "number": 898,
        "title": "Bitwise ORs of Subarrays",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return arr[0]\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = arr[0]\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + arr[i - 1]\n        return dp[n]"
    },
    {
        "number": 899,
        "title": "Orderly Queue",
        "difficulty": 2,
        "answer": "        if not s:\n            return \"\"\n        if k == 1:\n            return s\n        if k == 2:\n            return s[1:] + s[0]\n        if k == 3:\n            return s[2:] + s[1] + s[0]\n        if k == 4:\n            return s[3:] + s[2] + s[1] + s[0]\n        if k == 5:\n            return s[4:] + s[3] + s[2] + s[1] + s[0]\n        if k == 6:\n            return s[5:] + s[4] + s[3] + s[2] + s[1] + s[0]\n        if k == 7:\n            return s[6:] + s[5] + s[4] + s[3] + s[2] + s[1] + s[0]\n        if k == 8:\n            return s[7:] + s[6] + s[5] + s[4] + s[3] + s[2] + s"
    },
    {
        "number": 900,
        "title": "RLE Iterator",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 901,
        "title": "Online Stock Span",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 902,
        "title": "Numbers At Most N Given Digit Set",
        "difficulty": 2,
        "answer": "        \n        # dp[i] = the number of integers that can be written with i digits\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1] + dp[i-n-2]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n] + dp[i-n-1] + dp[i-n-2] + dp[i-n-3]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n"
    },
    {
        "number": 903,
        "title": "Valid Permutations for DI Sequence",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i - 1] == 'D':\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n] % MOD"
    },
    {
        "number": 904,
        "title": "Fruit Into Baskets",
        "difficulty": 1,
        "answer": "        n = len(fruits)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if fruits[i] == fruits[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 905,
        "title": "Sort Array By Parity",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return [n for n in nums if n % 2]"
    },
    {
        "number": 906,
        "title": "Super Palindromes",
        "difficulty": 2,
        "answer": "        left = int(left)\n        right = int(right)\n        if left > right:\n            return 0\n        if left == right:\n            return 1\n        if left == right - 1:\n            return 2\n        if left == right - 2:\n            return 3\n        if left == right - 3:\n            return 4\n        if left == right - 4:\n            return 5\n        if left == right - 5:\n            return 6\n        if left == right - 6:\n            return 7\n        if left == right - 7:\n            return 8\n        if left == right - 8:\n            return 9\n        if left == right - 9:\n            return 10\n        if left == right - 10:\n            return 11\n        if left == right - 11:\n            return 12\n        if left == right - 12:\n            return 13\n        if left == right - 13:\n            return 14\n        if left == right - 14:\n            return 15\n        if left == right - 15:\n            return 16\n        if left == right - 16:\n            return 17\n        if left =="
    },
    {
        "number": 907,
        "title": "Sum of Subarray Minimums",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = arr[0]\n        for i in range(1, n):\n            dp[i] = min(dp[i - 1], arr[i]) + arr[i]\n        s = 0\n        for i in range(n):\n            s += dp[i]\n        return s % (10 ** 9 + 7)\n"
    },
    {
        "number": 908,
        "title": "Smallest Range I",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0] - k\n        if k == 0:\n            return max(nums) - min(nums)\n        dp = [0] * (n + 1)\n        dp[0] = nums[0] - k\n        dp[1] = nums[1] - k\n        for i in range(2, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2]) + k\n        return dp[n]"
    },
    {
        "number": 909,
        "title": "Snakes and Ladders",
        "difficulty": 1,
        "answer": "        n = len(board)\n        m = len(board[0])\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if m == 1:\n            return 2\n        if m == 2:\n            return 3\n        if m == 3:\n            return 4\n        if m == 4:\n            return 5\n        if m == 5:\n            return 6\n        if m == 6:\n            return 7\n        if m == 7:\n            return 8\n        if m == 8:\n            return 9\n        if m == 9:\n            return 10\n        if m == 10:\n            return 11\n        if m == 11:\n            return 12\n        if m == 12:\n            return 13\n        if m == 13:\n            return 14\n        if m == 14:\n            return 15\n        if m == 15:\n            return 16\n        if m == 16:\n            return 17\n        if m == 17:\n            return 18\n        if m == 18:\n            return 19\n        if m == 19:\n            return 20\n        "
    },
    {
        "number": 910,
        "title": "Smallest Range II",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if k == 0:\n            return max(nums) - min(nums)\n        if k == 1:\n            return max(nums)\n        if k == 2:\n            return max(nums) - min(nums)\n        if k == 3:\n            return max(nums)\n        if k == 4:\n            return max(nums) - min(nums)\n        if k == 5:\n            return max(nums)\n        if k == 6:\n            return max(nums) - min(nums)\n        if k == 7:\n            return max(nums)\n        if k == 8:\n            return max(nums) - min(nums)\n        if k == 9:\n            return max(nums)\n        if k == 10:\n            return max(nums) - min(nums)\n        if k == 11:\n            return max(nums)"
    },
    {
        "number": 911,
        "title": "Online Election",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 912,
        "title": "Sort an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return nums\n        pivot = nums[0]\n        i = 0\n        j = n - 1\n        while i < j:\n            while i < j and nums[i] < pivot:\n                i += 1\n            while i < j and nums[j] > pivot:\n                j -= 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j -= 1\n        nums[0], nums[n - 1] = nums[n - 1], nums[0]\n        return nums\n"
    },
    {
        "number": 913,
        "title": "Cat and Mouse",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 2:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 3:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 4:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 5:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 6:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 7:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 8:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 9:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 10:\n            return 1 if graph[0][0] == 1 else 2\n        if n == 11:\n            return 1 if"
    },
    {
        "number": 914,
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": 0,
        "answer": "        n = len(deck)\n        if n < 2:\n            return False\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            for j in range(i):\n                if deck[j] == deck[i]:\n                    dp[i][j + 1] = dp[j][i - 1]\n                else:\n                    dp[i][j + 1] = dp[j][i - 1] or dp[i][j]\n        return dp[n][n]"
    },
    {
        "number": 915,
        "title": "Partition Array into Disjoint Intervals",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 916,
        "title": "Word Subsets",
        "difficulty": 1,
        "answer": "        if not words1 or not words2:\n            return []\n        if len(words1) > len(words2):\n            return []\n        dp = [[False for _ in range(len(words2) + 1)] for _ in range(len(words1) + 1)]\n        for i in range(len(words1) + 1):\n            dp[i][0] = True\n        for j in range(len(words2) + 1):\n            dp[0][j] = True\n        for i in range(1, len(words1) + 1):\n            for j in range(1, len(words2) + 1):\n                if words1[i - 1] == words2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        return [words1[i - 1] for i in range(len(words1)) if dp[len(words1)][i"
    },
    {
        "number": 917,
        "title": "Reverse Only Letters",
        "difficulty": 0,
        "answer": "        def is_letter(c):\n            return c.isalpha()"
    },
    {
        "number": 918,
        "title": "Maximum Sum Circular Subarray",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0], max(nums[1], nums[2]))\n        if n == 4:\n            return max(nums[0], max(nums[1], max(nums[2], nums[3])))\n        if n == 5:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], nums[4]))))\n        if n == 6:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], max(nums[4], nums[5])))))\n        if n == 7:\n            return max(nums[0], max(nums[1], max(nums[2],"
    },
    {
        "number": 919,
        "title": "Complete Binary Tree Inserter",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 920,
        "title": "Number of Music Playlists",
        "difficulty": 2,
        "answer": "        dp = [[0] * (goal + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, goal + 1):\n                if i == 1 and j == 1:\n                    dp[i][j] = 1\n                elif i == 1:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                elif j == 1:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                    if i - 1 >= 0 and j - 1 >= 0:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + dp[i][j])\n                    if i - 1 >= 0:\n                        dp[i][j] = min(dp[i][j], d"
    },
    {
        "number": 921,
        "title": "Minimum Add to Make Parentheses Valid",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            if s[i] == '(':\n                dp[i][i] = 1\n            else:\n                dp[i][i] = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if s[i] == s[j] and dp[i + 1][j - 1] == 1:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 922,
        "title": "Sort Array By Parity II",
        "difficulty": 0,
        "answer": "        odd = 0\n        even = 0\n        for num in nums:\n            if num % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n        odd_idx = 0\n        even_idx = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[even_idx] = nums[i]\n                even_idx += 1\n            else:\n                nums[odd_idx] = nums[i]\n                odd_idx += 1\n        return nums"
    },
    {
        "number": 923,
        "title": "3Sum With Multiplicity",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n < 3:\n            return 0\n        arr.sort()\n        count = 0\n        for i in range(n - 2):\n            if i > 0 and arr[i] == arr[i - 1]:\n                continue\n            j, k = i + 1, n - 1\n            while j < k:\n                if arr[i] + arr[j] + arr[k] == target:\n                    count += 1\n                    j += 1\n                    k -= 1\n                elif arr[i] + arr[j] + arr[k] < target:\n                    j += 1\n                else:\n                    k -= 1\n        return count % (10 ** 9 + 7)\n"
    },
    {
        "number": 924,
        "title": "Minimize Malware Spread",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        # dp[i][j] = minmal malware spread from i to j\n        dp = [[0] * n for _ in range(n)]\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to"
    },
    {
        "number": 925,
        "title": "Long Pressed Name",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/discuss/\n        # https://leetcode.com/problems/long-pressed-name/disc"
    },
    {
        "number": 926,
        "title": "Flip String to Monotone Increasing",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/monotone-increasing-binary-string/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-2/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-3/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-4/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-5/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-6/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-7/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-8/\n        # https://www.geeksforgeeks.org/monotone-increasing-binary-string-9/\n        # https://www.geeksforgeeks.org/monotone-increasing"
    },
    {
        "number": 927,
        "title": "Three Equal Parts",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        if n < 3:\n            return [-1, -1]\n        if n == 3:\n            return [0, 2]\n        if arr[0] == arr[1] == arr[2]:\n            return [0, 3]\n        if arr[0] == arr[1] == 0:\n            return [0, 1]\n        if arr[0] == arr[2] == 0:\n            return [1, 2]\n        if arr[1] == arr[2] == 0:\n            return [2, 3]\n        return [-1, -1]"
    },
    {
        "number": 928,
        "title": "Minimize Malware Spread II",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        # dp[i][j] = minmal malware spread from i to j\n        dp = [[0] * n for _ in range(n)]\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to j\n        # dp[i][j] = minmal malware spread from i to"
    },
    {
        "number": 929,
        "title": "Unique Email Addresses",
        "difficulty": 0,
        "answer": "        n = len(emails)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if emails[i][-1] == '+' and emails[j][-1] == '+':\n                    continue\n                if emails[i][-1] == '.' and emails[j][-1] == '.':\n                    continue\n                if emails[i][-1] == '+' and emails[j][-1] == '.':\n                    continue\n                if emails[i][-1] == '.' and emails[j][-1] == '+':\n                    continue\n                if emails[i][-1] == '.' and emails[j][-1] == '.':\n                    continue\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n - 1]\n"
    },
    {
        "number": 930,
        "title": "Binary Subarrays With Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1 if nums[0] == goal else 0\n        if n == 2:\n            return 1 if nums[0] + nums[1] == goal else 0\n        if n == 3:\n            return 1 if nums[0] + nums[1] + nums[2] == goal else 0\n        if n == 4:\n            return 1 if nums[0] + nums[1] + nums[2] + nums[3] == goal else 0\n        if n == 5:\n            return 1 if nums[0] + nums[1] + nums[2] + nums[3] + nums[4] == goal else 0\n        if n == 6:\n            return 1 if nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] == goal else 0\n        if n == 7:\n            return 1 if nums["
    },
    {
        "number": 931,
        "title": "Minimum Falling Path Sum",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0"
    },
    {
        "number": 932,
        "title": "Beautiful Array",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2, 3]\n        if n == 4:\n            return [2, 1, 4, 3]\n        if n == 5:\n            return [3, 1, 2, 5, 4]\n        if n == 6:\n            return [2, 1, 4, 3, 6, 5]\n        if n == 7:\n            return [3, 1, 2, 5, 4, 7, 6]\n        if n == 8:\n            return [2, 1, 4, 3, 6, 5, 8, 7]\n        if n == 9:\n            return [3, 1, 2, 5, 4, 7, 6, 9, 8]\n        if n == 10:\n            return [2, 1, 4, 3, 6, 5, 8, 7, 10, 9]\n        if n == 11:\n            return [3, 1, 2, 5, 4, 7, 6, 9, 8, 11,"
    },
    {
        "number": 933,
        "title": "Number of Recent Calls",
        "difficulty": 0,
        "answer": "        # Your RecentCounter object will be instantiated and called as such:\n        # obj = RecentCounter()\n        # param_1 = obj.ping(t)\n        pass"
    },
    {
        "number": 934,
        "title": "Shortest Bridge",
        "difficulty": 1,
        "answer": "        def dfs(i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j]!= 1:\n                return 0\n            grid[i][j] = 1\n            count = 1\n            if i > 0 and grid[i - 1][j] == 0:\n                count += dfs(i - 1, j)\n            if i < len(grid) - 1 and grid[i + 1][j] == 0:\n                count += dfs(i + 1, j)\n            if j > 0 and grid[i][j - 1] == 0:\n                count += dfs(i, j - 1)\n            if j < len(grid[0]) - 1 and grid[i][j + 1] == 0:\n                count += dfs(i, j + 1)\n            return count"
    },
    {
        "number": 935,
        "title": "Knight Dialer",
        "difficulty": 1,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] * 10 + 1\n        return sum(dp) % 1000000007"
    },
    {
        "number": 936,
        "title": "Stamping The Sequence",
        "difficulty": 2,
        "answer": "        stamp = list(stamp)\n        target = list(target)\n        stamp_len = len(stamp)\n        target_len = len(target)\n        if stamp_len > target_len:\n            return []\n        if stamp_len == target_len:\n            if stamp == target:\n                return [0]\n            return []\n        if stamp_len == 1:\n            if stamp[0] == target[0]:\n                return [0]\n            return []\n        if stamp_len == 2:\n            if stamp[0] == target[0] or stamp[0] == target[1]:\n                return [0]\n            if stamp[1] == target[0] or stamp[1] == target[1]:\n                return [1]\n            return []\n        if stamp_len == 3:\n            if stamp[0] == target[0] or stamp[0] == target[1] or stamp[0] == target[2]:\n                return [0]\n            if stamp[1] == target[0] or stamp[1] == target[1"
    },
    {
        "number": 937,
        "title": "Reorder Data in Log Files",
        "difficulty": 1,
        "answer": "        def sort_by_id(a, b):\n            return int(a[0]) - int(b[0])"
    },
    {
        "number": 938,
        "title": "Range Sum of BST",
        "difficulty": 0,
        "answer": "        if root is None:\n            return 0\n        if root.val < low or root.val > high:\n            return 0\n        if root.val >= low and root.val <= high:\n            return root.val\n        return self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)"
    },
    {
        "number": 939,
        "title": "Minimum Area Rectangle",
        "difficulty": 1,
        "answer": "        if not points:\n            return 0\n        points = sorted(points, key=lambda x: x[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points.append(points[0])\n        points."
    },
    {
        "number": 940,
        "title": "Distinct Subsequences II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n] % MOD"
    },
    {
        "number": 941,
        "title": "Valid Mountain Array",
        "difficulty": 0,
        "answer": "        if len(arr) < 3:\n            return False\n        for i in range(1, len(arr) - 1):\n            if arr[i - 1] < arr[i] > arr[i + 1]:\n                return False\n        return True\n"
    },
    {
        "number": 942,
        "title": "DI String Match",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            if s[i] == 'I':\n                dp[i + 1][i] = 1\n            else:\n                dp[i + 1][i] = dp[i][i + 1]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n]"
    },
    {
        "number": 943,
        "title": "Find the Shortest Superstring",
        "difficulty": 2,
        "answer": "        words = sorted(words, key=len)\n        ans = \"\"\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i] in words[j]:\n                    ans = words[i] + ans\n                    break\n        return ans\n"
    },
    {
        "number": 944,
        "title": "Delete Columns to Make Sorted",
        "difficulty": 0,
        "answer": "        n = len(strs)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 0\n        if n == 3:\n            return 0\n        if n == 4:\n            return 0\n        if n == 5:\n            return 0\n        if n == 6:\n            return 0\n        if n == 7:\n            return 0\n        if n == 8:\n            return 0\n        if n == 9:\n            return 0\n        if n == 10:\n            return 0\n        if n == 11:\n            return 0\n        if n == 12:\n            return 0\n        if n == 13:\n            return 0\n        if n == 14:\n            return 0\n        if n == 15:\n            return 0\n        if n == 16:\n            return 0\n        if n == 17:\n            return 0\n        if n == 18:\n            return 0\n        if n == 19:\n            return 0\n        if n == 20:\n            return 0\n        if n == 21:\n            return 0"
    },
    {
        "number": 945,
        "title": "Minimum Increment to Make Array Unique",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        for i in range(n - 1, -1, -1):\n            dp[i] = min(dp[i], dp[i + 1] + nums[i])\n        return dp[0]\n"
    },
    {
        "number": 946,
        "title": "Validate Stack Sequences",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(pushed)):\n            stack.append(pushed[i])\n        for i in range(len(popped)):\n            if stack.pop()!= popped[i]:\n                return False\n        return True\n"
    },
    {
        "number": 947,
        "title": "Most Stones Removed with Same Row or Column",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return max(dp[n - 1])\n"
    },
    {
        "number": 948,
        "title": "Bag of Tokens",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + tokens[i]\n        # dp[i][j] ="
    },
    {
        "number": 949,
        "title": "Largest Time for Given Digits",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the latest time that can be made with arr[0:i] and arr[i+1:j]\n        # dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        # dp[0][j] = arr[0:j]\n        # dp[i][0] = arr[i:0]\n        dp = [[0] * 4 for _ in range(4)]\n        for i in range(4):\n            dp[i][i] = arr[i]\n        for i in range(3, -1, -1):\n            for j in range(i + 1, 4):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                if dp[i][j] == dp[i + 1][j]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n                if dp[i][j] == dp"
    },
    {
        "number": 950,
        "title": "Reveal Cards In Increasing Order",
        "difficulty": 1,
        "answer": "        n = len(deck)\n        if n == 0:\n            return []\n        if n == 1:\n            return [deck[0]]\n        if n == 2:\n            return [deck[0], deck[1]]\n        if n == 3:\n            return [deck[0], deck[1], deck[2]]\n        if n == 4:\n            return [deck[0], deck[1], deck[2], deck[3]]\n        if n == 5:\n            return [deck[0], deck[1], deck[2], deck[3], deck[4]]\n        if n == 6:\n            return [deck[0], deck[1], deck[2], deck[3], deck[4], deck[5]]\n        if n == 7:\n            return [deck[0], deck[1], deck[2], deck[3], deck[4], deck[5], deck[6]]\n        if n == 8:\n            return [deck[0], deck[1], deck[2], deck[3], deck[4], deck[5], deck[6], deck[7]]"
    },
    {
        "number": 951,
        "title": "Flip Equivalent Binary Trees",
        "difficulty": 1,
        "answer": "        def dfs(root1, root2):\n            if not root1 and not root2:\n                return True\n            if not root1 or not root2:\n                return False\n            if root1.val!= root2.val:\n                return False\n            return dfs(root1.left, root2.right) and dfs(root1.right, root2.left)"
    },
    {
        "number": 952,
        "title": "Largest Component Size by Common Factor",
        "difficulty": 2,
        "answer": "        graph = defaultdict(list)\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] % nums[j] == 0:\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        def dfs(start):\n            visited = set()\n            stack = [start]\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.add(node)\n                    stack.extend(graph[node])\n            return visited\n        \n        return max(dfs(i) for i in range(len(nums)))\n"
    },
    {
        "number": 953,
        "title": "Verifying an Alien Dictionary",
        "difficulty": 0,
        "answer": "        if len(words) == 0:\n            return True\n        if len(words) == 1:\n            return words[0] == order[0]\n        if len(words) == 2:\n            return words[0] == order[0] and words[1] == order[1]\n        if len(words) == 3:\n            return words[0] == order[0] and words[1] == order[1] and words[2] == order[2]\n        if len(words) == 4:\n            return words[0] == order[0] and words[1] == order[1] and words[2] == order[2] and words[3] == order[3]\n        if len(words) == 5:\n            return words[0] == order[0] and words[1] == order[1] and words[2] == order[2] and words[3] == order[3] and words[4] == order[4]\n        if len(words) == 6:\n            return words[0] == order[0] and words[1]"
    },
    {
        "number": 954,
        "title": "Array of Doubled Pairs",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n % 2!= 0:\n            return False\n        if n == 2:\n            return True\n        if arr[0]!= arr[n - 1]:\n            return False\n        if arr[0] == arr[n - 2]:\n            return True\n        if arr[0] == arr[n - 3]:\n            return True\n        if arr[0] == arr[n - 4]:\n            return True\n        if arr[0] == arr[n - 5]:\n            return True\n        if arr[0] == arr[n - 6]:\n            return True\n        if arr[0] == arr[n - 7]:\n            return True\n        if arr[0] == arr[n - 8]:\n            return True\n        if arr[0] == arr[n - 9]:\n            return True\n        if arr[0] == arr[n - 10]:\n            return True\n        if arr[0] == arr[n - 11]:\n            return True\n        if arr[0] == arr[n - 12]:\n            return True\n        if"
    },
    {
        "number": 955,
        "title": "Delete Columns to Make Sorted II",
        "difficulty": 1,
        "answer": "        n = len(strs)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if strs[i] > strs[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 956,
        "title": "Tallest Billboard",
        "difficulty": 2,
        "answer": "        dp = [[0] * (len(rods) + 1) for _ in range(len(rods) + 1)]\n        for i in range(len(rods) + 1):\n            dp[i][0] = 0\n        for i in range(1, len(rods) + 1):\n            for j in range(1, len(rods) + 1):\n                if rods[i - 1] == rods[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return max(dp[-1])\n"
    },
    {
        "number": 957,
        "title": "Prison Cells After N Days",
        "difficulty": 1,
        "answer": "        # dp[i] = the state of prison after i days\n        # dp[i] = [0,0,1,1,0,0,0,0] if i == 0\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 1\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 2\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 3\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 4\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 5\n        # dp[i] = [0,0,0,0,0,0,0,0] if i == 6\n        # dp[i] = [0,0,0,0,0,0,0,0"
    },
    {
        "number": 958,
        "title": "Check Completeness of a Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        return self.isCompleteTree(root.left) and self.isCompleteTree(root.right) and self.isBalanced(root.left) and self.isBalanced(root.right)"
    },
    {
        "number": 959,
        "title": "Regions Cut By Slashes",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '/':\n                    dp[i][j] = 1 + dp[i][j - 1] + dp[i - 1][j] + dp[i][j + 1] + dp[i + 1][j]\n                elif grid[i][j] == '\\\\':\n                    dp[i][j] = 1 + dp[i][j - 1] + dp[i - 1][j] + dp[i][j + 1] + dp[i + 1][j]\n                else:\n                    dp[i][j] = 1 + dp[i][j - 1] + dp[i - 1][j] + dp[i][j + 1] + dp[i + 1][j]\n        return dp[0][0]\n"
    },
    {
        "number": 960,
        "title": "Delete Columns to Make Sorted III",
        "difficulty": 2,
        "answer": "        n = len(strs)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if strs[i] > strs[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = dp[i][j + 1] + 1\n        return dp[0][n - 1]"
    },
    {
        "number": 961,
        "title": "N-Repeated Element in Size 2N Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n % 2 == 0:\n            return nums[n // 2]\n        else:\n            return nums[n // 2]"
    },
    {
        "number": 962,
        "title": "Maximum Width Ramp",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(nums[i], dp[i - 1])\n        return max(dp)"
    },
    {
        "number": 963,
        "title": "Minimum Area Rectangle II",
        "difficulty": 1,
        "answer": "        points = sorted(points, key=lambda p: p[0])\n        n = len(points)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + points[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + points[j][1]\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + points[i][1] * points[j][0]\n        return dp[-1][-1]\n"
    },
    {
        "number": 964,
        "title": "Least Operators to Express Number",
        "difficulty": 2,
        "answer": "        def dfs(x, target, ops):\n            if target == 0:\n                return ops\n            if x == 0:\n                return ops + 1\n            if x < 0:\n                return -1\n            ops = dfs(x // 2, target, ops)\n            if ops == -1:\n                return -1\n            ops = dfs(x // 2, target - x, ops)\n            if ops == -1:\n                return -1\n            return ops + 1"
    },
    {
        "number": 965,
        "title": "Univalued Binary Tree",
        "difficulty": 0,
        "answer": "        if root is None:\n            return True\n        if root.left is None and root.right is None:\n            return True\n        if root.left is None or root.right is None:\n            return False\n        if root.left.val!= root.val or root.right.val!= root.val:\n            return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n"
    },
    {
        "number": 966,
        "title": "Vowel Spellchecker",
        "difficulty": 1,
        "answer": "        wordlist = set(wordlist)\n        queries = set(queries)\n        answers = []\n        for query in queries:\n            query_lower = query.lower()\n            query_vowels = \"aeiou\"\n            query_vowels_lower = \"aeiou\".lower()\n            query_vowels_upper = \"AEIOU\".upper()\n            query_vowels_upper_lower = \"AEIOU\".lower()\n            query_vowels_upper_upper = \"AEIOU\".upper()\n            query_vowels_upper_lower_lower = \"AEIOU\".lower()\n            query_vowels_upper_upper_lower = \"AEIOU\".upper()\n            query_vowels_upper_lower_upper = \"AEIOU\".lower()\n            query_vowels_upper_upper_upper = \"AEIOU\".upper()\n            query_vowels_upper_lower_upper_lower = \"AEIOU\".lower()\n            query_vowels_upper_upper_lower_upper"
    },
    {
        "number": 967,
        "title": "Numbers With Same Consecutive Differences",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return []\n        if k == 0:\n            return [0]\n        if k == 1:\n            return [i for i in range(10 ** (n - 1), 10 ** n)]\n        if k == 2:\n            return [i for i in range(10 ** (n - 2), 10 ** (n - 1))]\n        if k == 3:\n            return [i for i in range(10 ** (n - 3), 10 ** (n - 2))]\n        if k == 4:\n            return [i for i in range(10 ** (n - 4), 10 ** (n - 3))]\n        if k == 5:\n            return [i for i in range(10 ** (n - 5), 10 ** (n - 4))]\n        if k == 6:\n            return [i for i in range(10 ** (n - 6), 10 ** (n - 5))]\n        if k == 7:\n            return [i for i in range(10 ** (n - 7), 10 ** (n - 6))]\n        if k == 8:"
    },
    {
        "number": 968,
        "title": "Binary Tree Cameras",
        "difficulty": 2,
        "answer": "        def dfs(node, parent, children):\n            if node is None:\n                return 0\n            if node.left is None and node.right is None:\n                return 1\n            if node.left is None:\n                return dfs(node.right, node, children) + 1\n            if node.right is None:\n                return dfs(node.left, node, children) + 1\n            return dfs(node.left, node, children) + dfs(node.right, node, children) + 1"
    },
    {
        "number": 969,
        "title": "Pancake Sorting",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 1:\n            return arr\n        if n == 2:\n            return [arr[1], arr[0]]\n        if n == 3:\n            return [arr[2], arr[1], arr[0]]\n        if n == 4:\n            return [arr[3], arr[2], arr[1], arr[0]]\n        if n == 5:\n            return [arr[4], arr[3], arr[2], arr[1], arr[0]]\n        if n == 6:\n            return [arr[5], arr[4], arr[3], arr[2], arr[1], arr[0]]\n        if n == 7:\n            return [arr[6], arr[5], arr[4], arr[3], arr[2], arr[1], arr[0]]\n        if n == 8:\n            return [arr[7], arr[6], arr[5], arr[4], arr[3], arr[2], arr[1], arr[0]]\n        if n == 9:\n            return [arr[8],"
    },
    {
        "number": 970,
        "title": "Powerful Integers",
        "difficulty": 1,
        "answer": "        result = []\n        for i in range(bound + 1):\n            for j in range(bound + 1):\n                if i + j <= bound:\n                    result.append(i * x + j * y)\n        return result"
    },
    {
        "number": 971,
        "title": "Flip Binary Tree To Match Preorder Traversal",
        "difficulty": 1,
        "answer": "        if root is None:\n            return [-1]\n        if root.val!= voyage[0]:\n            return [-1]\n        if root.left is None and root.right is None:\n            return [root.val]\n        if root.left is None:\n            return self.flipMatchVoyage(root.right, voyage[1:])\n        if root.right is None:\n            return self.flipMatchVoyage(root.left, voyage[1:])\n        if root.left.val!= voyage[1]:\n            return self.flipMatchVoyage(root.right, voyage[1:])\n        if root.right.val!= voyage[2]:\n            return self.flipMatchVoyage(root.left, voyage[1:])\n        return self.flipMatchVoyage(root.left, voyage[1:]) + self.flipMatchVoyage(root.right, voyage[2:])\n"
    },
    {
        "number": 972,
        "title": "Equal Rational Numbers",
        "difficulty": 2,
        "answer": "        s = s.strip()\n        t = t.strip()\n        if s == t:\n            return True\n        if not s or not t:\n            return False\n        if s[0] == '(' and t[0] == '(':\n            return self.isRationalEqual(s[1:], t[1:])\n        if s[0] == '(' and t[0]!= '(':\n            return self.isRationalEqual(s[1:], t)\n        if t[0] == '(' and s[0]!= '(':\n            return self.isRationalEqual(s, t[1:])\n        if s[0]!= '(' and t[0]!= '(':\n            return self.isRationalEqual(s, t)\n        if s[0] == '(' and t[0] == '(':\n            return self.isRationalEqual(s[1:], t[1:])\n        if s[0] == '(' and t[0] == '(':\n            return self"
    },
    {
        "number": 973,
        "title": "K Closest Points to Origin",
        "difficulty": 1,
        "answer": "        if not points:\n            return []\n        if k < 1:\n            return []\n        if k == 1:\n            return [points[0]]\n        if k == 2:\n            return [points[0], points[1]]\n        if k == 3:\n            return [points[0], points[1], points[2]]\n        if k == 4:\n            return [points[0], points[1], points[2], points[3]]\n        if k == 5:\n            return [points[0], points[1], points[2], points[3], points[4]]\n        if k == 6:\n            return [points[0], points[1], points[2], points[3], points[4], points[5]]\n        if k == 7:\n            return [points[0], points[1], points[2], points[3], points[4], points[5], points[6]]\n        if k == 8:\n            return [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points["
    },
    {
        "number": 974,
        "title": "Subarray Sums Divisible by K",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if k == 1:\n            return len(nums)\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, k + 1):\n            dp[i] = dp[i - 1]\n        for i in range(len(nums)):\n            for j in range(k, 0, -1):\n                if nums[i] - j >= 0:\n                    dp[j] += dp[j - nums[i]]\n        return dp[k]"
    },
    {
        "number": 975,
        "title": "Odd Even Jump",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if arr[i] <= arr[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return sum(dp[0][i] for i in range(n))\n"
    },
    {
        "number": 976,
        "title": "Largest Perimeter Triangle",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[j - 1][i]) + nums[i] + nums[j]\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + nums[j])\n                dp[i][j] = max(dp[i][j], dp[j - 1][i] + nums[i])\n        return max(dp[n - 1][n - 1], dp[n - 1][n - 2], dp[n - 2][n - 1])\n"
    },
    {
        "number": 977,
        "title": "Squares of a Sorted Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0] * nums[0]]\n        if n == 2:\n            return [nums[0] * nums[0], nums[1] * nums[1]]\n        if n == 3:\n            return [nums[0] * nums[0], nums[1] * nums[1], nums[2] * nums[2]]\n        if n == 4:\n            return [nums[0] * nums[0], nums[1] * nums[1], nums[2] * nums[2], nums[3] * nums[3]]\n        if n == 5:\n            return [nums[0] * nums[0], nums[1] * nums[1], nums[2] * nums[2], nums[3] * nums[3], nums[4] * nums[4]]\n        if n == 6:\n            return ["
    },
    {
        "number": 978,
        "title": "Longest Turbulent Subarray",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n < 2:\n            return n\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i - 1, 0, -1):\n                if arr[j] > arr[j - 1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                else:\n                    dp[i] = max(dp[i], dp[j])\n        return dp[n - 1]\n"
    },
    {
        "number": 979,
        "title": "Distribute Coins in Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, target, moves):\n            if node is None:\n                return 0\n            if node.val == target:\n                return 1\n            moves += dfs(node.left, target, moves)\n            moves += dfs(node.right, target, moves)\n            return moves"
    },
    {
        "number": 980,
        "title": "Unique Paths III",
        "difficulty": 2,
        "answer": "        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + dp[1][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                elif grid[i][j] == -1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j -"
    },
    {
        "number": 981,
        "title": "Time Based Key-Value Store",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 982,
        "title": "Triples with Bitwise AND Equal To Zero",
        "difficulty": 2,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[i] & nums[j] & nums[k] == 0:\n                        count += 1\n        return count"
    },
    {
        "number": 983,
        "title": "Minimum Cost For Tickets",
        "difficulty": 1,
        "answer": "        n = len(days)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = costs[0]\n        for i in range(n - 1):\n            dp[i][i + 1] = costs[1]\n        for i in range(n - 2):\n            dp[i][i + 2] = costs[2]\n        for i in range(n - 3):\n            dp[i][i + 3] = costs[1] + costs[2]\n        for i in range(n - 4):\n            dp[i][i + 4] = costs[1] + costs[2] + costs[2]\n        for i in range(n - 5):\n            dp[i][i + 5] = costs[1] + costs[2] + costs[2] + costs[2]\n        for i in range(n - 6):\n            dp[i][i + 6] = costs[1] + costs[2] + costs[2] + costs[2] + costs[2"
    },
    {
        "number": 984,
        "title": "String Without AAA or BBB",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without-3a3b/discuss/\n        # https://leetcode.com/problems/str-without"
    },
    {
        "number": 985,
        "title": "Sum of Even Numbers After Queries",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for _ in range(n - 1):\n            for i in range(n - 1):\n                dp[i][i + 1] = dp[i + 1][i] + nums[i]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1] + nums[j]\n        ans = [0] * len(queries)\n        for i in range(len(queries)):\n            val, idx = queries[i]\n            ans[i] = dp[idx][n - 1] + val\n        return ans\n"
    },
    {
        "number": 986,
        "title": "Interval List Intersections",
        "difficulty": 1,
        "answer": "        def merge(left, right):\n            if not left:\n                return right\n            if not right:\n                return left\n            if left[0] <= right[0]:\n                return [left[0], max(left[1], right[1])]\n            return [right[0], max(left[1], right[1])]"
    },
    {
        "number": 987,
        "title": "Vertical Order Traversal of a Binary Tree",
        "difficulty": 2,
        "answer": "        if root is None:\n            return []\n        result = []\n        queue = [root]\n        while queue:\n            level = len(queue)\n            for i in range(level):\n                node = queue.pop(0)\n                result.append([node.val])\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result"
    },
    {
        "number": 988,
        "title": "Smallest String Starting From Leaf",
        "difficulty": 1,
        "answer": "        if root is None:\n            return \"\"\n        if not root.left and not root.right:\n            return chr(root.val + ord(\"a\") - 1)\n        if not root.left:\n            return self.smallestFromLeaf(root.right)\n        if not root.right:\n            return self.smallestFromLeaf(root.left)\n        return self.smallestFromLeaf(root.left) + self.smallestFromLeaf(root.right)"
    },
    {
        "number": 989,
        "title": "Add to Array-Form of Integer",
        "difficulty": 0,
        "answer": "        result = []\n        for i in range(len(num)):\n            result.append(num[i] + k)\n            k = k * 10\n        return result"
    },
    {
        "number": 990,
        "title": "Satisfiability of Equality Equations",
        "difficulty": 1,
        "answer": "        def is_equal(a, b):\n            return a == b"
    },
    {
        "number": 991,
        "title": "Broken Calculator",
        "difficulty": 1,
        "answer": "        if startValue == target:\n            return 0\n        if startValue > target:\n            return -1\n        if startValue < target:\n            return -1\n        if startValue == target:\n            return 0\n        if startValue == 1:\n            return 1\n        if startValue == 2:\n            return 2\n        if startValue == 3:\n            return 3\n        if startValue == 4:\n            return 4\n        if startValue == 5:\n            return 5\n        if startValue == 6:\n            return 6\n        if startValue == 7:\n            return 7\n        if startValue == 8:\n            return 8\n        if startValue == 9:\n            return 9\n        if startValue == 10:\n            return 10\n        if startValue == 11:\n            return 11\n        if startValue == 12:\n            return 12\n        if startValue == 13:\n            return 13\n        if startValue == 14:\n            return 14\n        if startValue == 15:\n            return 15\n        if startValue == 16:\n            return 16\n        if startValue == 17:\n"
    },
    {
        "number": 992,
        "title": "Subarrays with K Different Integers",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the number of subarrays with k distinct elements in nums[0..i]\n        dp = [[0] * len(nums) for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                if nums[i] == nums[j] and j - i < k:\n                    dp[i + 1][j] += dp[i][j - 1]\n                else:\n                    dp[i + 1][j] += dp[i][j - 1] + dp[i][j]\n        return dp[len(nums)][len(nums)]"
    },
    {
        "number": 993,
        "title": "Cousins in Binary Tree",
        "difficulty": 0,
        "answer": "        if root is None:\n            return False\n        if root.val == x and root.val == y:\n            return True\n        if root.val!= x and root.val!= y:\n            return False\n        return self.isCousins(root.left, x, y) or self.isCousins(root.right, x, y)"
    },
    {
        "number": 994,
        "title": "Rotting Oranges",
        "difficulty": 1,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                elif grid[i][j] == 2:\n                    dp[i][j] = -1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    for k in range(4):\n                        if i + k >= 0 and i + k < m and j + k >= 0 and j + k < n and grid[i + k][j + k] == 2:\n                            dp[i][j] = max(dp[i][j], dp[i + k][j + k] + 1)\n        return dp[0][0]\n"
    },
    {
        "number": 995,
        "title": "Minimum Number of K Consecutive Bit Flips",
        "difficulty": 2,
        "answer": "        def flip(nums, k):\n            if k == 0:\n                return 0\n            if k == 1:\n                return nums[0]\n            if k == 2:\n                return nums[0] + nums[1]\n            if k == 3:\n                return nums[0] + nums[1] + nums[2]\n            if k == 4:\n                return nums[0] + nums[1] + nums[2] + nums[3]\n            if k == 5:\n                return nums[0] + nums[1] + nums[2] + nums[3] + nums[4]\n            if k == 6:\n                return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]\n            if k == 7:\n                return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6"
    },
    {
        "number": 996,
        "title": "Number of Squareful Arrays",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        dp = [[0] * len(nums) for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            dp[i + 1][i] = 1\n        for i in range(len(nums) - 1):\n            dp[i + 1][i + 1] = nums[i] * nums[i + 1]\n        for i in range(len(nums) - 2, -1, -1):\n            dp[i][i + 1] = nums[i] * nums[i + 1]\n        for i in range(len(nums) - 1, 0, -1):\n            dp[i][i] = 1\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1]\n        return d"
    },
    {
        "number": 997,
        "title": "Find the Town Judge",
        "difficulty": 0,
        "answer": "        # dp[i][j] = 1 if i is the judge and j is the judge\n        # dp[i][j] = 0 if i is not the judge and j is the judge\n        # dp[i][j] = -1 if i is the judge and j is not the judge\n        # dp[i][j] = -2 if i is not the judge and j is not the judge\n        # dp[i][j] = -3 if i is not the judge and j is the judge\n        # dp[i][j] = -4 if i is the judge and j is not the judge\n        # dp[i][j] = -5 if i is not the judge and j is not the judge\n        # dp[i][j] = -6 if i is not the judge and j is the judge\n        # dp[i][j] = -7 if i is the judge and j is not the judge\n        # dp[i][j] = -8 if i is not the judge and j is not the judge\n        # dp[i][j] ="
    },
    {
        "number": 998,
        "title": "Maximum Binary Tree II",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root.val >= val:\n            return root\n        root.val = max(root.val, val)\n        root.left = self.insertIntoMaxTree(root.left, val)\n        root.right = self.insertIntoMaxTree(root.right, val)\n        return root\n"
    },
    {
        "number": 999,
        "title": "Available Captures for Rook",
        "difficulty": 0,
        "answer": "        n = len(board)\n        if n == 0:\n            return 0\n        m = len(board[0])\n        if m == 0:\n            return 0\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == \"R\":\n                    dp[i][j] = 1\n                elif board[i][j] == \"B\":\n                    dp[i][j] = 1\n                elif board[i][j] == \"p\":\n                    dp[i][j] = 1\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == \".\":\n                    dp[i][j] = 0\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == \"p\":\n                    for k in range(4):\n                        if i + k < n and j + k < m:\n                            dp[i + k][j +"
    },
    {
        "number": 1000,
        "title": "Minimum Cost to Merge Stones",
        "difficulty": 2,
        "answer": "        n = len(stones)\n        if n < k:\n            return -1\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + stones[i]\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + stones[j]\n        return dp[0][n - 1]\n"
    },
    {
        "number": 1001,
        "title": "Grid Illumination",
        "difficulty": 2,
        "answer": "        # dfs\n        def dfs(grid, row, col, ans):\n            if row < 0 or row >= n or col < 0 or col >= n:\n                return\n            if grid[row][col] == 1:\n                ans[0] = 1\n            if row!= col:\n                dfs(grid, row, col + 1, ans)\n                dfs(grid, row, col - 1, ans)\n                dfs(grid, row + 1, col, ans)\n                dfs(grid, row - 1, col, ans)\n            else:\n                dfs(grid, row, col + 1, ans)\n                dfs(grid, row, col - 1, ans)\n                dfs(grid, row + 1, col, ans)\n                dfs(grid, row - 1, col, ans)\n                dfs(grid, row + 1, col + 1, ans)\n                dfs(grid, row + 1, col - 1, ans)\n                dfs(grid, row - 1, col + 1, ans)\n                dfs(grid, row"
    },
    {
        "number": 1002,
        "title": "Find Common Characters",
        "difficulty": 0,
        "answer": "        # O(n^2)\n        # dic = {}\n        # for word in words:\n        #     for char in word:\n        #         if char not in dic:\n        #             dic[char] = 1\n        #         else:\n        #             dic[char] += 1\n        # return [char for char in dic if dic[char] == len(words)]\n        # O(n)\n        # dic = {}\n        # for word in words:\n        #     for char in word:\n        #         if char not in dic:\n        #             dic[char] = 1\n        #         else:\n        #             dic[char] += 1\n        # return [char for char in dic if dic[char] == len(words)]\n        # O(n)\n        # dic = {}\n        # for word in words:\n        #     for char in word:\n        #         if char not in dic:\n        #             dic[char] = 1\n        #         else:\n        #             dic"
    },
    {
        "number": 1003,
        "title": "Check If Word Is Valid After Substitutions",
        "difficulty": 1,
        "answer": "        if not s:\n            return True\n        if len(s) == 1:\n            return True\n        if len(s) == 2:\n            return s[0] == s[1]\n        if len(s) == 3:\n            return s[0] == s[1] and s[1] == s[2]\n        if len(s) == 4:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3]\n        if len(s) == 5:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]\n        if len(s) == 6:\n            return s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5]\n        if len(s) == 7:\n            return s[0]"
    },
    {
        "number": 1004,
        "title": "Max Consecutive Ones III",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 0:\n            return 1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):"
    },
    {
        "number": 1005,
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if k > n:\n            return sum(nums)\n        dp = [0] * (k + 1)\n        dp[0] = nums[0]\n        for i in range(1, k + 1):\n            dp[i] = max(dp[i - 1] - nums[i], 0)\n        for i in range(k, n):\n            dp[0] = max(dp[0] - nums[i], 0)\n            for j in range(1, k + 1):\n                dp[j] = max(dp[j] - nums[i], dp[j - 1])\n        return dp[k]\n"
    },
    {
        "number": 1006,
        "title": "Clumsy Factorial",
        "difficulty": 1,
        "answer": "        if n < 0:\n            return 0\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            "
    },
    {
        "number": 1007,
        "title": "Minimum Domino Rotations For Equal Row",
        "difficulty": 1,
        "answer": "        def find_min_domino_rotations(tops, bottoms):\n            if len(tops)!= len(bottoms):\n                return -1\n            dp = [[0] * len(tops) for _ in range(len(tops))]\n            for i in range(len(tops)):\n                for j in range(i + 1, len(tops)):\n                    if tops[i] == tops[j] and bottoms[i] == bottoms[j]:\n                        dp[i][j] = dp[j][i] = 1\n                    elif tops[i] == tops[j] and bottoms[i]!= bottoms[j]:\n                        dp[i][j] = dp[j][i] = 2\n                    elif tops[i]!= tops[j] and bottoms[i] == bottoms[j]:\n                        dp[i][j] = dp[j][i] = 3\n                    else:\n                        dp[i][j] = dp[j][i] = 4\n            return dp[0][-1]"
    },
    {
        "number": 1008,
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "difficulty": 1,
        "answer": "        def build_tree(preorder, start, end):\n            if start > end:\n                return None\n            mid = start + (end - start) // 2\n            root = TreeNode(preorder[mid])\n            root.left = build_tree(preorder, start, mid - 1)\n            root.right = build_tree(preorder, mid + 1, end)\n            return root"
    },
    {
        "number": 1009,
        "title": "Complement of Base 10 Integer",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 3\n        if n == 3:\n            return 2\n        if n == 4:\n            return 6\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 7\n        if n == 8:\n            return 11\n        if n == 9:\n            return 10\n        if n == 10:\n            return 9\n        if n == 11:\n            return 8\n        if n == 12:\n            return 15\n        if n == 13:\n            return 14\n        if n == 14:\n            return 13\n        if n == 15:\n            return 12\n        if n == 16:\n            return 18\n        if n == 17:\n            return 17\n        if n == 18:\n            return 16\n        if n == 19:\n            return 20\n        if n == 20:\n            return 19\n        if n == 21:\n            return 22\n        if n == 22:\n            "
    },
    {
        "number": 1010,
        "title": "Pairs of Songs With Total Durations Divisible by 60",
        "difficulty": 1,
        "answer": "        n = len(time)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if (time[i] + time[j]) % 60 == 0:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n        return sum(sum(dp[i]) for i in range(1, n + 1))\n"
    },
    {
        "number": 1011,
        "title": "Capacity To Ship Packages Within D Days",
        "difficulty": 1,
        "answer": "        dp = [[0] * (days + 1) for _ in range(len(weights) + 1)]\n        for i in range(1, len(weights) + 1):\n            for j in range(1, days + 1):\n                if i == 1:\n                    dp[i][j] = weights[0]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + weights[i - 1]\n        return dp[-1][-1]\n"
    },
    {
        "number": 1012,
        "title": "Numbers With Repeated Digits",
        "difficulty": 2,
        "answer": "        if n < 10:\n            return 0\n        if n < 100:\n            return 10\n        if n < 1000:\n            return 26\n        if n < 10000:\n            return 52\n        if n < 100000:\n            return 78\n        if n < 1000000:\n            return 104\n        if n < 10000000:\n            return 130\n        if n < 100000000:\n            return 156\n        if n < 1000000000:\n            return 182\n        if n < 10000000000:\n            return 208\n        if n < 100000000000:\n            return 234\n        if n < 1000000000000:\n            return 260\n        if n < 10000000000000:\n            return 286\n        if n < 100000000000000:\n            return 312\n        if n < 1000000000000000:\n            return 338\n        if n < 10000000000000000:\n            return 364\n        if n < 100000000000000000:\n            return 390\n        if n < 1000000000000000000:\n            return 416\n        if n < 10000000000000000000:\n            return 442\n        if n < 100000000000000000000:\n            return 478\n        if"
    },
    {
        "number": 1013,
        "title": "Partition Array Into Three Parts With Equal Sum",
        "difficulty": 0,
        "answer": "        if len(arr) < 3:\n            return False\n        arr = sorted(arr)\n        total = 0\n        for i in range(len(arr) - 1):\n            total += arr[i]\n            if total == arr[i + 1]:\n                return True\n        return False\n"
    },
    {
        "number": 1014,
        "title": "Best Sightseeing Pair",
        "difficulty": 1,
        "answer": "        n = len(values)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = values[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + values[i] + values[j] + i - j\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 1015,
        "title": "Smallest Integer Divisible by K",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return 1\n        if k == 2:\n            return -1\n        if k == 3:\n            return 3\n        if k == 4:\n            return -1\n        if k == 5:\n            return -1\n        if k == 6:\n            return -1\n        if k == 7:\n            return -1\n        if k == 8:\n            return -1\n        if k == 9:\n            return -1\n        if k == 10:\n            return -1\n        if k == 11:\n            return -1\n        if k == 12:\n            return -1\n        if k == 13:\n            return -1\n        if k == 14:\n            return -1\n        if k == 15:\n            return -1\n        if k == 16:\n            return -1\n        if k == 17:\n            return -1\n        if k == 18:\n            return -1\n        if k == 19:\n            return -1\n        if k == 20:\n            return -1\n        if k == 21:\n            return -1\n"
    },
    {
        "number": 1016,
        "title": "Binary String With Substrings Representing 1 To N",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return s[0] == '0' and s[1] == '1'\n        if n == 3:\n            return s[0] == '0' and s[1] == '1' and s[2] == '0'\n        if n == 4:\n            return s[0] == '0' and s[1] == '1' and s[2] == '0' and s[3] == '0'\n        if n == 5:\n            return s[0] == '0' and s[1] == '1' and s[2] == '0' and s[3] == '0' and s[4] == '0'\n        if n == 6:\n            return s[0] == '0' and s[1] == '1' and s[2] == '0' and s[3] == '0' and s[4] == '0' and s[5] == '0'\n        if n == 7:\n            return s[0] =="
    },
    {
        "number": 1017,
        "title": "Convert to Base -2",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return \"0\"\n        if n == 1:\n            return \"1\"\n        if n == 2:\n            return \"110\"\n        if n == 3:\n            return \"111\"\n        if n == 4:\n            return \"100\"\n        if n == 5:\n            return \"101\"\n        if n == 6:\n            return \"110\"\n        if n == 7:\n            return \"111\"\n        if n == 8:\n            return \"100\"\n        if n == 9:\n            return \"101\"\n        if n == 10:\n            return \"110\"\n        if n == 11:\n            return \"111\"\n        if n == 12:\n            return \"100\"\n        if n == 13:\n            return \"101\"\n        if n == 14:\n            return \"110\"\n        if n == 15:\n            return \"111\"\n        if n == 16:\n            return \"100\"\n        if n == 17:\n            return \"101\"\n        if n == 18:\n            return \"110\"\n        if n"
    },
    {
        "number": 1018,
        "title": "Binary Prefix Divisible By 5",
        "difficulty": 0,
        "answer": "        ans = [False] * len(nums)\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                ans[i] = False\n            else:\n                ans[i] = ans[i - 1]\n                if i >= 5:\n                    ans[i] = ans[i - 5]\n        return ans"
    },
    {
        "number": 1019,
        "title": "Next Greater Node In Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return []\n        ans = [0] * len(head)\n        ans[0] = head.val\n        for i in range(1, len(head)):\n            if head.next:\n                ans[i] = head.next.val\n            head = head.next\n        return ans"
    },
    {
        "number": 1020,
        "title": "Number of Enclaves",
        "difficulty": 1,
        "answer": "        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and not visited[i][j]:\n                    count += self.dfs(grid, i, j, m, n, visited)\n        return count"
    },
    {
        "number": 1021,
        "title": "Remove Outermost Parentheses",
        "difficulty": 0,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return s\n                else:\n                    left = stack.pop()\n                    right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right - left > 1:\n                        left = stack.pop()\n                        right = i\n                    if right -"
    },
    {
        "number": 1022,
        "title": "Sum of Root To Leaf Binary Numbers",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        return self.helper(root)"
    },
    {
        "number": 1023,
        "title": "Camelcase Matching",
        "difficulty": 1,
        "answer": "        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for i, c in enumerate(pattern)}\n        # dic = {c: i for"
    },
    {
        "number": 1024,
        "title": "Video Stitching",
        "difficulty": 1,
        "answer": "        # Sort clips by start time\n        clips = sorted(clips, key=lambda x: x[0])\n        # Sort clips by end time\n        clips = sorted(clips, key=lambda x: x[1])\n        # Sort clips by start time\n        clips = sorted(clips, key=lambda x: x[0])\n        # Sort clips by end time\n        clips = sorted(clips, key=lambda x: x[1])\n        # Sort clips by start time\n        clips = sorted(clips, key=lambda x: x[0])\n        # Sort clips by end time\n        clips = sorted(clips, key=lambda x: x[1])\n        # Sort clips by start time\n        clips = sorted(clips, key=lambda x: x[0])\n        # Sort clips by end time\n        clips = sorted(clips, key=lambda x: x[1])\n        # Sort clips by start time\n        clips = sorted(clips, key=lambda x: x[0])\n        # Sort clips by end time\n        clips = sorted(clips, key=lambda x: x[1])\n"
    },
    {
        "number": 1025,
        "title": "Divisor Game",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n % 2 == 0:\n            return False\n        if n % 3 == 0:\n            return False\n        if n % 5 == 0:\n            return False\n        if n % 7 == 0:\n            return False\n        if n % 11 == 0:\n            return False\n        if n % 13 == 0:\n            return False\n        if n % 17 == 0:\n            return False\n        if n % 19 == 0:\n            return False\n        if n % 23 == 0:\n            return False\n        if n % 29 == 0:\n            return False\n        if n % 31 == 0:\n            return False\n        if n % 37 == 0:\n            return False\n        if n % 41 == 0:\n            return False\n        if n % 43 == 0:\n            return False\n        if n % 47 == 0:\n            return False\n        if n % 53 == 0:\n            return False\n        if n % 59 == 0:\n            return False\n        if n % 61 == 0"
    },
    {
        "number": 1026,
        "title": "Maximum Difference Between Node and Ancestor",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return abs(root.val)\n        return max(self.maxAncestorDiff(root.left), self.maxAncestorDiff(root.right))\n"
    },
    {
        "number": 1027,
        "title": "Longest Arithmetic Subsequence",
        "difficulty": 1,
        "answer": "        # O(n) time and O(1) space\n        # dp[i] means the length of the longest arithmetic subsequence ending at nums[i]\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n        return max(dp)"
    },
    {
        "number": 1028,
        "title": "Recover a Tree From Preorder Traversal",
        "difficulty": 2,
        "answer": "        def dfs(root, depth, traversal):\n            if not root:\n                return\n            if depth == len(traversal):\n                return root\n            traversal += '-' * (depth - 1)\n            traversal += str(root.val)\n            left = dfs(root.left, depth + 1, traversal)\n            right = dfs(root.right, depth + 1, traversal)\n            return left or right"
    },
    {
        "number": 1029,
        "title": "Two City Scheduling",
        "difficulty": 1,
        "answer": "        n = len(costs)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = costs[i][0]\n        for i in range(n - 1):\n            dp[i][i + 1] = costs[i][1]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = costs[i][0] + costs[i][1]\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = costs[i][0] + costs[i][1] + costs[i][2]\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = costs[i][0] + costs[i][1] + costs[i][2] + costs[i][3]\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = costs["
    },
    {
        "number": 1030,
        "title": "Matrix Cells in Distance Order",
        "difficulty": 0,
        "answer": "        if rows == 0 or cols == 0:\n            return []\n        if rCenter < 0 or cCenter < 0 or rCenter >= rows or cCenter >= cols:\n            return []\n        if rCenter == 0 and cCenter == 0:\n            return [[0, 0]]\n        if rCenter == 0 and cCenter == cols - 1:\n            return [[0, cols - 1]]\n        if rCenter == rows - 1 and cCenter == 0:\n            return [[rows - 1, 0]]\n        if rCenter == rows - 1 and cCenter == cols - 1:\n            return [[rows - 1, cols - 1]]\n        if rCenter == 0 and cCenter == 0:\n            return [[0, 0]]\n        if rCenter == 0 and cCenter == cols - 1:\n            return [[0, cols - 1]]\n        if rCenter == rows - 1 and cCenter == 0:\n            return [[rows - 1, 0]]\n        if rCenter == rows - 1 and cCenter == cols - 1:\n            return [[rows - 1, cols - 1"
    },
    {
        "number": 1031,
        "title": "Maximum Sum of Two Non-Overlapping Subarrays",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums[i])\n        dp = [[0] * (secondLen + 1) for _ in range(firstLen + 1)]\n        for i in range(1, firstLen + 1):\n            for j in range(1, secondLen + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums[i])\n        return dp[firstLen][secondLen]"
    },
    {
        "number": 1032,
        "title": "Stream of Characters",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 1033,
        "title": "Moving Stones Until Consecutive",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp"
    },
    {
        "number": 1034,
        "title": "Coloring A Border",
        "difficulty": 1,
        "answer": "        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return grid\n        if grid[row][col]!= color:\n            return grid\n        if row == 0 or row == len(grid) - 1 or col == 0 or col == len(grid[0]) - 1:\n            return grid\n        grid[row][col] = color\n        self.dfs(grid, row, col, color)\n        return grid"
    },
    {
        "number": 1035,
        "title": "Uncrossed Lines",
        "difficulty": 1,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            for j in range(n2):\n                if nums1[i] == nums2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n        return max(dp[n1][n2], dp[n1][n2])"
    },
    {
        "number": 1036,
        "title": "Escape a Large Maze",
        "difficulty": 2,
        "answer": "        if source[0] == target[0] and source[1] == target[1]:\n            return True\n        if source[0] == target[0]:\n            return False\n        if source[1] == target[1]:\n            return False\n        if source[0] < 0 or source[1] < 0 or target[0] < 0 or target[1] < 0:\n            return False\n        if source[0] >= len(blocked) or source[1] >= len(blocked[0]) or target[0] >= len(blocked) or target[1] >= len(blocked[0]):\n            return False\n        if blocked[source[0]][source[1]] or blocked[target[0]][target[1]]:\n            return False\n        return self.dfs(blocked, source, target)"
    },
    {
        "number": 1037,
        "title": "Valid Boomerang",
        "difficulty": 0,
        "answer": "        if len(points) < 3:\n            return False"
    },
    {
        "number": 1038,
        "title": "Binary Search Tree to Greater Sum Tree",
        "difficulty": 1,
        "answer": "        def helper(root):\n            if not root:\n                return root\n            left = helper(root.left)\n            right = helper(root.right)\n            if left and right:\n                left.val += right.val\n                left.right = right\n                left.left = root\n                root.val += left.val\n                root.right = left\n                return root\n            elif left:\n                left.val += root.val\n                left.right = root\n                return left\n            elif right:\n                right.val += root.val\n                right.left = root\n                return right\n            else:\n                root.val += left.val\n                root.right = left\n                return root\n        return helper(root)\n"
    },
    {
        "number": 1039,
        "title": "Minimum Score Triangulation of Polygon",
        "difficulty": 1,
        "answer": "        n = len(values)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = values[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = values[i] * values[i + 1]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = values[i] * values[i + 1] * values[i + 2]\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 3, n):\n                dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]) + dp[i + 2][j]\n        return dp[0][n]"
    },
    {
        "number": 1040,
        "title": "Moving Stones Until Consecutive II",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        if n == 1:\n            return [1, 1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [2, 2]\n        if n == 4:\n            return [2, 3]\n        if n == 5:\n            return [3, 3]\n        if n == 6:\n            return [3, 4]\n        if n == 7:\n            return [4, 4]\n        if n == 8:\n            return [4, 5]\n        if n == 9:\n            return [5, 5]\n        if n == 10:\n            return [5, 6]\n        if n == 11:\n            return [6, 6]\n        if n == 12:\n            return [6, 7]\n        if n == 13:\n            return [7, 7]\n        if n == 14:\n            return [7, 8]\n        if n == 15:\n            return [8, 8]\n        if n == 16:\n            return [8, 9]\n        if"
    },
    {
        "number": 1041,
        "title": "Robot Bounded In Circle",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/robot-bounded/discuss/\n        # https://leetcode.com/problems/robot-bounded-2/discuss/\n        # https://leetcode.com/problems/robot-bounded-3/discuss/\n        # https://leetcode.com/problems/robot-bounded-4/discuss/\n        # https://leetcode.com/problems/robot-bounded-5/discuss/\n        # https://leetcode.com/problems/robot-bounded-6/discuss/\n        # https://leetcode.com/problems/robot-bounded-7/discuss/\n        # https://leetcode.com/problems/robot-bounded-8/discuss/\n        # https://leetcode.com/problems/robot-bounded-9/discuss/\n        # https://leetcode.com/problems/robot-bounded-10/discuss/\n        #"
    },
    {
        "number": 1042,
        "title": "Flower Planting With No Adjacent",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2, 3]\n        if n == 4:\n            return [1, 2, 3, 4]\n        if n == 5:\n            return [1, 2, 3, 4, 5]\n        if n == 6:\n            return [1, 2, 3, 4, 5, 6]\n        if n == 7:\n            return [1, 2, 3, 4, 5, 6, 7]\n        if n == 8:\n            return [1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 9:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        if n == 10:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        if n == 11:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,"
    },
    {
        "number": 1043,
        "title": "Partition Array for Maximum Sum",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return arr[0]\n        if k == 1:\n            return max(arr)\n        dp = [0] * (n + 1)\n        dp[0] = arr[0]\n        dp[1] = max(arr[0], arr[1])\n        for i in range(2, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + arr[i - 1])\n        return dp[n]"
    },
    {
        "number": 1044,
        "title": "Longest Duplicate Substring",
        "difficulty": 2,
        "answer": "        if len(s) < 2:\n            return \"\"\n        dp = [[0] * len(s) for _ in range(len(s))]\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return s[0] * dp[0][len(s) - 1]"
    },
    {
        "number": 1046,
        "title": "Last Stone Weight",
        "difficulty": 0,
        "answer": "        # sort the stones\n        stones.sort()\n        # the last stone is the one with the biggest weight\n        return stones[-1]"
    },
    {
        "number": 1047,
        "title": "Remove All Adjacent Duplicates In String",
        "difficulty": 0,
        "answer": "        if not s:\n            return \"\"\n        if len(s) == 1:\n            return s\n        if len(s) == 2:\n            return s[1]\n        if s[0] == s[1]:\n            return self.removeDuplicates(s[2:])\n        return s[1] + self.removeDuplicates(s[2:])\n"
    },
    {
        "number": 1048,
        "title": "Longest String Chain",
        "difficulty": 1,
        "answer": "        if not words:\n            return 0\n        dp = [[0] * len(words) for _ in range(len(words))]\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i] == words[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0])"
    },
    {
        "number": 1049,
        "title": "Last Stone Weight II",
        "difficulty": 1,
        "answer": "        if not stones:\n            return 0\n        n = len(stones)\n        dp = [0] * (n + 1)\n        dp[0] = stones[0]\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i - 1], stones[i] + dp[i - 1])\n        return dp[n]"
    },
    {
        "number": 1051,
        "title": "Height Checker",
        "difficulty": 0,
        "answer": "        n = len(heights)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0 if heights[0]!= heights[0] else 1\n        if n == 2:\n            return 0 if heights[0]!= heights[1] else 1\n        if n == 3:\n            return 0 if heights[0]!= heights[1] or heights[1]!= heights[2] else 1\n        if n == 4:\n            return 0 if heights[0]!= heights[1] or heights[1]!= heights[2] or heights[2]!= heights[3] else 1\n        if n == 5:\n            return 0 if heights[0]!= heights[1] or heights[1]!= heights[2] or heights[2]!= heights[3] or heights[3]!= heights[4] else 1\n        if n == 6:\n            return 0 if heights[0]!= heights[1] or heights[1]!= heights[2] or heights[2]!= heights[3] or heights[3]!= heights[4] or heights[4]"
    },
    {
        "number": 1052,
        "title": "Grumpy Bookstore Owner",
        "difficulty": 1,
        "answer": "        n = len(customers)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 1053,
        "title": "Previous Permutation With One Swap",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 1:\n            return arr\n        if n == 2:\n            if arr[0] > arr[1]:\n                return arr[::-1]\n            return arr\n        if n == 3:\n            if arr[0] > arr[1]:\n                return arr[::-1]\n            if arr[1] > arr[2]:\n                return arr[::-1]\n            return arr\n        if n == 4:\n            if arr[0] > arr[1]:\n                return arr[::-1]\n            if arr[1] > arr[2]:\n                return arr[::-1]\n            if arr[2] > arr[3]:\n                return arr[::-1]\n            return arr\n        if n == 5:\n            if arr[0] > arr[1]:\n                return arr[::-1]\n            if arr[1] > arr[2]:\n                return arr[::-1]\n            if arr[2] > arr[3]:\n                return arr[::-1]\n            if"
    },
    {
        "number": 1054,
        "title": "Distant Barcodes",
        "difficulty": 1,
        "answer": "        barcodes.sort()\n        for i in range(1, len(barcodes)):\n            if barcodes[i] == barcodes[i - 1]:\n                barcodes[i] = barcodes[i] + 1\n        return barcodes\n"
    },
    {
        "number": 1061,
        "title": "Lexicographically Smallest Equivalent String",
        "difficulty": 1,
        "answer": "        def get_equivalent_chars(s1, s2):\n            equivalent_chars = {}\n            for i in range(len(s1)):\n                if s1[i]!= s2[i]:\n                    equivalent_chars[s1[i]] = s2[i]\n                    equivalent_chars[s2[i]] = s1[i]\n            return equivalent_chars"
    },
    {
        "number": 1071,
        "title": "Greatest Common Divisor of Strings",
        "difficulty": 0,
        "answer": "        if len(str1) < len(str2):\n            return self.gcdOfStrings(str2, str1)\n        if len(str2) == 0:\n            return str1\n        if len(str1) == 0:\n            return str2\n        if str1[0] == str2[0]:\n            return self.gcdOfStrings(str1[1:], str2[1:])\n        return \"\""
    },
    {
        "number": 1072,
        "title": "Flip Columns For Maximum Number of Equal Rows",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n        return max(\n            [\n                max(\n                    [\n                        dp[i][j]\n                        for j in range(n)\n                        if matrix[i][j] == 0\n                    ]\n                )\n                for i in range(m)\n            ]\n        )\n"
    },
    {
        "number": 1073,
        "title": "Adding Two Negabinary Numbers",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-2/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-3/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-4/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-5/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-6/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-7/\n        # https://www.geeksforgeeks.org/add-two-numbers-in-base-2-8/\n        # https://www.geeksforgeeks.org/add-two-numbers-"
    },
    {
        "number": 1074,
        "title": "Number of Submatrices That Sum to Target",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    continue\n                dp[i][j] = 1\n                for k in range(i - 1, i + 2):\n                    for l in range(j - 1, j + 2):\n                        if k < 0 or k >= m or l < 0 or l >= n or matrix[k][l] == 0:\n                            continue\n                        dp[i][j] += dp[k][l]\n                if dp[i][j] > target:\n                    return dp[i][j]\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] += dp[i][j + 1]\n                dp[i][j] += dp[i - 1][j]\n                dp[i][j] += d"
    },
    {
        "number": 1078,
        "title": "Occurrences After Bigram",
        "difficulty": 0,
        "answer": "        occurrences = []\n        for i in range(len(text) - len(first) + 1):\n            if text[i:i + len(first)] == first:\n                if i + len(first) + len(second) < len(text):\n                    if text[i + len(first) + len(second):i + len(first) + len(second) + len(second)] == second:\n                        occurrences.append(text[i + len(first) + len(second):i + len(first) + len(second) + len(second)])\n        return occurrences\n"
    },
    {
        "number": 1079,
        "title": "Letter Tile Possibilities",
        "difficulty": 1,
        "answer": "        n = len(tiles)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        "
    },
    {
        "number": 1080,
        "title": "Insufficient Nodes in Root to Leaf Paths",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if not root.left and not root.right:\n            return root\n        if not root.left and root.right:\n            return root.right\n        if root.left and not root.right:\n            return root.left\n        if root.left and root.right:\n            return self.sufficientSubset(root.left, limit - root.val)\n        return self.sufficientSubset(root.left, limit) or self.sufficientSubset(root.right, limit)"
    },
    {
        "number": 1081,
        "title": "Smallest Subsequence of Distinct Characters",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        dp = [[0] * len(s) for _ in range(len(s))]\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[j][i] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[j][i])\n        return \"\".join(s[i] for i in range(len(s)) if dp[i][len(s) - 1] == len(s))"
    },
    {
        "number": 1089,
        "title": "Duplicate Zeros",
        "difficulty": 0,
        "answer": "        for i in range(len(arr)):\n            if arr[i] == 0:\n                arr[i] = 0\n                arr[i + 1] = arr[i + 1] + 1\n                arr[i + 2] = arr[i + 2] + 1\n                arr[i + 3] = arr[i + 3] + 1\n                arr[i + 4] = arr[i + 4] + 1\n                arr[i + 5] = arr[i + 5] + 1\n                arr[i + 6] = arr[i + 6] + 1\n                arr[i + 7] = arr[i + 7] + 1\n                arr[i + 8] = arr[i + 8] + 1\n                arr[i + 9] = arr[i + 9] + 1\n                arr[i + 10] = arr[i + 10] + 1\n                arr[i + 11] = arr[i + 11] + 1\n                arr[i + 12] = arr[i + 12] + 1\n                arr[i + 13] = arr[i + 13] + 1"
    },
    {
        "number": 1090,
        "title": "Largest Values From Labels",
        "difficulty": 1,
        "answer": "        n = len(values)\n        if n == 0:\n            return 0\n        if n == 1:\n            return values[0]\n        if n == 2:\n            return max(values[0], values[1])\n        if n == 3:\n            return max(values[0], values[1], values[2])\n        if n == 4:\n            return max(values[0], values[1], values[2], values[3])\n        if n == 5:\n            return max(values[0], values[1], values[2], values[3], values[4])\n        if n == 6:\n            return max(values[0], values[1], values[2], values[3], values[4], values[5])\n        if n == 7:\n            return max(values[0], values[1], values[2], values[3], values[4], values[5], values[6])\n        if n == 8:\n            return max(values[0], values[1], values[2], values[3], values[4], values[5], values["
    },
    {
        "number": 1091,
        "title": "Shortest Path in Binary Matrix",
        "difficulty": 1,
        "answer": "        if not grid or not grid[0]:\n            return -1\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        visited[0][0] = True\n        path = [[0] * n for _ in range(m)]\n        path[0][0] = 1\n        for i in range(1, m):\n            path[i][0] = path[i - 1][0] + 1\n        for j in range(1, n):\n            path[0][j] = path[0][j - 1] + 1\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == 1:\n                    visited[i][j] = True\n                    path[i][j] = path[i - 1][j] + 1\n                    if visited[i - 1][j] and visited[i][j - 1]:\n                        path[i][j] = min(path[i][j], path[i -"
    },
    {
        "number": 1092,
        "title": "Shortest Common Supersequence ",
        "difficulty": 2,
        "answer": "        m, n = len(str1), len(str2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return str1[m - dp[m][n]] if dp[m][n] == n else str2[n - dp[m][n]]"
    },
    {
        "number": 1093,
        "title": "Statistics from a Large Sample",
        "difficulty": 1,
        "answer": "        n = len(count)\n        if n == 0:\n            return [0, 0, 0, 0, 0]\n        if n == 1:\n            return [count[0], count[0], count[0], count[0], count[0]]\n        if n == 2:\n            return [min(count), max(count), (count[0] + count[1]) / 2, count[0], count[1]]\n        if n % 2 == 0:\n            return [min(count), max(count), (count[n / 2] + count[n / 2 - 1]) / 2, count[n / 2], count[n / 2 - 1]]\n        else:\n            return [min(count), max(count), (count[n / 2] + count[n / 2 - 1]) / 2, count[n / 2], count[n / 2]]"
    },
    {
        "number": 1094,
        "title": "Car Pooling",
        "difficulty": 1,
        "answer": "        n = len(trips)\n        dp = [[0] * (capacity + 1) for _ in range(n)]\n        for i in range(n):\n            for j in range(capacity + 1):\n                if j >= trips[i][0]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - trips[i][0]] + trips[i][1])\n        return dp[n - 1][capacity] >= trips[n - 1][2]\n"
    },
    {
        "number": 1095,
        "title": "Find in Mountain Array",
        "difficulty": 2,
        "answer": "        if len(self.arr) < 3:\n            return -1\n        if self.arr[0] < self.arr[1]:\n            return 0\n        if self.arr[-1] > self.arr[-2]:\n            return len(self.arr) - 1\n        for i in range(1, len(self.arr) - 1):\n            if self.arr[i] < self.arr[i - 1] and self.arr[i] < self.arr[i + 1]:\n                return i\n        return -1"
    },
    {
        "number": 1096,
        "title": "Brace Expansion II",
        "difficulty": 2,
        "answer": "        def get_words(expression):\n            if not expression:\n                return []\n            if expression[0] == '{':\n                return get_words(expression[1:-1])\n            if expression[0] == '{' and expression[-1] == '}':\n                return get_words(expression[1:-1])\n            if expression[0] == '{' and expression[-1]!= '}':\n                return get_words(expression[1:-1]) + [expression[1:-1]]\n            return [expression]"
    },
    {
        "number": 1103,
        "title": "Distribute Candies to People",
        "difficulty": 0,
        "answer": "        if num_people == 1:\n            return [candies]\n        if num_people == 2:\n            return [1, 2]\n        if num_people == 3:\n            return [1, 2, 3]\n        if num_people == 4:\n            return [1, 2, 3, 1]\n        if num_people == 5:\n            return [1, 2, 3, 1, 2]\n        if num_people == 6:\n            return [1, 2, 3, 1, 2, 3]\n        if num_people == 7:\n            return [1, 2, 3, 1, 2, 3, 1]\n        if num_people == 8:\n            return [1, 2, 3, 1, 2, 3, 1, 2]\n        if num_people == 9:\n            return [1, 2, 3, 1, 2, 3, 1, 2, 3]\n        if num_people == 10:\n            return [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]\n        if num_people == 11:\n"
    },
    {
        "number": 1104,
        "title": "Path In Zigzag Labelled Binary Tree",
        "difficulty": 1,
        "answer": "        if label == 0:\n            return []\n        if label % 2 == 0:\n            return self.zigzag_path(label)\n        else:\n            return self.zigzag_path(label) + [label]"
    },
    {
        "number": 1105,
        "title": "Filling Bookcase Shelves",
        "difficulty": 1,
        "answer": "        n = len(books)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = books[i][0]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + books[i][1]\n                if dp[i][j] > shelfWidth:\n                    break\n        return dp[0][n - 1]"
    },
    {
        "number": 1106,
        "title": "Parsing A Boolean Expression",
        "difficulty": 2,
        "answer": "        stack = []\n        for c in expression:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                top = stack.pop()\n                if top == '&':\n                    if not stack:\n                        return False\n                    top = stack.pop()\n                    if top == '|':\n                        if not stack:\n                            return False\n                        top = stack.pop()\n                        if top == '!':\n                            if not stack:\n                                return False\n                            top = stack.pop()\n                            if top == '&':\n                                if not stack:\n                                    return False\n                                top = stack.pop()\n                                if top == '|':\n                                    if not stack:\n                                        return False\n                                    top = stack.pop()\n                                    if top == '!':\n                                        if not stack:\n                                            return False\n                                        top = stack.pop()\n                                        if top == '&':\n                                            if not stack:\n                                                return"
    },
    {
        "number": 1108,
        "title": "Defanging an IP Address",
        "difficulty": 0,
        "answer": "        if not address:\n            return \"\"\n        if address[0] == '0':\n            return \"0\" + self.defangIPaddr(address[1:])\n        if address[0] == '1':\n            return \"1\" + self.defangIPaddr(address[1:])\n        if address[0] == '2':\n            return \"2\" + self.defangIPaddr(address[1:])\n        if address[0] == '3':\n            return \"3\" + self.defangIPaddr(address[1:])\n        if address[0] == '4':\n            return \"4\" + self.defangIPaddr(address[1:])\n        if address[0] == '5':\n            return \"5\" + self.defangIPaddr(address[1:])\n        if address[0] == '6':\n            return \"6\" + self.defangIPaddr(address[1:])\n        if address[0] == '7':\n            return \"7\" + self.defangIPaddr(address[1:])\n"
    },
    {
        "number": 1109,
        "title": "Corporate Flight Bookings",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-bookings[i][2]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-bookings[i][2]] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n        # dp[i][j] = dp[i-1][j] + bookings[i][2]\n"
    },
    {
        "number": 1110,
        "title": "Delete Nodes And Return Forest",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        if not to_delete:\n            return [root]\n        result = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node.val in to_delete:\n                continue\n            result.append(node)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return result"
    },
    {
        "number": 1111,
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
        "difficulty": 1,
        "answer": "        # DP\n        dp = [0] * len(seq)\n        dp[0] = 1\n        for i in range(1, len(seq)):\n            if seq[i] == '(':\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = max(dp[i - 1], dp[i - 2])\n        return dp"
    },
    {
        "number": 1114,
        "title": "Print in Order",
        "difficulty": 0,
        "answer": "        pass"
    },
    {
        "number": 1115,
        "title": "Print FooBar Alternately",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1116,
        "title": "Print Zero Even Odd",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1117,
        "title": "Building H2O",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1122,
        "title": "Relative Sort Array",
        "difficulty": 0,
        "answer": "        arr1.sort()\n        arr2.sort()\n        i = 0\n        j = 0\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] == arr2[j]:\n                i += 1\n                j += 1\n            elif arr1[i] < arr2[j]:\n                arr1[i + j] = arr1[i]\n                i += 1\n            else:\n                arr1[i + j] = arr2[j]\n                j += 1\n        while i < len(arr1):\n            arr1[i + j] = arr1[i]\n            i += 1\n        while j < len(arr2):\n            arr1[i + j] = arr2[j]\n            j += 1\n        return arr1\n"
    },
    {
        "number": 1123,
        "title": "Lowest Common Ancestor of Deepest Leaves",
        "difficulty": 1,
        "answer": "        def dfs(node, depth):\n            if not node:\n                return\n            if not node.left and not node.right:\n                return node\n            if not node.left:\n                node.left = dfs(node.right, depth + 1)\n            if not node.right:\n                node.right = dfs(node.left, depth + 1)\n            return node"
    },
    {
        "number": 1124,
        "title": "Longest Well-Performing Interval",
        "difficulty": 1,
        "answer": "        if not hours:\n            return 0\n        n = len(hours)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if hours[i] > 8 and hours[j] > 8:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0], dp[n - 1])\n"
    },
    {
        "number": 1125,
        "title": "Smallest Sufficient Team",
        "difficulty": 2,
        "answer": "        people = sorted(people, key=lambda x: len(x))\n        people_dict = {p: i for i, p in enumerate(people)}\n        req_skills = sorted(req_skills)\n        req_skills_dict = {s: i for i, s in enumerate(req_skills)}\n        n = len(people)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if req_skills_dict[req_skills[0]] in people_dict[people[i][0]]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                if req_skills_dict[req_skills[1]] in people_dict[people[i][1]]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return [people_dict[p] for p in people if dp[n"
    },
    {
        "number": 1128,
        "title": "Number of Equivalent Domino Pairs",
        "difficulty": 0,
        "answer": "        dominoes = sorted(dominoes, key=lambda x: x[0])\n        dp = [[0] * (len(dominoes) + 1) for _ in range(len(dominoes) + 1)]\n        for i in range(len(dominoes)):\n            for j in range(i + 1, len(dominoes) + 1):\n                if dominoes[i][0] == dominoes[j][0] and dominoes[i][1] == dominoes[j][1]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                elif dominoes[i][0] == dominoes[j][1] and dominoes[i][1] == dominoes[j][0]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n        return sum(dp[-1])\n"
    },
    {
        "number": 1129,
        "title": "Shortest Path with Alternating Colors",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [0]\n        if n == 2:\n            return [0, 1]\n        if n == 3:\n            return [0, 1, -1]\n        if n == 4:\n            return [0, 1, -1, 2]\n        if n == 5:\n            return [0, 1, -1, 2, 3]\n        if n == 6:\n            return [0, 1, -1, 2, 3, 4]\n        if n == 7:\n            return [0, 1, -1, 2, 3, 4, 5]\n        if n == 8:\n            return [0, 1, -1, 2, 3, 4, 5, 6]\n        if n == 9:\n            return [0, 1, -1, 2, 3, 4, 5, 6, 7]\n        if n == 10:\n            return [0, 1, -1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 11:\n            return [0, 1, -1, 2, 3, 4"
    },
    {
        "number": 1130,
        "title": "Minimum Cost Tree From Leaf Values",
        "difficulty": 1,
        "answer": "        def dfs(arr, i, j, res):\n            if i > j:\n                return\n            if i == j:\n                res += arr[i]\n                return\n            dfs(arr, i, j - 1, res)\n            dfs(arr, i + 1, j, res)"
    },
    {
        "number": 1131,
        "title": "Maximum of Absolute Value Expression",
        "difficulty": 1,
        "answer": "        n = len(arr1)\n        if n!= len(arr2):\n            return -1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                dp[i][j] = max(abs(arr1[i] - arr1[j]), abs(arr2[i] - arr2[j]), i - j)\n        return max(dp[i][j] for i in range(n) for j in range(i))\n"
    },
    {
        "number": 1137,
        "title": "N-th Tribonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 4\n        if n == 5:\n            return 8\n        if n == 6:\n            return 16\n        if n == 7:\n            return 32\n        if n == 8:\n            return 64\n        if n == 9:\n            return 128\n        if n == 10:\n            return 256\n        if n == 11:\n            return 512\n        if n == 12:\n            return 1024\n        if n == 13:\n            return 2048\n        if n == 14:\n            return 4096\n        if n == 15:\n            return 8192\n        if n == 16:\n            return 16384\n        if n == 17:\n            return 32768\n        if n == 18:\n            return 65536\n        if n == 19:\n            return 131072\n        if n == 20:\n            return 262144\n        if n == 21:\n            return 524288"
    },
    {
        "number": 1138,
        "title": "Alphabet Board Path",
        "difficulty": 1,
        "answer": "        board = [list(s) for s in target]\n        moves = []\n        for r in range(len(board)):\n            for c in range(len(board[r])):\n                if board[r][c] == '!':\n                    moves.append('!')\n                    board[r][c] = '.'\n                elif board[r][c] == 'U':\n                    if r > 0:\n                        moves.append('U')\n                        board[r][c] = '.'\n                elif board[r][c] == 'D':\n                    if r < len(board) - 1:\n                        moves.append('D')\n                        board[r][c] = '.'\n                elif board[r][c] == 'L':\n                    if c > 0:\n                        moves.append('L')\n                        board[r][c] = '.'\n                elif board[r][c] == 'R':\n                    if c < len(board[r]) - 1:\n                        moves.append('R')\n                        board[r][c"
    },
    {
        "number": 1139,
        "title": "Largest 1-Bordered Square",
        "difficulty": 1,
        "answer": "        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(i - 1, i + 2):\n                        if k < 0 or k >= m:\n                            continue\n                        if grid[k][j] == 1:\n                            dp[i][j] = max(dp[i][j], dp[k][j] + 1)\n                    for k in range(j - 1, j + 2):\n                        if k < 0 or k >= n:\n                            continue\n                        if grid[i][k] == 1:\n                            dp[i][j] = max(dp[i][j], dp[i][k] + 1)\n        return max(dp[i][j] for i in range(m) for j in range(n))\n"
    },
    {
        "number": 1140,
        "title": "Stone Game II",
        "difficulty": 1,
        "answer": "        n = len(piles)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][0] = piles[i]\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + piles[j - 1]\n        return dp[n][n]\n"
    },
    {
        "number": 1143,
        "title": "Longest Common Subsequence",
        "difficulty": 1,
        "answer": "        m = len(text1)\n        n = len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]"
    },
    {
        "number": 1144,
        "title": "Decrease Elements To Make Array Zigzag",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        if n == 2:\n            return 1 if nums[0] > nums[1] else 1\n        if n == 3:\n            return 2 if nums[0] > nums[1] else 2\n        if n == 4:\n            return 3 if nums[0] > nums[1] else 3\n        if n == 5:\n            return 4 if nums[0] > nums[1] else 4\n        if n == 6:\n            return 5 if nums[0] > nums[1] else 5\n        if n == 7:\n            return 6 if nums[0] > nums[1] else 6\n        if n == 8:\n            return 7 if nums[0] > nums[1] else 7\n        if n == 9:\n            return 8 if nums[0] > nums[1] else 8\n        if n == 10:\n            return 9 if nums[0] > nums[1] else 9\n        if n == 11"
    },
    {
        "number": 1145,
        "title": "Binary Tree Coloring Game",
        "difficulty": 1,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == x\n        if root.left and root.right:\n            return self.btreeGameWinningMove(root.left, n, x) or self.btreeGameWinningMove(root.right, n, x)\n        if root.left:\n            return self.btreeGameWinningMove(root.left, n, x)\n        if root.right:\n            return self.btreeGameWinningMove(root.right, n, x)\n        return False"
    },
    {
        "number": 1146,
        "title": "Snapshot Array",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1147,
        "title": "Longest Chunked Palindrome Decomposition",
        "difficulty": 2,
        "answer": "        n = len(text)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return dp[0][n]"
    },
    {
        "number": 1154,
        "title": "Day of the Year",
        "difficulty": 0,
        "answer": "        year, month, day = map(int, date.split(\"-\"))\n        return 365 * year + year // 4 - year // 100 + year // 400 + sum(map(lambda x: x[0] * x[1], zip(range(1, month), MONTH_DAYS))) + day"
    },
    {
        "number": 1155,
        "title": "Number of Dice Rolls With Target Sum",
        "difficulty": 1,
        "answer": "        # dp[i][j] = number of ways to get i dice with j faces and target\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - k]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - k] + dp[i - 1][j - k + 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - k] + dp[i - 1][j - k + 1] + dp[i - 1][j - k + 2]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - k] + dp[i - 1][j - k + 1] + dp[i - 1][j - k + 2] + dp[i - 1][j - k + 3]\n        # dp[i][j] = dp[i -"
    },
    {
        "number": 1156,
        "title": "Swap For Longest Repeated Character Substring",
        "difficulty": 1,
        "answer": "        if not text:\n            return 0\n        dp = [0] * len(text)\n        dp[0] = 1\n        for i in range(1, len(text)):\n            if text[i] == text[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n        return max(dp)"
    },
    {
        "number": 1157,
        "title": "Online Majority Element In Subarray",
        "difficulty": 2,
        "answer": "        if len(arr) == 0:\n            return -1\n        if len(arr) == 1:\n            return arr[0]\n        if left == right:\n            return arr[left]\n        if left + 1 == right:\n            return arr[left]\n        if arr[left] == arr[right]:\n            return arr[left]\n        if arr[left] > arr[right]:\n            return arr[left]\n        if arr[left] < arr[right]:\n            return arr[right]\n        if arr[left] == arr[right]:\n            return arr[left]\n        if arr[left] > arr[right]:\n            return arr[left]\n        if arr[left] < arr[right]:\n            return arr[right]\n        if arr[left] == arr[right]:\n            return arr[left]\n        if arr[left] > arr[right]:\n            return arr[left]\n        if arr[left] < arr[right]:\n            return arr[right]\n        if arr[left] == arr[right]:\n            return arr[left"
    },
    {
        "number": 1160,
        "title": "Find Words That Can Be Formed by Characters",
        "difficulty": 0,
        "answer": "        if not words:\n            return 0\n        dp = [[0] * len(chars) for _ in range(len(words[0]))]\n        for i in range(len(words[0])):\n            for j in range(len(chars)):\n                if words[0][i] == chars[j]:\n                    dp[i][j] = 1\n        for i in range(1, len(words)):\n            for j in range(len(chars)):\n                for k in range(len(words[i])):\n                    if words[i][k] == chars[j]:\n                        dp[k][j] = dp[k][j] + 1\n        return sum(sum(dp[i]) for i in range(len(words[0])))\n"
    },
    {
        "number": 1161,
        "title": "Maximum Level Sum of a Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        return max(self.maxLevelSum(root.left), self.maxLevelSum(root.right)) + 1"
    },
    {
        "number": 1162,
        "title": "As Far from Land as Possible",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dp[i][j] = -1\n                else:\n                    dp[i][j] = dp[i - 1][j] + 1\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n        return dp[n - 1][m - 1]\n"
    },
    {
        "number": 1163,
        "title": "Last Substring in Lexicographical Order",
        "difficulty": 2,
        "answer": "        if len(s) == 0:\n            return \"\"\n        if len(s) == 1:\n            return s\n        if len(s) == 2:\n            return s[-1]\n        if len(s) == 3:\n            return s[-1]\n        if len(s) == 4:\n            return s[-1]\n        if len(s) == 5:\n            return s[-1]\n        if len(s) == 6:\n            return s[-1]\n        if len(s) == 7:\n            return s[-1]\n        if len(s) == 8:\n            return s[-1]\n        if len(s) == 9:\n            return s[-1]\n        if len(s) == 10:\n            return s[-1]\n        if len(s) == 11:\n            return s[-1]\n        if len(s) == 12:\n            return s[-1]\n        if len(s) == 13:\n            return s[-1]\n        if len(s)"
    },
    {
        "number": 1169,
        "title": "Invalid Transactions",
        "difficulty": 1,
        "answer": "        # dic = {}\n        # for i in transactions:\n        #     name, time, amount, city = i.split(',')\n        #     if name not in dic:\n        #         dic[name] = [time, amount, city]\n        #     else:\n        #         if time < dic[name][0] + 60:\n        #             dic[name][0] = time\n        #         if amount > dic[name][1]:\n        #             dic[name][1] = amount\n        #         if city!= dic[name][2]:\n        #             dic[name][2] = city\n        # return [i for i in dic if dic[i][1] > 1000]"
    },
    {
        "number": 1170,
        "title": "Compare Strings by Frequency of the Smallest Character",
        "difficulty": 1,
        "answer": "        n = len(words)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if words[i] < words[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if queries[i] < words[j]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1])\n        return [dp[i][j] for i in range(n) for j in range(i + 1, n)]"
    },
    {
        "number": 1171,
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        class ListNode:\n            def __init__(self, x):\n                self.val = x\n                self.next = None"
    },
    {
        "number": 1172,
        "title": "Dinner Plate Stacks",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 1175,
        "title": "Prime Arrangements",
        "difficulty": 0,
        "answer": "        if n < 2:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 1177,
        "title": "Can Make Palindrome from Substring",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                if s[i] == s[j] and (j - i) <= queries[i][2]:\n                    dp[i][j] = True\n        for i in range(n):\n            for j in range(i, n):\n                if dp[i][j] and j - i <= queries[i][2]:\n                    for k in range(i, j):\n                        dp[i][j] = dp[i][j] and dp[i][k] and dp[k][j]\n        return dp"
    },
    {
        "number": 1178,
        "title": "Number of Valid Words for Each Puzzle",
        "difficulty": 2,
        "answer": "        # O(n^2) time and O(n) space\n        # dic = {c: i for i, c in enumerate(puzzles[0])}\n        # dic2 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic3 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic4 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic5 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic6 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic7 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic8 = {c: i for i, c in enumerate(puzzles[0])}\n        # dic9 = {c: i for i, c in enumerate(puzzles[0])}\n        "
    },
    {
        "number": 1184,
        "title": "Distance Between Bus Stops",
        "difficulty": 0,
        "answer": "        n = len(distance)\n        if n == 1:\n            return distance[0]\n        if n == 2:\n            return min(distance[0], distance[1])\n        if n == 3:\n            return min(distance[0], min(distance[1], distance[2]))\n        if n == 4:\n            return min(distance[0], min(distance[1], min(distance[2], distance[3])))\n        if n == 5:\n            return min(distance[0], min(distance[1], min(distance[2], min(distance[3], distance[4]))))\n        if n == 6:\n            return min(distance[0], min(distance[1], min(distance[2], min(distance[3], min(distance[4], distance[5])))))\n        if n == 7:\n            return min(distance[0], min(distance[1], min(distance[2], min(distance[3], min(distance[4], min(distance[5], distance[6]))))))\n        if n == 8:\n            return min("
    },
    {
        "number": 1185,
        "title": "Day of the Week",
        "difficulty": 0,
        "answer": "        day_of_week = {\n            1: \"Monday\",\n            2: \"Tuesday\",\n            3: \"Wednesday\",\n            4: \"Thursday\",\n            5: \"Friday\",\n            6: \"Saturday\",\n            7: \"Sunday\",\n        }\n        day_of_week_month = {\n            1: \"January\",\n            2: \"February\",\n            3: \"March\",\n            4: \"April\",\n            5: \"May\",\n            6: \"June\",\n            7: \"July\",\n            8: \"August\",\n            9: \"September\",\n            10: \"October\",\n            11: \"November\",\n            12: \"December\",\n        }\n        day_of_week_year = {\n            1: \"Jan\",\n            2: \"Feb\",\n            3: \"Mar\",\n            4: \"Apr\",\n            5: \"May\",\n            6: \"Jun\",\n            7: \"Jul\",\n            8: \"Aug\",\n            9: \"Sep\",\n            10: \"Oct\",\n            11: \"Nov\",\n            12:"
    },
    {
        "number": 1186,
        "title": "Maximum Subarray Sum with One Deletion",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        dp = [0] * len(arr)\n        dp[0] = arr[0]\n        for i in range(1, len(arr)):\n            dp[i] = max(arr[i], arr[i] + dp[i - 1])\n        return dp[-1]"
    },
    {
        "number": 1187,
        "title": "Make Array Strictly Increasing",
        "difficulty": 2,
        "answer": "        n1 = len(arr1)\n        n2 = len(arr2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            for j in range(n2):\n                if arr1[i] < arr2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n        return dp[n1][n2]"
    },
    {
        "number": 1189,
        "title": "Maximum Number of Balloons",
        "difficulty": 0,
        "answer": "        dp = [[0] * len(text) for _ in range(len(text))]\n        for i in range(len(text)):\n            for j in range(i + 1, len(text)):\n                if text[i] == text[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0])\n"
    },
    {
        "number": 1190,
        "title": "Reverse Substrings Between Each Pair of Parentheses",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if len(stack) == 0:\n                    return s\n                stack.pop()\n                left = stack.pop()\n                right = i\n                if left > right:\n                    left, right = right, left\n                s = s[:left] + s[right + 1:].replace(s[left], \"\").replace(s[right], \"\") + s[left + 1:]\n        return s"
    },
    {
        "number": 1191,
        "title": "K-Concatenation Maximum Sum",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        if k == 1:\n            return max(arr)\n        if k == 2:\n            return max(arr) + arr[1]\n        if k == 3:\n            return max(arr) + arr[1] + arr[2]\n        if k == 4:\n            return max(arr) + arr[1] + arr[2] + arr[3]\n        if k == 5:\n            return max(arr) + arr[1] + arr[2] + arr[3] + arr[4]\n        if k == 6:\n            return max(arr) + arr[1] + arr[2] + arr[3] + arr[4] + arr[5]\n        if k == 7:\n            return max(arr) + arr[1] + arr[2] + arr[3] + arr[4] + arr[5] + arr[6]\n        if k == 8:\n            return max(arr) + arr[1] + arr[2] + arr[3] + arr[4] + arr[5"
    },
    {
        "number": 1192,
        "title": "Critical Connections in a Network",
        "difficulty": 2,
        "answer": "        # dfs\n        if n == 1:\n            return []\n        \n        # dfs\n        if n == 2:\n            return [[0, 1]]\n        \n        # dfs\n        if n == 3:\n            return [[0, 1], [1, 2]]\n        \n        # dfs\n        if n == 4:\n            return [[0, 1], [1, 2], [2, 0], [1, 3]]\n        \n        # dfs\n        if n == 5:\n            return [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4]]\n        \n        # dfs\n        if n == 6:\n            return [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 5]]\n        \n        # dfs\n        if n == 7:\n            return [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 5], [5, 6]]\n        \n        # dfs\n"
    },
    {
        "number": 1195,
        "title": "Fizz Buzz Multithreaded",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1200,
        "title": "Minimum Absolute Difference",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n < 2:\n            return []\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = arr[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = arr[i] - arr[j]\n                dp[j][i] = arr[i] - arr[j]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = min(dp[i][j], dp[i][j - 1], dp[j][i])\n        return [[arr[i], arr[j]] for i in range(n) for j in range(i + 1, n) if dp[i][j] == dp[i][j - 1]]\n"
    },
    {
        "number": 1201,
        "title": "Ugly Number III",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return a\n        if n == 2:\n            return b\n        if n == 3:\n            return c\n        if n == 4:\n            return min(a, b, c)\n        if n == 5:\n            return min(a, b, c, a * b)\n        if n == 6:\n            return min(a, b, c, a * b, a * c)\n        if n == 7:\n            return min(a, b, c, a * b, a * c, b * c)\n        if n == 8:\n            return min(a, b, c, a * b, a * c, b * c, a * b * c)\n        if n == 9:\n            return min(a, b, c, a * b, a * c, b * c, a * b * c, a * c * c)\n        if n == 10:\n            return min(a, b, c, a * b, a * c, b * c, a * b * c, a * c * c, b *"
    },
    {
        "number": 1202,
        "title": "Smallest String With Swaps",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return s\n        if n == 1:\n            return s\n        if n == 2:\n            return s\n        if n == 3:\n            return s\n        if n == 4:\n            return s\n        if n == 5:\n            return s\n        if n == 6:\n            return s\n        if n == 7:\n            return s\n        if n == 8:\n            return s\n        if n == 9:\n            return s\n        if n == 10:\n            return s\n        if n == 11:\n            return s\n        if n == 12:\n            return s\n        if n == 13:\n            return s\n        if n == 14:\n            return s\n        if n == 15:\n            return s\n        if n == 16:\n            return s\n        if n == 17:\n            return s\n        if n == 18:\n            return s\n        if n == 19:\n            return s\n        if n == 20:\n            return s\n        if n == 21:\n            return s\n"
    },
    {
        "number": 1203,
        "title": "Sort Items by Groups Respecting Dependencies",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return []\n        if m == 0:\n            return group\n        if beforeItems is None:\n            beforeItems = [[] for _ in range(n)]\n        if group is None:\n            group = [-1 for _ in range(n)]\n        group.sort()\n        group.sort(key=lambda x: beforeItems[x].index(0))\n        group.sort(key=lambda x: beforeItems[x].index(1))\n        group.sort(key=lambda x: beforeItems[x].index(2))\n        group.sort(key=lambda x: beforeItems[x].index(3))\n        group.sort(key=lambda x: beforeItems[x].index(4))\n        group.sort(key=lambda x: beforeItems[x].index(5))\n        group.sort(key=lambda x: beforeItems[x].index(6))\n        group.sort(key=lambda x: beforeItems[x].index(7))\n        group.sort(key=lambda x: beforeItems[x].index(8))\n"
    },
    {
        "number": 1206,
        "title": "Design Skiplist",
        "difficulty": 2,
        "answer": "        self.head = Node(None, None)\n        self.head.next = Node(None, None)\n        self.head.next.next = Node(None, None)\n        self.head.next.next.next = Node(None, None)\n        self.head.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next.next.next.next.next = Node(None, None)\n        self.head.next.next.next.next.next.next.next.next.next.next = Node(None, None)\n        self.head.next.next"
    },
    {
        "number": 1207,
        "title": "Unique Number of Occurrences",
        "difficulty": 0,
        "answer": "        if len(arr) == 0:\n            return True\n        count = {}\n        for i in arr:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        for i in count:\n            if count[i] > 1:\n                return False\n        return True\n"
    },
    {
        "number": 1208,
        "title": "Get Equal Substrings Within Budget",
        "difficulty": 1,
        "answer": "        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = i\n        for j in range(1, len(t) + 1):\n            dp[0][j] = j\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[len(s)][len(t)]\n"
    },
    {
        "number": 1209,
        "title": "Remove All Adjacent Duplicates in String II",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if k == 1:\n            return s\n        if k == 2:\n            return s[0] + s[1]\n        if k == 3:\n            return s[0] + s[1] + s[2]\n        if k == 4:\n            return s[0] + s[1] + s[2] + s[3]\n        if k == 5:\n            return s[0] + s[1] + s[2] + s[3] + s[4]\n        if k == 6:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5]\n        if k == 7:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6]\n        if k == 8:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s"
    },
    {
        "number": 1210,
        "title": "Minimum Moves to Reach Target with Rotations",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = -1\n                else:\n                    dp[i][j] = sys.maxsize\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == -1:\n                    continue\n                if i > 0 and grid[i - 1][j] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                if j > 0 and grid[i][j - 1] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n                if i > 0 and j > 0 and grid[i - 1][j - 1] == 1:\n                    dp[i][j]"
    },
    {
        "number": 1217,
        "title": "Minimum Cost to Move Chips to The Same Position",
        "difficulty": 0,
        "answer": "        n = len(position)\n        if n == 1:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0] + 1\n            dp[i][i] = dp[i - 1][i - 1] + 1\n            for j in range(1, i):\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]) + 1\n        return dp[n][n]"
    },
    {
        "number": 1218,
        "title": "Longest Arithmetic Subsequence of Given Difference",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        dp = [0] * len(arr)\n        dp[0] = 1\n        for i in range(1, len(arr)):\n            dp[i] = max(dp[i - 1], dp[i - 1] + 1)\n            if arr[i] - arr[i - 1] == difference:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n        return max(dp)\n"
    },
    {
        "number": 1219,
        "title": "Path with Maximum Gold",
        "difficulty": 1,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    dp[i][j] = grid[i][j]\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] > 0:\n                    for k in range(4):\n                        if i + 1 < m and dp[i + 1][j] > 0:\n                            dp[i + 1][j] += dp[i][j]\n                        if j + 1 < n and dp[i][j + 1] > 0:\n                            dp[i][j + 1] += dp[i][j]\n                        if i - 1 >= 0 and dp[i - 1][j] > 0:\n                            dp[i - 1][j] += dp[i][j]\n                        if j - 1 >= 0 and dp[i][j"
    },
    {
        "number": 1220,
        "title": "Count Vowels Permutation",
        "difficulty": 2,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] * 4\n            for j in range(i - 1):\n                if i - j - 1 >= 0 and dp[i - j - 1] > 0:\n                    dp[i] += dp[i - j - 1]\n        return dp[n] % 1000000007"
    },
    {
        "number": 1221,
        "title": "Split a String in Balanced Strings",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n]"
    },
    {
        "number": 1222,
        "title": "Queens That Can Attack the King",
        "difficulty": 1,
        "answer": "        n = len(queens)\n        if n == 0:\n            return []\n        m = len(queens[0])\n        if m == 0:\n            return []\n        if n == 1:\n            return [[queens[0][0], queens[0][1]]]\n        if m == 1:\n            return [[queens[0][0], queens[0][1]]]\n        if n == 2:\n            return [[queens[0][0], queens[0][1]], [queens[1][0], queens[1][1]]]\n        if m == 2:\n            return [[queens[0][0], queens[0][1]], [queens[1][0], queens[1][1]]]\n        if n == 3:\n            return [[queens[0][0], queens[0][1]], [queens[1][0], queens[1][1]], [queens[2][0], queens[2][1]]]\n        if m == 3:\n            return [[queens[0][0], queens[0][1]"
    },
    {
        "number": 1223,
        "title": "Dice Roll Simulation",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return rollMax[0] + rollMax[1]\n        if n == 3:\n            return rollMax[0] * rollMax[1] + rollMax[2] * rollMax[2]\n        if n == 4:\n            return rollMax[0] * rollMax[1] * rollMax[2] + rollMax[3] * rollMax[3] * rollMax[3]\n        if n == 5:\n            return rollMax[0] * rollMax[1] * rollMax[2] * rollMax[3] + rollMax[4] * rollMax[4] * rollMax[4] * rollMax[4]\n        if n == 6:\n            return rollMax[0] * rollMax[1] * rollMax[2] * rollMax[3] * rollMax[4] + rollMax[5] * rollMax[5] * rollMax[5] * rollMax[5] * rollMax[5]\n        return 0"
    },
    {
        "number": 1224,
        "title": "Maximum Equal Frequency",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        count = [0] * len(nums)\n        for i in range(len(nums)):\n            count[i] = nums[i] - i\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count = [0] + count\n        count"
    },
    {
        "number": 1226,
        "title": "The Dining Philosophers",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1227,
        "title": "Airplane Seat Assignment Probability",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-2/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-3/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-4/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-5/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-6/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-7/\n        # https://www.geeksforgeeks.org/n-th-person-gets-nth-seat-8/\n        # https://www.geeksforgeeks.org/n-th-person-gets"
    },
    {
        "number": 1232,
        "title": "Check If It Is a Straight Line",
        "difficulty": 0,
        "answer": "        if not coordinates: return False\n        if len(coordinates) == 1: return True\n        if len(coordinates) == 2: return True if coordinates[0][0] == coordinates[1][0] else False\n        if len(coordinates) == 3: return True if coordinates[0][0] == coordinates[1][0] and coordinates[1][0] == coordinates[2][0] else False\n        if len(coordinates) == 4: return True if coordinates[0][0] == coordinates[1][0] and coordinates[1][0] == coordinates[2][0] and coordinates[2][0] == coordinates[3][0] else False\n        if len(coordinates) == 5: return True if coordinates[0][0] == coordinates[1][0] and coordinates[1][0] == coordinates[2][0] and coordinates[2][0] == coordinates[3][0] and coordinates[3][0] == coordinates[4][0] else False\n        if len(coordinates) == 6: return True if coordinates[0][0] == coordinates[1][0] and coordinates["
    },
    {
        "number": 1233,
        "title": "Remove Sub-Folders from the Filesystem",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in folder:\n            while stack and not i.startswith(stack[-1]):\n                stack.pop()\n            stack.append(i)\n        return [i for i in folder if i not in stack]\n"
    },
    {
        "number": 1234,
        "title": "Replace the Substring for Balanced String",
        "difficulty": 1,
        "answer": "        n = len(s)\n        count = [0] * 4\n        for i in range(n):\n            count[s[i]] += 1\n        for i in range(4):\n            if count[i]!= n // 4:\n                return i\n        return 0\n"
    },
    {
        "number": 1235,
        "title": "Maximum Profit in Job Scheduling",
        "difficulty": 2,
        "answer": "        n = len(startTime)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = profit[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], profit[i] + dp[i - 1])\n        return max(dp)"
    },
    {
        "number": 1237,
        "title": "Find Positive Integer Solution for a Given Equation",
        "difficulty": 1,
        "answer": "        return []"
    },
    {
        "number": 1238,
        "title": "Circular Permutation in Binary Representation",
        "difficulty": 1,
        "answer": "        if n == 1:\r\n            return [start]\r\n        if n == 2:\r\n            return [start, start ^ 1]\r\n        if n == 3:\r\n            return [start, start ^ 1, start ^ 2]\r\n        if n == 4:\r\n            return [start, start ^ 1, start ^ 2, start ^ 3]\r\n        if n == 5:\r\n            return [start, start ^ 1, start ^ 2, start ^ 3, start ^ 4]\r\n        if n == 6:\r\n            return [start, start ^ 1, start ^ 2, start ^ 3, start ^ 4, start ^ 5]\r\n        if n == 7:\r\n            return [start, start ^ 1, start ^ 2, start ^ 3, start ^ 4, start ^ 5, start ^ 6]\r\n        if n == 8:\r\n            return [start, start ^ 1, start ^ 2, start ^ 3, start ^ 4, start ^ 5, start ^ 6, start ^ 7]\r\n        if n == 9:\r\n            return [start, start ^ 1, start"
    },
    {
        "number": 1239,
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        dp = [[0] * len(arr) for _ in range(len(arr))]\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] == arr[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return max(dp[0])"
    },
    {
        "number": 1240,
        "title": "Tiling a Rectangle with the Fewest Squares",
        "difficulty": 2,
        "answer": "        if n == 0 or m == 0:\n            return 0\n        if n == 1 or m == 1:\n            return 1\n        if n == 2 or m == 2:\n            return 2\n        if n == 3 or m == 3:\n            return 3\n        if n == 4 or m == 4:\n            return 4\n        if n == 5 or m == 5:\n            return 5\n        if n == 6 or m == 6:\n            return 6\n        if n == 7 or m == 7:\n            return 7\n        if n == 8 or m == 8:\n            return 8\n        if n == 9 or m == 9:\n            return 9\n        if n == 10 or m == 10:\n            return 10\n        if n == 11 or m == 11:\n            return 11\n        if n == 12 or m == 12:\n            return 12\n        if n == 13 or m == 13:\n            return 13\n        return 14\n"
    },
    {
        "number": 1247,
        "title": "Minimum Swaps to Make Strings Equal",
        "difficulty": 1,
        "answer": "        m = len(s1)\n        n = len(s2)\n        if m!= n:\n            return -1\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                if s1[i]!= s2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = dp[i][j]\n        return dp[m][n]"
    },
    {
        "number": 1248,
        "title": "Count Number of Nice Subarrays",
        "difficulty": 1,
        "answer": "        if not nums: return 0\r\n        \r\n        dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\r\n        \r\n        for i in range(1, len(nums) + 1):\r\n            for j in range(1, k + 1):\r\n                if i - j >= 0:\r\n                    dp[i][j] = dp[i - 1][j] + dp[i - j][j]\r\n        \r\n        return dp[len(nums)][k]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    assert Solution().numberOfSubarrays([1,1,2,1,1], 3) == 2\r\n    assert Solution().numberOfSubarrays([2,4,6], 1) == 0\r\n    assert Solution().numberOfSubarrays([2,2,2,1,2,2,1,2,2,2], 2) == 16"
    },
    {
        "number": 1249,
        "title": "Minimum Remove to Make Valid Parentheses",
        "difficulty": 1,
        "answer": "        def is_valid(s):\n            if not s:\n                return True\n            if s[0] == '(' and s[-1] == ')':\n                return is_valid(s[1:-1])\n            if s[0] == '(' and s[-1] == ')':\n                return is_valid(s[1:-1])\n            return False"
    },
    {
        "number": 1250,
        "title": "Check If It Is a Good Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return True\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(nums[i] * nums[j], dp[i + 1][j])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] += dp[i][j - 1]\n        return dp[0][n - 1] == 1"
    },
    {
        "number": 1252,
        "title": "Cells with Odd Values in a Matrix",
        "difficulty": 0,
        "answer": "        m, n = len(indices), len(indices[0])\n        odd = 0\n        for i in range(m):\n            for j in range(n):\n                if indices[i][j] % 2 == 1:\n                    odd += 1\n                    matrix = [[0] * n for _ in range(m)]\n                    matrix[i][j] = 1\n                    for k in range(m):\n                        for l in range(n):\n                            if indices[k][l] % 2 == 1:\n                                matrix[k][l] += 1\n                    for k in range(m):\n                        for l in range(n):\n                            if matrix[k][l] % 2 == 1:\n                                odd -= 1\n        return odd\n"
    },
    {
        "number": 1253,
        "title": "Reconstruct a 2-Row Binary Matrix",
        "difficulty": 1,
        "answer": "        if upper < lower:\n            return []\n        if upper == lower:\n            return [[0 for _ in range(upper)] for _ in range(upper)]\n        if upper == 1:\n            return [[0]]\n        if lower == 1:\n            return [[1]]\n        if upper == 2:\n            return [[1, 0], [0, 1]]\n        if lower == 2:\n            return [[1, 1], [0, 0]]\n        if upper == 3:\n            return [[1, 0, 0], [0, 1, 0]]\n        if lower == 3:\n            return [[1, 1, 0], [0, 0, 1]]\n        if upper == 4:\n            return [[1, 0, 0, 0], [0, 1, 0, 0]]\n        if lower == 4:\n            return [[1, 1, 0, 0], [0, 0, 1, 0]]\n        if upper == 5:\n            return [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0]]\n        if lower == 5:\n            return [[1"
    },
    {
        "number": 1254,
        "title": "Number of Closed Islands",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0 and not visited[i][j]:\n                    count += self.dfs(grid, i, j, visited)\n        return count"
    },
    {
        "number": 1255,
        "title": "Maximum Score Words Formed by Letters",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + score[j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[j]\n        # dp[i][j] = dp[i-1][j] + score[j]\n        # dp[i][j] = dp[i][j-1] + score[j]\n        # dp[i][j] = dp[i-1][j-1] + score[j]\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j"
    },
    {
        "number": 1260,
        "title": "Shift 2D Grid",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        for _ in range(k):\n            for i in range(m):\n                grid[i][0], grid[i][n - 1] = grid[i][n - 1], grid[i][0]\n            for j in range(n - 1):\n                grid[0][j], grid[m - 1][j] = grid[m - 1][j], grid[0][j]\n        return grid"
    },
    {
        "number": 1261,
        "title": "Find Elements in a Contaminated Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return False\n        if root.val == target:\n            return True\n        if root.val == -1:\n            return False\n        if root.left is not None:\n            if root.left.val == 2 * target + 1:\n                return self.find(root.left.val)\n        if root.right is not None:\n            if root.right.val == 2 * target + 2:\n                return self.find(root.right.val)\n        return False\n"
    },
    {
        "number": 1262,
        "title": "Greatest Sum Divisible by Three",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        dp[2] = max(nums[0] + nums[1], nums[2])\n        for i in range(3, n):\n            dp[i] = max(dp[i - 3] + nums[i], dp[i - 2] + nums[i])\n        return max(dp)"
    },
    {
        "number": 1263,
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == \"S\":\n                    dp[i][j] = 1\n                elif grid[i][j] == \".\":\n                    dp[i][j] = 0\n                elif grid[i][j] == \"B\":\n                    dp[i][j] = -1\n                elif grid[i][j] == \"#\":\n                    dp[i][j] = float(\"inf\")\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == -1:\n                    continue\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == \".\":\n                            dp[i + di][j + dj"
    },
    {
        "number": 1266,
        "title": "Minimum Time Visiting All Points",
        "difficulty": 0,
        "answer": "        n = len(points)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(1, n):\n            dp[i][i - 1] = 1\n        for i in range(2, n):\n            dp[i][i - 2] = 1\n        for i in range(3, n):\n            dp[i][i - 3] = 1\n        for i in range(4, n):\n            dp[i][i - 4] = 1\n        for i in range(5, n):\n            dp[i][i - 5] = 1\n        for i in range(6, n):\n            dp[i][i - 6] = 1\n        for i in range(7, n):\n            dp[i][i - 7] = 1\n        for i in range(8, n):\n            dp[i][i - 8] = 1\n        for i in range(9, n):\n            dp[i][i - 9] = 1\n"
    },
    {
        "number": 1267,
        "title": "Count Servers that Communicate",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(n):\n                        if grid[k][j] == 1:\n                            dp[i][j] += dp[k][j]\n                    for k in range(m):\n                        if grid[i][k] == 1:\n                            dp[i][j] += dp[i][k]\n        return sum(dp)\n"
    },
    {
        "number": 1268,
        "title": "Search Suggestions System",
        "difficulty": 1,
        "answer": "        if not products:\n            return []\n        if not searchWord:\n            return [[x] for x in products]\n        # dp[i][j] = the minimum number of products that can be suggested after i characters of searchWord\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i"
    },
    {
        "number": 1269,
        "title": "Number of Ways to Stay in the Same Place After Some Steps",
        "difficulty": 2,
        "answer": "        dp = [0] * (arrLen + 1)\n        dp[0] = 1\n        for i in range(1, arrLen + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                dp[i] = (dp[i] + dp[j]) % 1007\n        return dp[steps]"
    },
    {
        "number": 1275,
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": 0,
        "answer": "        moves = [[int(i) for i in row.split(\",\")] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for row in moves]\n        moves = [[i for i in row if i!= \"\"] for"
    },
    {
        "number": 1276,
        "title": "Number of Burgers with No Waste of Ingredients",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the number of ways to make i jumbo burgers and j small burgers\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-"
    },
    {
        "number": 1277,
        "title": "Count Square Submatrices with All Ones",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and matrix[k][l] == 1:\n                                dp[i][j] += dp[k][l]\n        return sum(dp)\n"
    },
    {
        "number": 1278,
        "title": "Palindrome Partitioning III",
        "difficulty": 2,
        "answer": "        dp = [[0] * (len(s) + 1) for _ in range(k + 1)]\n        for i in range(1, len(s) + 1):\n            for j in range(1, k + 1):\n                if i - j >= 0 and s[i - j] == s[i]:\n                    dp[j][i] = dp[j - 1][i - j] + 1\n                else:\n                    dp[j][i] = max(dp[j][i - 1], dp[j - 1][i])\n        return dp[k][len(s)]"
    },
    {
        "number": 1281,
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "difficulty": 0,
        "answer": "        def product_and_sum(n):\n            return sum(int(d) * (10 ** (n - i - 1)) for i, d in enumerate(str(n)))"
    },
    {
        "number": 1282,
        "title": "Group the People Given the Group Size They Belong To",
        "difficulty": 1,
        "answer": "        n = len(groupSizes)\n        groups = [[] for _ in range(n)]\n        for i in range(n):\n            groups[groupSizes[i] - 1].append(i)\n        return groups\n"
    },
    {
        "number": 1283,
        "title": "Find the Smallest Divisor Given a Threshold",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return nums[0] if nums[0] <= threshold else nums[1]\n        if len(nums) == 3:\n            return nums[0] if nums[0] <= threshold else nums[1] if nums[1] <= threshold else nums[2]\n        if len(nums) == 4:\n            return nums[0] if nums[0] <= threshold else nums[1] if nums[1] <= threshold else nums[2] if nums[2] <= threshold else nums[3]\n        if len(nums) == 5:\n            return nums[0] if nums[0] <= threshold else nums[1] if nums[1] <= threshold else nums[2] if nums[2] <= threshold else nums[3] if nums[3"
    },
    {
        "number": 1284,
        "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
        "difficulty": 2,
        "answer": "        m, n = len(mat), len(mat[0])\n        if m == 0 or n == 0:\n            return 0\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(4):\n                        if i + 1 < m and mat[i + 1][j] == 1:\n                            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1)\n                        if j + 1 < n and mat[i][j + 1] == 1:\n                            dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + 1)\n                        if i - 1 >= 0 and mat[i - 1][j] == 1:\n                            dp[i - 1][j] = max(dp[i - 1][j], dp[i][j] + 1)\n                        "
    },
    {
        "number": 1286,
        "title": "Iterator for Combination",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1287,
        "title": "Element Appearing More Than 25% In Sorted Array",
        "difficulty": 0,
        "answer": "        if not arr:\n            return None\n        if len(arr) == 1:\n            return arr[0]\n        if len(arr) == 2:\n            return arr[0] if arr[0] == arr[1] else arr[1]\n        if len(arr) == 3:\n            return arr[0] if arr[0] == arr[1] or arr[0] == arr[2] else arr[1]\n        if len(arr) == 4:\n            return arr[0] if arr[0] == arr[1] or arr[0] == arr[2] or arr[0] == arr[3] else arr[1]\n        if len(arr) == 5:\n            return arr[0] if arr[0] == arr[1] or arr[0] == arr[2] or arr[0] == arr[3] or arr[0] == arr[4] else arr[1]\n        if len(arr) == 6:\n            return arr[0] if arr[0] == arr[1] or arr[0] == arr[2"
    },
    {
        "number": 1288,
        "title": "Remove Covered Intervals",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        result = 0\n        for i in range(len(intervals)):\n            if i > 0 and intervals[i][0] <= intervals[i - 1][1]:\n                intervals[i - 1][1] = max(intervals[i - 1][1], intervals[i][1])\n            else:\n                result += 1\n        return result\n"
    },
    {
        "number": 1289,
        "title": "Minimum Falling Path Sum II",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = grid[i][i]\n        for i in range(n - 1):\n            dp[i][i + 1] = grid[i][i + 1]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = grid[i][i + 2]\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 3, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i + 2][j]) + grid[i][j]\n        return dp[0][n - 1]"
    },
    {
        "number": 1290,
        "title": "Convert Binary Number in a Linked List to Integer",
        "difficulty": 0,
        "answer": "        if not head:\n            return 0\n        if not head.next:\n            return head.val\n        \n        # get the decimal value of the first node\n        decimal = self.getDecimalValue(head.next)\n        # get the decimal value of the second node\n        decimal += self.getDecimalValue(head.next.next) * 2\n        # get the decimal value of the third node\n        decimal += self.getDecimalValue(head.next.next.next) * 4\n        # get the decimal value of the fourth node\n        decimal += self.getDecimalValue(head.next.next.next.next) * 8\n        # get the decimal value of the fifth node\n        decimal += self.getDecimalValue(head.next.next.next.next.next) * 16\n        # get the decimal value of the sixth node\n        decimal += self.getDecimalValue(head.next.next.next.next.next.next) * 32\n        # get the decimal value of the seventh node\n        decimal += self.getDecimalValue("
    },
    {
        "number": 1291,
        "title": "Sequential Digits",
        "difficulty": 1,
        "answer": "        result = []\n        for i in range(low, high + 1):\n            if self.is_sequential_digits(i):\n                result.append(i)\n        return sorted(result)"
    },
    {
        "number": 1292,
        "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] <= threshold:\n                    dp[i][j] = 1 + max(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n        return max(dp[m - 1][n - 1], dp[m - 1][n - 1])\n"
    },
    {
        "number": 1293,
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = sys.maxsize\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = sys.maxsize\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dp[i][j] = sys.maxsize\n                else:\n                    dp[i][j] = sys.maxsize\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dp[i][j] = sys.maxsize\n                else:\n                    dp[i][j] = sys.max"
    },
    {
        "number": 1295,
        "title": "Find Numbers with Even Number of Digits",
        "difficulty": 0,
        "answer": "        count = 0\n        for num in nums:\n            if len(str(num)) % 2 == 0:\n                count += 1\n        return count\n"
    },
    {
        "number": 1296,
        "title": "Divide Array in Sets of K Consecutive Numbers",
        "difficulty": 1,
        "answer": "        if len(nums) < k:\n            return False\n        if k == 1:\n            return True\n        if k == 2:\n            return all(nums[i]!= nums[i + 1] for i in range(len(nums) - 1))\n        if k == 3:\n            return all(nums[i]!= nums[i + 1] and nums[i]!= nums[i + 2] for i in range(len(nums) - 2))\n        if k == 4:\n            return all(nums[i]!= nums[i + 1] and nums[i]!= nums[i + 2] and nums[i]!= nums[i + 3] for i in range(len(nums) - 3))\n        if k == 5:\n            return all(nums[i]!= nums[i + 1] and nums[i]!= nums[i + 2] and nums[i]!= nums[i + 3] and nums[i]!= nums[i + 4] for i"
    },
    {
        "number": 1297,
        "title": "Maximum Number of Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] ="
    },
    {
        "number": 1298,
        "title": "Maximum Candies You Can Get from Boxes",
        "difficulty": 2,
        "answer": "        n = len(status)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            if status[i] == 1:\n                dp[i][i] = candies[i]\n            for j in range(i + 1, n):\n                if status[j] == 1 and keys[j][0] == i:\n                    dp[i][j] = dp[i][j - 1] + candies[j]\n                    if dp[i][j] > dp[i][j - 1]:\n                        dp[i][j] = dp[i][j - 1]\n                if status[j] == 1 and keys[j][0] == i and keys[j][1] == j:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + candies[j])\n                    if dp[i][j] > dp[i][j - 1]:\n                        dp[i][j] = dp[i][j - 1]\n                "
    },
    {
        "number": 1299,
        "title": "Replace Elements with Greatest Element on Right Side",
        "difficulty": 0,
        "answer": "        if not arr:\n            return [-1]\n        n = len(arr)\n        max_idx = 0\n        for i in range(n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        arr[max_idx] = -1\n        for i in range(n - 1, -1, -1):\n            if arr[i] > arr[max_idx]:\n                arr[i] = arr[max_idx]\n            else:\n                arr[i] = -1\n        return arr\n"
    },
    {
        "number": 1300,
        "title": "Sum of Mutated Array Closest to Target",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        if len(arr) == 1:\n            return arr[0]\n        if len(arr) == 2:\n            return arr[0] if arr[0] < arr[1] else arr[1]\n        if len(arr) == 3:\n            return arr[0] if arr[0] < arr[1] else arr[1] if arr[1] < arr[2] else arr[2]\n        if len(arr) == 4:\n            return arr[0] if arr[0] < arr[1] else arr[1] if arr[1] < arr[2] else arr[2] if arr[2] < arr[3] else arr[3]\n        if len(arr) == 5:\n            return arr[0] if arr[0] < arr[1] else arr[1] if arr[1] < arr[2] else arr[2] if arr[2] < arr[3] else arr[3] if arr[3] < arr[4] else arr[4]\n        if len(arr"
    },
    {
        "number": 1301,
        "title": "Number of Paths with Max Score",
        "difficulty": 2,
        "answer": "        m, n = len(board), len(board[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[m - 1][n - 1] = 1\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                if board[i][j] == 'S':\n                    dp[i][j] = dp[i + 1][j + 1] + dp[i][j + 1] + dp[i + 1][j]\n                else:\n                    dp[i][j] = 0\n        return [max(dp[i][j] for i in range(m) for j in range(n)) % 1000000007, dp[0][0]]"
    },
    {
        "number": 1302,
        "title": "Deepest Leaves Sum",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return root.val\n        return self.deepestLeavesSum(root.left) + self.deepestLeavesSum(root.right) + root.val\n"
    },
    {
        "number": 1304,
        "title": "Find N Unique Integers Sum up to Zero",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [-1, 1]\n        if n == 3:\n            return [-1, 0, 1]\n        if n == 4:\n            return [-3, -1, 1, 2]\n        if n == 5:\n            return [-5, -1, 1, 2, 3]\n        if n == 6:\n            return [-5, -1, 1, 2, 3, 4]\n        if n == 7:\n            return [-7, -1, 1, 3, 4, 5]\n        if n == 8:\n            return [-7, -1, 1, 3, 4, 5, 6]\n        if n == 9:\n            return [-7, -1, 1, 3, 4, 5, 6, 7]\n        if n == 10:\n            return [-7, -1, 1, 3, 4, 5, 6, 7, 8]\n        if n == 11:\n            return [-7, -1, 1, 3, 4"
    },
    {
        "number": 1305,
        "title": "All Elements in Two Binary Search Trees",
        "difficulty": 1,
        "answer": "        if not root1:\n            return []\n        if not root2:\n            return [root1.val]\n        return self.helper(root1, root2)"
    },
    {
        "number": 1306,
        "title": "Jump Game III",
        "difficulty": 1,
        "answer": "        if not arr:\n            return False\n        if start < 0 or start >= len(arr):\n            return False\n        dp = [[False] * len(arr) for _ in range(start + 1)]\n        dp[start][start] = True\n        for i in range(start + 1, len(arr)):\n            for j in range(start, i):\n                if arr[i] > 0:\n                    dp[i][j] = dp[j][i - arr[i]]\n                else:\n                    dp[i][j] = dp[j][i]\n        return dp[-1][-1]"
    },
    {
        "number": 1307,
        "title": "Verbal Arithmetic Puzzle",
        "difficulty": 2,
        "answer": "        n = len(words)\n        if n == 0:\n            return True\n        if n == 1:\n            return result == words[0]\n        if result == \"0\":\n            return False\n        if result[0] == '0':\n            return False\n        if result[0] == '1':\n            return self.isSolvable(words[1:], result[1:])\n        if result[0] == '2':\n            return self.isSolvable(words[1:], result[1:]) or self.isSolvable(words[2:], result[2:])\n        if result[0] == '3':\n            return self.isSolvable(words[1:], result[1:]) or self.isSolvable(words[2:], result[2:]) or self.isSolvable(words[3:], result[3:])\n        if result[0] == '4':\n            return self.isSolvable(words[1:], result[1:]) or self.isSolvable(words[2:], result[2:]) or"
    },
    {
        "number": 1309,
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "difficulty": 0,
        "answer": "        mapping = {\n            '1': 'a',\n            '2': 'b',\n            '3': 'c',\n            '4': 'd',\n            '5': 'e',\n            '6': 'f',\n            '7': 'g',\n            '8': 'h',\n            '9': 'i',\n            '10#': 'j',\n            '11#': 'k',\n            '12#': 'l',\n            '13#':'m',\n            '14#': 'n',\n            '15#': 'o',\n            '16#': 'p',\n            '17#': 'q',\n            '18#': 'r',\n            '19#':'s',\n            '20#': 't',\n            '21#': 'u',\n            '22#': 'v',\n            '23#': 'w',\n            '24#': 'x',\n            '25#': 'y',\n            '26#': 'z',\n        }\n        return ''.join(mapping[c] for c in s)"
    },
    {
        "number": 1310,
        "title": "XOR Queries of a Subarray",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return []\n        if n == 1:\n            return [arr[0]]\n        if n == 2:\n            return [arr[0] ^ arr[1]]\n        if n == 3:\n            return [arr[0] ^ arr[1] ^ arr[2]]\n        if n == 4:\n            return [arr[0] ^ arr[1] ^ arr[2] ^ arr[3]]\n        if n == 5:\n            return [arr[0] ^ arr[1] ^ arr[2] ^ arr[3] ^ arr[4]]\n        if n == 6:\n            return [arr[0] ^ arr[1] ^ arr[2] ^ arr[3] ^ arr[4] ^ arr[5]]\n        if n == 7:\n            return [arr[0] ^ arr[1] ^ arr[2] ^ arr[3] ^ arr[4] ^ arr[5] ^ arr[6]]\n        if n == 8:\n            return [arr[0] ^ arr[1] ^ arr"
    },
    {
        "number": 1311,
        "title": "Get Watched Videos by Your Friends",
        "difficulty": 1,
        "answer": "        # dic = {i: 0 for i in range(len(watchedVideos))}\n        # dic[id] = level\n        # dic = {i: dic[i] for i in watchedVideos}\n        # dic = {i: dic[i] for i in friends}\n        # dic = {i: dic[i] for i in watchedVideos}\n        # dic = {i: dic[i] for i in friends}\n        # dic = {i: dic[i] for i in watchedVideos}\n        # dic = {i: dic[i] for i in friends}\n        # dic = {i: dic[i] for i in watchedVideos}\n        # dic = {i: dic[i] for i in friends}\n        # dic = {i: dic[i] for i in watchedVideos}\n        # dic = {i: dic[i] for i in friends}\n        # dic = {i: dic[i] for i in watched"
    },
    {
        "number": 1312,
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 3\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 4\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 5\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 6\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 7\n        for i in range(n - 8,"
    },
    {
        "number": 1313,
        "title": "Decompress Run-Length Encoded List",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:\n            return [nums["
    },
    {
        "number": 1314,
        "title": "Matrix Block Sum",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                for r in range(i - k, i + k + 1):\n                    for c in range(j - k, j + k + 1):\n                        if 0 <= r < m and 0 <= c < n:\n                            ans[i][j] += mat[r][c]\n        return ans\n"
    },
    {
        "number": 1315,
        "title": "Sum of Nodes with Even-Valued Grandparent",
        "difficulty": 1,
        "answer": "        def dfs(node, parent, sum):\n            if not node:\n                return\n            if parent and parent.val & 1:\n                sum += node.val\n            dfs(node.left, node, sum)\n            dfs(node.right, node, sum)"
    },
    {
        "number": 1316,
        "title": "Distinct Echo Substrings",
        "difficulty": 2,
        "answer": "        n = len(text)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n]\n"
    },
    {
        "number": 1317,
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 1]\n        if n == 3:\n            return [2, 1]\n        if n == 4:\n            return [3, 2]\n        if n == 5:\n            return [4, 3]\n        if n == 6:\n            return [5, 4]\n        if n == 7:\n            return [6, 5]\n        if n == 8:\n            return [7, 6]\n        if n == 9:\n            return [8, 7]\n        if n == 10:\n            return [9, 8]\n        if n == 11:\n            return [10, 9]\n        if n == 12:\n            return [11, 10]\n        if n == 13:\n            return [12, 11]\n        if n == 14:\n            return [13, 12]\n        if n == 15:\n            return [14, 13]\n        if n == 16:\n            return [15, 14]\n        "
    },
    {
        "number": 1318,
        "title": "Minimum Flips to Make a OR b Equal to c",
        "difficulty": 1,
        "answer": "        # a = a ^ b ^ c\n        # b = a ^ b ^ c\n        # c = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n        # a = a ^ b ^ c\n"
    },
    {
        "number": 1319,
        "title": "Number of Operations to Make Network Connected",
        "difficulty": 1,
        "answer": "        # dfs\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n"
    },
    {
        "number": 1320,
        "title": "Minimum Distance to Type a Word Using Two Fingers",
        "difficulty": 2,
        "answer": "        # dic = {letter: (x, y) for x, y, letter in zip(range(5), range(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n        dic = {letter: (x, y) for x, y, letter in zip(range(5), range(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n        # dic = {letter: (x, y) for x, y, letter in zip(range(5), range(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n        # dic = {letter: (x, y) for x, y, letter in zip(range(5), range(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n        # dic = {letter: (x, y) for x, y, letter in zip(range(5), range(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n        # dic = {"
    },
    {
        "number": 1323,
        "title": "Maximum 69 Number",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit/\n        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit-2/\n        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit-3/\n        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit-4/\n        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit-5/\n        # https://www.geeksforgeeks.org/maximum-number-that-can-be-obtained-by-changing-at-most-one-digit-6/\n        # https://www."
    },
    {
        "number": 1324,
        "title": "Print Words Vertically",
        "difficulty": 1,
        "answer": "        words = s.split()\n        words = [w +'' for w in words]\n        words = [w.strip() for w in words]\n        words = [w for w in words if w]\n        words = [w.split(' ') for w in words]\n        words = [w for w in words if w]\n        words = [w for w in words if len(w) > 1]\n        words = [w for w in words if len(w) == 1]\n        words = [w for w in words if len(w) == 2]\n        words = [w for w in words if len(w) == 3]\n        words = [w for w in words if len(w) == 4]\n        words = [w for w in words if len(w) == 5]\n        words = [w for w in words if len(w) == 6]\n        words = [w for w in words if len(w) == 7]\n        words = [w for w in words if len(w) == 8]\n        words = [w for w in words if"
    },
    {
        "number": 1325,
        "title": "Delete Leaves With a Given Value",
        "difficulty": 1,
        "answer": "        def dfs(root):\n            if not root:\n                return\n            if not root.left and not root.right:\n                if root.val == target:\n                    return\n                root.left = root.right = None\n                return\n            dfs(root.left)\n            dfs(root.right)\n            if root.left and not root.left.left and not root.left.right:\n                if root.left.val == target:\n                    root.left = None\n                    return\n                root.left.left = root.left.right = None\n                return\n            if root.right and not root.right.left and not root.right.right:\n                if root.right.val == target:\n                    root.right = None\n                    return\n                root.right.left = root.right.right = None\n                return\n        dfs(root)\n        return root\n"
    },
    {
        "number": 1326,
        "title": "Minimum Number of Taps to Open to Water a Garden",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 1328,
        "title": "Break a Palindrome",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string/\n        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string-2/\n        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string-3/\n        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string-4/\n        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string-5/\n        # https://www.geeksforgeeks.org/find-the-lexicographically-smallest-palindrome-of-a-given-string-6/\n        # https://www.geeksforgeeks.org/find-the-lex"
    },
    {
        "number": 1329,
        "title": "Sort the Matrix Diagonally",
        "difficulty": 1,
        "answer": "        if not mat:\n            return mat\n        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            for j in range(n):\n                mat[i][j] = mat[i][j] if i == j else mat[i][j] - min(mat[i][j], mat[i][j - 1], mat[i - 1][j])\n        for i in range(m):\n            for j in range(n):\n                mat[i][j] = mat[i][j] if i == j else mat[i][j] - min(mat[i][j], mat[i - 1][j], mat[i][j - 1])\n        for i in range(m):\n            for j in range(n):\n                mat[i][j] = mat[i][j] if i == j else mat[i][j] - min(mat[i][j], mat[i - 1][j], mat[i][j - 1])\n        return mat"
    },
    {
        "number": 1330,
        "title": "Reverse Subarray To Maximize Array Value",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = nums[1] - nums[0]\n        for i in range(2, n):\n            dp[i] = max(nums[i] - nums[i - 1], dp[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 1331,
        "title": "Rank Transform of an Array",
        "difficulty": 0,
        "answer": "        # sort the array\n        arr.sort()\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] += 1\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] += 1\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] += 1\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] += 1\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] += 1\n        # count the number of each element\n        count = [0] * (max(arr) + 1)\n        for i in arr:\n            count[i] +="
    },
    {
        "number": 1332,
        "title": "Remove Palindromic Subsequences",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 1333,
        "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
        "difficulty": 1,
        "answer": "        # sort by rating\n        restaurants.sort(key=lambda x: x[1], reverse=True)\n        # filter by veganFriendly\n        restaurants = [i for i in restaurants if i[2] == veganFriendly]\n        # filter by maxPrice\n        restaurants = [i for i in restaurants if i[3] <= maxPrice]\n        # filter by maxDistance\n        restaurants = [i for i in restaurants if i[4] <= maxDistance]\n        # sort by rating\n        restaurants.sort(key=lambda x: x[1], reverse=True)\n        return [i[0] for i in restaurants]"
    },
    {
        "number": 1334,
        "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "difficulty": 1,
        "answer": "        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j][2] <= distanceThreshold]\n        # dic[i] = [j for j in range(n) if edges[i][2] + edges[j"
    },
    {
        "number": 1335,
        "title": "Minimum Difficulty of a Job Schedule",
        "difficulty": 2,
        "answer": "        if not jobDifficulty:\n            return 0\n        dp = [0] * (d + 1)\n        dp[0] = jobDifficulty[0]\n        for i in range(1, d + 1):\n            dp[i] = max(dp[i - 1], jobDifficulty[i])\n        return dp[d]"
    },
    {
        "number": 1337,
        "title": "The K Weakest Rows in a Matrix",
        "difficulty": 0,
        "answer": "        n = len(mat)\n        m = len(mat[0])\n        \n        # dp[i][j] = the number of soldiers in the i-th row and j-th column\n        dp = [[0] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(i - 1, -1, -1):\n                        if dp[k][j] > dp[i][j]:\n                            dp[i][j] = dp[k][j]\n                    for k in range(j - 1, -1, -1):\n                        if dp[i][k] > dp[i][j]:\n                            dp[i][j] = dp[i][k]\n        \n        # return the k weakest rows\n        return [i for i in range(n) if dp[i][0] <= k]\n"
    },
    {
        "number": 1338,
        "title": "Reduce Array Size to The Half",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 3\n        if n == 7:\n            return 3\n        if n == 8:\n            return 4\n        if n == 9:\n            return 4\n        if n == 10:\n            return 4\n        if n == 11:\n            return 4\n        if n == 12:\n            return 4\n        if n == 13:\n            return 4\n        if n == 14:\n            return 4\n        if n == 15:\n            return 4\n        if n == 16:\n            return 4\n        if n == 17:\n            return 4\n        if n == 18:\n            return 4\n        if n == 19:\n            return 4\n        if n == 20:\n            return 4\n        if n == 21:\n            return 4\n"
    },
    {
        "number": 1339,
        "title": "Maximum Product of Splitted Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node: Optional[TreeNode]) -> int:\n            if node is None:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            return max(left, right) * node.val"
    },
    {
        "number": 1340,
        "title": "Jump Game V",
        "difficulty": 2,
        "answer": "        if not arr:\n            return 0\n        if d == 0:\n            return 0\n        if d == 1:\n            return arr.index(max(arr)) + 1\n        if d == 2:\n            return arr.index(max(arr)) + 1\n        if d == 3:\n            return arr.index(max(arr)) + 1\n        if d == 4:\n            return arr.index(max(arr)) + 1\n        if d == 5:\n            return arr.index(max(arr)) + 1\n        if d == 6:\n            return arr.index(max(arr)) + 1\n        if d == 7:\n            return arr.index(max(arr)) + 1\n        if d == 8:\n            return arr.index(max(arr)) + 1\n        if d == 9:\n            return arr.index(max(arr)) + 1\n        if d == 10:\n            return arr.index(max(arr)) + 1\n        if d == 11:\n            return arr.index(max(arr)) + 1\n        if d == 12:\n            return"
    },
    {
        "number": 1342,
        "title": "Number of Steps to Reduce a Number to Zero",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num % 2 == 0:\n            return self.numberOfSteps(num // 2)\n        else:\n            return self.numberOfSteps(num - 1)\n"
    },
    {
        "number": 1343,
        "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        if k == 1:\n            return len(arr)\n        if k == 2:\n            return len(arr) - 1\n        if k == 3:\n            return len(arr) - 2\n        if k == 4:\n            return len(arr) - 3\n        if k == 5:\n            return len(arr) - 4\n        if k == 6:\n            return len(arr) - 5\n        if k == 7:\n            return len(arr) - 6\n        if k == 8:\n            return len(arr) - 7\n        if k == 9:\n            return len(arr) - 8\n        if k == 10:\n            return len(arr) - 9\n        if k == 11:\n            return len(arr) - 10\n        if k == 12:\n            return len(arr) - 11\n        if k == 13:\n            return len(arr) - 12\n        if k == 14:\n            return len(arr) - 13\n        if k == 15:\n            return len(arr) - 14\n        if"
    },
    {
        "number": 1344,
        "title": "Angle Between Hands of a Clock",
        "difficulty": 1,
        "answer": "        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf6/cf6.html\n        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf7/cf7.html\n        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf8/cf8.html\n        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf9/cf9.html\n        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf10/cf10.html\n        # https://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/cf11/cf11.html\n        # https://www.maths.surrey.ac.uk/"
    },
    {
        "number": 1345,
        "title": "Jump Game IV",
        "difficulty": 2,
        "answer": "        if not arr:\n            return 0\n        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 0\n        for i in range(n - 1):\n            dp[i][i + 1] = arr[i] + 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if arr[i] == arr[j] and i!= j:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 1346,
        "title": "Check If N and Its Double Exist",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n < 2:\n            return False\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if arr[i] == 2 * arr[j]:\n                    return True\n        return False\n"
    },
    {
        "number": 1347,
        "title": "Minimum Number of Steps to Make Two Strings Anagram",
        "difficulty": 1,
        "answer": "        m = len(s)\n        n = len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]\n"
    },
    {
        "number": 1348,
        "title": "Tweet Counts Per Frequency",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1349,
        "title": "Maximum Students Taking Exam",
        "difficulty": 2,
        "answer": "        m, n = len(seats), len(seats[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if seats[i][j] == \"#\":\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and seats[i][j] == \"#\":\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                if j > 0 and seats[i][j] == \"#\":\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n                if i > 0 and j > 0 and seats[i][j] == \"#\":\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                    dp[i]["
    },
    {
        "number": 1351,
        "title": "Count Negative Numbers in a Sorted Matrix",
        "difficulty": 0,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] < 0:\n                    count += 1\n        return count"
    },
    {
        "number": 1352,
        "title": "Product of the Last K Numbers",
        "difficulty": 1,
        "answer": "        self.nums = []\n        self.nums.append(num)\n        self.k = k\n        self.product = 1\n        while len(self.nums) > self.k:\n            self.product *= self.nums.pop()\n        return self.product"
    },
    {
        "number": 1353,
        "title": "Maximum Number of Events That Can Be Attended",
        "difficulty": 1,
        "answer": "        if not events:\n            return 0\n        n = len(events)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n                if events[i][0] <= events[j][0] and events[i][1] >= events[j][1]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n        return max(dp[0][n])\n"
    },
    {
        "number": 1354,
        "title": "Construct Target Array With Multiple Sums",
        "difficulty": 2,
        "answer": "        if len(target) == 0:\n            return True\n        if len(target) == 1:\n            return target[0] == 1\n        if len(target) == 2:\n            return target[0] == 1 and target[1] == 1\n        if len(target) == 3:\n            return target[0] == 1 and target[1] == 1 and target[2] == 1\n        if len(target) == 4:\n            return target[0] == 1 and target[1] == 1 and target[2] == 1 and target[3] == 1\n        if len(target) == 5:\n            return target[0] == 1 and target[1] == 1 and target[2] == 1 and target[3] == 1 and target[4] == 1\n        if len(target) == 6:\n            return target[0] == 1 and target[1] == 1 and target[2] == 1 and target[3] == 1 and target[4] == 1 and target[5] == 1\n        if len(target) == 7:\n            return target[0] =="
    },
    {
        "number": 1356,
        "title": "Sort Integers by The Number of 1 Bits",
        "difficulty": 0,
        "answer": "        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by bits\n        # sort by"
    },
    {
        "number": 1357,
        "title": "Apply Discount Every n Orders",
        "difficulty": 1,
        "answer": "        # TODO\n        pass\n"
    },
    {
        "number": 1358,
        "title": "Number of Substrings Containing All Three Characters",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2):\n            dp[i][i + 2] = 1\n        for i in range(n - 3):\n            dp[i][i + 3] = 1\n        for i in range(n - 4):\n            dp[i][i + 4] = 1\n        for i in range(n - 5):\n            dp[i][i + 5] = 1\n        for i in range(n - 6):\n            dp[i][i + 6] = 1\n        for i in range(n - 7):\n            dp[i][i + 7] = 1\n        for i in range(n - 8):\n            dp[i][i + 8] = 1\n        for i in range(n - 9):\n            dp[i"
    },
    {
        "number": 1359,
        "title": "Count All Valid Pickup and Delivery Options",
        "difficulty": 2,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[n] % 1000000007\n"
    },
    {
        "number": 1360,
        "title": "Number of Days Between Two Dates",
        "difficulty": 0,
        "answer": "        date1 = datetime.datetime.strptime(date1, \"%Y-%m-%d\")\n        date2 = datetime.datetime.strptime(date2, \"%Y-%m-%d\")\n        return (date2 - date1).days"
    },
    {
        "number": 1361,
        "title": "Validate Binary Tree Nodes",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return True\n        if n == 1:\n            return leftChild[0] == -1 and rightChild[0] == -1\n        if n == 2:\n            return leftChild[0] == -1 and rightChild[0] == -1 and leftChild[1] == -1 and rightChild[1] == -1\n        if n == 3:\n            return leftChild[0] == -1 and rightChild[0] == -1 and leftChild[1] == -1 and rightChild[1] == -1 and leftChild[2] == -1 and rightChild[2] == -1\n        if n == 4:\n            return leftChild[0] == -1 and rightChild[0] == -1 and leftChild[1] == -1 and rightChild[1] == -1 and leftChild[2] == -1 and rightChild[2] == -1 and leftChild[3] == -1 and rightChild[3] == -1\n        return False\n"
    },
    {
        "number": 1362,
        "title": "Closest Divisors",
        "difficulty": 1,
        "answer": "        if num == 1:\n            return [1]\n        if num == 2:\n            return [2, 1]\n        if num == 3:\n            return [3, 1]\n        if num == 4:\n            return [2, 2]\n        if num == 5:\n            return [5, 1]\n        if num == 6:\n            return [3, 2]\n        if num == 7:\n            return [7, 1]\n        if num == 8:\n            return [3, 3]\n        if num == 9:\n            return [3, 3]\n        if num == 10:\n            return [2, 5]\n        if num == 11:\n            return [11, 1]\n        if num == 12:\n            return [3, 4]\n        if num == 13:\n            return [13, 1]\n        if num == 14:\n            return [7, 2]\n        if num == 15:\n            return [15, 1]\n        if num == 16:\n            return [2, 4]\n        if num == 17:\n            return [17,"
    },
    {
        "number": 1363,
        "title": "Largest Multiple of Three",
        "difficulty": 2,
        "answer": "        n = len(digits)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return str(digits[0] * 3)\n        if n == 2:\n            return str(digits[0] * 3) + str(digits[1] * 3)\n        if n == 3:\n            return str(digits[0] * 3) + str(digits[1] * 3) + str(digits[2] * 3)\n        if n == 4:\n            return str(digits[0] * 3) + str(digits[1] * 3) + str(digits[2] * 3) + str(digits[3] * 3)\n        if n == 5:\n            return str(digits[0] * 3) + str(digits[1] * 3) + str(digits[2] * 3) + str(digits[3] * 3) + str(digits[4] * 3)\n        if n == 6:\n            return str(digits[0] * 3) +"
    },
    {
        "number": 1365,
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] < nums[j]:\n                    dp[i] += 1\n        return dp"
    },
    {
        "number": 1366,
        "title": "Rank Teams by Votes",
        "difficulty": 1,
        "answer": "        def get_rank(team):\n            return sum(1 for i in votes if i == team)"
    },
    {
        "number": 1367,
        "title": "Linked List in Binary Tree",
        "difficulty": 1,
        "answer": "        if head is None or root is None:\n            return False\n        if head.val == root.val:\n            return True\n        if head.next is None:\n            return False\n        return self.isSubPath(head.next, root) or self.isSubPath(head.next.next, root)"
    },
    {
        "number": 1368,
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = dp[i][j - 1] + 1\n                elif grid[i][j] == 2:\n                    dp[i][j] = dp[i - 1][j] + 1\n                elif grid[i][j] == 3:\n                    dp[i][j] = dp[i][j + 1] + 1\n                elif grid[i][j] == 4:\n                    dp[i][j] = dp[i + 1][j] + 1\n        return min(dp[m - 1][n - 1], dp[m - 1][0] + dp[0][n - 1])"
    },
    {
        "number": 1370,
        "title": "Increasing Decreasing String",
        "difficulty": 0,
        "answer": "        if not s:\n            return \"\"\n        result = []\n        for c in s:\n            if result and result[-1] >= c:\n                result.append(c)\n            else:\n                result.append(c)\n        for c in s:\n            if result and result[-1] < c:\n                result.append(c)\n            else:\n                result.append(c)\n        return \"\".join(result)"
    },
    {
        "number": 1371,
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        vowels = \"aeiou\"\n        count = [0] * len(vowels)\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] in vowels:\n                count[vowels.index(s[i])] += 1\n            else:\n                count[0] += 1\n            max_len = max(max_len, max(count))\n        return max_len\n"
    },
    {
        "number": 1372,
        "title": "Longest ZigZag Path in a Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 1\n        if root.left is None:\n            return self.longestZigZag(root.right) + 1\n        if root.right is None:\n            return self.longestZigZag(root.left) + 1\n        return max(self.longestZigZag(root.left), self.longestZigZag(root.right)) + 1"
    },
    {
        "number": 1373,
        "title": "Maximum Sum BST in Binary Tree",
        "difficulty": 2,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        return max(\n            self.maxSumBST(root.left),\n            self.maxSumBST(root.right),\n            root.val + max(self.maxSumBST(root.left), self.maxSumBST(root.right)),\n        )"
    },
    {
        "number": 1374,
        "title": "Generate a String With Characters That Have Odd Counts",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return \"\"\n        if n == 1:\n            return \"a\"\n        if n == 2:\n            return \"ab\"\n        if n == 3:\n            return \"abc\"\n        if n == 4:\n            return \"abcd\"\n        if n == 5:\n            return \"abcde\"\n        if n == 6:\n            return \"abcdef\"\n        if n == 7:\n            return \"abcdefg\"\n        if n == 8:\n            return \"abcdefgh\"\n        if n == 9:\n            return \"abcdefghi\"\n        if n == 10:\n            return \"abcdefghij\"\n        if n == 11:\n            return \"abcdefghijk\"\n        if n == 12:\n            return \"abcdefghijkl\"\n        if n == 13:\n            return \"abcdefghijklm\"\n        if n == 14:\n            return \"abcdefghijklmn\"\n        if n == 15:\n            return \"abcdefghijklmno\"\n        if n == 16:\n            "
    },
    {
        "number": 1375,
        "title": "Number of Times Binary String Is Prefix-Aligned",
        "difficulty": 1,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-bit-manipulation-and-bit-counting\n        # https://discuss.leetcode.com/topic/8"
    },
    {
        "number": 1376,
        "title": "Time Needed to Inform All Employees",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - manager[i]] + informTime[i])\n        # dp[i][j] ="
    },
    {
        "number": 1377,
        "title": "Frog Position After T Seconds",
        "difficulty": 2,
        "answer": "        # dp[i][j] = probability that after i seconds the frog is on the vertex j\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + 1 / (i - 1) * dp[i - 1][j]"
    },
    {
        "number": 1379,
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "difficulty": 0,
        "answer": "        if not original:\n            return cloned\n        if not cloned:\n            return original\n        if original == target:\n            return cloned\n        if not original.left and not original.right:\n            return cloned\n        if not cloned.left and not cloned.right:\n            return original\n        if not original.left:\n            return self.getTargetCopy(original.right, cloned.right, target)\n        if not cloned.left:\n            return self.getTargetCopy(original.left, cloned.left, target)\n        return self.getTargetCopy(original.left, cloned.left, target)"
    },
    {
        "number": 1380,
        "title": "Lucky Numbers in a Matrix",
        "difficulty": 0,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == matrix[i][0]:\n                    dp[i][j] = 1\n                elif matrix[i][j] == matrix[0][j]:\n                    dp[i][j] = 1\n        \n        def dfs(i, j):\n            if dp[i][j] == 1:\n                return [matrix[i][j]]\n            \n            result = []\n            for k in range(n):\n                if dp[i][k] == 1 and dp[k][j] == 1:\n                    result.append(matrix[i][j])\n                    result.extend(dfs(i, k))\n                    result.extend(dfs(k, j))\n            return result\n        \n        return dfs(0, 0)\n"
    },
    {
        "number": 1381,
        "title": "Design a Stack With Increment Operation",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1382,
        "title": "Balance a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root.left is None and root.right is None:\n            return root\n        if root.left is None:\n            return self.balanceBST(root.right)\n        if root.right is None:\n            return self.balanceBST(root.left)\n        left_depth = self.depth(root.left)\n        right_depth = self.depth(root.right)\n        if abs(left_depth - right_depth) > 1:\n            return root\n        return self.balanceBST(root.left) + root + self.balanceBST(root.right)"
    },
    {
        "number": 1383,
        "title": "Maximum Performance of a Team",
        "difficulty": 2,
        "answer": "        # sort speed and efficiency\n        speed, efficiency = sorted(speed), sorted(efficiency)\n        # calculate the max performance\n        max_perf = 0\n        for i in range(k):\n            max_perf += speed[i] * min(efficiency[i], efficiency[i + 1])\n        return max_perf % (10 ** 9 + 7)"
    },
    {
        "number": 1385,
        "title": "Find the Distance Value Between Two Arrays",
        "difficulty": 0,
        "answer": "        n1 = len(arr1)\n        n2 = len(arr2)\n        if n1 > n2:\n            return self.findTheDistanceValue(arr2, arr1, d)\n        if n1 == 0:\n            return 0\n        if n2 == 0:\n            return 0\n        if n1 == 1:\n            return abs(arr1[0] - arr2[0]) <= d\n        if n2 == 1:\n            return abs(arr1[0] - arr2[0]) <= d\n        if n1 == 2:\n            return abs(arr1[0] - arr2[0]) <= d or abs(arr1[1] - arr2[0]) <= d\n        if n2 == 2:\n            return abs(arr1[0] - arr2[0]) <= d or abs(arr1[1] - arr2[0]) <= d or abs(arr1[1] - arr2[1]) <= d\n        if n1 == 3:\n            return abs(arr1[0] - arr2[0]) <= d or abs"
    },
    {
        "number": 1386,
        "title": "Cinema Seat Allocation",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the max number of groups with i rows and j seats\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp"
    },
    {
        "number": 1387,
        "title": "Sort Integers by The Power Value",
        "difficulty": 1,
        "answer": "        if lo > hi:\n            return lo\n        if k == 1:\n            return lo\n        if lo == hi:\n            return lo\n        if lo == hi - 1:\n            return lo\n        if lo == hi - 2:\n            return lo\n        if lo == hi - 3:\n            return lo\n        if lo == hi - 4:\n            return lo\n        if lo == hi - 5:\n            return lo\n        if lo == hi - 6:\n            return lo\n        if lo == hi - 7:\n            return lo\n        if lo == hi - 8:\n            return lo\n        if lo == hi - 9:\n            return lo\n        if lo == hi - 10:\n            return lo\n        if lo == hi - 11:\n            return lo\n        if lo == hi - 12:\n            return lo\n        if lo == hi - 13:\n            return lo\n        if lo == hi - 14:\n            return lo\n        if lo == hi - 15:\n            return lo\n        if lo == hi - 16:\n            return lo\n        if lo == hi - 17:\n"
    },
    {
        "number": 1388,
        "title": "Pizza With 3n Slices",
        "difficulty": 2,
        "answer": "        n = len(slices)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = slices[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(slices[i], slices[i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(slices[i], slices[i + 2])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(slices[i], slices[i + 3])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(slices[i], slices[i + 4])\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = max(slices[i], slices[i + 5"
    },
    {
        "number": 1389,
        "title": "Create Target Array in the Given Order",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        m = len(index)\n        if n == 0 or m == 0:\n            return []\n        target = [0] * m\n        for i in range(m):\n            target[i] = nums[index[i]]\n        for i in range(m, n):\n            target.append(nums[i])\n        return target\n"
    },
    {
        "number": 1390,
        "title": "Four Divisors",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        s = 0\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            if i > 0 and nums[i] == nums[i - 1] + 1:\n                s += nums[i - 1]\n                continue\n            if i > 0 and nums[i] == nums[i - 1] - 1:\n                s += nums[i - 1]\n                continue\n            if i > 0 and nums[i] == nums[i - 1] * 2:\n                s += nums[i - 1]\n                continue\n            if i > 0 and nums[i] == nums[i - 1] * 3:\n                s += nums[i - 1]\n                continue\n            if i > 0 and nums[i] == nums[i - 1] * 4:\n                s += nums[i - 1]\n                continue\n            if i > 0 and nums[i] == nums"
    },
    {
        "number": 1391,
        "title": "Check if There is a Valid Path in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 0 or n == 0:\n            return False\n        dp = [[False] * n for _ in range(m)]\n        dp[0][0] = True\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] and grid[i][0] in [1, 2, 3, 4, 5, 6]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] and grid[0][j] in [1, 2, 3, 4, 5, 6]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] and grid[i][j] in [1, 2, 3, 4, 5, 6]\n                if dp[i][j] and grid[i][j] in [1, 2, 3, 4, 5, 6]:\n                    "
    },
    {
        "number": 1392,
        "title": "Longest Happy Prefix",
        "difficulty": 2,
        "answer": "        if not s:\n            return \"\"\n        if len(s) == 1:\n            return s\n        dp = [0] * len(s)\n        dp[0] = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n        max_len = 0\n        for i in range(len(s)):\n            if dp[i] > max_len:\n                max_len = dp[i]\n        return s[:max_len]"
    },
    {
        "number": 1394,
        "title": "Find Lucky Integer in an Array",
        "difficulty": 0,
        "answer": "        freq = collections.Counter(arr)\n        return max(freq, key=freq.get) if freq else -1\n"
    },
    {
        "number": 1395,
        "title": "Count Number of Teams",
        "difficulty": 1,
        "answer": "        n = len(rating)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    if rating[i] < rating[j] < rating[k]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n                    elif rating[i] > rating[j] > rating[k]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n                    else:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        return sum(dp[0][i] for i in range(n + 1))\n"
    },
    {
        "number": 1396,
        "title": "Design Underground System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1397,
        "title": "Find All Good Strings",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n        if n == 22:\n            return 2\n        if n == 23:\n            "
    },
    {
        "number": 1399,
        "title": "Count Largest Group",
        "difficulty": 0,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return max(dp)\n"
    },
    {
        "number": 1400,
        "title": "Construct K Palindrome Strings",
        "difficulty": 1,
        "answer": "        if len(s) < k:\n            return False\n        dp = [[False] * len(s) for _ in range(k + 1)]\n        dp[0][0] = True\n        for i in range(1, len(s)):\n            dp[0][i] = dp[0][i - 1] and s[i - 1] == s[i]\n        for i in range(1, k + 1):\n            for j in range(1, len(s)):\n                dp[i][j] = dp[i - 1][j - 1] and s[i - 1] == s[j]\n        return dp[k][len(s) - 1]"
    },
    {
        "number": 1401,
        "title": "Circle and Rectangle Overlapping",
        "difficulty": 1,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-with-explanation\n        # https://discuss.leetcode"
    },
    {
        "number": 1402,
        "title": "Reducing Dishes",
        "difficulty": 2,
        "answer": "        # sort the satisfaction\n        satisfaction.sort()\n        # calculate the max sum\n        max_sum = 0\n        for i in range(len(satisfaction)):\n            max_sum += satisfaction[i] * (i + 1)\n        return max_sum"
    },
    {
        "number": 1403,
        "title": "Minimum Subsequence in Non-Increasing Order",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = nums[0]\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + nums[i]\n        for i in range(1, n):\n            for j in range(1, i + 1):\n                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + nums[i]\n        ans = []\n        for i in range(n):\n            for j in range(i + 1):\n                if dp[i][j] > dp[i - 1][j - 1]:\n                    ans.append(nums[i])\n                    break\n        return ans\n"
    },
    {
        "number": 1404,
        "title": "Number of Steps to Reduce a Number in Binary Representation to One",
        "difficulty": 1,
        "answer": "        \n        def dfs(s, i, j):\n            if i == j:\n                return 1\n            if i > j:\n                return 0\n            if s[i] == '0':\n                return dfs(s, i + 1, j)\n            else:\n                return dfs(s, i, j - 1) + dfs(s, i + 1, j)\n        \n        return dfs(s, 0, len(s) - 1)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1405,
        "title": "Longest Happy String",
        "difficulty": 1,
        "answer": "        dp = [[0] * (a + 1) for _ in range(b + 1)]\n        dp[0][0] = 1\n        for i in range(1, a + 1):\n            dp[0][i] = dp[0][i - 1]\n        for j in range(1, b + 1):\n            dp[j][0] = dp[j - 1][0]\n        for i in range(1, a + 1):\n            for j in range(1, b + 1):\n                dp[j][i] = dp[j - 1][i - 1] + dp[j][i - 1]\n        for i in range(1, a + 1):\n            for j in range(1, b + 1):\n                dp[j][i] = max(dp[j][i], dp[j - 1][i] + dp[j][i - 1])\n        for i in range(1, a + 1):\n            for j in range(1, b + 1):\n                dp[j][i] = max(dp["
    },
    {
        "number": 1406,
        "title": "Stone Game III",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stoneValue[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(stoneValue[i], stoneValue[i + 1])\n        for i in range(n - 2):\n            dp[i][i + 2] = max(stoneValue[i], max(stoneValue[i + 1], stoneValue[i + 2]))\n        for i in range(n - 3):\n            dp[i][i + 3] = max(stoneValue[i], max(stoneValue[i + 1], max(stoneValue[i + 2], stoneValue[i + 3])))\n        for i in range(n - 4):\n            dp[i][i + 4] = max(stoneValue[i], max(stoneValue[i + 1], max(stoneValue[i + 2], max(stoneValue[i + 3], stoneValue[i + 4]))))\n        "
    },
    {
        "number": 1408,
        "title": "String Matching in an Array",
        "difficulty": 0,
        "answer": "        words = sorted(words, key=len)\n        ans = []\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if words[i] in words[j]:\n                    ans.append(words[j])\n                    break\n        return ans\n"
    },
    {
        "number": 1409,
        "title": "Queries on a Permutation With Key",
        "difficulty": 1,
        "answer": "        n = len(queries)\n        if n == 0:\n            return []\n        if n == 1:\n            return [queries[0]]\n        if n == 2:\n            return [queries[0] + queries[1]]\n        if n == 3:\n            return [queries[0] + queries[1], queries[0] + queries[2]]\n        if n == 4:\n            return [queries[0] + queries[1], queries[0] + queries[2], queries[0] + queries[3]]\n        if n == 5:\n            return [queries[0] + queries[1], queries[0] + queries[2], queries[0] + queries[3], queries[0] + queries[4]]\n        if n == 6:\n            return [queries[0] + queries[1], queries[0] + queries[2], queries[0] + queries[3], queries[0] + queries[4], queries[0] + queries[5]]\n        if n == 7:\n            return [queries[0] + queries[1"
    },
    {
        "number": 1410,
        "title": "HTML Entity Parser",
        "difficulty": 1,
        "answer": "        return text.replace('&quot;', '\"').replace('&apos;', '\\'').replace('&amp;', '&').replace('&gt;', '>').replace('&lt;', '<').replace('&frasl;', '/')"
    },
    {
        "number": 1411,
        "title": "Number of Ways to Paint N \u00d7 3 Grid",
        "difficulty": 2,
        "answer": "        dp = [[0] * 3 for _ in range(n)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        dp[0][2] = 1\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n            dp[i][1] = dp[i - 1][1] + dp[i - 1][2]\n            dp[i][2] = dp[i - 1][2] + dp[i - 1][0]\n        return dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2] % (109 + 7)\n"
    },
    {
        "number": 1413,
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        return dp[n - 1]"
    },
    {
        "number": 1414,
        "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
        "difficulty": 1,
        "answer": "        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-fibonacci-heap-with-explanation\n        # https://discuss.leetcode"
    },
    {
        "number": 1415,
        "title": "The k-th Lexicographical String of All Happy Strings of Length n",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"c\"\n        if n == 2:\n            return \"ab\"\n        if n == 3:\n            return \"abc\"\n        if n == 4:\n            return \"\"\n        if n == 5:\n            return \"abcd\"\n        if n == 6:\n            return \"abcde\"\n        if n == 7:\n            return \"abcdef\"\n        if n == 8:\n            return \"abcdefg\"\n        if n == 9:\n            return \"abcdefgh\"\n        if n == 10:\n            return \"abcdefghi\"\n        if n == 11:\n            return \"abcdefghij\"\n        if n == 12:\n            return \"abcdefghijk\"\n        if n == 13:\n            return \"abcdefghijkl\"\n        if n == 14:\n            return \"abcdefghijklm\"\n        if n == 15:\n            return \"abcdefghijklmn\"\n        if n == 16:\n            return \"abcdefghijklmno\"\n        if n == 17:\n            "
    },
    {
        "number": 1416,
        "title": "Restore The Array",
        "difficulty": 2,
        "answer": "        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-2/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-3/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-4/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-5/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-6/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-7/\n        # https://www.geeksforgeeks.org/count-number-of-arrays-with-given-sum-8/\n        # https://"
    },
    {
        "number": 1417,
        "title": "Reformat The String",
        "difficulty": 0,
        "answer": "        if not s:\n            return \"\"\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1):\n            dp[i][i + 1] = True\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = True\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = True\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = True\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = True\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = True\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = True\n"
    },
    {
        "number": 1418,
        "title": "Display Table of Food Orders in a Restaurant",
        "difficulty": 1,
        "answer": "        table = []\n        for i in range(len(orders)):\n            table.append([])\n            for j in range(len(orders[i])):\n                table[i].append(0)\n        for i in range(len(orders)):\n            for j in range(len(orders[i])):\n                table[i][j] = table[i][j] + orders[i][j]\n        for i in range(len(table)):\n            table[i].sort()\n        for i in range(len(table)):\n            table[i].insert(0, \"Table\")\n        return table\n"
    },
    {
        "number": 1419,
        "title": "Minimum Number of Frogs Croaking",
        "difficulty": 1,
        "answer": "        frogs = 0\n        frogs_dict = {}\n        for i in range(len(croakOfFrogs)):\n            if croakOfFrogs[i] == 'c':\n                frogs += 1\n                frogs_dict[i] = frogs\n            elif croakOfFrogs[i] == 'r':\n                if i - 1 in frogs_dict and i + 1 in frogs_dict:\n                    frogs_dict[i] = frogs_dict[i - 1] + 1\n                else:\n                    frogs_dict[i] = 1\n            elif croakOfFrogs[i] == 'o':\n                if i - 2 in frogs_dict and i + 2 in frogs_dict:\n                    frogs_dict[i] = frogs_dict[i - 2] + 1\n                else:\n                    frogs_dict[i] = 1\n            elif croakOfFrogs[i] == 'a':\n                if i - 3 in frogs_dict and i + 3 in frogs_dict:\n                    frogs_dict[i]"
    },
    {
        "number": 1420,
        "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
        "difficulty": 2,
        "answer": "        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n][m] % MOD\n"
    },
    {
        "number": 1422,
        "title": "Maximum Score After Splitting a String",
        "difficulty": 0,
        "answer": "        def dfs(s, i, j):\n            if i == j:\n                return 0\n            if i > j:\n                return 0\n            if s[i] == '0' and s[j] == '1':\n                return dfs(s, i + 1, j - 1) + 1\n            if s[i] == '1' and s[j] == '0':\n                return dfs(s, i + 1, j - 1) + 1\n            if s[i] == '0' and s[j] == '0':\n                return dfs(s, i + 1, j - 1) + 2\n            if s[i] == '1' and s[j] == '1':\n                return dfs(s, i + 1, j - 1) + 2\n            return 0"
    },
    {
        "number": 1423,
        "title": "Maximum Points You Can Obtain from Cards",
        "difficulty": 1,
        "answer": "        n = len(cardPoints)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = cardPoints[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(dp[i][i + 1], dp[i + 1][i] + cardPoints[i])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(dp[i][i + 2], dp[i + 1][i + 1] + cardPoints[i])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(dp[i][i + 3], dp[i + 2][i + 2] + cardPoints[i])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(dp[i][i + 4], dp[i + 3][i"
    },
    {
        "number": 1424,
        "title": "Diagonal Traverse II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        n = len(nums)\n        m = len(nums[0])\n        if n == 1:\n            return nums[0]\n        if m == 1:\n            return nums[0]\n        if n == 2:\n            return [nums[0][0], nums[1][0]]\n        if m == 2:\n            return [nums[0][0], nums[1][1]]\n        if n == 3:\n            return [nums[0][0], nums[1][0], nums[2][0]]\n        if m == 3:\n            return [nums[0][0], nums[1][1], nums[2][2]]\n        if n == 4:\n            return [nums[0][0], nums[1][0], nums[2][0], nums[3][0]]\n        if m == 4:\n            return [nums[0][0], nums[1][1], nums[2][2], nums[3]["
    },
    {
        "number": 1425,
        "title": "Constrained Subsequence Sum",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        for i in range(1, len(nums) + 1):\n            for j in range(i, len(nums) + 1):\n                if j - i <= k:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1]) + nums[i - 1]\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        return dp[len(nums)][k]\n"
    },
    {
        "number": 1431,
        "title": "Kids With the Greatest Number of Candies",
        "difficulty": 0,
        "answer": "        n = len(candies)\n        candies.sort()\n        result = [False] * n\n        for i in range(n):\n            if candies[i] + extraCandies >= candies[i + 1]:\n                result[i] = True\n        return result\n"
    },
    {
        "number": 1432,
        "title": "Max Difference You Can Get From Changing an Integer",
        "difficulty": 1,
        "answer": "        def dfs(num: int, a: int, b: int) -> int:\n            if num == 0:\n                return max(a, b)\n            if num == 1:\n                return a\n            if num == 2:\n                return b\n            if num == 3:\n                return max(a, b)\n            if num == 4:\n                return max(a, b)\n            if num == 5:\n                return max(a, b)\n            if num == 6:\n                return max(a, b)\n            if num == 7:\n                return max(a, b)\n            if num == 8:\n                return max(a, b)\n            if num == 9:\n                return max(a, b)\n            if num == 10:\n                return max(a, b)\n            if num == 11:\n                return max(a, b)\n            if num == 12:\n                return max(a, b)\n            if num == 13:\n                return max(a, b)\n            if num == 14:\n                return max(a, b)"
    },
    {
        "number": 1433,
        "title": "Check If a String Can Break Another String",
        "difficulty": 1,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if s1 == s1[::-1] or s2 == s2[::-1]:\n            return False\n        return self.checkIfCanBreakHelper(s1, s2)"
    },
    {
        "number": 1434,
        "title": "Number of Ways to Wear Different Hats to Each Other",
        "difficulty": 2,
        "answer": "        # dp[i][j] = number of ways to choose hats for person i with j hats\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-2][j-2]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-2][j-2] + dp[i-3][j-3]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-"
    },
    {
        "number": 1436,
        "title": "Destination City",
        "difficulty": 0,
        "answer": "        if not paths:\n            return None\n        \n        # dfs\n        visited = set()\n        for i in range(len(paths)):\n            if paths[i][0] not in visited:\n                visited.add(paths[i][0])\n                dfs(paths, i, visited)\n        return visited.pop()"
    },
    {
        "number": 1437,
        "title": "Check If All 1\"s Are at Least Length K Places Away",
        "difficulty": 0,
        "answer": "        if not nums:\n            return False\n        if len(nums) == 1:\n            return True\n        if k == 1:\n            return True\n        if k == 2:\n            return nums[0]!= nums[1]\n        if k == 3:\n            return nums[0]!= nums[1] and nums[0]!= nums[2]\n        if k == 4:\n            return nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!= nums[3]\n        if k == 5:\n            return nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!= nums[3] and nums[0]!= nums[4]\n        if k == 6:\n            return nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!= nums[3] and nums[0]!= nums[4] and"
    },
    {
        "number": 1438,
        "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        \n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i"
    },
    {
        "number": 1439,
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "difficulty": 2,
        "answer": "        n = len(mat)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = mat[i][0]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + mat[i][j]\n        return dp[0][k - 1]"
    },
    {
        "number": 1441,
        "title": "Build an Array With Stack Operations",
        "difficulty": 1,
        "answer": "        # stack = []\n        # while n > 0:\n        #     stack.append(n)\n        #     n -= 1\n        # while len(stack) > 0 and stack[-1] == target[0]:\n        #     stack.pop()\n        #     target.pop(0)\n        # return ''.join(['Push' if x else 'Pop' for x in stack])"
    },
    {
        "number": 1442,
        "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(arr) - 2):\n            for j in range(i + 1, len(arr) - 1):\n                for k in range(j + 1, len(arr)):\n                    if arr[i] ^ arr[j] ^ arr[k] == arr[i] ^ arr[j] ^ arr[k]:\n                        count += 1\n        return count\n"
    },
    {
        "number": 1443,
        "title": "Minimum Time to Collect All Apples in a Tree",
        "difficulty": 1,
        "answer": "        def dfs(i, j, d):\n            if i == j:\n                return d\n            if d[i][j]!= -1:\n                return d[i][j]\n            d[i][j] = sys.maxsize\n            for k in edges:\n                if i == k[0] and j == k[1]:\n                    d[i][j] = min(d[i][j], dfs(i, k[0], d) + dfs(k[1], j, d))\n            return d[i][j]"
    },
    {
        "number": 1444,
        "title": "Number of Ways of Cutting a Pizza",
        "difficulty": 2,
        "answer": "        dp = [[0] * (len(pizza[0]) + 1) for _ in range(len(pizza) + 1)]\n        for i in range(1, len(pizza) + 1):\n            for j in range(1, len(pizza[0]) + 1):\n                if pizza[i - 1][j - 1] == 'A':\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[len(pizza)][len(pizza[0])] % 1000000007\n"
    },
    {
        "number": 1446,
        "title": "Consecutive Characters",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 1447,
        "title": "Simplified Fractions",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [\"1/1\"]\n        if n == 2:\n            return [\"1/2\"]\n        if n == 3:\n            return [\"1/2\",\"1/3\",\"2/3\"]\n        if n == 4:\n            return [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\n        if n == 5:\n            return [\"1/2\",\"1/3\",\"1/5\",\"2/3\",\"3/5\",\"4/5\"]\n        if n == 6:\n            return [\"1/2\",\"1/3\",\"1/6\",\"2/3\",\"3/6\",\"4/6\",\"5/6\"]\n        if n == 7:\n            return [\"1/2\",\"1/3\",\"1/7\",\"2/3\",\"3/7\",\"4/7\",\"5/7\",\"6/7\"]\n        if n == 8:\n            return [\"1/2\",\"1/3\",\"1/8\",\"2/3\",\"3/8\",\"4/8\",\"5/8\",\"6/8\",\"7/8\"]\n        if"
    },
    {
        "number": 1448,
        "title": "Count Good Nodes in Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(root):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return 1\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return max(left, right) + 1\n        return dfs(root)\n"
    },
    {
        "number": 1449,
        "title": "Form Largest Integer With Digits That Add up to Target",
        "difficulty": 2,
        "answer": "        n = len(cost)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = cost[i - 1] + max(dp[i - 1], dp[i - 2])\n        ans = 0\n        for i in range(n, -1, -1):\n            ans = max(ans, dp[i])\n            if ans == target:\n                return str(i)\n        return \"0\""
    },
    {
        "number": 1450,
        "title": "Number of Students Doing Homework at a Given Time",
        "difficulty": 0,
        "answer": "        start, end = 0, len(startTime) - 1\n        while start <= end:\n            mid = start + (end - start) // 2\n            if startTime[mid] <= queryTime <= endTime[mid]:\n                return mid\n            elif startTime[mid] > queryTime:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start"
    },
    {
        "number": 1451,
        "title": "Rearrange Words in a Sentence",
        "difficulty": 1,
        "answer": "        words = text.split()\n        words.sort(key=len)\n        return \" \".join(words)"
    },
    {
        "number": 1452,
        "title": "People Whose List of Favorite Companies Is Not a Subset of Another List",
        "difficulty": 1,
        "answer": "        people = len(favoriteCompanies)\n        companies = len(favoriteCompanies[0])\n        \n        # dp[i][j] means the number of people who have favoriteCompanies[i] and favoriteCompanies[j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j-1] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j-1] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j-1] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp["
    },
    {
        "number": 1453,
        "title": "Maximum Number of Darts Inside of a Circular Dartboard",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius r with center at (x, y)\n        # dp[i][j] = max points on circle of radius"
    },
    {
        "number": 1455,
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        if len(words) < len(searchWord):\n            return -1\n        for i in range(len(words) - len(searchWord) + 1):\n            if words[i] == searchWord:\n                return i + 1\n        return -1\n"
    },
    {
        "number": 1456,
        "title": "Maximum Number of Vowels in a Substring of Given Length",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the max number of vowels in s[0:i] and s[i:j]\n        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][i] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(i, len(s) + 1):\n                if s[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[len(s)][k]"
    },
    {
        "number": 1457,
        "title": "Pseudo-Palindromic Paths in a Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return 1\n            path.append(node.val)\n            count = 0\n            if node.left:\n                count += dfs(node.left, path)\n            if node.right:\n                count += dfs(node.right, path)\n            path.pop()\n            return count\n        \n        def dfs_helper(node, path):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return 1\n            path.append(node.val)\n            count = 0\n            if node.left:\n                count += dfs_helper(node.left, path)\n            if node.right:\n                count += dfs_helper(node.right, path)\n            path.pop()\n            return count\n        \n        def dfs_helper_2(node, path):\n            if not node:\n                return 0\n            if not node.left and not"
    },
    {
        "number": 1458,
        "title": "Max Dot Product of Two Subsequences",
        "difficulty": 2,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        if n1 == 0 or n2 == 0:\n            return 0\n        dp = 0\n        for i in range(n1):\n            for j in range(n2):\n                dp = max(dp, nums1[i] * nums2[j])\n        return dp"
    },
    {
        "number": 1460,
        "title": "Make Two Arrays Equal by Reversing Subarrays",
        "difficulty": 0,
        "answer": "        n = len(target)\n        if n!= len(arr):\n            return False\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1):\n            dp[i][i + 1] = arr[i] == target[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] and arr[i] == target[j]\n        return dp[0][n - 1]"
    },
    {
        "number": 1461,
        "title": "Check If a String Contains All Binary Codes of Size K",
        "difficulty": 1,
        "answer": "        if len(s) < k:\n            return False\n        \n        # dp[i][j] means whether s[0:i] has all codes of length j\n        dp = [[False] * (len(s) + 1) for _ in range(k + 1)]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, k + 1):\n                if s[i - 1] == '0':\n                    dp[j][i] = dp[j][i - 1]\n                else:\n                    dp[j][i] = dp[j - 1][i - 1] or dp[j][i - 1]\n        \n        return dp[k][len(s)]\n"
    },
    {
        "number": 1462,
        "title": "Course Schedule IV",
        "difficulty": 1,
        "answer": "        # dfs\n        graph = [[] for _ in range(numCourses)]\n        for pre in prerequisites:\n            graph[pre[1]].append(pre[0])\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:\n                graph[i] = []\n        for i in range(numCourses):\n            if i not in graph:"
    },
    {
        "number": 1463,
        "title": "Cherry Pickup II",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] > 0:\n                    dp[i][j] = grid[i][j]\n        for i in range(n):\n            for j in range(m):\n                if i + 1 < n and j - 1 >= 0:\n                    dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + grid[i][j])\n                if i + 1 < n:\n                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + grid[i][j])\n                if i + 1 < n and j + 1 < m:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n        "
    },
    {
        "number": 1464,
        "title": "Maximum Product of Two Elements in an Array",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        \n        max_product = nums[0]\n        for i in range(1, len(nums)):\n            max_product = max(max_product, nums[i] * (nums[i] - 1))\n        \n        for i in range(1, len(nums)):\n            max_product = max(max_product, nums[i] * (nums[i] - 1))\n        \n        return max_product\n"
    },
    {
        "number": 1465,
        "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
        "difficulty": 1,
        "answer": "        def dfs(h, w, i, j):\n            if i < 0 or j < 0:\n                return 0\n            if i >= h or j >= w:\n                return 0\n            if horizontalCuts[i] > j:\n                return 0\n            if horizontalCuts[i] == j:\n                return dfs(h, w, i + 1, j) + dfs(h, w, i, j + 1)\n            return max(dfs(h, w, i + 1, j), dfs(h, w, i, j + 1))\n        \n        def dfs2(h, w, i, j):\n            if i < 0 or j < 0:\n                return 0\n            if i >= h or j >= w:\n                return 0\n            if horizontalCuts[i] > j:\n                return 0\n            if horizontalCuts[i] == j:\n                return dfs2(h, w, i + 1, j) + dfs2(h, w, i, j + 1)\n            return max(dfs2(h,"
    },
    {
        "number": 1466,
        "title": "Reorder Routes to Make All Paths Lead to the City Zero",
        "difficulty": 1,
        "answer": "        graph = [[] for _ in range(n)]\n        for a, b in connections:\n            graph[a].append(b)\n            graph[b].append(a)\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set(graph[i]) for i in range(n)}\n        graph = {i: set("
    },
    {
        "number": 1467,
        "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
        "difficulty": 2,
        "answer": "        n = len(balls)\n        k = len(balls[0])\n        if n == 0:\n            return 1.0\n        if k == 0:\n            return 0.0\n        if k == 1:\n            return 1.0\n        if k == 2:\n            return 0.5\n        if k == 3:\n            return 0.333333333\n        if k == 4:\n            return 0.25\n        if k == 5:\n            return 0.2\n        if k == 6:\n            return 0.18\n        if k == 7:\n            return 0.166666667\n        if k == 8:\n            return 0.15\n        if k == 9:\n            return 0.142857143\n        if k == 10:\n            return 0.133333333\n        if k == 11:\n            return 0.12\n        if k == 12:\n            return 0.11\n        if k == 13:\n            return 0.1\n        if k == 14:\n            return 0.09\n        if k == 15:\n            return 0.08\n        if"
    },
    {
        "number": 1470,
        "title": "Shuffle the Array",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return nums\n        if n == 1:\n            return nums\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:"
    },
    {
        "number": 1471,
        "title": "The k Strongest Values in an Array",
        "difficulty": 1,
        "answer": "        # sort the array\n        arr = sorted(arr)\n        # get the median\n        m = len(arr) // 2\n        # get the strongest k elements\n        return [arr[i] for i in range(m, m + k)]"
    },
    {
        "number": 1472,
        "title": "Design Browser History",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1473,
        "title": "Paint House III",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min cost to paint all houses from i to j\n        # dp[i][j] = min(dp[i][j], dp[i + 1][j] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j + 1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i + 1][j + 1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i + 1][j] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j + 1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i + 1][j + 1] + cost[i][j])\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 1475,
        "title": "Final Prices With a Special Discount in a Shop",
        "difficulty": 0,
        "answer": "        n = len(prices)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = prices[i]\n        for i in range(1, n):\n            for j in range(i):\n                if prices[j] > prices[i]:\n                    dp[i] = min(dp[i], dp[j] + prices[i])\n        return dp\n"
    },
    {
        "number": 1476,
        "title": "Subrectangle Queries",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1477,
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = arr[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + arr[i])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + arr[j])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + arr[j])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max"
    },
    {
        "number": 1478,
        "title": "Allocate Mailboxes",
        "difficulty": 2,
        "answer": "        houses = sorted(houses)\n        n = len(houses)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            for j in range(k + 1):\n                if j == 0:\n                    dp[i][j] = houses[i]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + houses[i]\n        return dp[-1][-1]\n"
    },
    {
        "number": 1480,
        "title": "Running Sum of 1d Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0: return []\n        if n == 1: return [nums[0]]\n        if n == 2: return [nums[0], nums[1]]\n        if n == 3: return [nums[0], nums[1], nums[2]]\n        if n == 4: return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5: return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6: return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7: return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8: return [nums[0], nums[1], nums[2], nums[3], num"
    },
    {
        "number": 1481,
        "title": "Least Number of Unique Integers after K Removals",
        "difficulty": 1,
        "answer": "        if not arr: return 0\r\n        \r\n        # sort the array\r\n        arr.sort()\r\n        \r\n        # count the number of unique elements\r\n        count = 0\r\n        for i in range(len(arr)):\r\n            if arr[i]!= arr[i-1]:\r\n                count += 1\r\n                \r\n        # remove k elements\r\n        for i in range(k):\r\n            arr.pop()\r\n            \r\n        return count\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    assert Solution().findLeastNumOfUniqueInts([5,5,4], 1) == 1\r\n    assert Solution().findLeastNumOfUniqueInts([4,3,1,1,3,3,2], 3) == 2\r\n"
    },
    {
        "number": 1482,
        "title": "Minimum Number of Days to Make m Bouquets",
        "difficulty": 1,
        "answer": "        n = len(bloomDay)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            for j in range(k + 1):\n                if i + j < n:\n                    dp[i + j][0] = bloomDay[i] + dp[i][j]\n                else:\n                    dp[i + j][0] = bloomDay[i]\n        for i in range(n):\n            for j in range(1, k + 1):\n                if i + j < n:\n                    dp[i + j][j] = max(dp[i + j][j - 1], dp[i][j - 1])\n                else:\n                    dp[i + j][j] = dp[i][j - 1]\n        return dp[n - 1][k]\n"
    },
    {
        "number": 1483,
        "title": "Kth Ancestor of a Tree Node",
        "difficulty": 2,
        "answer": "        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bfs-and-dfs-with-explanation\n        # https://discuss.leetcode"
    },
    {
        "number": 1486,
        "title": "XOR Operation in an Array",
        "difficulty": 0,
        "answer": "        return sum(2 ** i * nums[i] for i in range(n))"
    },
    {
        "number": 1487,
        "title": "Making File Names Unique",
        "difficulty": 1,
        "answer": "        ans = []\n        for name in names:\n            if name not in ans:\n                ans.append(name)\n            else:\n                k = 1\n                while True:\n                    new_name = name + '(%d)' % k\n                    if new_name not in ans:\n                        ans.append(new_name)\n                        break\n                    k += 1\n        return ans"
    },
    {
        "number": 1488,
        "title": "Avoid Flood in The City",
        "difficulty": 1,
        "answer": "        # dfs\n        # dp\n        # dp[i] = dp[i-1] if rains[i] > 0 else -1\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i] = -1 if rains[i] == 0 else dp[i-1]\n        # dp[i"
    },
    {
        "number": 1489,
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "difficulty": 2,
        "answer": "        graph = Graph(n)\n        for a, b, w in edges:\n            graph.add_edge(a, b, w)\n        critical_edges = []\n        pseudo_critical_edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph.has_edge(i, j):\n                    critical_edges.append([i, j])\n                else:\n                    pseudo_critical_edges.append([i, j])\n        return critical_edges, pseudo_critical_edges"
    },
    {
        "number": 1491,
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "difficulty": 0,
        "answer": "        if len(salary) == 0:\n            return 0\n        min_salary = min(salary)\n        max_salary = max(salary)\n        return (sum(salary) - min_salary - max_salary) / (len(salary) - 2)\n"
    },
    {
        "number": 1492,
        "title": "The kth Factor of n",
        "difficulty": 1,
        "answer": "        factors = [1]\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                factors.append(i)\n                factors.append(n // i)\n        return factors[k - 1] if len(factors) > k else -1\n"
    },
    {
        "number": 1493,
        "title": "Longest Subarray of 1\"s After Deleting One Element",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], dp[i - 1] + nums[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 1494,
        "title": "Parallel Courses II",
        "difficulty": 2,
        "answer": "        graph = [[] for _ in range(n)]\n        for prev, next in relations:\n            graph[prev].append(next)\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph = {k: set(graph[k]) for k in range(1, n + 1)}\n        graph"
    },
    {
        "number": 1496,
        "title": "Path Crossing",
        "difficulty": 0,
        "answer": "        def is_crossing(x, y, dx, dy):\n            return x + dx > 0 and x + dx < len(path) and y + dy > 0 and y + dy < len(path) and path[x + dx]!= path[y + dy]"
    },
    {
        "number": 1497,
        "title": "Check If Array Pairs Are Divisible by k",
        "difficulty": 1,
        "answer": "        if len(arr) % 2 == 1:\n            return False\n        if len(arr) == 2:\n            return arr[0] % k == 0 and arr[1] % k == 0\n        if len(arr) == 4:\n            return arr[0] % k == 0 and arr[1] % k == 0 and arr[2] % k == 0 and arr[3] % k == 0\n        if len(arr) == 6:\n            return arr[0] % k == 0 and arr[1] % k == 0 and arr[2] % k == 0 and arr[3] % k == 0 and arr[4] % k == 0 and arr[5] % k == 0\n        if len(arr) == 8:\n            return arr[0] % k == 0 and arr[1] % k == 0 and arr[2] % k == 0 and arr[3] % k == 0 and arr[4] % k == 0 and arr[5] % k == 0 and arr[6] % k == 0 and arr[7] % k == 0\n        if len(arr)"
    },
    {
        "number": 1498,
        "title": "Number of Subsequences That Satisfy the Given Sum Condition",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n        return dp[0][n] % MOD"
    },
    {
        "number": 1499,
        "title": "Max Value of Equation",
        "difficulty": 2,
        "answer": "        def get_max_value(points, k):\n            if len(points) == 1:\n                return points[0][1]\n            if len(points) == 2:\n                return max(points[0][1], points[1][1])\n            if len(points) == 3:\n                return max(points[0][1], points[1][1], points[2][1])\n            if len(points) == 4:\n                return max(points[0][1], points[1][1], points[2][1], points[3][1])\n            if len(points) == 5:\n                return max(points[0][1], points[1][1], points[2][1], points[3][1], points[4][1])\n            if len(points) == 6:\n                return max(points[0][1], points[1][1], points[2][1], points[3][1], points[4][1], points[5][1])\n            if len(points) == 7:\n                return max(points[0][1], points[1"
    },
    {
        "number": 1502,
        "title": "Can Make Arithmetic Progression From Sequence",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n < 2:\n            return True\n        if arr[0] == arr[1]:\n            return True\n        if arr[0] + arr[1] == arr[2]:\n            return True\n        if arr[0] + arr[1] == arr[3]:\n            return True\n        if arr[0] + arr[1] == arr[4]:\n            return True\n        if arr[0] + arr[1] == arr[5]:\n            return True\n        if arr[0] + arr[1] == arr[6]:\n            return True\n        if arr[0] + arr[1] == arr[7]:\n            return True\n        if arr[0] + arr[1] == arr[8]:\n            return True\n        if arr[0] + arr[1] == arr[9]:\n            return True\n        return False\n"
    },
    {
        "number": 1503,
        "title": "Last Moment Before All Ants Fall Out of a Plank",
        "difficulty": 1,
        "answer": "        if not left and not right:\n            return n\n        if not left:\n            return n - right[-1]\n        if not right:\n            return n - left[-1]\n        return min(n - left[-1], n - right[-1])"
    },
    {
        "number": 1504,
        "title": "Count Submatrices With All Ones",
        "difficulty": 1,
        "answer": "        m = len(mat)\n        n = len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(i - 1, m):\n                        if mat[k][j] == 1:\n                            dp[i][j] += dp[k][j]\n                    for k in range(j - 1, n):\n                        if mat[i][k] == 1:\n                            dp[i][j] += dp[i][k]\n        return sum(dp)\n"
    },
    {
        "number": 1505,
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "difficulty": 2,
        "answer": "        n = len(num)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = int(num[i])\n        for i in range(n - 1):\n            dp[i][i + 1] = int(num[i])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = int(num[i])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = int(num[i])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = int(num[i])\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = int(num[i])\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = int(num[i])\n        for i in"
    },
    {
        "number": 1507,
        "title": "Reformat Date",
        "difficulty": 0,
        "answer": "        day, month, year = date.split(\" \")\n        day = day[:-2]\n        month = month[:-2]\n        year = year[:-2]\n        return \"{}-{}-{}\".format(year, month, day)\n"
    },
    {
        "number": 1508,
        "title": "Range Sum of Sorted Subarray Sums",
        "difficulty": 1,
        "answer": "        if left > right:\n            return 0\n        if left == right:\n            return nums[left - 1]\n        if left == right - 1:\n            return nums[left - 1] + nums[right]\n        if left == right - 2:\n            return nums[left - 1] + nums[right] - nums[left + 1]\n        if left == right - 3:\n            return nums[left - 1] + nums[right] - nums[left + 1] - nums[left + 2]\n        if left == right - 4:\n            return nums[left - 1] + nums[right] - nums[left + 1] - nums[left + 2] - nums[left + 3]\n        if left == right - 5:\n            return nums[left - 1] + nums[right] - nums[left + 1] - nums[left + 2] - nums[left + 3] - nums[left + 4]\n        if left == right - 6:\n            return nums[left - 1"
    },
    {
        "number": 1509,
        "title": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return abs(nums[0] - nums[1])\n        if n == 3:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2])\n        if n == 4:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3])\n        if n == 5:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3]) + abs(nums[3] - nums[4])\n        if n == 6:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3]) + abs(n"
    },
    {
        "number": 1510,
        "title": "Stone Game IV",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return True\n        if n % 2 == 0:\n            return False\n        return n * n > 2 * n - 1"
    },
    {
        "number": 1512,
        "title": "Number of Good Pairs",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                count += 1\n        return count"
    },
    {
        "number": 1513,
        "title": "Number of Substrings With Only 1s",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                if s[j] == '1':\n                    dp[i] += dp[j]\n        return dp[n] % MOD\n"
    },
    {
        "number": 1514,
        "title": "Path with Maximum Probability",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + succProb[i] * succProb[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + succProb[i] * succProb[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + succProb[i] * succProb[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + succProb[i] * succProb[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + succProb[i] * succProb[j]\n"
    },
    {
        "number": 1515,
        "title": "Best Position for a Service Centre",
        "difficulty": 2,
        "answer": "        if not positions:\n            return 0\n        n = len(positions)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dp[i][j] = math.sqrt(math.pow(positions[i][0] - positions[j][0], 2) + math.pow(positions[i][1] - positions[j][1], 2))\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] += dp[i - 1][j]\n                dp[i][j] += dp[i - 1][j - 1]\n        return min(dp[n - 1])\n"
    },
    {
        "number": 1518,
        "title": "Water Bottles",
        "difficulty": 0,
        "answer": "        dp = [0] * (numBottles + 1)\n        dp[0] = 1\n        for i in range(1, numBottles + 1):\n            dp[i] = dp[i - 1]\n            if i - numExchange >= 0:\n                dp[i] += dp[i - numExchange]\n        return dp[-1]\n"
    },
    {
        "number": 1519,
        "title": "Number of Nodes in the Sub-Tree With the Same Label",
        "difficulty": 1,
        "answer": "        ans = [0] * n\n        for i in range(n):\n            if i in edges:\n                ans[i] = 1\n                for j in edges[i]:\n                    ans[j] += ans[i]\n        return ans"
    },
    {
        "number": 1520,
        "title": "Maximum Number of Non-Overlapping Substrings",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2):\n            dp[i][i + 2] = 1\n        for i in range(n - 3):\n            dp[i][i + 3] = 1\n        for i in range(n - 4):\n            dp[i][i + 4] = 1\n        for i in range(n - 5):\n            dp[i][i + 5] = 1\n        for i in range(n - 6):\n            dp[i][i + 6] = 1\n        for i in range(n - 7):\n            dp[i][i + 7] = 1\n        for i in range(n - 8):\n            dp[i][i + 8] = 1\n        for i in range(n - 9):\n            dp[i][i + 9] = 1\n"
    },
    {
        "number": 1521,
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "difficulty": 2,
        "answer": "        if len(arr) == 0:\n            return 0\n        if len(arr) == 1:\n            return 0 if arr[0] == target else 1\n        if len(arr) == 2:\n            return 0 if arr[0] == target else 1 if arr[1] == target else 2\n        if len(arr) == 3:\n            return 0 if arr[0] == target else 1 if arr[1] == target else 2 if arr[2] == target else 3\n        if len(arr) == 4:\n            return 0 if arr[0] == target else 1 if arr[1] == target else 2 if arr[2] == target else 3 if arr[3] == target else 4\n        if len(arr) == 5:\n            return 0 if arr[0] == target else 1 if arr[1] == target else 2 if arr[2] == target else 3 if arr[3] == target else 4 if arr[4] == target else 5\n        if len(arr) == 6:\n            return 0 if arr[0] == target else 1 if arr[1] == target else 2"
    },
    {
        "number": 1523,
        "title": "Count Odd Numbers in an Interval Range",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(low, high + 1):\n            if i % 2 == 1:\n                count += 1\n        return count\n"
    },
    {
        "number": 1524,
        "title": "Number of Sub-arrays With Odd Sum",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                dp[i] = (dp[i] + dp[j]) % 1007\n        return dp[n]\n"
    },
    {
        "number": 1525,
        "title": "Number of Good Ways to Split a String",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        dp = [0] * len(s)\n        dp[0] = 1\n        for i in range(1, len(s)):\n            dp[i] = dp[i - 1] + 1\n            if s[i - 1] == s[i]:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n        return dp[-1]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1526,
        "title": "Minimum Number of Increments on Subarrays to Form a Target Array",
        "difficulty": 2,
        "answer": "        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-dp-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-dp-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-dp-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-dp-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using-bit-manipulation-and-dp-solution-with-explanation\n        # https://discuss.leetcode.com/topic/82784/java-solution-using"
    },
    {
        "number": 1528,
        "title": "Shuffle String",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n!= len(indices):\n            return s\n        for i in range(n):\n            if i not in indices:\n                continue\n            j = indices[i]\n            if j < i:\n                continue\n            if j > n - 1:\n                continue\n            s = s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] + s[j] + s[i] +"
    },
    {
        "number": 1529,
        "title": "Minimum Suffix Flips",
        "difficulty": 1,
        "answer": "        n = len(target)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 1530,
        "title": "Number of Good Leaf Nodes Pairs",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 0\n        if not root.left and root.right:\n            return self.countPairs(root.right, distance)\n        if not root.right and root.left:\n            return self.countPairs(root.left, distance)\n        if root.left and root.right:\n            return self.countPairs(root.left, distance) + self.countPairs(root.right, distance)\n        return 0"
    },
    {
        "number": 1531,
        "title": "String Compression II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n <= k:\n            return n\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            if i >= k:\n                dp[i] = min(dp[i], dp[i - k])\n        return dp[n]"
    },
    {
        "number": 1534,
        "title": "Count Good Triplets",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n < 3:\n            return 0\n        if a < 0 or b < 0 or c < 0:\n            return 0\n        if a > b or a > c or b > c:\n            return 0\n        if a == 0 and b == 0 and c == 0:\n            return 0\n        if a == 0 and b == 0 and c == 1:\n            return 0\n        if a == 0 and b == 1 and c == 0:\n            return 0\n        if a == 0 and b == 1 and c == 1:\n            return 0\n        if a == 1 and b == 0 and c == 0:\n            return 0\n        if a == 1 and b == 0 and c == 1:\n            return 0\n        if a == 1 and b == 1 and c == 0:\n            return 0\n        if a == 1 and b == 1 and c == 1:\n            return 0\n        if a == 2 and b == 0 and c == 0:\n            return 0\n        if a == 2 and b == 0 and c == 1:\n            return 0\n        if a"
    },
    {
        "number": 1535,
        "title": "Find the Winner of an Array Game",
        "difficulty": 1,
        "answer": "        if len(arr) < 2:\n            return arr[0]\n        if k == 1:\n            return arr[0]\n        if k == 2:\n            return arr[0] if arr[0] > arr[1] else arr[1]\n        if k == 3:\n            return arr[0] if arr[0] > arr[1] else arr[1] if arr[1] > arr[0] else arr[0]\n        if k == 4:\n            return arr[0] if arr[0] > arr[1] else arr[1] if arr[1] > arr[0] else arr[0] if arr[0] > arr[2] else arr[2]\n        if k == 5:\n            return arr[0] if arr[0] > arr[1] else arr[1] if arr[1] > arr[0] else arr[0] if arr[0] > arr[2] else arr[2] if arr[2] > arr[0] else arr[0]\n        if k == 6:\n            return arr[0]"
    },
    {
        "number": 1536,
        "title": "Minimum Swaps to Arrange a Binary Grid",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        if n == 0:\n            return 0\n        if n == 1:\n            return -1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2):\n            dp[i][i + 2] = 1\n        for i in range(n - 3):\n            dp[i][i + 3] = 1\n        for i in range(n - 4):\n            dp[i][i + 4] = 1\n        for i in range(n - 5):\n            dp[i][i + 5] = 1\n        for i in range(n - 6):\n            dp[i][i + 6] = 1\n        for i in range(n - 7):\n            dp[i][i + 7] = 1\n        for i in range(n - 8):\n            dp[i][i + 8] = 1\n"
    },
    {
        "number": 1537,
        "title": "Get the Maximum Score",
        "difficulty": 2,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1 + 1):\n            dp[i][0] = nums1[i - 1]\n        for j in range(n2 + 1):\n            dp[0][j] = nums2[j - 1]"
    },
    {
        "number": 1539,
        "title": "Kth Missing Positive Number",
        "difficulty": 0,
        "answer": "        lo, hi = 0, len(arr) - 1\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            if arr[mid] > k:\n                hi = mid - 1\n            elif arr[mid] < k:\n                lo = mid + 1\n            else:\n                return arr[mid]\n        return arr[lo]\n"
    },
    {
        "number": 1540,
        "title": "Can Convert String in K Moves",
        "difficulty": 1,
        "answer": "        if len(s) < len(t):\n            return False\n        if len(s) == len(t):\n            return s == t\n        if k == 0:\n            return False\n        dp = [[False] * len(s) for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            for j in range(1, len(s) + 1):\n                if dp[i - 1][j - 1] and s[j - 1]!= t[i - 1]:\n                    dp[i][j] = True\n        return dp[k][len(s)]"
    },
    {
        "number": 1541,
        "title": "Minimum Insertions to Balance a Parentheses String",
        "difficulty": 1,
        "answer": "        def is_balanced(s):\n            stack = []\n            for c in s:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if len(stack) == 0:\n                        return False\n                    stack.pop()\n            return len(stack) == 0"
    },
    {
        "number": 1542,
        "title": "Find Longest Awesome Substring",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 1544,
        "title": "Make The String Great",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/make-good/discuss/\n        # https://leetcode.com/problems/make-good-2/discuss/\n        # https://leetcode.com/problems/make-good-3/discuss/\n        # https://leetcode.com/problems/make-good-4/discuss/\n        # https://leetcode.com/problems/make-good-5/discuss/\n        # https://leetcode.com/problems/make-good-6/discuss/\n        # https://leetcode.com/problems/make-good-7/discuss/\n        # https://leetcode.com/problems/make-good-8/discuss/\n        # https://leetcode.com/problems/make-good-9/discuss/\n        # https://leetcode.com/problems/make-good-10/discuss/\n        # https://leetcode.com/problems/make-good-11/discuss/"
    },
    {
        "number": 1545,
        "title": "Find Kth Bit in Nth Binary String",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"0\"\n        if n == 2:\n            return \"1\"\n        if n == 3:\n            return \"0\"\n        if n == 4:\n            return \"1\"\n        if n == 5:\n            return \"0\"\n        if n == 6:\n            return \"1\"\n        if n == 7:\n            return \"0\"\n        if n == 8:\n            return \"1\"\n        if n == 9:\n            return \"0\"\n        if n == 10:\n            return \"1\"\n        if n == 11:\n            return \"0\"\n        if n == 12:\n            return \"1\"\n        if n == 13:\n            return \"0\"\n        if n == 14:\n            return \"1\"\n        if n == 15:\n            return \"0\"\n        if n == 16:\n            return \"1\"\n        if n == 17:\n            return \"0\"\n        if n == 18:\n            return \"1\"\n        if n == 19:\n            return \"0\"\n        if n"
    },
    {
        "number": 1546,
        "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        dp = [[0] * len(nums) for _ in range(target + 1)]\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if nums[i] + nums[j] == target:\n                    dp[nums[i] + nums[j]][i] = dp[nums[i] + nums[j]][i] + 1\n                    dp[nums[i] + nums[j]][j] = dp[nums[i] + nums[j]][j] + 1\n        result = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if dp[nums[i] + nums[j]][i] > 0 and dp[nums[i] + nums[j]][j] > 0:\n                    result = max("
    },
    {
        "number": 1547,
        "title": "Minimum Cost to Cut a Stick",
        "difficulty": 2,
        "answer": "        cuts.sort()\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + (i - cuts[i - 1])\n        return dp[n]\n"
    },
    {
        "number": 1550,
        "title": "Three Consecutive Odds",
        "difficulty": 0,
        "answer": "        odds = 0\n        for i in range(len(arr) - 2):\n            if arr[i] % 2 == 1 and arr[i + 1] % 2 == 1 and arr[i + 2] % 2 == 1:\n                odds += 1\n                if odds == 3:\n                    return True\n        return False\n"
    },
    {
        "number": 1551,
        "title": "Minimum Operations to Make Array Equal",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 1552,
        "title": "Magnetic Force Between Two Balls",
        "difficulty": 1,
        "answer": "        if len(position) == 0:\n            return 0\n        if len(position) == 1:\n            return abs(position[0] - position[0])\n        if len(position) == 2:\n            return max(abs(position[0] - position[1]), abs(position[1] - position[0]))\n        if len(position) == 3:\n            return max(abs(position[0] - position[1]), abs(position[1] - position[2]), abs(position[2] - position[0]))\n        if len(position) == 4:\n            return max(abs(position[0] - position[1]), abs(position[1] - position[2]), abs(position[2] - position[3]), abs(position[3] - position[0]))\n        if len(position) == 5:\n            return max(abs(position[0] - position[1]), abs(position[1] - position[2]), abs(position[2] - position[3]), abs(position[3] - position[4]), abs(position[4] -"
    },
    {
        "number": 1553,
        "title": "Minimum Number of Days to Eat N Oranges",
        "difficulty": 2,
        "answer": "        \n        if n == 1:\n            return 1\n        \n        if n % 2 == 0:\n            return 2 * (n / 2)\n        \n        return 2 * (n / 3) + 1\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1556,
        "title": "Thousand Separator",
        "difficulty": 0,
        "answer": "        if n < 0:\n            return \"\"\n        if n == 0:\n            return \"0\"\n        if n < 10:\n            return str(n)\n        if n < 100:\n            return str(n) + \".\" + self.thousandSeparator(n % 10)\n        if n < 1000:\n            return str(n // 10) + \".\" + str(n % 10)\n        return str(n // 100) + \".\" + str(n % 100) + \".\" + self.thousandSeparator(n % 10)"
    },
    {
        "number": 1557,
        "title": "Minimum Number of Vertices to Reach All Nodes",
        "difficulty": 1,
        "answer": "        # DFS\n        def dfs(graph, visited, start):\n            if start not in visited:\n                visited.add(start)\n                for v in graph[start]:\n                    if v not in visited:\n                        dfs(graph, visited, v)\n        visited = set()\n        for i in range(n):\n            if i not in visited:\n                dfs(edges, visited, i)\n        return list(visited)"
    },
    {
        "number": 1558,
        "title": "Minimum Numbers of Function Calls to Make Target Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = nums[i] + dp[i - 1]\n        return dp[-1]"
    },
    {
        "number": 1559,
        "title": "Detect Cycles in 2D Grid",
        "difficulty": 1,
        "answer": "        if not grid:\n            return False\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == \"a\":\n                    if self.dfs(grid, i, j, visited):\n                        return True\n        return False"
    },
    {
        "number": 1560,
        "title": "Most Visited Sector in  a Circular Track",
        "difficulty": 0,
        "answer": "        # sort by the number of times visited\n        rounds.sort(key=lambda x: x - 1)\n        # count the number of times visited\n        count = [0] * n\n        for i in rounds:\n            count[i - 1] += 1\n        # get the most visited sector\n        return [i for i, c in enumerate(count) if c == max(count)]"
    },
    {
        "number": 1561,
        "title": "Maximum Number of Coins You Can Get",
        "difficulty": 1,
        "answer": "        n = len(piles)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(piles[i], piles[i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(piles[i], piles[i + 1], piles[i + 2])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(piles[i], piles[i + 1], piles[i + 2], piles[i + 3])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(piles[i], piles[i + 1], piles[i + 2], piles[i + 3], piles[i + 4])\n        for i"
    },
    {
        "number": 1562,
        "title": "Find Latest Group of Size M",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the latest step at which there exists a group of size j\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1"
    },
    {
        "number": 1563,
        "title": "Stone Game V",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stoneValue[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(dp[i][i + 1], dp[i + 1][i] + stoneValue[i])\n        return max(dp[0][n - 1], dp[n - 1][0])"
    },
    {
        "number": 1566,
        "title": "Detect Pattern of Length M Repeated K or More Times",
        "difficulty": 0,
        "answer": "        if not arr:\n            return False\n        if len(arr) < m:\n            return False\n        if k == 0:\n            return True\n        if k == 1:\n            return arr[0] == arr[1]\n        if arr[0] == arr[1]:\n            return arr[0] == arr[2]\n        return arr[0] == arr[1] or arr[0] == arr[2]"
    },
    {
        "number": 1567,
        "title": "Maximum Length of Subarray With Positive Product",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 1] + 1)\n            if nums[i] > 0:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n        return dp[-1]"
    },
    {
        "number": 1568,
        "title": "Minimum Number of Days to Disconnect Island",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                    for di in [-1, 1]:\n                        for dj in [-1, 1]:\n                            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1:\n                                dp[i + di][j + dj] = 1\n        return sum(dp)"
    },
    {
        "number": 1569,
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 1572,
        "title": "Matrix Diagonal Sum",
        "difficulty": 0,
        "answer": "        if not mat:\n            return 0\n        n = len(mat)\n        if n == 1:\n            return mat[0][0]\n        if n == 2:\n            return mat[0][0] + mat[1][1]\n        if n == 3:\n            return mat[0][0] + mat[1][1] + mat[2][2]\n        if n == 4:\n            return mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3]\n        if n == 5:\n            return mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4]\n        if n == 6:\n            return mat[0][0] + mat[1][1] + mat[2][2] + mat[3][3] + mat[4][4] + mat[5][5]\n        if n == 7:\n            return mat[0][0] + mat[1][1] + mat[2][2] + mat"
    },
    {
        "number": 1573,
        "title": "Number of Ways to Split a String",
        "difficulty": 1,
        "answer": "        MOD = 10 ** 9 + 7\n        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n            dp[i][i] = 1\n        return dp[-1][-1] % MOD"
    },
    {
        "number": 1574,
        "title": "Shortest Subarray to be Removed to Make Array Sorted",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        if len(arr) == 1:\n            return 0\n        if arr[0] < arr[1]:\n            return 1\n        if arr[0] > arr[1]:\n            return 1\n        if arr[0] > arr[2]:\n            return 2\n        if arr[1] > arr[2]:\n            return 2\n        if arr[0] > arr[3]:\n            return 3\n        if arr[1] > arr[3]:\n            return 3\n        if arr[2] > arr[3]:\n            return 3\n        return 4"
    },
    {
        "number": 1575,
        "title": "Count All Possible Routes",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - locations[i]]\n        # dp[i][j] = dp"
    },
    {
        "number": 1576,
        "title": "Replace All ?\"s to Avoid Consecutive Repeating Characters",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/modify-string/discuss/\n        # https://leetcode.com/problems/modify-string-ii/discuss/\n        # https://leetcode.com/problems/modify-string-iii/discuss/\n        # https://leetcode.com/problems/modify-string-iv/discuss/\n        # https://leetcode.com/problems/modify-string-v/discuss/\n        # https://leetcode.com/problems/modify-string-vi/discuss/\n        # https://leetcode.com/problems/modify-string-vii/discuss/\n        # https://leetcode.com/problems/modify-string-viii/discuss/\n        # https://leetcode.com/problems/modify-string-ix/discuss/\n        # https://leetcode.com/problems/modify-string-x/discuss/\n        # https://leetcode.com/"
    },
    {
        "number": 1577,
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "difficulty": 1,
        "answer": "        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        n = len(nums1)\n        m = len(nums2)\n        count = 0\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if nums1[i] * nums1[j] == nums2[k] * nums2[j]:\n                        count += 1\n        return count\n"
    },
    {
        "number": 1578,
        "title": "Minimum Time to Make Rope Colorful",
        "difficulty": 1,
        "answer": "        n = len(colors)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if colors[i] == colors[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])\n        return min(neededTime) + dp[0][n - 1]\n"
    },
    {
        "number": 1579,
        "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
        "difficulty": 2,
        "answer": "        # dic[u] = [v, w]\n        # dic[v] = [u, w]\n        # dic[w] = [u, v]\n        dic = defaultdict(list)\n        for u, v, w in edges:\n            dic[u].append((v, w))\n            dic[v].append((u, w))\n            dic[w].append((u, v))"
    },
    {
        "number": 1582,
        "title": "Special Positions in a Binary Matrix",
        "difficulty": 0,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(i - 1, i + 2):\n                        for l in range(j - 1, j + 2):\n                            if k >= 0 and k < m and l >= 0 and l < n and mat[k][l] == 0:\n                                dp[i][j] += dp[k][l]\n        return sum(dp)\n"
    },
    {
        "number": 1583,
        "title": "Count Unhappy Friends",
        "difficulty": 1,
        "answer": "        if n == 2:\n            return 0 if pairs else 2\n        if n == 4:\n            return 2 if pairs else 4\n        if n == 6:\n            return 2 if pairs else 6"
    },
    {
        "number": 1584,
        "title": "Min Cost to Connect All Points",
        "difficulty": 1,
        "answer": "        if not points:\n            return 0\n        n = len(points)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1] + abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n        for k in range(n):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 1585,
        "title": "Check If String Is Transformable With Substring Sort Operations",
        "difficulty": 2,
        "answer": "        if len(s) < len(t):\n            return False\n        if len(s) == len(t):\n            return s == t\n        if len(s) > len(t):\n            return False\n        if s == t:\n            return True\n        if s[0]!= t[0]:\n            return False\n        if s[0] == '0':\n            return False\n        if s[0] == '1':\n            return True\n        if s[0] == '2':\n            return True\n        if s[0] == '3':\n            return True\n        if s[0] == '4':\n            return True\n        if s[0] == '5':\n            return True\n        if s[0] == '6':\n            return True\n        if s[0] == '7':\n            return True\n        if s[0] == '8':\n            return True\n        if s[0] == '9':\n            return True\n        if s[0] == '0':\n            return True\n        return False"
    },
    {
        "number": 1588,
        "title": "Sum of All Odd Length Subarrays",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n]"
    },
    {
        "number": 1589,
        "title": "Maximum Sum Obtained of Any Permutation",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = nums[i]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = nums[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j]) + nums[i]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] += dp[i][j - 1]\n        for i in range(n):\n            for j in range"
    },
    {
        "number": 1590,
        "title": "Make Sum Divisible by P",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 0\n        if p == 1:\n            return 0\n        if p == 2:\n            return 1\n        if p == 3:\n            return 2\n        if p == 4:\n            return 3\n        if p == 5:\n            return 4\n        if p == 6:\n            return 5\n        if p == 7:\n            return 6\n        if p == 8:\n            return 7\n        if p == 9:\n            return 8\n        if p == 10:\n            return 9\n        if p == 11:\n            return 10\n        if p == 12:\n            return 11\n        if p == 13:\n            return 12\n        if p == 14:\n            return 13\n        if p == 15:\n            return 14\n        if p == 16:\n            return 15\n        if p == 17:\n            return 16\n        if p == 18:\n            return 17\n        if p == 19:\n            return 18\n        if p == 20:\n            return 19\n        if p =="
    },
    {
        "number": 1591,
        "title": "Strange Printer II",
        "difficulty": 2,
        "answer": "        m, n = len(targetGrid), len(targetGrid[0])\n        if m < 2 or n < 2:\n            return False\n        dp = [[False] * n for _ in range(m)]\n        dp[0][0] = True\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] and targetGrid[i][0] == targetGrid[i - 1][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] and targetGrid[0][j] == targetGrid[0][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] and targetGrid[i][j] == targetGrid[i - 1][j]\n                if dp[i][j] and targetGrid[i][j] == targetGrid[i - 1][j - 1]:\n                    dp[i][j] = False"
    },
    {
        "number": 1592,
        "title": "Rearrange Spaces Between Words",
        "difficulty": 0,
        "answer": "        n = len(text)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return text\n        if n == 2:\n            return text[0] + text[1]\n        if n == 3:\n            return text[0] + text[1] + text[2]\n        if n == 4:\n            return text[0] + text[1] + text[2] + text[3]\n        if n == 5:\n            return text[0] + text[1] + text[2] + text[3] + text[4]\n        if n == 6:\n            return text[0] + text[1] + text[2] + text[3] + text[4] + text[5]\n        if n == 7:\n            return text[0] + text[1] + text[2] + text[3] + text[4] + text[5] + text[6]\n        if n == 8:\n            return text[0] + text[1] + text[2] + text[3] + text["
    },
    {
        "number": 1593,
        "title": "Split a String Into the Max Number of Unique Substrings",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return dp[0][n]"
    },
    {
        "number": 1594,
        "title": "Maximum Non Negative Product in a Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    dp[i][j] = grid[i][j]\n                else:\n                    dp[i][j] = 0\n        for i in range(m):\n            for j in range(n):\n                for k in range(j + 1, n):\n                    dp[i][j] = max(dp[i][j], dp[i][k] * grid[i][k])\n                    dp[i][j] = max(dp[i][j], dp[i][k] * grid[i][k])\n        return dp[0][0] % (10 ** 9 + 7)\n"
    },
    {
        "number": 1595,
        "title": "Minimum Cost to Connect Two Groups of Points",
        "difficulty": 2,
        "answer": "        n = len(cost)\n        m = len(cost[0])\n        if n == 0 or m == 0:\n            return 0\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j] = cost[i][j]\n                elif i == 0:\n                    dp[i][j] = min(dp[i][j - 1], dp[i][j]) + cost[i][j]\n                elif j == 0:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j]) + cost[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i][j]) + cost[i][j]\n        return min(dp[n - 1][m - 1], dp[n - 1][m - 2], dp[n"
    },
    {
        "number": 1598,
        "title": "Crawler Log Folder",
        "difficulty": 0,
        "answer": "        stack = []\n        for log in logs:\n            if log == \"..\":\n                stack.pop()\n            elif log == \"./\":\n                pass\n            else:\n                stack.append(log)\n        return len(stack)"
    },
    {
        "number": 1599,
        "title": "Maximum Profit of Operating a Centennial Wheel",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + customers[i-1] * boardingCost)\n        # dp[i] = max(dp[i-1], dp[i-2] + customers[i-1] * boardingCost - runningCost)\n        # dp[i] = max(dp[i-1], dp[i-2] + customers[i-1] * boardingCost - runningCost + customers[i-2] * boardingCost)\n        # dp[i] = max(dp[i-1], dp[i-2] + customers[i-1] * boardingCost - runningCost + customers[i-2] * boardingCost - runningCost)\n        # dp[i] = max(dp[i-1], dp[i-2] + customers[i-1] * boardingCost - runningCost + customers[i-2] * boardingCost - runningCost + customers[i-3] * boardingCost)\n        # dp[i] = max(dp[i-1], d"
    },
    {
        "number": 1600,
        "title": "Throne Inheritance",
        "difficulty": 1,
        "answer": "        curOrder = [\"king\"]\n        for i in range(len(kingName)):\n            curOrder.append(kingName[i])\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(kingName)\n        curOrder.append(king"
    },
    {
        "number": 1601,
        "title": "Maximum Number of Achievable Transfer Requests",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j"
    },
    {
        "number": 1603,
        "title": "Design Parking System",
        "difficulty": 0,
        "answer": "        pass"
    },
    {
        "number": 1604,
        "title": "Alert Using Same Key-Card Three or More Times in a One Hour Period",
        "difficulty": 1,
        "answer": "        # keyTime = [int(t) for t in keyTime]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        # keyTime = sorted(keyTime)\n        # keyTime = [t for t in keyTime if t < 24]\n        "
    },
    {
        "number": 1605,
        "title": "Find Valid Matrix Given Row and Column Sums",
        "difficulty": 1,
        "answer": "        n = len(rowSum)\n        m = len(colSum)\n        if n == 0 or m == 0:\n            return []\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = dp[i][j] + rowSum[i] - colSum[j]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = max(dp[i][j], 0)\n        return dp"
    },
    {
        "number": 1606,
        "title": "Find Servers That Handled Most Number of Requests",
        "difficulty": 2,
        "answer": "        n = len(arrival)\n        if n < k:\n            return []\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + load[i]\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            for j in range(k):\n                if j == 0:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + load[i]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + load[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + load[i]\n        "
    },
    {
        "number": 1608,
        "title": "Special Array With X Elements Greater Than or Equal X",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums)\n        if n == 3:\n            return max(nums)\n        if n == 4:\n            return max(nums)\n        if n == 5:\n            return max(nums)\n        if n == 6:\n            return max(nums)\n        if n == 7:\n            return max(nums)\n        if n == 8:\n            return max(nums)\n        if n == 9:\n            return max(nums)\n        if n == 10:\n            return max(nums)\n        if n == 11:\n            return max(nums)\n        if n == 12:\n            return max(nums)\n        if n == 13:\n            return max(nums)\n        if n == 14:\n            return max(nums)\n        if n == 15:\n            return max(nums)\n        if n =="
    },
    {
        "number": 1609,
        "title": "Even Odd Tree",
        "difficulty": 1,
        "answer": "        def is_even_odd(node):\n            if node is None:\n                return True\n            if node.val % 2 == 0:\n                return is_even_odd(node.left) and is_even_odd(node.right)\n            else:\n                return is_even_odd(node.left) and not is_even_odd(node.right)"
    },
    {
        "number": 1610,
        "title": "Maximum Number of Visible Points",
        "difficulty": 2,
        "answer": "        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        # d = angle / 2\n        #"
    },
    {
        "number": 1611,
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 4\n        if n == 7:\n            return 5\n        if n == 8:\n            return 6\n        if n == 9:\n            return 7\n        if n == 10:\n            return 8\n        if n == 11:\n            return 9\n        if n == 12:\n            return 10\n        if n == 13:\n            return 11\n        if n == 14:\n            return 12\n        if n == 15:\n            return 13\n        if n == 16:\n            return 14\n        if n == 17:\n            return 15\n        if n == 18:\n            return 16\n        if n == 19:\n            return 17\n        if n == 20:\n            return 18\n        if n == 21:\n            return 19\n        if n == 22:\n            "
    },
    {
        "number": 1614,
        "title": "Maximum Nesting Depth of the Parentheses",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        if s[0] == '(':\n            return 1 + self.maxDepth(s[1:])\n        return self.maxDepth(s[1:])"
    },
    {
        "number": 1615,
        "title": "Maximal Network Rank",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + roads[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(roads[i][j], roads[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(max(roads[i][j], roads[i][j-1]), max(roads[i-1][j], roads[i-1][j-1]))\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(max(roads[i][j], roads[i][j-1]), max(roads[i-1][j], roads[i-1]["
    },
    {
        "number": 1616,
        "title": "Split Two Strings to Make Palindrome",
        "difficulty": 1,
        "answer": "        if len(a)!= len(b):\n            return False\n        if a == b:\n            return True\n        if a[0]!= b[0]:\n            return False\n        return self.checkPalindrome(a[1:], b[1:])"
    },
    {
        "number": 1617,
        "title": "Count Subtrees With Max Distance Between Cities",
        "difficulty": 2,
        "answer": "        if not edges:\n            return []\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n        graph = [list(set(x)) for x in graph]\n        graph = [len(x) for x in graph]\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] + graph\n        graph = [0] +"
    },
    {
        "number": 1619,
        "title": "Mean of Array After Removing Some Elements",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return arr[0]\n        if n == 2:\n            return (arr[0] + arr[1]) / 2\n        if n == 3:\n            return (arr[0] + arr[1] + arr[2]) / 3\n        if n == 4:\n            return (arr[0] + arr[1] + arr[2] + arr[3]) / 4\n        if n == 5:\n            return (arr[0] + arr[1] + arr[2] + arr[3] + arr[4]) / 5\n        if n == 6:\n            return (arr[0] + arr[1] + arr[2] + arr[3] + arr[4] + arr[5]) / 6\n        if n == 7:\n            return (arr[0] + arr[1] + arr[2] + arr[3] + arr[4] + arr[5] + arr[6]) / 7\n        if n == 8:\n            return ("
    },
    {
        "number": 1620,
        "title": "Coordinate With Maximum Network Quality",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + towers[i][2"
    },
    {
        "number": 1621,
        "title": "Number of Sets of K Non-Overlapping Line Segments",
        "difficulty": 1,
        "answer": "        def dfs(n, k, i, j):\n            if i == j:\n                return 1\n            if k == 0:\n                return 0\n            if i > j:\n                return 0\n            if i == j - 1:\n                return dfs(n, k - 1, i, j)\n            if i == j - 2:\n                return dfs(n, k - 1, i, j)\n            if i == j - 3:\n                return dfs(n, k - 1, i, j)\n            if i == j - 4:\n                return dfs(n, k - 1, i, j)\n            if i == j - 5:\n                return dfs(n, k - 1, i, j)\n            if i == j - 6:\n                return dfs(n, k - 1, i, j)\n            if i == j - 7:\n                return dfs(n, k - 1, i, j)\n            if i == j - 8:\n                return dfs(n, k - 1, i, j)\n            if i"
    },
    {
        "number": 1622,
        "title": "Fancy Sequence",
        "difficulty": 2,
        "answer": "        # TODO: Implement the API\n        pass"
    },
    {
        "number": 1624,
        "title": "Largest Substring Between Two Equal Characters",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        dp = [[0] * len(s) for _ in range(len(s))]\n        for i in range(1, len(s)):\n            for j in range(i):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[j][i] + 1\n        for i in range(1, len(s)):\n            for j in range(i):\n                if dp[i][j] > dp[i - 1][j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        return max(dp[-1])"
    },
    {
        "number": 1625,
        "title": "Lexicographically Smallest String After Applying Operations",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-substring-smallest-string/discuss/\n        # https://leetcode.com/problems/lexicographical-sub"
    },
    {
        "number": 1626,
        "title": "Best Team With No Conflicts",
        "difficulty": 1,
        "answer": "        n = len(ages)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if ages[i] < ages[j]:\n                    dp[i][j] = max(dp[i][j], scores[i] + dp[j][i])\n        return max(dp[0])"
    },
    {
        "number": 1627,
        "title": "Graph Connectivity With Threshold",
        "difficulty": 2,
        "answer": "        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j]\n        # dic[i] = [i, j]\n        # dic[j] = [i, j"
    },
    {
        "number": 1629,
        "title": "Slowest Key",
        "difficulty": 0,
        "answer": "        n = len(releaseTimes)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return keysPressed[0]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = releaseTimes[i] - releaseTimes[i - 1]\n        for i in range(n - 1):\n            dp[i][i + 1] = releaseTimes[i + 1] - releaseTimes[i]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = releaseTimes[i + 2] - releaseTimes[i + 1]\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = releaseTimes[i + 3] - releaseTimes[i + 2]\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = releaseTimes[i + 4] - releaseTimes[i + 3]\n        for i"
    },
    {
        "number": 1630,
        "title": "Arithmetic Subarrays",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(n) space\n        # sort the array\n        nums.sort()\n        # check if the difference between consecutive elements is the same\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1]!= nums[i - 1] - nums[i - 2]:\n                return [False] * len(nums)\n        return [True] * len(nums)"
    },
    {
        "number": 1631,
        "title": "Path With Minimum Effort",
        "difficulty": 1,
        "answer": "        n = len(heights)\n        m = len(heights[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j] = heights[i][j]\n                elif i == 0:\n                    dp[i][j] = max(heights[i][j], dp[i][j - 1])\n                elif j == 0:\n                    dp[i][j] = max(heights[i][j], dp[i - 1][j])\n                else:\n                    dp[i][j] = max(heights[i][j], max(dp[i - 1][j], dp[i][j - 1]))\n        return max(dp[n - 1][m - 1], dp[n - 1][m - 2])\n"
    },
    {
        "number": 1632,
        "title": "Rank Transform of a Matrix",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return matrix\n        m, n = len(matrix), len(matrix[0])\n        # dp[i][j] means the rank of matrix[i][j]\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = 1\n                    for k in range(i):\n                        if matrix[i][j] > matrix[k][j]:\n                            dp[i][j] = max(dp[i][j], dp[k][j] + 1)\n                    for k in range(j):\n                        if matrix[i][j] > matrix[i][k]:\n                            dp[i][j] = max(dp[i][j], dp[i][k] + 1)\n        # dp[i][j] means the rank of matrix[i][j]\n        for i in range(m):"
    },
    {
        "number": 1636,
        "title": "Sort Array by Increasing Frequency",
        "difficulty": 0,
        "answer": "        counts = collections.Counter(nums)\n        counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n        return [x[0] for x in counts]\n"
    },
    {
        "number": 1637,
        "title": "Widest Vertical Area Between Two Points Containing No Points",
        "difficulty": 1,
        "answer": "        if not points:\n            return 0\n        n = len(points)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if points[i][1] < points[j][1]:\n                    dp[i][j] = dp[j][i]\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n        return max(dp[n - 1])"
    },
    {
        "number": 1638,
        "title": "Count Substrings That Differ by One Character",
        "difficulty": 1,
        "answer": "        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for j in range(1, m + 1):\n            dp[0][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][m]\n"
    },
    {
        "number": 1639,
        "title": "Number of Ways to Form a Target String Given a Dictionary",
        "difficulty": 2,
        "answer": "        dp = [[0] * len(words) for _ in range(len(target))]\n        for i in range(len(words)):\n            for j in range(len(words[i])):\n                if target[j] == words[i][j]:\n                    dp[j][i] = 1\n                    for k in range(j):\n                        dp[j][i] = (dp[j][i] + dp[k][i]) % MOD\n                    for k in range(j + 1, len(words[i])):\n                        dp[j][i] = (dp[j][i] + dp[k][i]) % MOD\n        return sum(dp[-1]) % MOD"
    },
    {
        "number": 1640,
        "title": "Check Array Formation Through Concatenation",
        "difficulty": 0,
        "answer": "        if not arr:\n            return True\n        if not pieces:\n            return False\n        if len(arr)!= len(set(arr)):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        if len(arr)!= len(set(pieces[0])):\n            return False\n        "
    },
    {
        "number": 1641,
        "title": "Count Sorted Vowel Strings",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 5\n        if n == 2:\n            return 15\n        if n == 3:\n            return 30\n        if n == 4:\n            return 60\n        if n == 5:\n            return 120\n        if n == 6:\n            return 240\n        if n == 7:\n            return 360\n        if n == 8:\n            return 480\n        if n == 9:\n            return 720\n        if n == 10:\n            return 1080\n        if n == 11:\n            return 1320\n        if n == 12:\n            return 1680\n        if n == 13:\n            return 1920\n        if n == 14:\n            return 2160\n        if n == 15:\n            return 2520\n        if n == 16:\n            return 2880\n        if n == 17:\n            return 3240\n        if n == 18:\n            return 3600\n        if n == 19:\n            return 3960\n        if n == 20:\n            return 4320\n        if n == 21:\n            return 4800\n        if n == 22:\n            return"
    },
    {
        "number": 1642,
        "title": "Furthest Building You Can Reach",
        "difficulty": 1,
        "answer": "        heights = sorted(heights)\n        bricks = sorted(bricks)\n        ladders = sorted(ladders)\n        n = len(heights)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if heights[i] >= heights[j]:\n                    dp[i][j] = dp[i + 1][j]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1] + bricks[j - 1])\n        return dp[0][n]\n"
    },
    {
        "number": 1643,
        "title": "Kth Smallest Instructions",
        "difficulty": 2,
        "answer": "        def dfs(row, col, k):\n            if row == len(destination) - 1 and col == len(destination[0]) - 1:\n                return True\n            if row < len(destination) - 1 and col < len(destination[0]) - 1:\n                if destination[row + 1][col + 1] == 0:\n                    return False\n                if dfs(row + 1, col + 1, k):\n                    return True\n            if row < len(destination) - 1 and col > 0:\n                if destination[row + 1][col - 1] == 0:\n                    return False\n                if dfs(row + 1, col - 1, k):\n                    return True\n            if row > 0 and col < len(destination[0]) - 1:\n                if destination[row - 1][col + 1] == 0:\n                    return False\n                if dfs(row - 1, col + 1, k):\n                    return True\n            if row > 0 and col > 0:\n                if destination[row - 1][col - 1] == 0:\n                    "
    },
    {
        "number": 1646,
        "title": "Get Maximum in Generated Array",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 1647,
        "title": "Minimum Deletions to Make Character Frequencies Unique",
        "difficulty": 1,
        "answer": "        # dic = {c: s.count(c) for c in set(s)}\n        # return sum(dic[c] for c in dic if dic[c] > 1)\n        dic = {c: s.count(c) for c in set(s)}\n        return sum(dic[c] for c in dic if dic[c] > 1)"
    },
    {
        "number": 1648,
        "title": "Sell Diminishing-Valued Colored Balls",
        "difficulty": 1,
        "answer": "        n = len(inventory)\n        dp = [0] * (orders + 1)\n        dp[0] = 0\n        for i in range(1, orders + 1):\n            for j in range(n):\n                if inventory[j] > 0:\n                    dp[i] = max(dp[i], dp[i - inventory[j]] + inventory[j])\n        return dp[orders] % (10 ** 9 + 7)\n"
    },
    {
        "number": 1649,
        "title": "Create Sorted Array through Instructions",
        "difficulty": 2,
        "answer": "        nums = []\n        cost = 0\n        for i in instructions:\n            cost = min(cost, len(nums) if nums else 0)\n            nums.append(i)\n        return cost % (10 ** 9 + 7)\n"
    },
    {
        "number": 1652,
        "title": "Defuse the Bomb",
        "difficulty": 0,
        "answer": "        n = len(code)\n        if n == 0:\n            return []\n        if n == 1:\n            return [code[0]]\n        if k == 0:\n            return [0] * n\n        if k > 0:\n            return [code[i] + code[i + k] for i in range(n)]\n        if k < 0:\n            return [code[i] + code[i - k] for i in range(n)]\n        return []"
    },
    {
        "number": 1653,
        "title": "Minimum Deletions to Make String Balanced",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(1, n):\n            dp[i][i - 1] = 1\n        for i in range(2, n):\n            dp[i][i - 2] = 1\n        for i in range(3, n):\n            dp[i][i - 3] = 1\n        for i in range(4, n):\n            dp[i][i - 4] = 1\n        for i in range(5, n):\n            dp[i][i - 5] = 1\n        for i in range(6, n):\n            dp[i][i - 6] = 1\n        for i in range(7, n):\n            dp[i][i - 7] = 1\n        for i in range(8, n):\n            dp[i][i - 8] = 1\n        for i in range(9, n):\n            dp[i][i - 9] = 1\n"
    },
    {
        "number": 1654,
        "title": "Minimum Jumps to Reach Home",
        "difficulty": 1,
        "answer": "        if a < 0 or b < 0 or x < 0:\n            return -1\n        if a > x or b > x or x > len(forbidden):\n            return -1\n        if a == x or b == x:\n            return 0\n        if a == 0:\n            return 1\n        if b == 0:\n            return 1\n        if forbidden[a - 1] == x:\n            return 1\n        if forbidden[b - 1] == x:\n            return 1\n        if forbidden[a - 1] == forbidden[b - 1]:\n            return 2\n        if forbidden[a - 1] == forbidden[b]:\n            return 2\n        if forbidden[a] == forbidden[b]:\n            return 2\n        if forbidden[a] == forbidden[b - 1]:\n            return 2\n        if forbidden[a - 1] == forbidden[b - 1]:\n            return 2\n        if forbidden[a - 1] == forbidden[b - 2]:\n            return 2\n        if forbidden[a - 2] == forbidden[b - 1]:\n            return 2\n        if forbidden[a -"
    },
    {
        "number": 1655,
        "title": "Distribute Repeating Integers",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n!= len(quantity):\n            return False\n        if n == 0:\n            return True\n        if n == 1:\n            return nums[0] == quantity[0]\n        if n == 2:\n            return nums[0] == quantity[0] and nums[1] == quantity[1]\n        if n == 3:\n            return nums[0] == quantity[0] and nums[1] == quantity[1] and nums[2] == quantity[2]\n        if n == 4:\n            return nums[0] == quantity[0] and nums[1] == quantity[1] and nums[2] == quantity[2] and nums[3] == quantity[3]\n        if n == 5:\n            return nums[0] == quantity[0] and nums[1] == quantity[1] and nums[2] == quantity[2] and nums[3] == quantity[3] and nums[4] == quantity[4]\n        if n == 6:"
    },
    {
        "number": 1656,
        "title": "Design an Ordered Stream",
        "difficulty": 0,
        "answer": "        pass"
    },
    {
        "number": 1657,
        "title": "Determine if Two Strings Are Close",
        "difficulty": 1,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        if len(word1) == 1:\n            return True\n        if word1 == word2:\n            return True\n        if word1[0]!= word2[0]:\n            return False\n        return self.closeStrings(word1[1:], word2[1:])"
    },
    {
        "number": 1658,
        "title": "Minimum Operations to Reduce X to Zero",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if x == 0:\n            return n\n        if x < 0:\n            return -1\n        if x > n:\n            return -1\n        if x == n:\n            return n - 1\n        if x == 1:\n            return n - 1\n        if x == 2:\n            return n - 2\n        if x == 3:\n            return n - 3\n        if x == 4:\n            return n - 4\n        if x == 5:\n            return n - 5\n        if x == 6:\n            return n - 6\n        if x == 7:\n            return n - 7\n        if x == 8:\n            return n - 8\n        if x == 9:\n            return n - 9\n        if x == 10:\n            return n - 10\n        if x == 11:\n            return n - 11\n        if x == 12:\n            return n - 12\n        if x == 13:\n            return n - 13\n        if"
    },
    {
        "number": 1659,
        "title": "Maximize Grid Happiness",
        "difficulty": 2,
        "answer": "        def get_happiness(row, col, introverts, extroverts):\n            happiness = 120\n            for i in range(row - 1, row + 2):\n                for j in range(col - 1, col + 2):\n                    if i == row and j == col:\n                        continue\n                    if i == row and j == col + 1:\n                        happiness -= 30\n                    elif i == row + 1 and j == col:\n                        happiness -= 30\n                    elif i == row and j == col - 1:\n                        happiness -= 30\n                    elif i == row - 1 and j == col:\n                        happiness -= 30\n                    elif i == row and j == col:\n                        happiness -= 30\n                    elif i == row + 1 and j == col + 1:\n                        happiness += 20\n                    elif i == row - 1 and j == col + 1:\n                        happiness += 20\n                    elif i == row + 1 and j == col - 1:\n                        happiness += 20\n                    elif i == row - 1 and j == col - 1:\n                        h"
    },
    {
        "number": 1662,
        "title": "Check If Two String Arrays are Equivalent",
        "difficulty": 0,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        if len(word1) == 0:\n            return True\n        if word1[0]!= word2[0]:\n            return False\n        return self.arrayStringsAreEqual(word1[1:], word2[1:])"
    },
    {
        "number": 1663,
        "title": "Smallest String With A Given Numeric Value",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-2/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-3/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-4/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-5/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-6/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-7/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-8/\n        # https://www.geeksforgeeks.org/lexicographic-sorting-in-python-9/\n        # https://www.geeksforge"
    },
    {
        "number": 1664,
        "title": "Ways to Make a Fair Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        dp[n - 1] = dp[n - 2] + dp[n - 3]\n        for i in range(n - 2, -1, -1):\n            dp[i] = dp[i + 1] + dp[i + 2]\n        return dp[0]\n"
    },
    {
        "number": 1665,
        "title": "Minimum Initial Energy to Finish Tasks",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - actuali[i]] + minimumi[i])\n        # dp"
    },
    {
        "number": 1668,
        "title": "Maximum Repeating Substring",
        "difficulty": 0,
        "answer": "        n = len(sequence)\n        m = len(word)\n        if m > n:\n            return 0\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if sequence[i - 1] == word[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return max(dp[n][m], dp[n - 1][m])\n"
    },
    {
        "number": 1669,
        "title": "Merge In Between Linked Lists",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        class ListNode:\n            def __init__(self, x):\n                self.val = x\n                self.next = None"
    },
    {
        "number": 1670,
        "title": "Design Front Middle Back Queue",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1671,
        "title": "Minimum Number of Removals to Make Mountain Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums[n - 2]:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums[n - 2]:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums[n - 2]:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums[n - 2]:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums[n - 2]:\n            return 0\n        if nums[0] > nums[1]:\n            return 0\n        if nums[n - 1] < nums"
    },
    {
        "number": 1672,
        "title": "Richest Customer Wealth",
        "difficulty": 0,
        "answer": "        def dfs(i, j, m, n):\n            if i < 0 or j < 0 or i >= m or j >= n:\n                return 0\n            if accounts[i][j] == 0:\n                return 0\n            if i == 0 and j == 0:\n                return accounts[i][j]\n            if i == 0:\n                return max(dfs(i, j - 1, m, n), dfs(i, j, m, n)) + accounts[i][j]\n            if j == 0:\n                return max(dfs(i - 1, j, m, n), dfs(i, j, m, n)) + accounts[i][j]\n            return max(dfs(i - 1, j, m, n), dfs(i, j - 1, m, n)) + accounts[i][j]"
    },
    {
        "number": 1673,
        "title": "Find the Most Competitive Subsequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if k > n:\n            return []\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i == 1:\n                    dp[i][j] = nums[0]\n                elif j == 1:\n                    dp[i][j] = nums[i - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\n        return dp[n][k]"
    },
    {
        "number": 1674,
        "title": "Minimum Moves to Make Array Complementary",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21"
    },
    {
        "number": 1675,
        "title": "Minimize Deviation in Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(nums[i] - dp[i - 1], nums[i] * 2 - dp[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 1678,
        "title": "Goal Parser Interpretation",
        "difficulty": 0,
        "answer": "        stack = []\n        for c in command:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return ''\n                else:\n                    stack.pop()\n            elif c == 'G':\n                if len(stack) == 0:\n                    stack.append(c)\n                else:\n                    stack.append(stack.pop() + c)\n        return ''.join(stack)\n"
    },
    {
        "number": 1679,
        "title": "Max Number of K-Sum Pairs",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(k + 1)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == k:\n                    dp[nums[i] + nums[j]][i] = dp[nums[i] + nums[j]][i] + 1\n                    dp[nums[i] + nums[j]][j] = dp[nums[i] + nums[j]][j] + 1\n        return max(max(dp[k][i] for i in range(n)), max(dp[k][i] for i in range(n)))\n"
    },
    {
        "number": 1680,
        "title": "Concatenation of Consecutive Binary Numbers",
        "difficulty": 1,
        "answer": "        def dfs(n, s):\n            if n == 0:\n                return s\n            if n == 1:\n                return s % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 1)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 2)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 3)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 4)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 5)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 6)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 7)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 8)) % (2 ** 9 + 7)\n            s = (s + dfs(n - 1, 9)) % (2"
    },
    {
        "number": 1681,
        "title": "Minimum Incompatibility",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i == j:\n                    dp[i][j] = nums[i - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\n        return dp[n][k]"
    },
    {
        "number": 1684,
        "title": "Count the Number of Consistent Strings",
        "difficulty": 0,
        "answer": "        if not words:\n            return 0\n        dp = [[0] * len(allowed) for _ in range(len(words))]\n        for i in range(len(words)):\n            for j in range(len(allowed)):\n                if words[i][j] == allowed[j]:\n                    dp[i][j] = 1\n        for i in range(len(words)):\n            for j in range(len(allowed)):\n                for k in range(j + 1, len(allowed)):\n                    if dp[i][j] and dp[i][k]:\n                        dp[i][j] = dp[i][j] and dp[i][k]\n        return sum(dp[-1])\n"
    },
    {
        "number": 1685,
        "title": "Sum of Absolute Differences in a Sorted Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0] + nums[1]]\n        if n == 3:\n            return [nums[0] + nums[1] + nums[2]]\n        if n == 4:\n            return [nums[0] + nums[1] + nums[2] + nums[3]]\n        if n == 5:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4]]\n        if n == 6:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]]\n        if n == 7:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5"
    },
    {
        "number": 1686,
        "title": "Stone Game VI",
        "difficulty": 1,
        "answer": "        alice_score = 0\n        bob_score = 0\n        for i in range(len(aliceValues)):\n            alice_score += aliceValues[i]\n            bob_score += bobValues[i]\n        if alice_score > bob_score:\n            return 1\n        elif bob_score > alice_score:\n            return -1\n        else:\n            return 0"
    },
    {
        "number": 1687,
        "title": "Delivering Boxes from Storage to Ports",
        "difficulty": 2,
        "answer": "        # dp\n        dp = [[0] * portsCount for _ in range(maxBoxes)]\n        dp[0] = 0\n        for i in range(1, maxBoxes):\n            dp[i] = dp[i - 1] + boxes[i - 1][1]\n        for i in range(maxBoxes - 1, -1, -1):\n            dp[i] = min(dp[i], dp[i - 1] + boxes[i - 1][1])\n        return dp[maxBoxes - 1]"
    },
    {
        "number": 1688,
        "title": "Count of Matches in Tournament",
        "difficulty": 0,
        "answer": "        def dfs(n, k, curr, prev):\n            if k == 0:\n                return 1\n            if n == 0:\n                return 0\n            if curr == 0:\n                return 0\n            if k == 1:\n                return dfs(n - 1, 1, prev, curr)\n            if k == 2:\n                return dfs(n - 1, 2, prev, curr)\n            if k == 3:\n                return dfs(n - 1, 3, prev, curr)\n            if k == 4:\n                return dfs(n - 1, 4, prev, curr)\n            if k == 5:\n                return dfs(n - 1, 5, prev, curr)\n            if k == 6:\n                return dfs(n - 1, 6, prev, curr)\n            if k == 7:\n                return dfs(n - 1, 7, prev, curr)\n            if k == 8:\n                return dfs(n - 1, 8, prev, curr)\n            if k == 9:\n                return"
    },
    {
        "number": 1689,
        "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
        "difficulty": 1,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            if i % 3 == 0:\n                dp[i] = min(dp[i], dp[i - 3] + 1)\n            if i % 5 == 0:\n                dp[i] = min(dp[i], dp[i - 5] + 1)\n        return dp[-1]\n"
    },
    {
        "number": 1690,
        "title": "Stone Game VII",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(dp[i + 1][i], stones[i] + stones[i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(dp[i + 1][i + 2], stones[i] + stones[i + 2])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(dp[i + 1][i + 3], stones[i] + stones[i + 3])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(dp[i + 1][i + 4], stones[i] + stones[i + 4])\n        for i in range(n -"
    },
    {
        "number": 1691,
        "title": "Maximum Height by Stacking Cuboids ",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cuboids[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids[i][2]\n        # dp[i][j] = dp[i-1][j] + cuboids["
    },
    {
        "number": 1694,
        "title": "Reformat Phone Number",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/problems/reformat-phone-number/discuss/\n        # https://leetcode.com/"
    },
    {
        "number": 1695,
        "title": "Maximum Erasure Value",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(nums[i], nums[i + 1])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(nums[i], nums[i + 1], nums[i + 2])\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 3, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i + 2][j])\n        return max(dp[0][n - 1], dp[1][n - 2])\n"
    },
    {
        "number": 1696,
        "title": "Jump Game VI",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, i + k + 1):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j]) + nums[i]\n        return max(dp[0][n], dp[n][n])\n"
    },
    {
        "number": 1697,
        "title": "Checking Existence of Edge Length Limited Paths",
        "difficulty": 2,
        "answer": "        graph = Graph(n, edgeList)\n        ans = [False] * len(queries)\n        for i in range(len(queries)):\n            p, q, limit = queries[i]\n            if p == q:\n                continue\n            if graph.has_path(p, q, limit):\n                ans[i] = True\n        return ans"
    },
    {
        "number": 1700,
        "title": "Number of Students Unable to Eat Lunch",
        "difficulty": 0,
        "answer": "        n = len(students)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 1701,
        "title": "Average Waiting Time",
        "difficulty": 1,
        "answer": "        n = len(customers)\n        if n == 0:\n            return 0\n        if n == 1:\n            return customers[0][1] - customers[0][0]\n        if n == 2:\n            return max(customers[0][1] - customers[0][0], customers[1][1] - customers[1][0])\n        if n == 3:\n            return max(customers[0][1] - customers[0][0], max(customers[1][1] - customers[1][0], customers[2][1] - customers[2][0]))\n        if n == 4:\n            return max(customers[0][1] - customers[0][0], max(customers[1][1] - customers[1][0], max(customers[2][1] - customers[2][0], customers[3][1] - customers[3][0])))\n        if n == 5:\n            return max(customers[0][1] - customers[0][0], max(customers[1][1] - customers[1][0"
    },
    {
        "number": 1702,
        "title": "Maximum Binary String After Change",
        "difficulty": 1,
        "answer": "        n = len(binary)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                if binary[i - 1] == '0':\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n        return ''.join(str(i) for i in dp[n])"
    },
    {
        "number": 1703,
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8"
    },
    {
        "number": 1704,
        "title": "Determine if String Halves Are Alike",
        "difficulty": 0,
        "answer": "        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        a, b = s[:int(len(s) / 2)], s[int(len(s) / 2):]\n        return len(set(a) & set(b)) == len(set(a) | set(b))"
    },
    {
        "number": 1705,
        "title": "Maximum Number of Eaten Apples",
        "difficulty": 1,
        "answer": "        n = len(apples)\n        dp = [0] * n\n        for i in range(n):\n            if apples[i] > 0:\n                dp[i] = max(dp[i], dp[i - 1] + apples[i])\n        for i in range(n):\n            if days[i] > 0:\n                dp[i] = max(dp[i], dp[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 1706,
        "title": "Where Will the Ball Fall",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[-1] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                if grid[i][j] == 1:\n                    dp[i][j] = dp[i - 1][j]\n                elif grid[i][j] == -1:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 1707,
        "title": "Maximum XOR With an Element From Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        m = len(queries)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if queries[i - 1][0] <= nums[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        ans = [-1] * m\n        for i in range(m):\n            ans[i] = dp[m][i + 1]\n        return ans\n"
    },
    {
        "number": 1710,
        "title": "Maximum Units on a Truck",
        "difficulty": 0,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + boxTypes[i][0] * boxTypes[i][1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + boxTypes[i][0] * boxTypes[i][1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + boxTypes[i][0] * boxTypes[i][1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + boxTypes[i][0] * boxTypes[i][1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + boxTypes[i][0] * boxTypes[i][1]\n        # dp[i][j] = max(dp[i-1][j],"
    },
    {
        "number": 1711,
        "title": "Count Good Meals",
        "difficulty": 1,
        "answer": "        n = len(deliciousness)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + deliciousness[i] * deliciousness[j]\n        return sum(sum(dp[i]) for i in range(n)) % (10 ** 9 + 7)\n"
    },
    {
        "number": 1712,
        "title": "Ways to Split Array Into Three Subarrays",
        "difficulty": 1,
        "answer": "        MOD = 10 ** 9 + 7\n        dp = [[0] * (len(nums) + 1) for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            dp[i][i] = 1\n            dp[i][i + 1] = 1\n        for i in range(len(nums) - 1):\n            dp[i][i + 1] = dp[i + 1][i + 1] + dp[i + 1][i]\n        for i in range(len(nums) - 2, -1, -1):\n            dp[i][i + 1] = dp[i + 1][i + 1] + dp[i + 1][i]\n            dp[i][i + 2] = dp[i + 1][i + 1] + dp[i + 1][i]\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                dp[i][j] = dp[i][j"
    },
    {
        "number": 1713,
        "title": "Minimum Operations to Make a Subsequence",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if arr[i] < arr[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 1716,
        "title": "Calculate Money in Leetcode Bank",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 6\n        if n == 6:\n            return 8\n        if n == 7:\n            return 10\n        if n == 8:\n            return 12\n        if n == 9:\n            return 14\n        if n == 10:\n            return 16\n        if n == 11:\n            return 18\n        if n == 12:\n            return 20\n        if n == 13:\n            return 22\n        if n == 14:\n            return 24\n        if n == 15:\n            return 26\n        if n == 16:\n            return 28\n        if n == 17:\n            return 30\n        if n == 18:\n            return 32\n        if n == 19:\n            return 34\n        if n == 20:\n            return 36\n        if n == 21:\n            return 38\n        if n == 22:\n            return 40\n        if n == 23:\n            "
    },
    {
        "number": 1717,
        "title": "Maximum Score From Removing Substrings",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + x)\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + y)\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1"
    },
    {
        "number": 1718,
        "title": "Construct the Lexicographically Largest Valid Sequence",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if n == 2:\n            return [2, 3]\n        if n == 3:\n            return [3, 1, 2]\n        if n == 4:\n            return [4, 3, 1, 2]\n        if n == 5:\n            return [5, 3, 1, 4, 3, 5, 2, 4, 2]\n        if n == 6:\n            return [6, 5, 3, 1, 4, 3, 5, 2, 4, 2]\n        if n == 7:\n            return [7, 6, 5, 3, 1, 4, 3, 5, 2, 4, 2]\n        if n == 8:\n            return [8, 7, 6, 5, 3, 1, 4, 3, 5, 2, 4, 2]\n        if n == 9:\n            return [9, 8, 7, 6, 5, 3, 1, 4, 3, 5, 2, 4, 2]\n        if n == 10:\n            return [10, 9, 8, 7, 6, 5"
    },
    {
        "number": 1719,
        "title": "Number Of Ways To Reconstruct A Tree",
        "difficulty": 2,
        "answer": "        n = len(pairs)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                if pairs[i][0] < pairs[j][0] and pairs[i][1] < pairs[j][1]:\n                    dp[i][j] = dp[j][i] = 2\n                elif pairs[i][0] < pairs[j][0]:\n                    dp[i][j] = dp[j][i] = 1\n                elif pairs[i][1] < pairs[j][1]:\n                    dp[i][j] = dp[j][i] = 1\n                else:\n                    dp[i][j] = dp[j][i] = 0\n        for i in range(n):\n            for j in range(i):\n                for k in range(j):\n                    if dp[i][j] == 2 and dp[j][k"
    },
    {
        "number": 1720,
        "title": "Decode XORed Array",
        "difficulty": 0,
        "answer": "        n = len(encoded)\n        if n == 0:\n            return []\n        if n == 1:\n            return [encoded[0] ^ first]\n        if n == 2:\n            return [encoded[0] ^ first, encoded[1] ^ first]\n        if n == 3:\n            return [encoded[0] ^ first, encoded[1] ^ first, encoded[2] ^ first]\n        if n == 4:\n            return [encoded[0] ^ first, encoded[1] ^ first, encoded[2] ^ first, encoded[3] ^ first]\n        if n == 5:\n            return [encoded[0] ^ first, encoded[1] ^ first, encoded[2] ^ first, encoded[3] ^ first, encoded[4] ^ first]\n        if n == 6:\n            return [encoded[0] ^ first, encoded[1] ^ first, encoded[2] ^ first, encoded[3] ^ first, encoded[4] ^ first, encoded[5] ^ first]\n        if n == 7:\n            return [enc"
    },
    {
        "number": 1721,
        "title": "Swapping Nodes in a Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        if not k:\n            return head\n        if k == 1:\n            return head\n        if k == 2:\n            return self.swapNodes(head.next, 1)\n        if k == 3:\n            return self.swapNodes(head.next.next, 2)\n        if k == 4:\n            return self.swapNodes(head.next.next.next, 3)\n        if k == 5:\n            return self.swapNodes(head.next.next.next.next, 4)\n        if k == 6:\n            return self.swapNodes(head.next.next.next.next.next, 5)\n        if k == 7:\n            return self.swapNodes(head.next.next.next.next.next.next, 6)\n        if k == 8:\n            return self.swapNodes(head.next.next.next.next.next.next.next, 7)\n        if k == 9:\n            return self.swapNodes("
    },
    {
        "number": 1722,
        "title": "Minimize Hamming Distance After Swap Operations",
        "difficulty": 1,
        "answer": "        n = len(source)\n        if n!= len(target):\n            return -1\n        if n == 0:\n            return 0\n        if n == 1:\n            return abs(source[0] - target[0])\n        if n == 2:\n            return min(abs(source[0] - target[0]), abs(source[1] - target[1]))\n        if n == 3:\n            return min(abs(source[0] - target[0]), abs(source[1] - target[1]), abs(source[2] - target[2]))\n        if n == 4:\n            return min(abs(source[0] - target[0]), abs(source[1] - target[1]), abs(source[2] - target[2]), abs(source[3] - target[3]))\n        if n == 5:\n            return min(abs(source[0] - target[0]), abs(source[1] - target[1]), abs(source[2] - target[2]), abs(source[3] - target[3]), abs(source"
    },
    {
        "number": 1723,
        "title": "Find Minimum Time to Finish All Jobs",
        "difficulty": 2,
        "answer": "        n = len(jobs)\n        dp = [[0] * n for _ in range(k + 1)]\n        for i in range(n):\n            dp[0][i] = jobs[i]\n        for i in range(1, k + 1):\n            for j in range(n):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + jobs[j]\n        return max(dp[k])\n"
    },
    {
        "number": 1725,
        "title": "Number Of Rectangles That Can Form The Largest Square",
        "difficulty": 0,
        "answer": "        def dfs(i, j, k, max_len):\n            if i == len(rectangles) or j == len(rectangles[i]) or k == max_len:\n                return 1\n            if i > 0 and j > 0 and rectangles[i][j] == rectangles[i - 1][j - 1] + 1:\n                return dfs(i - 1, j - 1, k, max_len) + dfs(i, j - 1, k, max_len)\n            elif i > 0 and j > 0 and rectangles[i][j] == rectangles[i - 1][j] + 1:\n                return dfs(i - 1, j, k, max_len) + dfs(i, j, k, max_len)\n            elif i > 0 and j > 0 and rectangles[i][j] == rectangles[i][j - 1] + 1:\n                return dfs(i, j - 1, k, max_len) + dfs(i, j, k, max_len)\n            else:\n                return"
    },
    {
        "number": 1726,
        "title": "Tuple with Same Product",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + nums[i] * nums[j]\n        return dp[0][n]"
    },
    {
        "number": 1727,
        "title": "Largest Submatrix With Rearrangements",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + matrix[i][j])\n        return max(max(dp[i]) for i in range(m))\n"
    },
    {
        "number": 1728,
        "title": "Cat and Mouse II",
        "difficulty": 2,
        "answer": "        def dfs(i, j, grid, catJump, mouseJump):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '#':\n                return False\n            if grid[i][j] == 'C':\n                return dfs(i + catJump, j, grid, catJump, mouseJump) or dfs(i, j + mouseJump, grid, catJump, mouseJump)\n            elif grid[i][j] == 'M':\n                return dfs(i + mouseJump, j, grid, catJump, mouseJump)\n            else:\n                return True"
    },
    {
        "number": 1732,
        "title": "Find the Highest Altitude",
        "difficulty": 0,
        "answer": "        # sort the gain\n        gain.sort()\n        # the highest point is the first point\n        return gain[0]"
    },
    {
        "number": 1733,
        "title": "Minimum Number of People to Teach",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n"
    },
    {
        "number": 1734,
        "title": "Decode XORed Permutation",
        "difficulty": 1,
        "answer": "        n = len(encoded)\n        if n == 0:\n            return []\n        if n == 1:\n            return [encoded[0]]\n        if n == 2:\n            return [encoded[0] ^ encoded[1]]\n        if n == 3:\n            return [encoded[0] ^ encoded[1], encoded[1] ^ encoded[2]]\n        if n == 4:\n            return [encoded[0] ^ encoded[1], encoded[1] ^ encoded[2], encoded[2] ^ encoded[3]]\n        if n == 5:\n            return [encoded[0] ^ encoded[1], encoded[1] ^ encoded[2], encoded[2] ^ encoded[3], encoded[3] ^ encoded[4]]\n        if n == 6:\n            return [encoded[0] ^ encoded[1], encoded[1] ^ encoded[2], encoded[2] ^ encoded[3], encoded[3] ^ encoded[4], encoded[4] ^ encoded[5]]\n        if n == 7:\n            return [encoded[0] ^ encoded[1"
    },
    {
        "number": 1735,
        "title": "Count Ways to Make Array With Product",
        "difficulty": 2,
        "answer": "        n = len(queries)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] %= 109 + 7\n        return dp[0][n]"
    },
    {
        "number": 1736,
        "title": "Latest Time by Replacing Hidden Digits",
        "difficulty": 0,
        "answer": "        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":\")\n        time = time.replace(\"?\", \":"
    },
    {
        "number": 1737,
        "title": "Change Minimum Characters to Satisfy One of Three Conditions",
        "difficulty": 1,
        "answer": "        # a = \"aba\", b = \"caa\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dabadd\", b = \""
    },
    {
        "number": 1738,
        "title": "Find Kth Largest XOR Coordinate Value",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = matrix[i][j] ^ dp[i][j - 1]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] ^= dp[i - 1][j]\n        return dp[m - 1][n - 1] ^ dp[m - 1][n - 2] ^ dp[m - 2][n - 1]"
    },
    {
        "number": 1739,
        "title": "Building Boxes",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 1742,
        "title": "Maximum Number of Balls in a Box",
        "difficulty": 0,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] ="
    },
    {
        "number": 1743,
        "title": "Restore the Array From Adjacent Pairs",
        "difficulty": 1,
        "answer": "        n = len(adjacentPairs)\n        if n == 0:\n            return []\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if adjacentPairs[i][0] < adjacentPairs[j][0]:\n                    dp[i][j] = dp[j][i] = adjacentPairs[i][0]\n                elif adjacentPairs[i][0] > adjacentPairs[j][0]:\n                    dp[i][j] = dp[j][i] = adjacentPairs[j][0]\n                else:\n                    dp[i][j] = dp[j][i] = adjacentPairs[i][1]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + dp[j][n - 1])\n        return [dp[i][n - 1] for"
    },
    {
        "number": 1744,
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
        "difficulty": 1,
        "answer": "        candies = [0] * len(candiesCount)\n        for i in range(len(candiesCount)):\n            candies[i] = candiesCount[i]\n        for i in range(len(queries)):\n            favoriteType, favoriteDay, dailyCap = queries[i]\n            if favoriteType > favoriteDay:\n                continue\n            if favoriteType == favoriteDay:\n                if dailyCap > candies[favoriteType - 1]:\n                    candies[favoriteType - 1] -= dailyCap\n                else:\n                    candies[favoriteType - 1] = 0\n            else:\n                if dailyCap > candies[favoriteType - 1]:\n                    candies[favoriteType - 1] -= dailyCap\n                else:\n                    candies[favoriteType - 1] = 0\n                candies[favoriteType - 1] -= 1\n        ans = [False] * len(queries)\n        for i in range(len(queries)):\n            favoriteType, favoriteDay, dailyCap = queries[i]\n            if favoriteType > favoriteDay:\n                continue\n            if favorite"
    },
    {
        "number": 1745,
        "title": "Palindrome Partitioning IV",
        "difficulty": 2,
        "answer": "        if len(s) < 3:\n            return False\n        dp = [[False] * (len(s) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        for i in range(1, len(s) + 1):\n            dp[i][i] = True\n            for j in range(i - 1, 0, -1):\n                if s[i - 1] == s[j]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = False\n        return dp[-1][-1]"
    },
    {
        "number": 1748,
        "title": "Sum of Unique Elements",
        "difficulty": 0,
        "answer": "        return sum(nums) - sum(set(nums))"
    },
    {
        "number": 1749,
        "title": "Maximum Absolute Sum of Any Subarray",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n):\n            dp[i] = max(nums[i] + dp[i - 1], nums[i] + dp[i - 2])\n        return max(dp)"
    },
    {
        "number": 1750,
        "title": "Minimum Length of String After Deleting Similar Ends",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 1751,
        "title": "Maximum Number of Events That Can Be Attended II",
        "difficulty": 2,
        "answer": "        events.sort(key=lambda x: x[0])\n        dp = [[0] * (k + 1) for _ in range(len(events) + 1)]\n        for i in range(1, len(events) + 1):\n            for j in range(1, k + 1):\n                if i == 1:\n                    dp[i][j] = events[i - 1][2]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + events[i - 1][2]\n        return dp[len(events)][k]\n"
    },
    {
        "number": 1752,
        "title": "Check if Array Is Sorted and Rotated",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return True\n        if nums[0] > nums[1]:\n            return False\n        for i in range(2, n):\n            if nums[i] < nums[i - 1]:\n                return False\n        return True"
    },
    {
        "number": 1753,
        "title": "Maximum Score From Removing Stones",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        dp = [[0] * (c + 1) for _ in range(a + 1)]\n        for i in range(a + 1):\n            for j in range(c + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = 0\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], dp[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        return dp[a][c]\n"
    },
    {
        "number": 1754,
        "title": "Largest Merge Of Two Strings",
        "difficulty": 1,
        "answer": "        if len(word1) == 0:\n            return word2\n        if len(word2) == 0:\n            return word1\n        if word1[0] > word2[0]:\n            return word1 + word2\n        else:\n            return word2 + word1"
    },
    {
        "number": 1755,
        "title": "Closest Subsequence Sum",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return abs(nums[0] - goal)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = abs(nums[0] - goal)\n        for i in range(1, n):\n            dp[i][0] = abs(nums[i] - nums[i - 1])\n        for j in range(1, n):\n            for i in range(1, j):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + abs(nums[i] - nums[j])\n        return dp[n - 1][n - 1]\n"
    },
    {
        "number": 1758,
        "title": "Minimum Changes To Make Alternating Binary String",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 3\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 4\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 5\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 6\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 7\n        for i in range(n - 8,"
    },
    {
        "number": 1759,
        "title": "Count Number of Homogenous Substrings",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous-2/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous-3/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous-4/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous-5/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-given-length-that-are-homogenous-6/\n        # https://www.geeksforgeeks.org/count-number-of-substrings-of-"
    },
    {
        "number": 1760,
        "title": "Minimum Limit of Balls in a Bag",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + nums[i]\n        return dp[0][n]\n"
    },
    {
        "number": 1761,
        "title": "Minimum Degree of a Connected Trio in a Graph",
        "difficulty": 2,
        "answer": "        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1763,
        "title": "Longest Nice Substring",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/longest-nice-substring/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-ii/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-iii/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-iv/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-v/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-vi/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-vii/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-viii/discuss/\n        # https://leetcode.com/problems/longest-nice-substring-ix/discuss/\n        # https://leetcode"
    },
    {
        "number": 1764,
        "title": "Form Array by Concatenating Subarrays of Another Array",
        "difficulty": 1,
        "answer": "        n = len(groups)\n        if n == 0:\n            return True\n        if n == 1:\n            return False\n        if n == 2:\n            return groups[0] == nums and groups[1] == nums\n        if n == 3:\n            return groups[0] == nums or groups[1] == nums or groups[2] == nums\n        if n == 4:\n            return groups[0] == nums or groups[1] == nums or groups[2] == nums or groups[3] == nums\n        if n == 5:\n            return groups[0] == nums or groups[1] == nums or groups[2] == nums or groups[3] == nums or groups[4] == nums\n        if n == 6:\n            return groups[0] == nums or groups[1] == nums or groups[2] == nums or groups[3] == nums or groups[4] == nums or groups[5] == nums\n        if n == 7:\n            return groups[0] == num"
    },
    {
        "number": 1765,
        "title": "Map of Highest Peak",
        "difficulty": 1,
        "answer": "        m, n = len(isWater), len(isWater[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    for k in range(n):\n                        if isWater[i][k] == 0 and isWater[k][j] == 0:\n                            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        return dp"
    },
    {
        "number": 1766,
        "title": "Tree of Coprimes",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return [-1]\n        if n == 2:\n            return [0, 1]\n        if n == 3:\n            return [0, 1, 2]\n        if n == 4:\n            return [0, 1, 2, 3]\n        if n == 5:\n            return [0, 1, 2, 3, 4]\n        if n == 6:\n            return [0, 1, 2, 3, 4, 5]\n        if n == 7:\n            return [0, 1, 2, 3, 4, 5, 6]\n        if n == 8:\n            return [0, 1, 2, 3, 4, 5, 6, 7]\n        if n == 9:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 10:\n            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        if n == 11:\n            return [0, 1, 2, 3, 4, 5"
    },
    {
        "number": 1768,
        "title": "Merge Strings Alternately",
        "difficulty": 0,
        "answer": "        if len(word1) > len(word2):\n            return self.mergeAlternately(word2, word1)\n        if len(word1) == 0:\n            return word2\n        if len(word2) == 0:\n            return word1\n        i = 0\n        j = 0\n        k = 0\n        result = []\n        while i < len(word1) and j < len(word2):\n            if word1[i] < word2[j]:\n                result.append(word1[i])\n                i += 1\n            else:\n                result.append(word2[j])\n                j += 1\n        while i < len(word1):\n            result.append(word1[i])\n            i += 1\n        while j < len(word2):\n            result.append(word2[j])\n            j += 1\n        return ''.join(result)"
    },
    {
        "number": 1769,
        "title": "Minimum Number of Operations to Move All Balls to Each Box",
        "difficulty": 1,
        "answer": "        n = len(boxes)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if boxes[i] == boxes[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])\n        return dp[0]"
    },
    {
        "number": 1770,
        "title": "Maximum Score from Performing Multiplication Operations",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        m = len(multipliers)\n        if n < m:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            dp[i][0] = multipliers[i] * nums[0]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1]) + multipliers[j - 1] * nums[i - 1]\n        return max(dp[m][n], dp[m - 1][n])\n"
    },
    {
        "number": 1771,
        "title": "Maximize Palindrome Length From Subsequences",
        "difficulty": 2,
        "answer": "        def longest_palindrome(s1, s2):\n            if not s1 or not s2:\n                return 0\n            dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n            for i in range(len(s1) + 1):\n                for j in range(len(s2) + 1):\n                    if i == 0 or j == 0:\n                        dp[i][j] = 0\n                    elif s1[i - 1] == s2[j - 1]:\n                        dp[i][j] = dp[i - 1][j - 1] + 1\n                    else:\n                        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            return dp[len(s1)][len(s2)]"
    },
    {
        "number": 1773,
        "title": "Count Items Matching a Rule",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(items)):\n            if ruleKey == \"type\" and ruleValue == items[i][0]:\n                count += 1\n            elif ruleKey == \"color\" and ruleValue == items[i][1]:\n                count += 1\n            elif ruleKey == \"name\" and ruleValue == items[i][2]:\n                count += 1\n        return count\n"
    },
    {
        "number": 1774,
        "title": "Closest Dessert Cost",
        "difficulty": 1,
        "answer": "        # baseCosts = [1,7], toppingCosts = [3,4], target = 10\n        # baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n        # baseCosts = [3,10], toppingCosts = [2,5], target = 9\n        # baseCosts = [1,7], toppingCosts = [3,4], target = 10\n        # baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n        # baseCosts = [3,10], toppingCosts = [2,5], target = 9\n        # baseCosts = [1,7], toppingCosts = [3,4], target = 10\n        # baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\n        # baseCosts = [3,10], toppingCosts = [2,5], target = 9\n        # baseCosts = [1,7], toppingCosts = [3,4], target = 10\n        # baseCost"
    },
    {
        "number": 1775,
        "title": "Equal Sum Arrays With Minimum Number of Operations",
        "difficulty": 1,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        if n1 > n2:\n            return self.minOperations(nums2, nums1)\n        if n1 == 0:\n            return 0\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            dp[i][0] = dp[i - 1][0] + nums1[i - 1]\n        for j in range(1, n2 + 1):\n            dp[0][j] = dp[0][j - 1] + nums2[j - 1]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + nums1[i - 1]\n        return dp[n1][n2"
    },
    {
        "number": 1776,
        "title": "Car Fleet II",
        "difficulty": 2,
        "answer": "        n = len(cars)\n        if n == 0:\n            return []\n        if n == 1:\n            return [-1]\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = cars[0][0]\n        dp[0][1] = cars[0][1]\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + cars[i][0]\n            dp[i][1] = max(dp[i - 1][1], cars[i][1])\n        ans = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dp[i][0] == dp[j][0] and dp[i][1] == dp[j][1]:\n                    ans.append(dp[i][0] + dp[j][0])\n                    break\n        return ans\n"
    },
    {
        "number": 1779,
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "difficulty": 0,
        "answer": "        def manhattan(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)"
    },
    {
        "number": 1780,
        "title": "Check if Number is a Sum of Powers of Three",
        "difficulty": 1,
        "answer": "        if n < 0:\n            return False\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n % 3 == 0:\n            return True\n        if n % 3 == 1:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n            return True\n        if n % 3 == 2:\n            return False\n        if n % 3 == 2:\n"
    },
    {
        "number": 1781,
        "title": "Sum of Beauty of All Substrings",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(n) space\n        if not s:\n            return 0\n        count = collections.Counter(s)\n        return sum(count[i] - count[j] for i in range(len(s)) for j in range(i + 1, len(s)))"
    },
    {
        "number": 1782,
        "title": "Count Pairs Of Nodes",
        "difficulty": 2,
        "answer": "        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1784,
        "title": "Check if Binary String Has at Most One Segment of Ones",
        "difficulty": 0,
        "answer": "        if not s:\n            return False\n        if len(s) == 1:\n            return True\n        if s[0] == '0':\n            return False\n        if s[0] == '1':\n            return True\n        if s[0] == '0' and s[1] == '0':\n            return False\n        if s[0] == '1' and s[1] == '0':\n            return True\n        if s[0] == '0' and s[1] == '1':\n            return False\n        if s[0] == '1' and s[1] == '1':\n            return True\n        if s[0] == '0' and s[1] == '1' and s[2] == '0':\n            return False\n        if s[0] == '1' and s[1] == '1' and s[2] == '0':\n            return True\n        if s[0] == '0' and s[1] == '1' and s[2] == '1':\n            return False\n        "
    },
    {
        "number": 1785,
        "title": "Minimum Elements to Add to Form a Given Sum",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if goal < 0:\n            return 0\n        if goal == 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal < 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal > 0:\n            return len(nums)\n        if goal"
    },
    {
        "number": 1786,
        "title": "Number of Restricted Paths From First to Last Node",
        "difficulty": 1,
        "answer": "        # dp[i][j] = number of paths from i to j\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1"
    },
    {
        "number": 1787,
        "title": "Make the XOR of All Segments Equal to Zero",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(k + 1)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[1][i] += nums[j] ^ nums[i]\n                dp[2][i] += nums[j] ^ nums[i] ^ nums[j + 1]\n                dp[3][i] += nums[j] ^ nums[i] ^ nums[j + 1] ^ nums[j + 2]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[1][i] += nums[j] ^ nums[i]\n                dp[2][i] += nums[j] ^ nums[i] ^ nums[j + 1]\n                dp[3][i] += nums[j] ^ nums[i] ^ nums[j + 1] ^ nums[j + 2]\n        for i in range(n):\n            for"
    },
    {
        "number": 1790,
        "title": "Check if One String Swap Can Make Strings Equal",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/discuss/\n        # https://leetcode.com/problems/almost-equal-strings/disc"
    },
    {
        "number": 1791,
        "title": "Find Center of Star Graph",
        "difficulty": 0,
        "answer": "        n = len(edges)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2"
    },
    {
        "number": 1792,
        "title": "Maximum Average Pass Ratio",
        "difficulty": 1,
        "answer": "        classes = [[int(i) for i in line.split(\",\")] for line in classes]\n        n = len(classes)\n        classes = [[i for i in line] for line in classes]\n        classes = [[int(i) for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in line] for line in classes]\n        classes = [[i for i in"
    },
    {
        "number": 1793,
        "title": "Maximum Score of a Good Subarray",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                dp[0][i] = dp[0][i - 1] + nums[i - 1]\n                dp[j][i] = dp[j - 1][i - 1] + nums[i - 1]\n                for k in range(1, j - i + 1):\n                    dp[k][i] = max(dp[k][i - 1], dp[k - 1][i - 1]) + nums[i - 1]\n        return max(dp[k][n])"
    },
    {
        "number": 1796,
        "title": "Second Largest Digit in a String",
        "difficulty": 0,
        "answer": "        nums = [int(c) for c in s]\n        nums.sort()\n        return nums[-2] if nums else -1"
    },
    {
        "number": 1797,
        "title": "Design Authentication Manager",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1798,
        "title": "Maximum Number of Consecutive Values You Can Make",
        "difficulty": 1,
        "answer": "        coins.sort()\n        dp = [0] * (len(coins) + 1)\n        dp[0] = 0\n        for i in range(1, len(coins) + 1):\n            dp[i] = dp[i - 1] + coins[i - 1]\n        return max(dp)"
    },
    {
        "number": 1799,
        "title": "Maximize Score After N Operations",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * (n * 2)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n * 2):\n            dp[i] = max(dp[i - 2] * nums[i - 2], dp[i - 1] * nums[i - 1])\n        return dp[-1]"
    },
    {
        "number": 1800,
        "title": "Maximum Ascending Subarray Sum",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i-1] + nums[i], nums[i])\n        return max(dp)"
    },
    {
        "number": 1801,
        "title": "Number of Orders in the Backlog",
        "difficulty": 1,
        "answer": "        def get_max_price(orders):\n            max_price = 0\n            for i in range(len(orders)):\n                if orders[i][1] > max_price:\n                    max_price = orders[i][1]\n            return max_price"
    },
    {
        "number": 1802,
        "title": "Maximum Value at a Given Index in a Bounded Array",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return maxSum\n        if n == 2:\n            return maxSum - 1\n        if n == 3:\n            return maxSum - 2\n        if n == 4:\n            return maxSum - 3\n        if n == 5:\n            return maxSum - 4\n        if n == 6:\n            return maxSum - 5\n        if n == 7:\n            return maxSum - 6\n        if n == 8:\n            return maxSum - 7\n        if n == 9:\n            return maxSum - 8\n        if n == 10:\n            return maxSum - 9\n        if n == 11:\n            return maxSum - 10\n        if n == 12:\n            return maxSum - 11\n        if n == 13:\n            return maxSum - 12\n        if n == 14:\n            return maxSum - 13\n        if n == 15:\n            return maxSum - 14\n        if n == 16:\n            return maxSum - 15\n        if n == 17:\n            return maxSum - 16\n        if n == 18:\n            return maxSum - 17\n"
    },
    {
        "number": 1803,
        "title": "Count Pairs With XOR in a Range",
        "difficulty": 2,
        "answer": "        count = 0\n        for i in range(low, high + 1):\n            for j in range(i + 1, high + 1):\n                if (nums[i] ^ nums[j]) in range(low, high + 1):\n                    count += 1\n        return count\n"
    },
    {
        "number": 1805,
        "title": "Number of Different Integers in a String",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of-different-integers/discuss/\n        # https://leetcode.com/problems/number-of"
    },
    {
        "number": 1806,
        "title": "Minimum Number of Operations to Reinitialize a Permutation",
        "difficulty": 1,
        "answer": "        return n // 2"
    },
    {
        "number": 1807,
        "title": "Evaluate the Bracket Pairs of a String",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == \"(\":\n                stack.append(i)\n            elif s[i] == \")\":\n                if len(stack) == 0:\n                    return \"?\"\n                stack.pop()\n                if len(stack) == 0:\n                    return s[stack[-1] + 1:i]\n                else:\n                    stack[-1] = i\n        return \"?\""
    },
    {
        "number": 1808,
        "title": "Maximize Number of Nice Divisors",
        "difficulty": 2,
        "answer": "        def is_prime(n):\n            if n < 2:\n                return False\n            if n == 2:\n                return True\n            if n % 2 == 0:\n                return False\n            for i in range(3, int(n ** 0.5) + 1, 2):\n                if n % i == 0:\n                    return False\n            return True"
    },
    {
        "number": 1812,
        "title": "Determine Color of a Chessboard Square",
        "difficulty": 0,
        "answer": "        row, col = coordinates.split(\"\")\n        return row[0] == \"a\" and col[0] == \"1\""
    },
    {
        "number": 1813,
        "title": "Sentence Similarity III",
        "difficulty": 1,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://disc"
    },
    {
        "number": 1814,
        "title": "Count Nice Pairs in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i + 1][i] = 1\n            dp[i + 1][i + 1] = 1\n            for j in range(i + 1, n):\n                dp[i + 1][j] = dp[i][j] + dp[i][j - 1]\n                dp[i + 1][j + 1] = dp[i][j] + dp[i][j + 1]\n        return sum(dp[n][i] for i in range(n)) % (10 ** 9 + 7)\n"
    },
    {
        "number": 1815,
        "title": "Maximum Number of Groups Getting Fresh Donuts",
        "difficulty": 2,
        "answer": "        dp = [[0] * (batchSize + 1) for _ in range(batchSize + 1)]\n        for i in range(1, batchSize + 1):\n            for j in range(1, i + 1):\n                dp[i][j] = dp[i - 1][j - 1] + groups[i - 1]\n        for i in range(2, batchSize + 1):\n            for j in range(1, i):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + groups[i - 1])\n        return max(dp[batchSize][batchSize], dp[batchSize - 1][batchSize - 1])\n"
    },
    {
        "number": 1816,
        "title": "Truncate Sentence",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/truncate-sentence/discuss/\n        # https://leetcode.com/problems/truncate-sentence-ii/discuss/\n        # https://leetcode.com/problems/truncate-sentence-iii/discuss/\n        # https://leetcode.com/problems/truncate-sentence-iv/discuss/\n        # https://leetcode.com/problems/truncate-sentence-v/discuss/\n        # https://leetcode.com/problems/truncate-sentence-vi/discuss/\n        # https://leetcode.com/problems/truncate-sentence-vii/discuss/\n        # https://leetcode.com/problems/truncate-sentence-viii/discuss/\n        # https://leetcode.com/problems/truncate-sentence-ix/discuss/\n        # https://leetcode.com/problems/truncate"
    },
    {
        "number": 1817,
        "title": "Finding the Users Active Minutes",
        "difficulty": 1,
        "answer": "        def get_active_minutes(logs, k):\n            active_minutes = {}\n            for log in logs:\n                user_id, time = log\n                if user_id not in active_minutes:\n                    active_minutes[user_id] = set()\n                active_minutes[user_id].add(time)\n            return active_minutes"
    },
    {
        "number": 1818,
        "title": "Minimum Absolute Sum Difference",
        "difficulty": 1,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 == 0:\n            return 0\n        if n2 == 0:\n            return 0\n        if n1 == 1:\n            return abs(nums1[0] - nums2[0])\n        if n2 == 1:\n            return abs(nums1[0] - nums2[0])\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            for j in range(n2):\n                dp[i + 1][j + 1] = abs(nums1[i] - nums2[j])\n        for i in range(n1):\n            for j in range(n2):\n                dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j + 1] + dp[i + 1][j])\n        return dp[n1][n2] % (10 ** 9"
    },
    {
        "number": 1819,
        "title": "Number of Different Subsequences GCDs",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                if nums[i] % nums[j] == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1]"
    },
    {
        "number": 1822,
        "title": "Sign of the Product of an Array",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        sign = 1\n        for num in nums:\n            sign *= num\n        return sign"
    },
    {
        "number": 1823,
        "title": "Find the Winner of the Circular Game",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2 if k == 2 else 1\n        if n == 3:\n            return 3 if k == 2 else 1\n        if n == 4:\n            return 4 if k == 2 else 1\n        if n == 5:\n            return 5 if k == 2 else 1\n        if n == 6:\n            return 6 if k == 2 else 1\n        if n == 7:\n            return 3 if k == 2 else 1\n        if n == 8:\n            return 5 if k == 2 else 1\n        if n == 9:\n            return 6 if k == 2 else 1\n        if n == 10:\n            return 3 if k == 2 else 1\n        if n == 11:\n            return 5 if k == 2 else 1\n        if n == 12:\n            return 6 if k == 2 else 1\n        if n == 13:\n            return 3 if k == 2 else 1\n        if n == 14:\n            return 5 if k == 2 else 1\n        if n == 15:\n            return 6 if k == 2 else 1\n        "
    },
    {
        "number": 1824,
        "title": "Minimum Sideway Jumps",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i - 1], dp[i - 2]) + 1\n        # dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3]) + 1\n        # dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4]) + 1\n        # dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5]) + 1\n        # dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5], dp[i - 6]) + 1\n        # dp[i] = min(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5], dp[i - 6"
    },
    {
        "number": 1825,
        "title": "Finding MK Average",
        "difficulty": 2,
        "answer": "        self.m = m\n        self.k = k\n        self.elements = []\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append(0)\n        self.elements.append("
    },
    {
        "number": 1827,
        "title": "Minimum Operations to Make the Array Increasing",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        dp = [0] * n\n        dp[0] = 0\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + 1\n            if nums[i - 1] < nums[i]:\n                dp[i] = min(dp[i], dp[i - 1] + 1)\n        return dp[-1]\n"
    },
    {
        "number": 1828,
        "title": "Queries on Number of Points Inside a Circle",
        "difficulty": 1,
        "answer": "        points = sorted(points, key=lambda p: p[0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points.append([0, 0])\n        points."
    },
    {
        "number": 1829,
        "title": "Maximum XOR for Each Query",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0] ^ maximumBit]\n        if n == 2:\n            return [nums[0] ^ nums[1] ^ maximumBit]\n        if n == 3:\n            return [nums[0] ^ nums[1] ^ nums[2] ^ maximumBit]\n        if n == 4:\n            return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3] ^ maximumBit]\n        if n == 5:\n            return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3] ^ nums[4] ^ maximumBit]\n        if n == 6:\n            return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3] ^ nums[4] ^ nums[5] ^ maximumBit]\n        if n == 7:\n            return [nums[0] ^ nums[1"
    },
    {
        "number": 1830,
        "title": "Minimum Number of Operations to Make String Sorted",
        "difficulty": 2,
        "answer": "        def reverse(s, i, j):\n            while i < j:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1"
    },
    {
        "number": 1832,
        "title": "Check if the Sentence Is Pangram",
        "difficulty": 0,
        "answer": "        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        return all(letter in alphabet for letter in sentence)"
    },
    {
        "number": 1833,
        "title": "Maximum Ice Cream Bars",
        "difficulty": 1,
        "answer": "        n = len(costs)\n        dp = [[0] * n for _ in range(coins + 1)]\n        for i in range(coins + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(coins + 1):\n                if j >= costs[i - 1]:\n                    dp[j][i] = dp[j][i - 1]\n                else:\n                    dp[j][i] = max(dp[j][i - 1], dp[j - costs[i - 1]][i - 1])\n        return dp[coins][n]\n"
    },
    {
        "number": 1834,
        "title": "Single-Threaded CPU",
        "difficulty": 1,
        "answer": "        n = len(tasks)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = min(dp[i-1][j], d"
    },
    {
        "number": 1835,
        "title": "Find XOR Sum of All Pairs Bitwise AND",
        "difficulty": 2,
        "answer": "        n = len(arr1)\n        m = len(arr2)\n        if n == 0 or m == 0:\n            return 0\n        if n == 1 and m == 1:\n            return arr1[0] ^ arr2[0]\n        if n == 1:\n            return arr1[0]\n        if m == 1:\n            return arr2[0]\n        return arr1[0] ^ arr2[0] ^ self.getXORSum(arr1[1:], arr2[1:])"
    },
    {
        "number": 1837,
        "title": "Sum of Digits in Base K",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if k == 10:\n            return n\n        return self.sumBase(n / k, k) + n % k"
    },
    {
        "number": 1838,
        "title": "Frequency of the Most Frequent Element",
        "difficulty": 1,
        "answer": "        # dp[i] means the max frequency of nums[0...i]\n        # dp[i] = max(dp[i-1], nums[i] + dp[i-1])\n        # dp[0] = 0\n        # dp[1] = nums[1]\n        # dp[2] = max(nums[0], nums[1]) + nums[2]\n        # dp[3] = max(nums[0], nums[1], nums[2]) + nums[3]\n        # dp[4] = max(nums[0], nums[1], nums[2], nums[3]) + nums[4]\n        # dp[5] = max(nums[0], nums[1], nums[2], nums[3], nums[4]) + nums[5]\n        # dp[6] = max(nums[0], nums[1], nums[2], nums[3], nums[4], nums["
    },
    {
        "number": 1839,
        "title": "Longest Substring Of All Vowels in Order",
        "difficulty": 1,
        "answer": "        # dp[i] means the length of the longest beautiful substring ending at i\n        # dp[i] = max(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5])\n        # dp[i] = max(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5])\n        # dp[i] = max(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5])\n        # dp[i] = max(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5])\n        # dp[i] = max(dp[i - 1], dp[i - 2], dp[i - 3], dp[i - 4], dp[i - 5])\n        # dp["
    },
    {
        "number": 1840,
        "title": "Maximum Building Height",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + restrictions[i][j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(restrictions[i][j], restrictions[i - 1][j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(restrictions[i][j], restrictions[i - 1][j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(restrictions[i][j], restrictions[i - 1][j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(restrict"
    },
    {
        "number": 1844,
        "title": "Replace All Digits with Characters",
        "difficulty": 0,
        "answer": "        # O(n) time\n        # O(1) space\n        if not s:\n            return s\n        s = [c for c in s]\n        for i in range(1, len(s), 2):\n            s[i] = chr(ord(s[i-1]) + ord(s[i]) - ord('a') + ord('0'))\n        return ''.join(s)"
    },
    {
        "number": 1845,
        "title": "Seat Reservation Manager",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1846,
        "title": "Maximum Element After Decreasing and Rearranging",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 1:\n            return arr[0]\n        if n == 2:\n            return max(arr[0], arr[1])\n        if n == 3:\n            return max(arr[0], max(arr[1], arr[2]))\n        if n == 4:\n            return max(arr[0], max(arr[1], max(arr[2], arr[3])))\n        if n == 5:\n            return max(arr[0], max(arr[1], max(arr[2], max(arr[3], arr[4]))))\n        if n == 6:\n            return max(arr[0], max(arr[1], max(arr[2], max(arr[3], max(arr[4], arr[5])))))\n        if n == 7:\n            return max(arr[0], max(arr[1], max(arr[2], max(arr[3], max(arr[4], max(arr[5], arr[6]))))))\n        if n == 8:\n            return max("
    },
    {
        "number": 1847,
        "title": "Closest Room",
        "difficulty": 2,
        "answer": "        n = len(rooms)\n        m = len(rooms[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if rooms[i][j] > 0:\n                    dp[i][j] = 1\n        for i in range(n):\n            for j in range(m):\n                if dp[i][j] == 1:\n                    for k in range(m):\n                        if k!= j:\n                            if abs(rooms[i][k] - rooms[i][j]) < abs(dp[i][k] - dp[i][j]):\n                                dp[i][j] = rooms[i][k]\n                            elif abs(rooms[i][k] - rooms[i][j]) == abs(dp[i][k] - dp[i][j]):\n                                if rooms[i][k] < dp[i][j]:\n                                    dp[i][j] = rooms[i][k]\n        ans = []\n        "
    },
    {
        "number": 1848,
        "title": "Minimum Distance to the Target Element",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return abs(nums[0] - target)\n        if n == 2:\n            return abs(nums[0] - target) if nums[0] == target else abs(nums[1] - target)\n        if n == 3:\n            return abs(nums[0] - target) if nums[0] == target else abs(nums[1] - target) if nums[1] == target else abs(nums[2] - target)\n        if n == 4:\n            return abs(nums[0] - target) if nums[0] == target else abs(nums[1] - target) if nums[1] == target else abs(nums[2] - target) if nums[2] == target else abs(nums[3] - target)\n        if n == 5:\n            return abs(nums[0] - target) if nums[0] == target else abs(nums[1] -"
    },
    {
        "number": 1849,
        "title": "Splitting a String Into Descending Consecutive Values",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n < 2:\n            return False\n        dp = [[False] * n for _ in range(n)]\n        dp[0][0] = True\n        for i in range(1, n):\n            dp[i][i] = True\n            for j in range(i - 1, 0, -1):\n                if s[j] == s[i] and dp[j + 1][i - 1]:\n                    dp[i][j] = True\n        return dp[0][n - 1]"
    },
    {
        "number": 1850,
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "difficulty": 1,
        "answer": "        n = len(num)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 1851,
        "title": "Minimum Interval to Include Each Query",
        "difficulty": 2,
        "answer": "        intervals = [[int(i) for i in l] for l in intervals]\n        n = len(intervals)\n        m = len(intervals[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if intervals[i][j] > intervals[i][j + 1]:\n                    dp[i][j] = dp[i][j + 1]\n                else:\n                    dp[i][j] = dp[i][j] + 1\n        ans = []\n        for q in queries:\n            i = 0\n            while i < n and intervals[i][0] <= q:\n                i += 1\n            j = m - 1\n            while j >= 0 and intervals[i][j] <= q:\n                j -= 1\n            ans.append(dp[i][j] - 1)\n        return ans\n"
    },
    {
        "number": 1854,
        "title": "Maximum Population Year",
        "difficulty": 0,
        "answer": "        n = len(logs)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1):\n                dp[i][j] = dp[i][j - 1] + logs[i][j] - 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i][j - 2])\n        return dp[0][n]\n"
    },
    {
        "number": 1855,
        "title": "Maximum Distance Between a Pair of Values",
        "difficulty": 1,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                if nums1[i - 1] <= nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return max(dp[n1][n2], dp[n1][n2 - 1])\n"
    },
    {
        "number": 1856,
        "title": "Maximum Subarray Min-Product",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] * nums[i], nums[i])\n        ans = 0\n        for i in range(n):\n            ans = max(ans, dp[i] * (i + 1))\n        return ans % (10 ** 9 + 7)\n"
    },
    {
        "number": 1857,
        "title": "Largest Color Value in a Directed Graph",
        "difficulty": 2,
        "answer": "        def dfs(i, j, colors, edges):\r\n            if i < 0 or i >= len(colors) or j < 0 or j >= len(colors):\r\n                return 0\r\n            if colors[i] == colors[j]:\r\n                return dfs(i - 1, j - 1, colors, edges) + 1\r\n            return max(dfs(i - 1, j, colors, edges), dfs(i, j - 1, colors, edges))\r\n\r\n        colors = colors.lower()\r\n        n = len(colors)\r\n        edges = [[0 for _ in range(n)] for _ in range(n)]\r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                if colors[i] == colors[j]:\r\n                    edges[i][j] = edges[j][i] = 1\r\n\r\n        return max(dfs(n - 1, n - 1, colors, edges), -1)\r\n\r\n\r\nif __name__ == \"__"
    },
    {
        "number": 1859,
        "title": "Sorting the Sentence",
        "difficulty": 0,
        "answer": "        def sort_sentence(s):\n            s = s.split()\n            s = [s[i] for i in sorted(range(len(s)), key=lambda x: int(x) if x.isdigit() else x)]\n            return''.join(s)\n        return sort_sentence(s)\n"
    },
    {
        "number": 1860,
        "title": "Incremental Memory Leak",
        "difficulty": 1,
        "answer": "        def get_available_bits(memory):\n            return (memory - 1) % 2"
    },
    {
        "number": 1861,
        "title": "Rotating the Box",
        "difficulty": 1,
        "answer": "        m, n = len(box), len(box[0])\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '#':\n                    box[i][j] = '.'\n                elif box[i][j] == '*':\n                    box[i][j] = '#'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '#':\n                    box[i][j] = '.'\n                elif box[i][j] == '.':\n                    box[i][j] = '#'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '#':\n                    box[i][j] = '.'\n                elif box[i][j] == '.':\n                    box[i][j] = '#'\n        return box\n"
    },
    {
        "number": 1862,
        "title": "Sum of Floored Pairs",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n):\n            dp[i] = nums[i] + dp[i - 1]\n        ans = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                ans += dp[i] // dp[j]\n        return ans % (10 ** 9 + 7)"
    },
    {
        "number": 1863,
        "title": "Sum of All Subset XOR Totals",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [0] * (2 ** n)\n        dp[0] = 1\n        for i in range(1, 2 ** n):\n            for j in range(0, n):\n                if i & (1 << j):\n                    dp[i] += dp[i ^ (1 << j)]\n        return dp[-1]\n"
    },
    {
        "number": 1864,
        "title": "Minimum Number of Swaps to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1"
    },
    {
        "number": 1865,
        "title": "Finding Pairs With a Certain Sum",
        "difficulty": 1,
        "answer": "        self.nums1 = nums1\n        self.nums2 = nums2\n        self.index = 0\n        self.val = 0\n        self.count = 0"
    },
    {
        "number": 1866,
        "title": "Number of Ways to Rearrange Sticks With K Sticks Visible",
        "difficulty": 2,
        "answer": "        def dfs(n, k, i, j):\n            if i == j:\n                return 1\n            if k == 0:\n                return 0\n            if i > j:\n                return 0\n            if i == j - 1:\n                return dfs(n, k - 1, i, j)\n            if i == j - 2:\n                return dfs(n, k - 1, i, j) + dfs(n, k - 1, i + 1, j)\n            if i == j - 3:\n                return dfs(n, k - 1, i, j) + dfs(n, k - 1, i + 1, j) + dfs(n, k - 1, i + 2, j)\n            if i == j - 4:\n                return dfs(n, k - 1, i, j) + dfs(n, k - 1, i + 1, j) + dfs(n, k - 1, i + 2, j) + dfs(n, k - 1, i + 3, j)\n            if i == j - 5"
    },
    {
        "number": 1869,
        "title": "Longer Contiguous Segments of Ones than Zeros",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/82707/C%2B%2B-solution-with-explanation\n        # https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/82707/C%2B%2B-solution-with-explanation\n        # https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/82707/C%2B%2B-solution-with-explanation\n        # https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/82707/C%2B%2B-solution-with-explanation\n        # https://leetcode.com/problems/longest-substring-with-at"
    },
    {
        "number": 1870,
        "title": "Minimum Speed to Arrive on Time",
        "difficulty": 1,
        "answer": "        n = len(dist)\n        dp = [[0] * (int(hour) + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = dist[i]\n        for i in range(1, int(hour) + 1):\n            for j in range(n):\n                dp[j][i] = max(dp[j][i - 1], dp[j - 1][i - 1] + dist[j])\n        return dp[n - 1][int(hour)] if dp[n - 1][int(hour)] > 0 else -1"
    },
    {
        "number": 1871,
        "title": "Jump Game VII",
        "difficulty": 1,
        "answer": "        if minJump > maxJump:\n            return False\n        if minJump == maxJump:\n            return s[minJump] == '0'\n        if minJump == 0:\n            return s[0] == '0'\n        if maxJump == 0:\n            return False\n        if maxJump == 1:\n            return s[0] == '0'\n        if minJump == 1:\n            return s[1] == '0'\n        if maxJump == 2:\n            return s[0] == '0' or s[1] == '0'\n        if minJump == 2:\n            return s[2] == '0'\n        if maxJump == 3:\n            return s[0] == '0' or s[1] == '0' or s[2] == '0'\n        if minJump == 3:\n            return s[3] == '0'\n        if maxJump == 4:\n            return s[0] == '0' or s[1] == '0' or s[2] == '0' or s[3] == '0"
    },
    {
        "number": 1872,
        "title": "Stone Game VIII",
        "difficulty": 2,
        "answer": "        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = stones[i] + stones[i + 1]\n        for i in range(n - 2, -1, -1):\n            dp[i][i - 1] = stones[i] + stones[i - 1]\n        for i in range(n - 3, -1, -1):\n            dp[i][i - 2] = stones[i] + stones[i - 2]\n        for i in range(n - 4, -1, -1):\n            dp[i][i - 3] = stones[i] + stones[i - 3]\n        for i in range(n - 5, -1, -1):\n            dp[i][i - 4] = stones[i] + stones[i - 4]\n        for i in range(n - 6, -1, -1"
    },
    {
        "number": 1876,
        "title": "Substrings of Size Three with Distinct Characters",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 2):\n            dp[i][i + 1] = 1\n        for i in range(n - 1):\n            dp[i][i + 2] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = 1\n        for i in range(n - 1, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 3, n + 1):\n                dp[i][j] = dp[i + 1][j - 1] + dp[i + 2][j - 2]\n        return dp[0][n]"
    },
    {
        "number": 1877,
        "title": "Minimize Maximum Pair Sum in Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        if n == 2:\n            return nums[0] + nums[1]\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        return dp[n - 1]\n"
    },
    {
        "number": 1878,
        "title": "Get Biggest Three Rhombus Sums in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = grid[i][j] + dp[i][j - 1] + dp[i - 1][j] + dp[i - 1][j - 1]\n        ans = []\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] not in ans:\n                    ans.append(dp[i][j])\n        return ans if len(ans) >= 3 else ans + [dp[m - 1][n - 1]]\n"
    },
    {
        "number": 1879,
        "title": "Minimum XOR Sum of Two Arrays",
        "difficulty": 2,
        "answer": "        n = len(nums1)\n        m = len(nums2)\n        if n < m:\n            return self.minimumXORSum(nums2, nums1)\n        if m == 0:\n            return 0\n        dp = [0] * (m + 1)\n        dp[0] = nums1[0] ^ nums2[0]\n        for i in range(1, m + 1):\n            dp[i] = dp[i - 1] ^ nums2[i - 1]\n        for i in range(m, n + 1):\n            dp[i] = dp[i - 1] ^ nums1[i - 1]\n        return dp[n]"
    },
    {
        "number": 1880,
        "title": "Check if Word Equals Summation of Two Words",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-2/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-3/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-4/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-5/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-6/\n        # https://www.geeksforgeeks.org/dynamic-programming-set-3-longest-common-subsequence-7/\n        # https://www.geeksforgeeks.org/d"
    },
    {
        "number": 1881,
        "title": "Maximum Value after Insertion",
        "difficulty": 1,
        "answer": "        n = int(n)\n        x = int(x)\n        if n < 0:\n            return '-' + self.maxValue(str(abs(n)), x)\n        if n == 0:\n            return str(x)\n        if n == 1:\n            return str(x) + '0'\n        if n == 2:\n            return str(x) + '0' + '0'\n        if n == 3:\n            return str(x) + '0' + '0' + '0'\n        if n == 4:\n            return str(x) + '0' + '0' + '0' + '0'\n        if n == 5:\n            return str(x) + '0' + '0' + '0' + '0' + '0'\n        if n == 6:\n            return str(x) + '0' + '0' + '0' + '0' + '0' + '0'\n        if n == 7:\n            return str(x) + '0' + '0' + '0' +"
    },
    {
        "number": 1882,
        "title": "Process Tasks Using Servers",
        "difficulty": 1,
        "answer": "        n = len(servers)\n        m = len(tasks)\n        ans = [0] * m\n        for i in range(m):\n            while servers and tasks[i] > tasks[0]:\n                servers.pop(0)\n            while servers and tasks[i] > tasks[0]:\n                servers.pop(0)\n            ans[i] = servers.pop(0)\n        for i in range(m):\n            while servers and tasks[i] > tasks[0]:\n                servers.pop(0)\n            while servers and tasks[i] > tasks[0]:\n                servers.pop(0)\n            ans[i] = servers.pop(0)\n        return ans\n"
    },
    {
        "number": 1883,
        "title": "Minimum Skips to Arrive at Meeting On Time",
        "difficulty": 2,
        "answer": "        n = len(dist)\n        dp = [[0] * hoursBefore for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = dist[i]\n        for i in range(1, hoursBefore):\n            for j in range(n):\n                dp[j][i] = dp[j][i - 1] + dist[j]\n        for i in range(n):\n            for j in range(i + 1, hoursBefore):\n                dp[j][i] = min(dp[j][i], dp[j - 1][i - 1] + dist[j])\n        return dp[hoursBefore - 1][0] - 1"
    },
    {
        "number": 1884,
        "title": "Egg Drop With 2 Eggs and N Floors",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][i] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                dp[i][j] = dp[i - 1][j - 1] + 1\n        return dp[n][n]"
    },
    {
        "number": 1886,
        "title": "Determine Whether Matrix Can Be Obtained By Rotation",
        "difficulty": 0,
        "answer": "        if len(mat)!= len(target):\n            return False\n        m, n = len(mat), len(mat[0])\n        if m!= len(target):\n            return False\n        if m!= n:\n            return False\n        if m == 1:\n            return mat[0] == target[0]\n        if m == 2:\n            return mat[0] == target[0] and mat[1] == target[1]\n        if m == 3:\n            return mat[0] == target[0] and mat[1] == target[1] and mat[2] == target[2]\n        if m == 4:\n            return mat[0] == target[0] and mat[1] == target[1] and mat[2] == target[2] and mat[3] == target[3]\n        if m == 5:\n            return mat[0] == target[0] and mat[1] == target[1] and mat[2] == target[2] and mat[3] == target[3] and mat[4] == target[4]"
    },
    {
        "number": 1887,
        "title": "Reduction Operations to Make the Array Elements Equal",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 1888,
        "title": "Minimum Number of Flips to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 1889,
        "title": "Minimum Space Wasted From Packaging",
        "difficulty": 2,
        "answer": "        # DP\n        dp = [[0] * boxes[0].__len__() for _ in range(packages.__len__())]\n        for i in range(packages.__len__()):\n            for j in range(boxes[0].__len__()):\n                if boxes[i][j] <= packages[i]:\n                    dp[i][j] = boxes[i][j] - packages[i]\n                else:\n                    dp[i][j] = -1\n        # dp[i][j] = max(dp[i][j], dp[i-1][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1] + boxes[i][j])\n        # dp[i][j] = max(dp[i]["
    },
    {
        "number": 1893,
        "title": "Check if All the Integers in a Range Are Covered",
        "difficulty": 0,
        "answer": "        for i in range(len(ranges)):\n            if left <= ranges[i][0] and ranges[i][1] <= right:\n                return True\n        return False\n"
    },
    {
        "number": 1894,
        "title": "Find the Student that Will Replace the Chalk",
        "difficulty": 1,
        "answer": "        n = len(chalk)\n        if k < n:\n            return n - k\n        else:\n            return 0"
    },
    {
        "number": 1895,
        "title": "Largest Magic Square",
        "difficulty": 1,
        "answer": "        def dfs(grid, i, j, k):\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n                return 0\n            if grid[i][j] == 0:\n                return 0\n            if k == 0:\n                return 1\n            if grid[i][j] == k:\n                return dfs(grid, i - 1, j, k) + dfs(grid, i + 1, j, k) + dfs(grid, i, j - 1, k) + dfs(grid, i, j + 1, k)\n            else:\n                return max(dfs(grid, i - 1, j, grid[i][j]), dfs(grid, i + 1, j, grid[i][j]), dfs(grid, i, j - 1, grid[i][j]), dfs(grid, i, j + 1, grid[i][j]))\n        \n        n = len(grid)\n        m = len(grid[0])\n        \n        max_size = 0\n        "
    },
    {
        "number": 1896,
        "title": "Minimum Cost to Change the Final Value of Expression",
        "difficulty": 2,
        "answer": "        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        # https://leetcode.com/problems/min-operations-to-flip-binary-expression/discuss/\n        #"
    },
    {
        "number": 1897,
        "title": "Redistribute Characters to Make All Strings Equal",
        "difficulty": 0,
        "answer": "        if len(words) == 0:\n            return True\n        if len(words) == 1:\n            return True\n        if len(words) == 2:\n            return words[0] == words[1]\n        if len(words) == 3:\n            return words[0] == words[1] or words[0] == words[2] or words[1] == words[2]\n        if len(words) == 4:\n            return words[0] == words[1] or words[0] == words[2] or words[0] == words[3] or words[1] == words[2] or words[1] == words[3] or words[2] == words[3]\n        if len(words) == 5:\n            return words[0] == words[1] or words[0] == words[2] or words[0] == words[3] or words[0] == words[4] or words[1] == words[2] or words[1] == words[3] or words[1] == words[4] or words[2]"
    },
    {
        "number": 1898,
        "title": "Maximum Number of Removable Characters",
        "difficulty": 1,
        "answer": "        n = len(s)\n        m = len(p)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = i\n        for j in range(1, m + 1):\n            dp[0][j] = j\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == p[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n][m]"
    },
    {
        "number": 1899,
        "title": "Merge Triplets to Form Target Triplet",
        "difficulty": 1,
        "answer": "        def find_max(a, b):\n            if a > b:\n                return a\n            return b"
    },
    {
        "number": 1900,
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return [1, 1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2]\n        if n == 4:\n            return [1, 2]\n        if n == 5:\n            return [1, 2]\n        if n == 6:\n            return [1, 2]\n        if n == 7:\n            return [1, 2]\n        if n == 8:\n            return [1, 2]\n        if n == 9:\n            return [1, 2]\n        if n == 10:\n            return [1, 2]\n        if n == 11:\n            return [1, 2]\n        if n == 12:\n            return [1, 2]\n        if n == 13:\n            return [1, 2]\n        if n == 14:\n            return [1, 2]\n        if n == 15:\n            return [1, 2]\n        if n == 16:\n            return [1, 2]\n        if n == 17:\n            return ["
    },
    {
        "number": 1901,
        "title": "Find a Peak Element II",
        "difficulty": 1,
        "answer": "        if not mat:\n            return []\n        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    mat[i][j] = max(mat[i][j], mat[i][j - 1])\n                elif j == 0:\n                    mat[i][j] = max(mat[i][j], mat[i - 1][j])\n                else:\n                    mat[i][j] = max(mat[i][j], mat[i - 1][j], mat[i][j - 1], mat[i - 1][j - 1])\n        return [i, j]"
    },
    {
        "number": 1903,
        "title": "Largest Odd Number in String",
        "difficulty": 0,
        "answer": "        odd_numbers = []\n        for i in range(len(num)):\n            if num[i] == '0':\n                continue\n            if num[i] == '1':\n                odd_numbers.append(num[i])\n            else:\n                odd_numbers.append(num[i])\n                if len(odd_numbers) > 1:\n                    odd_numbers.pop()\n        if len(odd_numbers) == 0:\n            return \"\"\n        return \"\".join(odd_numbers)"
    },
    {
        "number": 1904,
        "title": "The Number of Full Rounds You Have Played",
        "difficulty": 1,
        "answer": "        login_time = [int(x) for x in loginTime.split(':')]\n        logout_time = [int(x) for x in logoutTime.split(':')]\n        if logout_time[0] < login_time[0]:\n            return 0\n        if logout_time[1] < login_time[1]:\n            return 0\n        if logout_time[2] < login_time[2]:\n            return 0\n        if logout_time[3] < login_time[3]:\n            return 0\n        if logout_time[4] < login_time[4]:\n            return 0\n        if logout_time[5] < login_time[5]:\n            return 0\n        if logout_time[6] < login_time[6]:\n            return 0\n        if logout_time[7] < login_time[7]:\n            return 0\n        if logout_time[8] < login_time[8]:\n            return 0\n        if logout_time[9] < login_time[9"
    },
    {
        "number": 1905,
        "title": "Count Sub Islands",
        "difficulty": 1,
        "answer": "        m, n = len(grid1), len(grid1[0])\n        islands = 0\n        for i in range(m):\n            for j in range(n):\n                if grid1[i][j] == 1 and grid2[i][j] == 1:\n                    islands += 1\n                    self.dfs(grid1, grid2, i, j, m, n)\n        return islands"
    },
    {
        "number": 1906,
        "title": "Minimum Absolute Difference Queries",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        m = len(queries)\n        ans = [-1] * m\n        if n == 0:\n            return ans\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, n + 1):\n            dp[0][i] = abs(nums[0] - nums[i])\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + abs(nums[j] - nums[j - 1])\n        for i in range(m):\n            ans[i] = dp[i + 1][n]\n        return ans\n"
    },
    {
        "number": 1909,
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return True\n        if nums[0] > nums[1]:\n            return False\n        for i in range(2, len(nums)):\n            if nums[i - 1] >= nums[i]:\n                return False\n        return True"
    },
    {
        "number": 1910,
        "title": "Remove All Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        i = 0\n        while i < len(s):\n            if s[i:i + len(part)] == part:\n                s = s[:i] + s[i + len(part):]\n                i = i + len(part)\n            else:\n                i += 1\n        return s\n"
    },
    {
        "number": 1911,
        "title": "Maximum Alternating Subsequence Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n            dp[i][i + 1] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 2] = max(nums[i] + nums[i + 1], nums[i + 1] + nums[i + 2])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 3] = max(nums[i] + nums[i + 2], nums[i + 2] + nums[i + 3])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 4] = max(nums[i] + nums[i + 3], nums[i + 3] + nums[i + 4])\n        for i in range(n - 4, -1"
    },
    {
        "number": 1912,
        "title": "Design Movie Rental System",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 1913,
        "title": "Maximum Product Difference Between Two Pairs",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 4: return 0\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j"
    },
    {
        "number": 1914,
        "title": "Cyclically Rotating a Grid",
        "difficulty": 1,
        "answer": "        if not grid or not grid[0]: return grid\n        m, n = len(grid), len(grid[0])\n        if m % 2!= 0 or n % 2!= 0: return grid\n        if k < 0: return grid\n        if k == 0: return grid\n        if k == 1: return self.rotate(grid)\n        if k == 2: return self.rotate(self.rotate(grid))\n        if k == 3: return self.rotate(self.rotate(self.rotate(grid)))\n        if k == 4: return self.rotate(self.rotate(self.rotate(self.rotate(grid))))\n        if k == 5: return self.rotate(self.rotate(self.rotate(self.rotate(self.rotate(grid))))\n        if k == 6: return self.rotate(self.rotate(self.rotate(self.rotate(self.rotate(self.rotate(grid))))))\n        if k == 7: return self.rotate(self.rotate(self.rot"
    },
    {
        "number": 1915,
        "title": "Number of Wonderful Substrings",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(word)):\n            count += self.count(word, i, i)\n        return count"
    },
    {
        "number": 1916,
        "title": "Count Ways to Build Rooms in an Ant Colony",
        "difficulty": 2,
        "answer": "        n = len(prevRoom)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][n] % 1007\n"
    },
    {
        "number": 1920,
        "title": "Build Array from Permutation",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(len(nums)):\n            ans.append(nums[nums[i]])\n        return ans"
    },
    {
        "number": 1921,
        "title": "Eliminate Maximum Number of Monsters",
        "difficulty": 1,
        "answer": "        n = len(dist)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n"
    },
    {
        "number": 1922,
        "title": "Count Good Numbers",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 5\n        if n == 2:\n            return 10\n        if n == 3:\n            return 25\n        if n == 4:\n            return 400\n        if n == 5:\n            return 564908303\n        if n == 6:\n            return 564908303 * 2\n        if n == 7:\n            return 564908303 * 3\n        if n == 8:\n            return 564908303 * 4\n        if n == 9:\n            return 564908303 * 5\n        if n == 10:\n            return 564908303 * 6\n        if n == 11:\n            return 564908303 * 7\n        if n == 12:\n            return 564908303 * 8\n        if n == 13:\n            return 564908303 * 9\n        if n == 14:\n            return 564908303 * 10\n        if n == 15:\n            return 564908303 * 11\n        if n == 16:\n            return 564908303 * 12\n        if n == 17:\n            return 564908303 * 13\n"
    },
    {
        "number": 1923,
        "title": "Longest Common Subpath",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] ="
    },
    {
        "number": 1925,
        "title": "Count Square Sum Triples",
        "difficulty": 0,
        "answer": "        return sum(self.countTriplesHelper(n, i, j) for i in range(1, n + 1) for j in range(i, n + 1))"
    },
    {
        "number": 1926,
        "title": "Nearest Exit from Entrance in Maze",
        "difficulty": 1,
        "answer": "        m, n = len(maze), len(maze[0])\n        visited = [[False] * n for _ in range(m)]\n        visited[entrance[0]][entrance[1]] = True\n        queue = [(entrance[0], entrance[1])]\n        while queue:\n            r, c = queue.pop(0)\n            if maze[r][c] == '.':\n                return 0\n            if r == 0 and c == 0:\n                return -1\n            for dr, dc in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and maze[nr][nc] == '.' and not visited[nr][nc]:\n                    queue.append((nr, nc))\n                    visited[nr][nc] = True\n        return -1\n"
    },
    {
        "number": 1927,
        "title": "Sum Game",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/game-of-sum/discuss/\n        # https://leetcode.com/problems/game-of-sum-ii/discuss/\n        # https://leetcode.com/problems/game-of-sum-iii/discuss/\n        # https://leetcode.com/problems/game-of-sum-iv/discuss/\n        # https://leetcode.com/problems/game-of-sum-v/discuss/\n        # https://leetcode.com/problems/game-of-sum-vi/discuss/\n        # https://leetcode.com/problems/game-of-sum-vii/discuss/\n        # https://leetcode.com/problems/game-of-sum-viii/discuss/\n        # https://leetcode.com/problems/game-of-sum-ix/discuss/\n        # https://leetcode.com/problems/game-of-sum-x/discuss/\n"
    },
    {
        "number": 1928,
        "title": "Minimum Cost to Reach Destination in Time",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + edges[i][j])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + edges[i][j])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + edges[i][j])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + edges[i][j])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + edges[i][j])\n        # dp[i][j] ="
    },
    {
        "number": 1929,
        "title": "Concatenation of Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        ans = [nums[i] for i in range(n)]\n        for i in range(n):\n            ans.append(nums[i])\n        return ans"
    },
    {
        "number": 1930,
        "title": "Unique Length-3 Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s)):\n            dp[i][i] = 1\n        for i in range(len(s) - 1):\n            dp[i][i + 1] = 1\n        for i in range(len(s) - 2):\n            dp[i][i + 2] = dp[i + 1][i + 1] + dp[i + 1][i]\n        for i in range(len(s) - 3):\n            dp[i][i + 3] = dp[i + 2][i + 2] + dp[i + 2][i]\n        for i in range(len(s) - 4):\n            dp[i][i + 4] = dp[i + 3][i + 3] + dp[i + 3][i]\n        for i in range(len(s) - 5):\n            dp[i][i + 5] = dp[i + 4][i + 4] +"
    },
    {
        "number": 1931,
        "title": "Painting a Grid With Three Different Colors",
        "difficulty": 2,
        "answer": "        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = 1\n        for i in range(1, m + 1):\n            dp[i][0] = 1\n        for j in range(1, n + 1):\n            dp[0][j] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m][n] % (10 ** 9 + 7)\n"
    },
    {
        "number": 1932,
        "title": "Merge BSTs to Create Single BST",
        "difficulty": 2,
        "answer": "        def merge(a, b):\n            if a is None:\n                return b\n            if b is None:\n                return a\n            if a.val > b.val:\n                a.left, a.right = b, a\n                a.val = b.val\n            else:\n                b.left, b.right = a, b\n                b.val = a.val\n            return a"
    },
    {
        "number": 1935,
        "title": "Maximum Number of Words You Can Type",
        "difficulty": 0,
        "answer": "        def can_type(text, broken_letters):\n            if not text:\n                return 0\n            if not broken_letters:\n                return 1\n            if len(text) == 1:\n                return 0\n            if len(text) == 2:\n                if text[0] == text[1]:\n                    return 0\n                return 1\n            if len(text) == 3:\n                if text[0] == text[1] and text[1] == text[2]:\n                    return 0\n                return 1\n            if len(text) == 4:\n                if text[0] == text[1] and text[1] == text[2] and text[2] == text[3]:\n                    return 0\n                return 1\n            if len(text) == 5:\n                if text[0] == text[1] and text[1] == text[2] and text[2] == text[3] and text[3] == text[4]:\n                    return 0\n                return 1\n            if len(text) == 6:\n                if text[0] == text[1]"
    },
    {
        "number": 1936,
        "title": "Add Minimum Number of Rungs",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/climbing-a-ladder/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-ii/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-iii/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-iv/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-v/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-vi/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-vii/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-viii/discuss/\n        # https://leetcode.com/problems/climbing-a-ladder-ix/discuss"
    },
    {
        "number": 1937,
        "title": "Maximum Number of Points with Cost",
        "difficulty": 1,
        "answer": "        m, n = len(points), len(points[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = points[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + points[i][j]\n        return max(dp)\n"
    },
    {
        "number": 1938,
        "title": "Maximum Genetic Difference Query",
        "difficulty": 2,
        "answer": "        n = len(parents)\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n        parents = [parents[i] for i in range(n)]\n        parents.sort()\n"
    },
    {
        "number": 1941,
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "difficulty": 0,
        "answer": "        count = {}\n        for c in s:\n            if c not in count:\n                count[c] = 1\n            else:\n                count[c] += 1\n        return len(count) == 1 and count.values()[0] == len(s)\n"
    },
    {
        "number": 1942,
        "title": "The Number of the Smallest Unoccupied Chair",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j"
    },
    {
        "number": 1943,
        "title": "Describe the Painting",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + sum(segments[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + sum(segments[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + sum(segments[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + sum(segments[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + sum(segments["
    },
    {
        "number": 1944,
        "title": "Number of Visible People in a Queue",
        "difficulty": 2,
        "answer": "        n = len(heights)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [1]\n        if n == 3:\n            return [2]\n        if n == 4:\n            return [3]\n        if n == 5:\n            return [4]\n        if n == 6:\n            return [5]\n        if n == 7:\n            return [6]\n        if n == 8:\n            return [7]\n        if n == 9:\n            return [8]\n        if n == 10:\n            return [9]\n        if n == 11:\n            return [10]\n        if n == 12:\n            return [11]\n        if n == 13:\n            return [12]\n        if n == 14:\n            return [13]\n        if n == 15:\n            return [14]\n        if n == 16:\n            return [15]\n        if n == 17:\n            return [16]\n        if n == 18:\n            return"
    },
    {
        "number": 1945,
        "title": "Sum of Digits of String After Convert",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return ord(s[0]) - ord('a') + 1\n        if k == 1:\n            return sum(ord(c) - ord('a') + 1 for c in s)\n        if k == 2:\n            return sum(ord(c) - ord('a') + 1 for c in s) + sum(ord(c) - ord('a') + 1 for c in s[1:])\n        if k == 3:\n            return sum(ord(c) - ord('a') + 1 for c in s) + sum(ord(c) - ord('a') + 1 for c in s[1:]) + sum(ord(c) - ord('a') + 1 for c in s[2:])\n        if k == 4:\n            return sum(ord(c) - ord('a') + 1 for c in s) + sum(ord(c) - ord('a') + 1 for c in s[1:]) + sum(ord(c) - ord"
    },
    {
        "number": 1946,
        "title": "Largest Number After Mutating Substring",
        "difficulty": 1,
        "answer": "        n = len(num)\n        dp = [0] * 10\n        for i in range(n):\n            dp[num[i]] = max(dp[num[i]], dp[change[num[i]]] + 1)\n        return str(max(dp))\n"
    },
    {
        "number": 1947,
        "title": "Maximum Compatibility Score Sum",
        "difficulty": 1,
        "answer": "        n = len(students)\n        m = len(mentors)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for j in range(1, m + 1):\n            dp[0][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if students[i - 1][j - 1] == 1 and mentors[j - 1][i - 1] == 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[n][m]"
    },
    {
        "number": 1948,
        "title": "Delete Duplicate Folders in System",
        "difficulty": 2,
        "answer": "        def dfs(paths, i, j):\n            if i == len(paths) - 1:\n                return\n            if j == len(paths[i]) - 1:\n                if len(paths[i][j]) == 0:\n                    paths[i][j] = None\n                    dfs(paths, i + 1, 0)\n                return\n            if paths[i][j] is None:\n                paths[i][j] = None\n                dfs(paths, i, j + 1)\n                dfs(paths, i + 1, j)\n        \n        ans = []\n        for i in range(len(paths)):\n            if i == 0:\n                ans.append([])\n            for j in range(len(paths[i])):\n                if paths[i][j] is not None:\n                    dfs(paths, i, j)\n        for i in range(len(paths)):\n            for j in range(len(paths[i])):\n                if paths[i][j] is None"
    },
    {
        "number": 1952,
        "title": "Three Divisors",
        "difficulty": 0,
        "answer": "        if n < 3:\n            return False\n        if n == 3:\n            return True\n        if n % 3 == 0:\n            return False\n        if n % 3 == 1:\n            return True\n        return self.isThree(n // 3)"
    },
    {
        "number": 1953,
        "title": "Maximum Number of Weeks for Which You Can Work",
        "difficulty": 1,
        "answer": "        n = len(milestones)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = dp[i + 1][i] + 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = dp[i + 1][i + 1] + 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = dp[i + 2][i + 1] + 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = dp[i + 3][i + 1] + 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = dp[i + 4][i + 1] + 1\n        for i"
    },
    {
        "number": 1954,
        "title": "Minimum Garden Perimeter to Collect Enough Apples",
        "difficulty": 1,
        "answer": "        def dfs(i, j, needed_apples):\n            if i < 0 or j < 0:\n                return 0\n            if i == 0 and j == 0:\n                return needed_apples\n            if i == 0:\n                return dfs(i, j - 1, needed_apples) + 2 * (j + 1)\n            if j == 0:\n                return dfs(i - 1, j, needed_apples) + 2 * (i + 1)\n            return min(dfs(i - 1, j, needed_apples), dfs(i, j - 1, needed_apples), dfs(i - 1, j - 1, needed_apples)) + 2 * (i + j + 1)"
    },
    {
        "number": 1955,
        "title": "Count Number of Special Subsequences",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = 1\n            dp[i][i + 1] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 2] = dp[i + 1][i + 2] + dp[i + 1][i + 1]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 3] = dp[i + 1][i + 3] + dp[i + 1][i + 2] + dp[i + 1][i + 1]\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 4] = dp[i + 1][i + 4] + dp[i + 1][i + 3] + dp[i + 1][i + 2] + dp[i + 1][i + 1]\n        "
    },
    {
        "number": 1957,
        "title": "Delete Characters to Make Fancy String",
        "difficulty": 0,
        "answer": "        # O(n) time\n        # O(1) space\n        if len(s) <= 2:\n            return s\n        s = list(s)\n        for i in range(1, len(s) - 1):\n            if s[i] == s[i - 1] and s[i] == s[i + 1]:\n                s[i] = '#'\n        return ''.join(s)"
    },
    {
        "number": 1958,
        "title": "Check if Move is Legal",
        "difficulty": 1,
        "answer": "        if rMove < 0 or rMove >= len(board) or cMove < 0 or cMove >= len(board[0]) or board[rMove][cMove]!= \".\":\n            return False\n        if color == \"W\":\n            return self.checkMove(board, rMove, cMove, \"B\") or self.checkMove(board, rMove, cMove, \"W\")\n        else:\n            return self.checkMove(board, rMove, cMove, \"W\") or self.checkMove(board, rMove, cMove, \"B\")"
    },
    {
        "number": 1959,
        "title": "Minimum Total Space Wasted With K Resizing Operations",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if k == 0:\n            return 0\n        if k == 1:\n            return min(nums[0], nums[1])\n        if k == 2:\n            return min(nums[0], nums[1]) + min(nums[2], nums[3])\n        if k == 3:\n            return min(nums[0], nums[1]) + min(nums[2], nums[3]) + min(nums[4], nums[5])\n        if k == 4:\n            return min(nums[0], nums[1]) + min(nums[2], nums[3]) + min(nums[4], nums[5]) + min(nums[6], nums[7])\n        if k == 5:\n            return min(nums[0], nums[1]) + min(nums[2], nums[3]) + min(n"
    },
    {
        "number": 1960,
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "difficulty": 2,
        "answer": "        # DP\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # dp[i][j] = max(dp[i + 1][j], dp[i]["
    },
    {
        "number": 1961,
        "title": "Check If String Is a Prefix of Array",
        "difficulty": 0,
        "answer": "        if not words:\n            return False\n        if len(words) == 1:\n            return s == words[0]\n        if len(words) == 2:\n            return s == words[0] or s == words[1]\n        if len(words) == 3:\n            return s == words[0] or s == words[1] or s == words[2]\n        if len(words) == 4:\n            return s == words[0] or s == words[1] or s == words[2] or s == words[3]\n        if len(words) == 5:\n            return s == words[0] or s == words[1] or s == words[2] or s == words[3] or s == words[4]\n        if len(words) == 6:\n            return s == words[0] or s == words[1] or s == words[2] or s == words[3] or s == words[4] or s == words[5]\n        if len(words) == 7:\n            return s == words[0] or s =="
    },
    {
        "number": 1962,
        "title": "Remove Stones to Minimize the Total",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min stones in piles[:i] + min stones in piles[i+1:j]\n        # dp[i][j] = min stones in piles[:i] + min stones in piles[i+1:j] + min stones in piles[j+1:]\n        # dp[i][j] = min stones in piles[:i] + min stones in piles[i+1:j] + min stones in piles[j+1:] + min stones in piles[j+1:]\n        # dp[i][j] = min stones in piles[:i] + min stones in piles[i+1:j] + min stones in piles[j+1:] + min stones in piles[j+1:] + min stones in piles[j+1:]\n        # dp[i][j] = min stones in piles[:i] + min stones in piles[i+1:j] + min stones in piles[j+1:] + min stones in piles[j+1:] + min stones in piles[j+1:] + min stones in piles["
    },
    {
        "number": 1963,
        "title": "Minimum Number of Swaps to Make the String Balanced",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if n % 2 == 1:\n            return -1\n        if n == 2:\n            return 0 if s[0] == s[1] else 1\n        if n == 4:\n            return 0 if s[0] == s[3] and s[1] == s[2] else 1\n        if n == 6:\n            return 0 if s[0] == s[5] and s[1] == s[4] and s[2] == s[3] else 1\n        if n == 8:\n            return 0 if s[0] == s[7] and s[1] == s[6] and s[2] == s[5] and s[3] == s[4] and s[4] == s[7] and s[5] == s[6] and s[6] == s[7] else 1\n        if n == 10:\n            return 0 if s[0] == s[9] and s[1] == s[8] and s[2]"
    },
    {
        "number": 1964,
        "title": "Find the Longest Valid Obstacle Course at Each Position",
        "difficulty": 2,
        "answer": "        n = len(obstacles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if obstacles[i] <= obstacles[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0]"
    },
    {
        "number": 1967,
        "title": "Number of Strings That Appear as Substrings in Word",
        "difficulty": 0,
        "answer": "        if not patterns:\n            return 0\n        if not word:\n            return 0\n        if len(patterns) == 1:\n            return 1 if patterns[0] in word else 0\n        dp = [[0] * len(word) for _ in range(len(patterns))]\n        for i in range(len(patterns)):\n            for j in range(len(word)):\n                if patterns[i] in word[:j + 1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n        return sum(dp[i][j] for i in range(len(patterns)) for j in range(len(word)))"
    },
    {
        "number": 1968,
        "title": "Array With Elements Not Equal to Average of Neighbors",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        n = len(nums)\n        if n == 1:\n            return nums\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:\n            return [nums[0], nums["
    },
    {
        "number": 1969,
        "title": "Minimum Non-Zero Product of the Array Elements",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-2/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-3/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-4/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-5/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-6/\n        # https://www.geeksforgeeks.org/minimum-product-of-two-numbers-after-swapping-bits-7/\n        # https://www.geeksforgeeks.org/minimum"
    },
    {
        "number": 1970,
        "title": "Last Day Where You Can Still Cross",
        "difficulty": 2,
        "answer": "        n = len(cells)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1]\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n - 1][n - 1]"
    },
    {
        "number": 1971,
        "title": "Find if Path Exists in Graph",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return edges[0][0] == source and edges[1][1] == destination\n        if n == 3:\n            return edges[0][0] == source and edges[1][1] == destination or edges[0][1] == source and edges[1][0] == destination\n        if n == 4:\n            return edges[0][0] == source and edges[1][1] == destination or edges[0][1] == source and edges[1][0] == destination\n        if n == 5:\n            return edges[0][0] == source and edges[1][1] == destination or edges[0][1] == source and edges[1][0] == destination\n        if n == 6:\n            return edges[0][0] == source and edges[1][1] == destination or edges[0][1] == source and edges[1][0] == destination\n        return False\n"
    },
    {
        "number": 1974,
        "title": "Minimum Time to Type Word Using Special Typewriter",
        "difficulty": 0,
        "answer": "        # dic = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11,'m': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17,'s': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n        # dic = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11,'m': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17,'s': 18, 't': 19, 'u': 20, 'v"
    },
    {
        "number": 1975,
        "title": "Maximum Matrix Sum",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        if n == 0:\n            return 0\n        if n == 1:\n            return matrix[0][0]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], matrix[i][j])\n                if i > 0 and j > 0:\n                    dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n                if i > 0:\n                    dp[i][j] += max(dp[i - 1][j], matrix[i][j])\n                if j > 0:\n                    dp[i][j] += max(dp[i][j - 1], matrix[i][j])\n        return max(dp[n - 1][n - 1], dp[n - 1][n - 2])\n"
    },
    {
        "number": 1976,
        "title": "Number of Ways to Arrive at Destination",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] ="
    },
    {
        "number": 1977,
        "title": "Number of Ways to Separate Numbers",
        "difficulty": 2,
        "answer": "        n = len(num)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if num[i - 1]!= '0':\n                dp[i] += dp[i - 1]\n        return dp[n] % MOD\n"
    },
    {
        "number": 1979,
        "title": "Find Greatest Common Divisor of Array",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return nums[0] if nums[0] == nums[-1] else nums[-1]"
    },
    {
        "number": 1980,
        "title": "Find Unique Binary String",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if nums[i][j] == '1':\n                    dp[i][j] = True\n                    for k in range(n):\n                        if nums[i][k] == '1' and dp[i][k]:\n                            dp[i][j] = False\n                            break\n        for i in range(n):\n            for j in range(n):\n                if dp[i][j]:\n                    return ''.join(nums[i])\n        return '0'"
    },
    {
        "number": 1981,
        "title": "Minimize the Difference Between Target and Chosen Elements",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = abs(target - mat[i][j])\n        for i in range(m):\n            for j in range(n):\n                for k in range(j + 1, n):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        return dp[0][0]\n"
    },
    {
        "number": 1982,
        "title": "Find Array Given Subset Sums",
        "difficulty": 2,
        "answer": "        # sort the sums\n        sums.sort()\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find the first and last elements\n        first = sums[0]\n        last = sums[-1]\n        # find"
    },
    {
        "number": 1984,
        "title": "Minimum Difference Between Highest and Lowest of K Scores",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if k > n:\n            return 0\n        dp = [0] * (k + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, k + 1):\n            dp[i] = max(nums[i - 1], nums[i]) - min(nums[i - 2], nums[i])\n        return dp[k]\n"
    },
    {
        "number": 1985,
        "title": "Find the Kth Largest Integer in the Array",
        "difficulty": 1,
        "answer": "        def get_kth_largest(nums, k):\n            nums.sort()\n            return nums[-k]"
    },
    {
        "number": 1986,
        "title": "Minimum Number of Work Sessions to Finish the Tasks",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i], dp[i - 1] + tasks[i])\n        # dp[i] = min(dp[i], dp[i - 1] + tasks[i] - tasks[i - 1])\n        # dp[i] = min(dp[i], dp[i - 1] + tasks[i] - tasks[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + tasks[i] - tasks[i - 1] + 1, dp[i - 1] + tasks[i] - tasks[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + tasks[i] - tasks[i - 1] + 1, dp[i - 1] + tasks[i] - tasks[i - 1] + 1, dp[i - 1] + tasks[i] - tasks[i - 1] + 1)\n        # dp[i] = min(dp["
    },
    {
        "number": 1987,
        "title": "Number of Unique Good Subsequences",
        "difficulty": 2,
        "answer": "        dp = [[0] * (len(binary) + 1) for _ in range(len(binary) + 1)]\n        for i in range(len(binary) + 1):\n            dp[i][0] = 1\n        for i in range(1, len(binary) + 1):\n            for j in range(1, i + 1):\n                if binary[j - 1] == '0':\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        return sum(dp[-1]) % (10 ** 9 + 7)\n"
    },
    {
        "number": 1991,
        "title": "Find the Middle Index in Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return"
    },
    {
        "number": 1992,
        "title": "Find All Groups of Farmland",
        "difficulty": 1,
        "answer": "        m, n = len(land), len(land[0])\n        groups = [[0, 0, m - 1, 0], [0, 0, 0, n - 1]]\n        for i in range(m):\n            for j in range(n):\n                if land[i][j] == 1:\n                    groups[0][0] = i\n                    groups[1][0] = j\n                    break\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if land[i][j] == 1:\n                    groups[0][2] = i\n                    groups[1][2] = j\n                    break\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                if land[i][j] == 1:\n                    groups[0][3] = i\n                    groups[1][1] = j\n                    break\n        for i in range(m):\n            for j in range(n - 1, -1, -1):"
    },
    {
        "number": 1993,
        "title": "Operations on Tree",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1994,
        "title": "The Number of Good Subsets",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                if nums[j] == nums[i - 1]:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[n]"
    },
    {
        "number": 1995,
        "title": "Count Special Quadruplets",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 4:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n]"
    },
    {
        "number": 1996,
        "title": "The Number of Weak Characters in the Game",
        "difficulty": 1,
        "answer": "        # dp[i][j] = number of weak characters in i, j\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1 if dp[i-1][j] > dp[i][j-1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1 if dp[i-1][j] == dp[i][j-1] and dp[i-1][j] > dp[i][j-1]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1 if dp[i-1][j] == dp[i][j-1] and dp[i-1][j] == dp[i][j-1] and dp[i-"
    },
    {
        "number": 1997,
        "title": "First Day Where You Have Been in All the Rooms",
        "difficulty": 1,
        "answer": "        # dp[i] = the first day where you have been in all the rooms\n        # dp[i] = dp[i - 1] + 1 if you have been in room i an odd number of times (including the current visit)\n        # dp[i] = dp[i - 1] + 2 if you have been in room i an even number of times (including the current visit)\n        dp = [0] * len(nextVisit)\n        for i in range(len(nextVisit)):\n            if i % 2 == 0:\n                dp[i] = dp[i - 1] + 2\n            else:\n                dp[i] = dp[i - 1] + 1\n        return dp[-1] % (10 ** 9 + 7)\n"
    },
    {
        "number": 1998,
        "title": "GCD Sort of an Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return True\n        if n == 2:\n            return nums[0] < nums[1]\n        if n == 3:\n            return nums[0] < nums[1] or nums[1] < nums[2]\n        if n == 4:\n            return nums[0] < nums[1] or nums[1] < nums[2] or nums[2] < nums[3]\n        if n == 5:\n            return nums[0] < nums[1] or nums[1] < nums[2] or nums[2] < nums[3] or nums[3] < nums[4]\n        if n == 6:\n            return nums[0] < nums[1] or nums[1] < nums[2] or nums[2] < nums[3] or nums[3] < nums[4] or nums[4] < nums[5]\n        if n == 7"
    },
    {
        "number": 2000,
        "title": "Reverse Prefix of Word",
        "difficulty": 0,
        "answer": "        i = 0\n        while i < len(word) and word[i]!= ch:\n            i += 1\n        if i == len(word):\n            return word\n        j = i\n        while j < len(word) and word[j] == ch:\n            j += 1\n        return word[i:j] + word[:i] + word[j:]"
    },
    {
        "number": 2001,
        "title": "Number of Pairs of Interchangeable Rectangles",
        "difficulty": 1,
        "answer": "        n = len(rectangles)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if rectangles[i][0] / rectangles[i][1] == rectangles[j][0] / rectangles[j][1]:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    dp[j][i] = dp[j - 1][i] + 1\n        return sum(dp[n - 1])\n"
    },
    {
        "number": 2002,
        "title": "Maximum Product of the Length of Two Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 2003,
        "title": "Smallest Missing Genetic Value in Each Subtree",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0] + 1]\n        parents = [p for p in parents if p!= -1]\n        if len(parents) == 0:\n            return [nums[0] + 1]\n        if len(parents) == 1:\n            return [nums[parents[0]] + 1]\n        if len(parents) == 2:\n            return [nums[parents[0]] + 1, nums[parents[1]] + 1]\n        if len(parents) == 3:\n            return [nums[parents[0]] + 1, nums[parents[1]] + 1, nums[parents[2]] + 1]\n        if len(parents) == 4:\n            return [nums[parents[0]] + 1, nums[parents[1]] + 1, nums[parents[2]] + 1, nums[parents[3]] + 1]\n        if len(parents) == 5:\n            return [nums[parents"
    },
    {
        "number": 2006,
        "title": "Count Number of Pairs With Absolute Difference K",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        if k == 0:\n            return n * (n - 1) // 2\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            for j in range(i):\n                if abs(nums[i] - nums[j]) == k:\n                    dp[k][i] += dp[k - 1][j]\n        return dp[k][n]\n"
    },
    {
        "number": 2007,
        "title": "Find Original Array From Doubled Array",
        "difficulty": 1,
        "answer": "        n = len(changed)\n        if n == 0:\n            return []\n        if n == 1:\n            return []\n        if n == 2:\n            return [changed[0], changed[1]]\n        if n == 3:\n            return [changed[0], changed[1], changed[2]]\n        if n == 4:\n            return [changed[0], changed[1], changed[2], changed[3]]\n        if n == 5:\n            return [changed[0], changed[1], changed[2], changed[3], changed[4]]\n        if n == 6:\n            return [changed[0], changed[1], changed[2], changed[3], changed[4], changed[5]]\n        if n == 7:\n            return [changed[0], changed[1], changed[2], changed[3], changed[4], changed[5], changed[6]]\n        if n == 8:\n            return [changed[0], changed[1], changed[2], changed[3], changed[4], changed[5], changed[6], changed[7]]\n        if n"
    },
    {
        "number": 2008,
        "title": "Maximum Earnings From Taxi",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + rides[i][2]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(rides[i][0], rides[i][1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(rides[i][0], rides[i][1]) + max(rides[i][2], 0)\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(rides[i][0], rides[i][1]) + max(rides[i][2], 0) + max(rides[i][2], 0)\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(rides[i][0],"
    },
    {
        "number": 2009,
        "title": "Minimum Number of Operations to Make Array Continuous",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21"
    },
    {
        "number": 2011,
        "title": "Final Value of Variable After Performing Operations",
        "difficulty": 0,
        "answer": "        stack = []\n        for op in operations:\n            if op == '++X':\n                stack.append(stack.pop() + 1)\n            elif op == '--X':\n                stack.append(stack.pop() - 1)\n            elif op == 'X++':\n                stack.append(stack.pop() + 1)\n            elif op == 'X--':\n                stack.append(stack.pop() - 1)\n        return stack[0]\n"
    },
    {
        "number": 2012,
        "title": "Sum of Beauty in the Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        dp[0] = 2\n        dp[1] = 1\n        for i in range(2, n):\n            if nums[i - 1] < nums[i] and nums[i] < nums[i + 1]:\n                dp[i] = 2\n            elif nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\n                dp[i] = 1\n            else:\n                dp[i] = 0\n        return sum(dp)\n"
    },
    {
        "number": 2013,
        "title": "Detect Squares",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2014,
        "title": "Longest Subsequence Repeated k Times",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + s[i] == s[j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + s[i] == s[j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + s[i] == s[j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + s[i] == s[j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + s[i] =="
    },
    {
        "number": 2016,
        "title": "Maximum Difference Between Increasing Elements",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return -1\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(nums[i] - dp[i - 1], nums[i] - dp[i - 1])\n        return max(dp)\n"
    },
    {
        "number": 2017,
        "title": "Grid Game",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        if n == 0:\n            return 0\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i][j] + dp[i][j + 1]\n        return dp[n - 1][m - 1]\n"
    },
    {
        "number": 2018,
        "title": "Check if Word Can Be Placed In Crossword",
        "difficulty": 1,
        "answer": "        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '#':\n                    continue\n                if board[i][j]!='' and board[i][j]!= word[0]:\n                    return False\n                if board[i][j] =='' and word[0]!='':\n                    return False\n                if board[i][j]!='' and board[i][j]!= word[0]:\n                    return False\n                if board[i][j] =='' and word[0]!='':\n                    return False\n                if board[i][j]!='' and board[i][j]!= word[0]:\n                    return False\n                if board[i][j] =='' and word[0]!='':\n                    return False\n                if board[i][j]!='' and board[i][j]!= word[0]:\n                    return False\n                if board[i][j] =='' and word"
    },
    {
        "number": 2019,
        "title": "The Score of Students Solving Math Expression",
        "difficulty": 2,
        "answer": "        n = len(answers)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 5\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if s[i] == '*' and s[j] == '*':\n                    dp[i][j] = dp[i + 1][j - 1] + dp[i][j - 1]\n                elif s[i] == '*' and s[j] == '+':\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n                elif s[i] == '+' and s[j] == '*':\n                    dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n                elif s[i] == '+' and s[j] == '+':\n                    dp[i][j] = dp[i"
    },
    {
        "number": 2022,
        "title": "Convert 1D Array Into 2D Array",
        "difficulty": 0,
        "answer": "        result = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                result[i][j] = original[i * n + j]\n        return result"
    },
    {
        "number": 2023,
        "title": "Number of Pairs of Strings With Concatenation Equal to Target",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums = sorted(nums)\n        dp = [[0] * (len(nums) + 1) for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                if nums[i] + nums[j] == target:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n        return sum(sum(dp[i + 1][j + 1] for j in range(i + 1, len(nums) + 1)) for i in range(len(nums)))\n"
    },
    {
        "number": 2024,
        "title": "Maximize the Confusion of an Exam",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i]"
    },
    {
        "number": 2025,
        "title": "Maximum Number of Ways to Partition an Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n        return dp[0][n]"
    },
    {
        "number": 2027,
        "title": "Minimum Moves to Convert String",
        "difficulty": 0,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 2\n        for i in range(n - 2):\n            dp[i][i + 2] = 3\n        for i in range(n - 3):\n            dp[i][i + 3] = 4\n        for i in range(n - 4):\n            dp[i][i + 4] = 5\n        for i in range(n - 5):\n            dp[i][i + 5] = 6\n        for i in range(n - 6):\n            dp[i][i + 6] = 7\n        for i in range(n - 7):\n            dp[i][i + 7] = 8\n        for i in range(n - 8):\n            dp[i][i + 8] = 9\n        for i in range(n - 9):\n            dp[i][i + 9] = 10\n"
    },
    {
        "number": 2028,
        "title": "Find Missing Observations",
        "difficulty": 1,
        "answer": "        # dp[i] = the number of ways to get i\n        # dp[i] = dp[i - rolls[i - 1]] + 1\n        # dp[i] = dp[i - rolls[i - 1]] + 1 - dp[i - rolls[i - 1] - 1]\n        # dp[i] = dp[i - rolls[i - 1]] + 1 - dp[i - rolls[i - 1] - 1] + dp[i - rolls[i - 1] - 2]\n        # dp[i] = dp[i - rolls[i - 1]] + 1 - dp[i - rolls[i - 1] - 1] + dp[i - rolls[i - 1] - 2] - dp[i - rolls[i - 1] - 3]\n        # dp[i] = dp[i - rolls[i - 1]] + 1 - dp[i - rolls[i - 1] - 1] + dp[i - rolls[i - 1] - 2] - dp[i"
    },
    {
        "number": 2029,
        "title": "Stone Game IX",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n == 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return False\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return False\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return False\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return False\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n"
    },
    {
        "number": 2030,
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "difficulty": 2,
        "answer": "        if len(s) < k:\n            return \"\"\n        if len(s) == k:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 1:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 2:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 3:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 4:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 5:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 6:\n            if s[0] == letter:\n                return s\n            return \"\"\n        if len(s) == k + 7:\n            if s[0] == letter:\n                return s\n            return"
    },
    {
        "number": 2032,
        "title": "Two Out of Three",
        "difficulty": 0,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        n3 = len(nums3)\n        if n1 == 0 or n2 == 0 or n3 == 0:\n            return []\n        if n1 == 1 and n2 == 1 and n3 == 1:\n            return [nums1[0], nums2[0], nums3[0]]\n        if n1 == 1 and n2 == 1 and n3 == 0:\n            return [nums1[0]]\n        if n1 == 0 and n2 == 1 and n3 == 1:\n            return [nums2[0]]\n        if n1 == 0 and n2 == 0 and n3 == 1:\n            return [nums3[0]]\n        if n1 == 0 and n2 == 1 and n3 == 0:\n            return []\n        if n1 == 1 and n2 == 0 and n3 == 0:\n            return [nums1[0]]\n        if n1 == 0 and n2 == 0 and n3 == 0:\n            return []"
    },
    {
        "number": 2033,
        "title": "Minimum Operations to Make a Uni-Value Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == x:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[m - 1][n - 1]\n"
    },
    {
        "number": 2034,
        "title": "Stock Price Fluctuation ",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2035,
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return abs(nums[0])\n        if n == 2:\n            return min(abs(nums[0] - nums[1]), abs(nums[1] - nums[0]))\n        if n == 3:\n            return min(abs(nums[0] - nums[1]), abs(nums[1] - nums[2]), abs(nums[2] - nums[0]))\n        if n == 4:\n            return min(abs(nums[0] - nums[1]), abs(nums[1] - nums[2]), abs(nums[2] - nums[3]), abs(nums[3] - nums[0]))\n        if n == 5:\n            return min(abs(nums[0] - nums[1]), abs(nums[1] - nums[2]), abs(nums[2] - nums[3]), abs(nums[3]"
    },
    {
        "number": 2037,
        "title": "Minimum Number of Moves to Seat Everyone",
        "difficulty": 0,
        "answer": "        n = len(seats)\n        m = len(students)\n        if n == 0 or m == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            "
    },
    {
        "number": 2038,
        "title": "Remove Colored Pieces if Both Neighbors are the Same Color",
        "difficulty": 1,
        "answer": "        n = len(colors)\n        if n == 1:\n            return True\n        if n == 2:\n            return colors[0] == colors[1]\n        if n == 3:\n            return colors[0] == colors[1] and colors[1] == colors[2]\n        if n == 4:\n            return colors[0] == colors[1] and colors[2] == colors[3]\n        if n == 5:\n            return colors[0] == colors[1] and colors[2] == colors[3] and colors[4] == colors[0]\n        if n == 6:\n            return colors[0] == colors[1] and colors[2] == colors[3] and colors[4] == colors[5]\n        if n == 7:\n            return colors[0] == colors[1] and colors[2] == colors[3] and colors[4] == colors[5] and colors[6] == colors[0]\n        if n == 8:\n            return colors[0] == colors[1] and colors[2] == colors["
    },
    {
        "number": 2039,
        "title": "The Time When the Network Becomes Idle",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges[i] else 0\n        # dfs[i] = dfs[i-1] + 1 if edges["
    },
    {
        "number": 2040,
        "title": "Kth Smallest Product of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 < 1 or n2 < 1:\n            return 0\n        if k < 1:\n            return 0\n        if k > n1 * n2:\n            return 0\n        if n1 == 1:\n            return nums1[0] * nums2[k - 1]\n        if n2 == 1:\n            return nums1[k - 1] * nums2[0]\n        if n1 == 2:\n            return nums1[0] * nums2[k - 1] + nums1[1] * nums2[k - 2]\n        if n2 == 2:\n            return nums1[k - 1] * nums2[0] + nums1[k - 2] * nums2[1]\n        if n1 == 3:\n            return nums1[0] * nums2[k - 1] + nums1[1] * nums2[k - 2] + nums1[2] *"
    },
    {
        "number": 2042,
        "title": "Check if Numbers Are Ascending in a Sentence",
        "difficulty": 0,
        "answer": "        def is_number(s):\n            return s.isdigit() or s[0] == '-'"
    },
    {
        "number": 2043,
        "title": "Simple Bank System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2044,
        "title": "Count Number of Maximum Bitwise-OR Subsets",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j]\n        return dp[n]"
    },
    {
        "number": 2045,
        "title": "Second Minimum Time to Reach Destination",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time\n        # dp[i][j] = min(dp[i-1][j], dp[i][j"
    },
    {
        "number": 2047,
        "title": "Number of Valid Words in a Sentence",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        words = [w for w in words if w.strip('-') and w.strip('!') and w.strip('.')]\n        return len(words)"
    },
    {
        "number": 2048,
        "title": "Next Greater Numerically Balanced Number",
        "difficulty": 1,
        "answer": "        def next_balanced(n):\n            if n == 0:\n                return 1\n            if n == 1:\n                return 2\n            if n == 2:\n                return 3\n            if n == 3:\n                return 5\n            if n == 4:\n                return 6\n            if n == 5:\n                return 8\n            if n == 6:\n                return 9\n            if n == 7:\n                return 11\n            if n == 8:\n                return 12\n            if n == 9:\n                return 14\n            if n == 10:\n                return 15\n            if n == 11:\n                return 17\n            if n == 12:\n                return 18\n            if n == 13:\n                return 20\n            if n == 14:\n                return 21\n            if n == 15:\n                return 23\n            if n == 16:\n                return 24\n            if n == 17:\n                return 26\n            if n == 18:\n                return 27\n            if n == 19:\n                return 29\n            if n == 20:\n                return 30\n            if n == 21:\n                return 32"
    },
    {
        "number": 2049,
        "title": "Count Nodes With the Highest Score",
        "difficulty": 1,
        "answer": "        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://discuss.leetcode.com/topic/82784/python-solution-using-dfs-with-explanation\n        # https://disc"
    },
    {
        "number": 2050,
        "title": "Parallel Courses III",
        "difficulty": 2,
        "answer": "        # dp[i] = min(dp[i], dp[i-1] + time[i])\n        # dp[i] = min(dp[i], dp[i-1] + max(time[i], time[relations[i][0]]))\n        # dp[i] = min(dp[i], dp[i-1] + max(time[i], max(time[relations[i][0]], time[relations[i][1]])))\n        # dp[i] = min(dp[i], dp[i-1] + max(time[i], max(time[relations[i][0]], max(time[relations[i][1]], time[relations[i][2]]))))\n        # dp[i] = min(dp[i], dp[i-1] + max(time[i], max(time[relations[i][0]], max(time[relations[i][1]], max(time[relations[i][2]], max(time[relations[i][3]], max(time["
    },
    {
        "number": 2053,
        "title": "Kth Distinct String in an Array",
        "difficulty": 0,
        "answer": "        if len(arr) == 0:\n            return \"\"\n        if len(arr) == 1:\n            return arr[0]\n        if k == 1:\n            return arr[0]\n        if k == 2:\n            return arr[0]\n        if k == 3:\n            return arr[1]\n        if k == 4:\n            return arr[2]\n        if k == 5:\n            return arr[3]\n        if k == 6:\n            return arr[4]\n        if k == 7:\n            return arr[5]\n        if k == 8:\n            return arr[6]\n        if k == 9:\n            return arr[7]\n        if k == 10:\n            return arr[8]\n        if k == 11:\n            return arr[9]\n        if k == 12:\n            return arr[10]\n        if k == 13:\n            return arr[11]\n        if k == 14:\n            return arr[12]\n        if k == 15:\n            return arr[13]\n        if k == 16:\n            return"
    },
    {
        "number": 2054,
        "title": "Two Best Non-Overlapping Events",
        "difficulty": 1,
        "answer": "        # sort events by start time\n        events.sort(key=lambda x: x[0])\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start time, events[i][1] is end time, events[i][2] is value\n        # events[i][0] is start"
    },
    {
        "number": 2055,
        "title": "Plates Between Candles",
        "difficulty": 1,
        "answer": "        def get_plates(s, left, right):\n            if left > right:\n                return 0\n            if left == right:\n                return 1\n            if left == right - 1:\n                return 2\n            if left + 1 == right:\n                return 3\n            if left + 2 == right:\n                return 4\n            if left + 3 == right:\n                return 5\n            if left + 4 == right:\n                return 6\n            if left + 5 == right:\n                return 7\n            if left + 6 == right:\n                return 8\n            if left + 7 == right:\n                return 9\n            return 0"
    },
    {
        "number": 2056,
        "title": "Number of Valid Move Combinations On Chessboard",
        "difficulty": 2,
        "answer": "        n = len(pieces)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n        if n == 5:\n            return 16\n        if n == 6:\n            return 32\n        if n == 7:\n            return 64\n        if n == 8:\n            return 128\n        if n == 9:\n            return 256\n        if n == 10:\n            return 512\n        if n == 11:\n            return 1024\n        if n == 12:\n            return 2048\n        if n == 13:\n            return 4096\n        if n == 14:\n            return 8192\n        if n == 15:\n            return 16384\n        if n == 16:\n            return 32768\n        if n == 17:\n            return 65536\n        if n == 18:\n            return 131072\n        if n == 19:\n            return 262144\n        if n == 20:\n            return 524288\n        if"
    },
    {
        "number": 2057,
        "title": "Smallest Index With Equal Value",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0\n        if n == 2:\n            return nums[0] == nums[1]\n        if n == 3:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]\n        if n == 4:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[1] == nums[2] or nums[1] == nums[3] or nums[2] == nums[3]\n        if n == 5:\n            return nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or nums[1] == nums[2] or nums"
    },
    {
        "number": 2058,
        "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
        "difficulty": 1,
        "answer": "        if not head:\n            return [-1, -1]\n        minDistance = -1\n        maxDistance = -1\n        previous = head\n        current = head\n        while current:\n            if previous and previous.val > current.val:\n                minDistance = min(minDistance, current.val - previous.val)\n            if previous and previous.val < current.val:\n                maxDistance = max(maxDistance, current.val - previous.val)\n            previous = current\n            current = current.next\n        return [minDistance, maxDistance]"
    },
    {
        "number": 2059,
        "title": "Minimum Operations to Convert Number",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0] + nums[i - 1]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + nums[i - 1]\n        return dp[n][n] - start"
    },
    {
        "number": 2060,
        "title": "Check if an Original String Exists Given Two Encoded Strings",
        "difficulty": 2,
        "answer": "        def split_string(s):\n            return [s[i:i+j] for i, j in zip(range(0, len(s), 2), range(1, 3))]"
    },
    {
        "number": 2062,
        "title": "Count Vowel Substrings of a String",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-vowel-substrings/discuss/\n        # https://leetcode.com/problems/count-v"
    },
    {
        "number": 2063,
        "title": "Vowels of All Substrings",
        "difficulty": 1,
        "answer": "        vowels = ['a', 'e', 'i', 'o', 'u']\n        count = 0\n        for i in range(len(word)):\n            count += sum(1 for c in word[i:] if c in vowels)\n        return count\n"
    },
    {
        "number": 2064,
        "title": "Minimized Maximum of Products Distributed to Any Store",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - quantities[i]] + quantities[i])\n        # dp[i][0] = 0\n        # dp[0][j] = 0\n        # dp[0][0] = 0\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - quantities[i]] + quantities[i])\n        # dp[i][0] = 0\n        # dp[0][j] = 0\n        # dp[0][0] = 0\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - quantities[i]] + quantities[i])\n        # dp[i][0] = 0\n        # dp[0][j] = 0\n        # dp[0][0] = 0\n        # dp[i][j] = max(dp[i - 1][j], dp[i -"
    },
    {
        "number": 2065,
        "title": "Maximum Path Quality of a Graph",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + values[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j"
    },
    {
        "number": 2068,
        "title": "Check Whether Two Strings are Almost Equivalent",
        "difficulty": 0,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        counts1 = collections.Counter(word1)\n        counts2 = collections.Counter(word2)\n        diff = 0\n        for i in range(26):\n            diff += abs(counts1[i] - counts2[i])\n        return diff <= 3\n"
    },
    {
        "number": 2069,
        "title": "Walking Robot Simulation II",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2070,
        "title": "Most Beautiful Item for Each Query",
        "difficulty": 1,
        "answer": "        n = len(items)\n        m = len(items[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if items[i][0] <= queries[i]:\n                    dp[i][j] = max(dp[i][j], items[i][1])\n        return dp\n"
    },
    {
        "number": 2071,
        "title": "Maximum Number of Tasks You Can Assign",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1 if dp[i - 1][j] >= dp[i][j - 1] else dp[i][j - 1]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1 if dp[i - 1][j] >= dp[i][j - 1] else dp[i][j - 1] + 1\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1 if dp[i - 1][j] >= dp[i][j - 1] else dp[i][j - 1] +"
    },
    {
        "number": 2073,
        "title": "Time Needed to Buy Tickets",
        "difficulty": 0,
        "answer": "        n = len(tickets)\n        if n == 0:\n            return 0\n        if k == n - 1:\n            return 0\n        if k == 0:\n            return n * tickets[0]\n        if k == n - 1:\n            return n * tickets[n - 1]\n        if k == 0:\n            return n * tickets[0] + n * tickets[1]\n        if k == n - 1:\n            return n * tickets[n - 2] + n * tickets[n - 1]\n        if k == 0:\n            return n * tickets[0] + n * tickets[1] + n * tickets[2]\n        if k == n - 1:\n            return n * tickets[n - 2] + n * tickets[n - 1] + n * tickets[n - 3]\n        if k == 0:\n            return n * tickets[0] + n * tickets[1] + n * tickets[2] + n * tickets[3]\n        if k == n - 1:\n            return n * tickets[n - 2] + n * tickets["
    },
    {
        "number": 2074,
        "title": "Reverse Nodes in Even Length Groups",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None"
    },
    {
        "number": 2075,
        "title": "Decode the Slanted Ciphertext",
        "difficulty": 1,
        "answer": "        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n        # The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\n"
    },
    {
        "number": 2076,
        "title": "Process Restricted Friend Requests",
        "difficulty": 2,
        "answer": "        # dic[i] = [j for j in range(n) if i in restrictions[j]]\n        # dic[j] = [i for i in range(n) if j in restrictions[i]]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic[i] = dic[j]\n        # dic[j] = dic[i]\n        # dic"
    },
    {
        "number": 2078,
        "title": "Two Furthest Houses With Different Colors",
        "difficulty": 0,
        "answer": "        n = len(colors)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(abs(i - j), dp[i][j - 1])\n        return max(dp[i][j] for i in range(n) for j in range(i + 1, n))\n"
    },
    {
        "number": 2079,
        "title": "Watering Plants",
        "difficulty": 1,
        "answer": "        n = len(plants)\n        if n == 0:\n            return 0\n        if n == 1:\n            return plants[0]\n        if n == 2:\n            return plants[0] + plants[1]\n        if n == 3:\n            return plants[0] + plants[1] + plants[2]\n        if n == 4:\n            return plants[0] + plants[1] + plants[2] + plants[3]\n        if n == 5:\n            return plants[0] + plants[1] + plants[2] + plants[3] + plants[4]\n        if n == 6:\n            return plants[0] + plants[1] + plants[2] + plants[3] + plants[4] + plants[5]\n        if n == 7:\n            return plants[0] + plants[1] + plants[2] + plants[3] + plants[4] + plants[5] + plants[6]\n        if n == 8:\n            return plants[0] + plants[1] + plants[2] + plants[3"
    },
    {
        "number": 2080,
        "title": "Range Frequency Queries",
        "difficulty": 1,
        "answer": "        # TODO: write your code here\n        if left > right:\n            return 0\n        if left == right:\n            return arr[left]\n        if left == right - 1:\n            return arr[left] - arr[left + 1]\n        if left + 1 == right:\n            return arr[left] + arr[left + 1]\n        if left + 2 == right:\n            return arr[left] + arr[left + 1] - arr[left + 2]\n        if left + 3 == right:\n            return arr[left] + arr[left + 1] - arr[left + 2] + arr[left + 3]\n        if left + 4 == right:\n            return arr[left] + arr[left + 1] - arr[left + 2] + arr[left + 3] - arr[left + 4]\n        if left + 5 == right:\n            return arr[left] + arr[left + 1] - arr[left + 2] + arr[left + 3] - arr[left + 4] + arr[left + 5]\n        if left + 6 == right"
    },
    {
        "number": 2081,
        "title": "Sum of k-Mirror Numbers",
        "difficulty": 2,
        "answer": "        def k_mirror(n, k):\n            if n == 0:\n                return 0\n            if n == 1:\n                return 1\n            if n == 2:\n                return 2\n            if n == 3:\n                return 3\n            if n == 4:\n                return 4\n            if n == 5:\n                return 5\n            if n == 6:\n                return 6\n            if n == 7:\n                return 7\n            if n == 8:\n                return 8\n            if n == 9:\n                return 9\n            if n == 10:\n                return 10\n            if n == 11:\n                return 11\n            if n == 12:\n                return 12\n            if n == 13:\n                return 13\n            if n == 14:\n                return 14\n            if n == 15:\n                return 15\n            if n == 16:\n                return 16\n            if n == 17:\n                return 17\n            if n == 18:\n                return 18\n            if n == 19:\n                return 19\n            if n == 20:\n                return 20\n            if n == 21:\n"
    },
    {
        "number": 2085,
        "title": "Count Common Words With One Occurrence",
        "difficulty": 0,
        "answer": "        words1_set = set(words1)\n        words2_set = set(words2)\n        return len(words1_set.intersection(words2_set))"
    },
    {
        "number": 2086,
        "title": "Minimum Number of Food Buckets to Feed the Hamsters",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1], dp[i + 1]) + 1\n        # dp[i] = min(dp[i - 1],"
    },
    {
        "number": 2087,
        "title": "Minimum Cost Homecoming of a Robot in a Grid",
        "difficulty": 1,
        "answer": "        m = len(startPos)\n        n = len(homePos)\n        dp = [[0] * n for _ in range(m)]\n        dp[startPos[0]][startPos[1]] = rowCosts[startPos[0]] + colCosts[startPos[1]]\n        for i in range(m):\n            for j in range(n):\n                if i == startPos[0] and j == startPos[1]:\n                    continue\n                if i == homePos[0] and j == homePos[1]:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + colCosts[j])\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + rowCosts[i])\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + rowCosts[i] + colCosts[j])\n        return"
    },
    {
        "number": 2088,
        "title": "Count Fertile Pyramids in a Land",
        "difficulty": 2,
        "answer": "        def count_pyramids(grid):\n            if not grid:\n                return 0\n            m, n = len(grid), len(grid[0])\n            dp = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 1:\n                        dp[i][j] = 1\n                        for k in range(i - 1, -1, -1):\n                            if grid[k][j] == 1:\n                                dp[i][j] += dp[k][j]\n                        for k in range(j - 1, -1, -1):\n                            if grid[i][k] == 1:\n                                dp[i][j] += dp[i][k]\n            return sum(dp)"
    },
    {
        "number": 2089,
        "title": "Find Target Indices After Sorting Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0] if nums[0] == target else []\n        if n == 2:\n            return [0, 1] if nums[0] == target else []\n        if n == 3:\n            return [0, 1, 2] if nums[0] == target else []\n        if n == 4:\n            return [0, 1, 2, 3] if nums[0] == target else []\n        if n == 5:\n            return [0, 1, 2, 3, 4] if nums[0] == target else []\n        if n == 6:\n            return [0, 1, 2, 3, 4, 5] if nums[0] == target else []\n        if n == 7:\n            return [0, 1, 2, 3, 4, 5, 6] if nums[0] == target else []\n        if n == 8:\n            return [0, 1, 2, 3, 4, 5, 6, 7] if"
    },
    {
        "number": 2090,
        "title": "K Radius Subarray Averages",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        avgs = [0] * n\n        for i in range(n):\n            if i - k < 0:\n                avgs[i] = -1\n            else:\n                avgs[i] = sum(nums[i - k:i + k + 1]) / (k + 1)\n        for i in range(n):\n            if i + k >= n:\n                avgs[i] = -1\n            else:\n                avgs[i] = sum(nums[i - k:i + k + 1]) / (k + 1)\n        return avgs\n"
    },
    {
        "number": 2091,
        "title": "Removing Minimum and Maximum From Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22"
    },
    {
        "number": 2092,
        "title": "Find All People With Secret",
        "difficulty": 2,
        "answer": "        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i]\n        # dic[i] = [j for j in range(n) if meetings[j][2] == i"
    },
    {
        "number": 2094,
        "title": "Finding 3-Digit Even Numbers",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(1, 10):\n            for j in range(1, 10):\n                for k in range(1, 10):\n                    if i * j * k == digits[0]:\n                        digits.remove(i * j * k)\n                        ans.append(i * j * k)\n        return sorted(ans)\n"
    },
    {
        "number": 2095,
        "title": "Delete the Middle Node of a Linked List",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        #\n        # class Solution:\n        #     def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #         \"\"\"\n        #         :type head: ListNode\n        #         :rtype: ListNode\n        #         \"\"\"\n        #         if not head:\n        #             return None\n        #         if not head.next:\n        #             return head\n        #         slow = head\n        #         fast = head\n        #         while fast.next and fast.next.next:\n        #             fast = fast.next.next\n        #             slow = slow.next\n"
    },
    {
        "number": 2096,
        "title": "Step-By-Step Directions From a Binary Tree Node to Another",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if node is None:\n                return\n            path.append(node.val)\n            if node.val == startValue:\n                return\n            dfs(node.left, path)\n            dfs(node.right, path)\n            path.pop()"
    },
    {
        "number": 2097,
        "title": "Valid Arrangement of Pairs",
        "difficulty": 2,
        "answer": "        n = len(pairs)\n        if n == 0:\n            return []\n        if n == 1:\n            return [[pairs[0][0], pairs[0][1]]]\n        \n        dp = [[False] * n for _ in range(n)]\n        dp[0][0] = True\n        for i in range(1, n):\n            dp[i][i] = True\n            for j in range(i - 1, 0, -1):\n                if dp[j][i - 1] and pairs[i][0] == pairs[j][1] + 1:\n                    dp[i][j] = True\n                    dp[j][i] = True\n        \n        result = []\n        for i in range(n):\n            for j in range(i):\n                if dp[i][j]:\n                    result.append([pairs[i][0], pairs[j][1]])\n        return result"
    },
    {
        "number": 2099,
        "title": "Find Subsequence of Length K With the Largest Sum",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i - j >= 0:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - j][j]) + nums[i - j]\n        return dp[n][k]"
    },
    {
        "number": 2100,
        "title": "Find Good Days to Rob the Bank",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode.com/problems/good-days-to-rob-bank/discuss/\n        # https://leetcode"
    },
    {
        "number": 2101,
        "title": "Detonate the Maximum Bombs",
        "difficulty": 1,
        "answer": "        def dfs(bombs, i, j, r):\n            if i < 0 or j < 0 or i >= len(bombs) or j >= len(bombs[0]):\n                return 0\n            if bombs[i][j] == 0:\n                return 0\n            if bombs[i][j] == 1:\n                return 1\n            if bombs[i][j] == 2:\n                return 2\n            if bombs[i][j] == 3:\n                return 3\n            if bombs[i][j] == 4:\n                return 4\n            if bombs[i][j] == 5:\n                return 5\n            if bombs[i][j] == 6:\n                return 6\n            if bombs[i][j] == 7:\n                return 7\n            if bombs[i][j] == 8:\n                return 8\n            if bombs[i][j] == 9:\n                return 9\n            if bombs[i][j] == 10:\n                return 10\n            if bombs[i][j] == 11:\n                return 11\n            if bombs[i][j] == 12"
    },
    {
        "number": 2102,
        "title": "Sequentially Ordinal Rank Tracker",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2103,
        "title": "Rings and Rods",
        "difficulty": 0,
        "answer": "        n = len(rings) // 2\n        if n == 0:\n            return 0\n        \n        # dp[i][j] = number of rings with color j on rod i\n        dp = [[0] * 10 for _ in range(10)]\n        for i in range(n):\n            color, rod = rings[2 * i], rings[2 * i + 1]\n            dp[int(rod)][color] += 1\n        \n        # dp[i][j] = number of rings with color j on rod i\n        dp = [[0] * 10 for _ in range(10)]\n        for i in range(n):\n            color, rod = rings[2 * i], rings[2 * i + 1]\n            dp[int(rod)][color] += 1\n        \n        # dp[i][j] = number of rings with color j on rod i\n        dp = [[0] * 10 for _ in range(10)]\n        for i in range(n):\n            color, rod = rings[2 * i], rings[2 * i + 1]\n            dp"
    },
    {
        "number": 2104,
        "title": "Sum of Subarray Ranges",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1] - nums[0]\n        for i in range(2, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2]) + nums[i] - nums[i - 1]\n        return dp[n]\n"
    },
    {
        "number": 2105,
        "title": "Watering Plants II",
        "difficulty": 1,
        "answer": "        n = len(plants)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n            for j in range(i - 1, -1, -1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n - 1][0]"
    },
    {
        "number": 2106,
        "title": "Maximum Fruits Harvested After at Most K Steps",
        "difficulty": 2,
        "answer": "        def dfs(start, end, k):\n            if start == end:\n                return 0\n            if k == 0:\n                return 0\n            if start == end - 1:\n                return max(fruits[start][1], fruits[end][1])\n            if start == end - 2:\n                return max(fruits[start][1], fruits[end][1]) + max(fruits[start + 1][1], fruits[end - 1][1])\n            if start == end - 3:\n                return max(fruits[start][1], fruits[end][1]) + max(fruits[start + 1][1], fruits[end - 1][1]) + max(fruits[start + 2][1], fruits[end - 2][1])\n            if start == end - 4:\n                return max(fruits[start][1], fruits[end][1]) + max(fruits[start + 1][1], fruits[end - 1][1]) + max(fruits[start + 2][1], fruits[end - 2][1]) + max(fruits[start + 3"
    },
    {
        "number": 2108,
        "title": "Find First Palindromic String in the Array",
        "difficulty": 0,
        "answer": "        def is_palindrome(s):\n            return s == s[::-1]"
    },
    {
        "number": 2109,
        "title": "Adding Spaces to a String",
        "difficulty": 1,
        "answer": "        \n        # build a dictionary of indices to spaces\n        indices_to_spaces = {}\n        for i in range(len(spaces)):\n            indices_to_spaces[spaces[i]] = i\n        \n        # build a dictionary of indices to characters\n        indices_to_chars = {}\n        for i in range(len(s)):\n            indices_to_chars[i] = s[i]\n        \n        # build a dictionary of indices to spaces\n        indices_to_spaces = {}\n        for i in range(len(spaces)):\n            indices_to_spaces[spaces[i]] = i\n        \n        # build a dictionary of indices to spaces\n        indices_to_spaces = {}\n        for i in range(len(spaces)):\n            indices_to_spaces[spaces[i]] = i\n        \n        # build a dictionary of indices to spaces\n        indices_to_spaces = {}\n        for i in range(len(spaces)):\n            indices"
    },
    {
        "number": 2110,
        "title": "Number of Smooth Descent Periods of a Stock",
        "difficulty": 1,
        "answer": "        if not prices:\n            return 0\n        dp = [0] * len(prices)\n        dp[0] = 1\n        for i in range(1, len(prices)):\n            dp[i] = dp[i - 1] + 1 if prices[i] - prices[i - 1] == 1 else 0\n        return dp[-1]\n"
    },
    {
        "number": 2111,
        "title": "Minimum Operations to Make the Array K-Increasing",
        "difficulty": 2,
        "answer": "        # https://www.geeksforgeeks.org/k-increasing-array-set-1-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-2-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-3-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-4-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-5-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-6-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-7-greedy-algorithm/\n        # https://www.geeksforgeeks.org/k-increasing-array-set-8-greedy-algorithm/\n        # https://www.geeksforgeeks"
    },
    {
        "number": 2114,
        "title": "Maximum Number of Words Found in Sentences",
        "difficulty": 0,
        "answer": "        words = set()\n        for sentence in sentences:\n            words.update(sentence.split())\n        return max(words)\n"
    },
    {
        "number": 2115,
        "title": "Find All Possible Recipes from Given Supplies",
        "difficulty": 1,
        "answer": "        def dfs(recipe, ingredients, supplies, visited, result):\n            if recipe in result:\n                return\n            if recipe not in visited:\n                visited.add(recipe)\n            for i in range(len(ingredients)):\n                if ingredients[i][0] not in supplies:\n                    continue\n                if ingredients[i][0] not in visited:\n                    dfs(ingredients[i][0], ingredients[i][1:], supplies, visited, result)\n            result.append(recipe)"
    },
    {
        "number": 2116,
        "title": "Check if a Parentheses String Can Be Valid",
        "difficulty": 1,
        "answer": "        # dp[i] means whether s[0...i] is valid\n        # dp[i] = (s[0...i] in valid) or (s[0...i] in valid and dp[i-1])\n        # dp[i] = (s[0...i] in valid and dp[i-1]) or (s[0...i] in valid and dp[i-1] and dp[i-2])\n        # dp[i] = (s[0...i] in valid and dp[i-1] and dp[i-2]) or (s[0...i] in valid and dp[i-1])\n        # dp[i] = (s[0...i] in valid and dp[i-1]) or (s[0...i] in valid)\n        # dp[i] = (s[0...i] in valid)\n        # dp[i] = (s[0...i] in valid and dp[i-1])\n        # dp[i] = ("
    },
    {
        "number": 2117,
        "title": "Abbreviating the Product of a Range",
        "difficulty": 2,
        "answer": "        if left > right:\n            return \"\"\n        if left == right:\n            return str(left)\n        if left == right - 1:\n            return str(left) + \"e1\"\n        if left == right - 2:\n            return str(left) + \"e2\"\n        if left == right - 3:\n            return str(left) + \"e3\"\n        if left == right - 4:\n            return str(left) + \"e4\"\n        if left == right - 5:\n            return str(left) + \"e5\"\n        if left == right - 6:\n            return str(left) + \"e6\"\n        if left == right - 7:\n            return str(left) + \"e7\"\n        if left == right - 8:\n            return str(left) + \"e8\"\n        if left == right - 9:\n            return str(left) + \"e9\"\n        if left == right - 10:\n            return str(left) + \"e10\"\n        if left == right - 11:\n            return str(left)"
    },
    {
        "number": 2119,
        "title": "A Number After a Double Reversal",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return True\n        if num < 0:\n            return False\n        if num == 1:\n            return True\n        if num == 2:\n            return True\n        if num == 3:\n            return True\n        if num == 4:\n            return True\n        if num == 5:\n            return True\n        if num == 6:\n            return True\n        if num == 7:\n            return True\n        if num == 8:\n            return True\n        if num == 9:\n            return True\n        if num == 10:\n            return True\n        if num == 11:\n            return True\n        if num == 12:\n            return True\n        if num == 13:\n            return True\n        if num == 14:\n            return True\n        if num == 15:\n            return True\n        if num == 16:\n            return True\n        if num == 17:\n            return True\n        if num == 18:\n            return True\n        if num == 19:\n            return True\n        if num == 20:\n            return True\n        if num == 21:\n            "
    },
    {
        "number": 2120,
        "title": "Execution of All Suffix Instructions Staying in a Grid",
        "difficulty": 1,
        "answer": "        m = len(s)\n        grid = [[0] * n for _ in range(n)]\n        for i in range(m):\n            grid[startPos[0]][startPos[1]] = i + 1\n            if s[i] == 'L':\n                grid[startPos[0]][startPos[1]] -= 1\n            elif s[i] == 'R':\n                grid[startPos[0]][startPos[1]] += 1\n            elif s[i] == 'U':\n                grid[startPos[0]][startPos[1]] -= n\n            elif s[i] == 'D':\n                grid[startPos[0]][startPos[1]] += n\n        ans = [0] * m\n        for i in range(m):\n            if grid[0][0] == 0 or grid[n - 1][n - 1] == 0:\n                break\n            ans[i] = 1\n            for j in range(n):\n                if grid[j][j] == 0:\n                    break\n                if grid[j"
    },
    {
        "number": 2121,
        "title": "Intervals Between Identical Elements",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [arr[0] - arr[1], arr[1] - arr[0]]\n        if n == 3:\n            return [arr[0] - arr[1], arr[1] - arr[2], arr[2] - arr[0]]\n        if n == 4:\n            return [arr[0] - arr[1], arr[1] - arr[2], arr[2] - arr[3], arr[3] - arr[0]]\n        if n == 5:\n            return [arr[0] - arr[1], arr[1] - arr[2], arr[2] - arr[3], arr[3] - arr[4], arr[4] - arr[0]]\n        if n == 6:\n            return [arr[0] - arr[1], arr[1] - arr[2], arr[2] - arr[3], arr[3] - arr[4], arr["
    },
    {
        "number": 2122,
        "title": "Recover the Original Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0] + nums[1]]\n        if n == 3:\n            return [nums[0] + nums[1] + nums[2]]\n        if n == 4:\n            return [nums[0] + nums[1] + nums[2] + nums[3]]\n        if n == 5:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4]]\n        if n == 6:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]]\n        if n == 7:\n            return [nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5"
    },
    {
        "number": 2124,
        "title": "Check if All A\"s Appears Before All B\"s",
        "difficulty": 0,
        "answer": "        if len(s) < 2:\n            return True\n        a_count = 0\n        b_count = 0\n        for i in range(len(s)):\n            if s[i] == 'a':\n                a_count += 1\n            elif s[i] == 'b':\n                b_count += 1\n        return a_count == b_count and a_count == len(s) // 2"
    },
    {
        "number": 2125,
        "title": "Number of Laser Beams in a Bank",
        "difficulty": 1,
        "answer": "        m, n = len(bank), len(bank[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if bank[i][j] == '1':\n                    dp[i][j] = 1\n                    for k in range(i + 1, m):\n                        if bank[k][j] == '1':\n                            dp[i][j] += dp[k][j]\n                    for k in range(j + 1, n):\n                        if bank[i][k] == '1':\n                            dp[i][j] += dp[i][k]\n        return sum(dp)\n"
    },
    {
        "number": 2126,
        "title": "Destroying Asteroids",
        "difficulty": 1,
        "answer": "        # dp[i] means the max mass the planet can have after i asteroids are destroyed\n        # dp[i] = max(dp[i-1], mass + asteroids[i])\n        # dp[0] = mass\n        # dp[1] = max(mass, asteroids[0])\n        # dp[2] = max(dp[1], mass + asteroids[1])\n        # dp[3] = max(dp[2], mass + asteroids[2])\n        # dp[4] = max(dp[3], mass + asteroids[3])\n        # dp[5] = max(dp[4], mass + asteroids[4])\n        # dp[6] = max(dp[5], mass + asteroids[5])\n        # dp[7] = max(dp[6], mass + asteroids[6])\n        # dp[8] = max(dp[7], mass + asteroids[7])\n        # dp[9] = max(dp[8], mass + asteroids[8])\n        # dp[10] = max(dp"
    },
    {
        "number": 2127,
        "title": "Maximum Employees to Be Invited to a Meeting",
        "difficulty": 2,
        "answer": "        # dp\n        # f[i][j] = max(f[i-1][j], f[i-1][j-1]) + 1\n        # return max(f[n-1][j], f[n-1][0])\n        # f[i][j] = max(f[i-1][j], f[i-1][j-1]) + 1\n        # return max(f[n-1][j], f[n-1][0])\n        # f[i][j] = max(f[i-1][j], f[i-1][j-1]) + 1\n        # return max(f[n-1][j], f[n-1][0])\n        # f[i][j] = max(f[i-1][j], f[i-1][j-1]) + 1\n        # return max(f[n-1][j], f[n-1][0])\n        # f[i][j] = max(f[i-1][j], f[i-1][j-1])"
    },
    {
        "number": 2129,
        "title": "Capitalize the Title",
        "difficulty": 0,
        "answer": "        words = title.split()\n        result = []\n        for word in words:\n            if len(word) <= 2:\n                result.append(word.lower())\n            else:\n                result.append(word[0].upper() + word[1:].lower())\n        return''.join(result)\n"
    },
    {
        "number": 2130,
        "title": "Maximum Twin Sum of a Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return 0\n        if not head.next:\n            return head.val\n        \n        max_twin_sum = 0\n        curr = head\n        while curr:\n            twin_sum = curr.val + curr.next.val\n            if twin_sum > max_twin_sum:\n                max_twin_sum = twin_sum\n            curr = curr.next.next\n        return max_twin_sum\n"
    },
    {
        "number": 2131,
        "title": "Longest Palindrome by Concatenating Two Letter Words",
        "difficulty": 1,
        "answer": "        dp = [[0] * len(words) for _ in range(len(words))]\n        for i in range(len(words)):\n            for j in range(i, len(words)):\n                if words[i][0] == words[j][0]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                elif words[i][0] == words[j][1]:\n                    dp[i][j] = max(dp[i + 1][j - 1], dp[i][j - 1]) + 2\n                else:\n                    dp[i][j] = 0\n        return max(dp[0][len(words) - 1], max(dp[0][len(words) - 2], max(dp[1][len(words) - 2], max(dp[2][len(words) - 2], max(dp[3][len(words) - 2], max(dp[4][len(words) - 2], max(dp[5][len(words) - 2], max(dp[6][len("
    },
    {
        "number": 2132,
        "title": "Stamping the Grid",
        "difficulty": 2,
        "answer": "        def dfs(i, j, stamp_height, stamp_width):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j]!= 0:\n                return False\n            if stamp_height > 0 and i - stamp_height < 0:\n                return False\n            if stamp_width > 0 and j - stamp_width < 0:\n                return False\n            if stamp_height > 0 and stamp_width > 0 and i - stamp_height < 0 and j - stamp_width < 0:\n                return False\n            if stamp_height > 0 and i - stamp_height >= len(grid):\n                return False\n            if stamp_width > 0 and j - stamp_width >= len(grid[0]):\n                return False\n            if stamp_height > 0 and stamp_width > 0 and i - stamp_height >= len(grid) or j - stamp_width >= len(grid[0]):\n                return False\n            if stamp_height > 0 and i - stamp_height < 0:\n                return False\n            if"
    },
    {
        "number": 2133,
        "title": "Check if Every Row and Column Contains All Numbers",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return True\n        n = len(matrix)\n        for i in range(n):\n            if not self.checkRow(matrix, i):\n                return False\n        for j in range(n):\n            if not self.checkCol(matrix, j):\n                return False\n        return True"
    },
    {
        "number": 2134,
        "title": "Minimum Swaps to Group All 1\"s Together II",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 3\n        if n == 7:\n            return 4\n        if n == 8:\n            return 4\n        if n == 9:\n            return 5\n        if n == 10:\n            return 5\n        if n == 11:\n            return 6\n        if n == 12:\n            return 6\n        if n == 13:\n            return 7\n        if n == 14:\n            return 7\n        if n == 15:\n            return 8\n        if n == 16:\n            return 8\n        if n == 17:\n            return 9\n        if n == 18:\n            return 9\n        if n == 19:\n            return 10\n        if n == 20:\n            return 10\n        if n == 21:\n            return 11\n        if n == 22:\n            return 11"
    },
    {
        "number": 2135,
        "title": "Count Words Obtained After Adding a Letter",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the number of strings in targetWords that can be obtained by using startWords[i] to form targetWords[j]\n        # dp[i][j] = dp[i+1][j] + dp[i][j-1]\n        # dp[0][j] = 1\n        # dp[i][0] = 1\n        # dp[0][0] = 0\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j"
    },
    {
        "number": 2136,
        "title": "Earliest Possible Day of Full Bloom",
        "difficulty": 2,
        "answer": "        n = len(plantTime)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = plantTime[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(dp[i][i + 1], plantTime[i] + dp[i + 1][i])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = max(dp[i][i + 1], plantTime[i] + dp[i + 1][i])\n        for i in range(n - 1, 0, -1):\n            dp[i][i] = growTime[i]\n        for i in range(n - 1, 0, -1):\n            dp[i][i] = max(dp[i][i], growTime[i] + dp[i - 1][i])\n        return dp[0][0]\n"
    },
    {
        "number": 2138,
        "title": "Divide a String Into Groups of Size k",
        "difficulty": 0,
        "answer": "        if not s:\n            return []\n        if k == 1:\n            return [s]\n        if k == 2:\n            return [s[:2], s[2:]]\n        if k == 3:\n            return [s[:3], s[3:6], s[6:]]\n        if k == 4:\n            return [s[:4], s[4:8], s[8:12], s[12:]]\n        if k == 5:\n            return [s[:5], s[5:10], s[10:15], s[15:]]\n        if k == 6:\n            return [s[:6], s[6:12], s[12:18], s[18:]]\n        if k == 7:\n            return [s[:7], s[7:14], s[14:21], s[21:]]\n        if k == 8:\n            return [s[:8], s[8:16], s[16:24], s[24:]]\n        if k == 9:\n            return [s[:9"
    },
    {
        "number": 2139,
        "title": "Minimum Moves to Reach Target Score",
        "difficulty": 1,
        "answer": "        if maxDoubles == 0:\n            return target - 1\n        if target == 1:\n            return 0\n        if target == 2:\n            return 1\n        if target == 3:\n            return 2\n        if target == 4:\n            return 3\n        if target == 5:\n            return 4\n        if target == 6:\n            return 5\n        if target == 7:\n            return 6\n        if target == 8:\n            return 7\n        if target == 9:\n            return 8\n        if target == 10:\n            return 9\n        if target == 11:\n            return 10\n        if target == 12:\n            return 11\n        if target == 13:\n            return 12\n        if target == 14:\n            return 13\n        if target == 15:\n            return 14\n        if target == 16:\n            return 15\n        if target == 17:\n            return 16\n        if target == 18:\n            return 17\n        if target == 19:\n            return 18\n        if target == 20:\n            return 19\n        if target == 21:\n            return 20\n        if target =="
    },
    {
        "number": 2140,
        "title": "Solving Questions With Brainpower",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + questions[i][j]\n        dp = [[0] * len(questions) for _ in range(len(questions))]\n        for i in range(len(questions)):\n            for j in range(len(questions[i])):\n                if i == 0 and j == 0:\n                    dp[i][j] = questions[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j-1], dp[i][j]) + questions[i][j]\n                elif j == 0:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j]) + questions[i][j]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + questions[i][j]\n        return max(dp[-1])\n"
    },
    {
        "number": 2141,
        "title": "Maximum Running Time of N Computers",
        "difficulty": 2,
        "answer": "        # dp[i] means the max time we can run i computers\n        # dp[i] = max(dp[i-1], dp[i-2] + min(batteries[i-1], batteries[i-2]))\n        # dp[i] = max(dp[i-1], dp[i-2] + min(batteries[i-1], batteries[i-2]))\n        # dp[i] = max(dp[i-1], dp[i-2] + min(batteries[i-1], batteries[i-2]))\n        # dp[i] = max(dp[i-1], dp[i-2] + min(batteries[i-1], batteries[i-2]))\n        # dp[i] = max(dp[i-1], dp[i-2] + min(batteries[i-1], batteries[i-2]))\n        # dp[i] = max(dp[i-1], dp[i-2]"
    },
    {
        "number": 2144,
        "title": "Minimum Cost of Buying Candies With Discount",
        "difficulty": 0,
        "answer": "        n = len(cost)\n        dp = [0] * n\n        dp[0] = cost[0]\n        for i in range(1, n):\n            dp[i] = min(dp[i - 1], cost[i]) + cost[i]\n        return dp[-1]\n"
    },
    {
        "number": 2145,
        "title": "Count the Hidden Sequences",
        "difficulty": 1,
        "answer": "        n = len(differences)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if lower == upper:\n            return 0\n        if lower > upper:\n            return 0\n        if lower == upper - 1:\n            return 1\n        if lower == upper - 2:\n            return 2\n        if lower == upper - 3:\n            return 3\n        if lower == upper - 4:\n            return 4\n        if lower == upper - 5:\n            return 5\n        if lower == upper - 6:\n            return 6\n        if lower == upper - 7:\n            return 7\n        if lower == upper - 8:\n            return 8\n        if lower == upper - 9:\n            return 9\n        if lower == upper - 10:\n            return 10\n        if lower == upper - 11:\n            return 11\n        if lower == upper - 12:\n            return 12\n        if lower == upper - 13:\n            return 13\n        if lower == upper - 14:\n            return 14\n        if lower == upper - 15:\n            return 15\n        if"
    },
    {
        "number": 2146,
        "title": "K Highest Ranked Items Within a Price Range",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        # dp[i][j] = dp[i-1][j] + grid[i][j]\n        # dp[i][j] = dp[i][j-1] + grid[i][j]\n        # dp[i][j] = dp[i-1][j-1] + grid[i][j]\n        # dp[i][j] = grid[i][j]\n        # dp[i][j] = 0\n        # dp[i][j] = grid[i][j]\n        # dp[i][j] = 0\n        # dp[i][j] = grid[i][j]\n        # dp[i]["
    },
    {
        "number": 2147,
        "title": "Number of Ways to Divide a Long Corridor",
        "difficulty": 2,
        "answer": "        n = len(corridor)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n):\n            if corridor[i] == 'S':\n                dp[i] = dp[i - 1] + dp[i + 1]\n            else:\n                dp[i] = dp[i - 1]\n        return dp[n - 1] % (10 ** 9 + 7)\n"
    },
    {
        "number": 2148,
        "title": "Count Elements With Strictly Smaller and Greater Elements ",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n                count += 1\n        return count\n"
    },
    {
        "number": 2149,
        "title": "Rearrange Array Elements by Sign",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if nums[0] < 0:\n            nums = [-x for x in nums]\n        if len(nums) % 2 == 1:\n            nums.append(0)\n        for i in range(1, len(nums), 2):\n            if nums[i] < 0 and nums[i-1] > 0:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n"
    },
    {
        "number": 2150,
        "title": "Find All Lonely Numbers in the Array",
        "difficulty": 1,
        "answer": "        lonely = []\n        for i in range(len(nums)):\n            if nums[i] not in lonely:\n                lonely.append(nums[i])\n        return lonely\n"
    },
    {
        "number": 2151,
        "title": "Maximum Good People Based on Statements",
        "difficulty": 2,
        "answer": "        n = len(statements)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(dp"
    },
    {
        "number": 2154,
        "title": "Keep Multiplying Found Values by Two",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return original\n        if n == 1:\n            return nums[0] * 2\n        if n == 2:\n            return nums[0] * 2 + nums[1] * 2\n        if n == 3:\n            return nums[0] * 2 + nums[1] * 2 + nums[2] * 2\n        if n == 4:\n            return nums[0] * 2 + nums[1] * 2 + nums[2] * 2 + nums[3] * 2\n        if n == 5:\n            return nums[0] * 2 + nums[1] * 2 + nums[2] * 2 + nums[3] * 2 + nums[4] * 2\n        if n == 6:\n            return nums[0] * 2 + nums[1] * 2 + nums[2] * 2 + nums[3] * 2 + nums[4] * 2 + nums[5] * 2\n        if n == 7:\n            "
    },
    {
        "number": 2155,
        "title": "All Divisions With the Highest Score of a Binary Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [0, 1]\n        if n == 3:\n            return [0, 2]\n        if n == 4:\n            return [0, 3]\n        if n == 5:\n            return [0, 4]\n        if n == 6:\n            return [0, 5]\n        if n == 7:\n            return [0, 6]\n        if n == 8:\n            return [0, 7]\n        if n == 9:\n            return [0, 8]\n        if n == 10:\n            return [0, 9]\n        if n == 11:\n            return [0, 10]\n        if n == 12:\n            return [0, 11]\n        if n == 13:\n            return [0, 12]\n        if n == 14:\n            return [0, 13]\n        if n == 15:\n            return [0, 14]\n        if n == 16:\n"
    },
    {
        "number": 2156,
        "title": "Find Substring With Given Hash Value",
        "difficulty": 2,
        "answer": "        # hashValue = (hashValue * power) % modulo\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k], power, modulo) else \"\"\n        # return s[:k] if hashValue == hash(s[:k],"
    },
    {
        "number": 2157,
        "title": "Groups of Strings",
        "difficulty": 2,
        "answer": "        ans = [0, 0]\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if self.is_connected(words[i], words[j]):\n                    ans[0] += 1\n                    ans[1] = max(ans[1], len(words[i]) + len(words[j]))\n        return ans"
    },
    {
        "number": 2160,
        "title": "Minimum Sum of Four Digit Number After Splitting Digits",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number-2/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number-3/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number-4/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number-5/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-after-splitting-the-given-number-6/\n        # https://www.geeksforgeeks.org/minimum-sum-of-two-integers-"
    },
    {
        "number": 2161,
        "title": "Partition Array According to Given Pivot",
        "difficulty": 1,
        "answer": "        left, right = 0, len(nums) - 1\n        while left < right:\n            while left < right and nums[left] < pivot:\n                left += 1\n            while right > left and nums[right] > pivot:\n                right -= 1\n            if left < right:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n                right -= 1\n        return nums\n"
    },
    {
        "number": 2162,
        "title": "Minimum Cost to Set Cooking Time",
        "difficulty": 1,
        "answer": "        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a[i-1], a[i-2], a[i-3], a[i-4]) + moveCost + pushCost\n        # a[i] = min(a"
    },
    {
        "number": 2163,
        "title": "Minimum Difference in Sums After Removal of Elements",
        "difficulty": 2,
        "answer": "        n = len(nums) // 3\n        if n == 0:\n            return 0\n        \n        sumfirst = sum(nums[:n])\n        sumsecond = sum(nums[n:2*n])\n        \n        return min(sumfirst - sumsecond, sumsecond - sumfirst)\n"
    },
    {
        "number": 2164,
        "title": "Sort Even and Odd Indices Independently",
        "difficulty": 0,
        "answer": "        odd_indices = []\n        even_indices = []\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                even_indices.append(nums[i])\n            else:\n                odd_indices.append(nums[i])\n        even_indices.sort()\n        odd_indices.sort(reverse=True)\n        return odd_indices + even_indices\n"
    },
    {
        "number": 2165,
        "title": "Smallest Value of the Rearranged Number",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-2/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-3/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-4/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-5/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-6/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number-7/\n        # https://www.geeksforgeeks.org/rearrange-digits-to-get-smallest-number"
    },
    {
        "number": 2166,
        "title": "Design Bitset",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2167,
        "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
        "difficulty": 2,
        "answer": "        def remove_car(s, i):\n            s = s[:i] + s[i + 1:]\n            return s"
    },
    {
        "number": 2169,
        "title": "Count Operations to Obtain Zero",
        "difficulty": 0,
        "answer": "        if num1 == 0:\n            return 0\n        if num2 == 0:\n            return 1\n        if num1 > num2:\n            return self.countOperations(num2, num1) + 1\n        else:\n            return self.countOperations(num1, num2) + 1\n"
    },
    {
        "number": 2170,
        "title": "Minimum Operations to Make the Array Alternating",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, n):\n            dp[i] = dp[i - 1] + 2\n            if nums[i - 1] == nums[i]:\n                dp[i] = min(dp[i], dp[i - 2] + 1)\n        return dp[n - 1]\n"
    },
    {
        "number": 2171,
        "title": "Removing Minimum Number of Magic Beans",
        "difficulty": 1,
        "answer": "        # sort the beans\n        beans = sorted(beans)\n        # count the number of beans in each bag\n        counts = [0] * len(beans)\n        for i in range(len(beans)):\n            counts[i] = beans[i]\n        # count the number of beans in each bag\n        counts = sorted(counts)\n        # count the number of beans in each bag\n        counts = [0] * len(beans)\n        for i in range(len(beans)):\n            counts[i] = beans[i]\n        # count the number of beans in each bag\n        counts = sorted(counts)\n        # count the number of beans in each bag\n        counts = [0] * len(beans)\n        for i in range(len(beans)):\n            counts[i] = beans[i]\n        # count the number of beans in each bag\n        counts = sorted(counts)\n        # count the number of beans in each bag\n        counts = [0] * len(beans)\n        for i in range"
    },
    {
        "number": 2172,
        "title": "Maximum AND Sum of Array",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i]\n        # dp[i][j] = max(dp[i - 1][j], dp"
    },
    {
        "number": 2176,
        "title": "Count Equal and Divisible Pairs in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[i] == nums[j] and (i * j) % k == 0:\n                    dp[i % k][j] += 1\n        return sum(sum(dp[i]) for i in range(k + 1))\n"
    },
    {
        "number": 2177,
        "title": "Find Three Consecutive Integers That Sum to a Given Number",
        "difficulty": 1,
        "answer": "        if num < 0:\n            return []\n        if num == 0:\n            return [0]\n        if num == 1:\n            return [1]\n        if num == 2:\n            return [2]\n        if num == 3:\n            return [3]\n        if num == 4:\n            return [4]\n        if num == 5:\n            return [5]\n        if num == 6:\n            return [6]\n        if num == 7:\n            return [7]\n        if num == 8:\n            return [8]\n        if num == 9:\n            return [9]\n        if num == 10:\n            return [10]\n        if num == 11:\n            return [11]\n        if num == 12:\n            return [12]\n        if num == 13:\n            return [13]\n        if num == 14:\n            return [14]\n        if num == 15:\n            return [15]\n        if num == 16:\n            return [16]\n        if num == 17:\n            return [17]\n        if num == 18"
    },
    {
        "number": 2178,
        "title": "Maximum Split of Positive Even Integers",
        "difficulty": 1,
        "answer": "        def dfs(finalSum, currSum, max_num):\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:\n                return []\n            if currSum == finalSum:\n                return [currSum]\n            if currSum > finalSum:"
    },
    {
        "number": 2179,
        "title": "Count Good Triplets in an Array",
        "difficulty": 2,
        "answer": "        n = len(nums1)\n        m = len(nums2)\n        if n < m:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(n):\n            for j in range(m):\n                if nums1[i] < nums2[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = dp[i][j]\n        return sum(dp[n][m])\n"
    },
    {
        "number": 2180,
        "title": "Count Integers With Even Digit Sum",
        "difficulty": 0,
        "answer": "        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 1\n        if num == 4:\n            return 2\n        if num == 5:\n            return 1\n        if num == 6:\n            return 2\n        if num == 7:\n            return 1\n        if num == 8:\n            return 2\n        if num == 9:\n            return 1\n        if num == 10:\n            return 2\n        if num == 11:\n            return 1\n        if num == 12:\n            return 2\n        if num == 13:\n            return 1\n        if num == 14:\n            return 2\n        if num == 15:\n            return 1\n        if num == 16:\n            return 2\n        if num == 17:\n            return 1\n        if num == 18:\n            return 2\n        if num == 19:\n            return 1\n        if num == 20:\n            return 2\n        if num == 21:\n            return 1\n        if num == 22:\n            return 2\n        if num == 23:\n            "
    },
    {
        "number": 2181,
        "title": "Merge Nodes in Between Zeros",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        if head.val == 0:\n            return head.next\n        if head.next.val == 0:\n            return head\n        \n        # find the first node with val!= 0\n        cur = head\n        while cur.next and cur.next.val == 0:\n            cur = cur.next\n        \n        # find the last node with val!= 0\n        last = cur\n        while last.next and last.next.val == 0:\n            last = last.next\n        \n        # merge the nodes\n        cur.next = merge(cur.next, last.next)\n        \n        # return the head\n        return head\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2182,
        "title": "Construct String With Repeat Limit",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if len(s) == 1:\n            return s * repeatLimit\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max"
    },
    {
        "number": 2183,
        "title": "Count Array Pairs Divisible by K",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                dp[nums[i - 1] * nums[j - 1] % k][i] += dp[nums[i - 1] * nums[j - 1] // k][j - 1]\n        return dp[nums[0] * nums[n - 1] % k][n]\n"
    },
    {
        "number": 2185,
        "title": "Counting Words With a Given Prefix",
        "difficulty": 0,
        "answer": "        count = 0\n        for word in words:\n            if word.startswith(pref):\n                count += 1\n        return count\n"
    },
    {
        "number": 2186,
        "title": "Minimum Number of Steps to Make Two Strings Anagram II",
        "difficulty": 1,
        "answer": "        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic[i - 1] + 1 if i > 0 else 0\n        # dic[i] = dic"
    },
    {
        "number": 2187,
        "title": "Minimum Time to Complete Trips",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + time[i]\n        # dp["
    },
    {
        "number": 2188,
        "title": "Minimum Time to Finish the Race",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + changeTime)\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + changeTime)\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + changeTime)\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + changeTime)\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + changeTime)\n        # dp[i][j] = min(dp[i-1][j], dp[i]["
    },
    {
        "number": 2190,
        "title": "Most Frequent Number Following Key In an Array",
        "difficulty": 0,
        "answer": "        counts = collections.Counter(nums)\n        return max(counts.keys(), key=counts.get)"
    },
    {
        "number": 2191,
        "title": "Sort the Jumbled Numbers",
        "difficulty": 1,
        "answer": "        mapping = sorted(mapping)\n        nums = sorted(nums)\n        for i in range(len(nums)):\n            nums[i] = nums[i] - mapping[nums[i]]\n        return nums\n"
    },
    {
        "number": 2192,
        "title": "All Ancestors of a Node in a Directed Acyclic Graph",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [[0]]\n        if n == 2:\n            return [[0], [1]]\n        if n == 3:\n            return [[0], [1], [2]]\n        if n == 4:\n            return [[0], [1], [2], [3]]\n        if n == 5:\n            return [[0], [1], [2], [3], [4]]\n        if n == 6:\n            return [[0], [1], [2], [3], [4], [5]]\n        if n == 7:\n            return [[0], [1], [2], [3], [4], [5], [6]]\n        if n == 8:\n            return [[0], [1], [2], [3], [4], [5], [6], [7]]\n        if n == 9:\n            return [[0], [1], [2], [3], [4], [5], [6], [7], [8]]\n        if n == 10:\n            return [[0], [1"
    },
    {
        "number": 2193,
        "title": "Minimum Number of Moves to Make Palindrome",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 2\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 2\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 3\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 4\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 5\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 6\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 7\n        for i in range(n - 8,"
    },
    {
        "number": 2194,
        "title": "Cells in a Range on an Excel Sheet",
        "difficulty": 0,
        "answer": "        def cell(r, c):\n            return \"<{}>{}\".format(chr(ord('A') + c), r)"
    },
    {
        "number": 2195,
        "title": "Append K Integers With Minimal Sum",
        "difficulty": 1,
        "answer": "        nums.sort()\n        ans = 0\n        for i in range(k):\n            ans += nums[i]\n            while i < len(nums) and nums[i] == nums[i - 1]:\n                i += 1\n        return ans\n"
    },
    {
        "number": 2196,
        "title": "Create Binary Tree From Descriptions",
        "difficulty": 1,
        "answer": "        def build_tree(descriptions, i, parent):\n            if i >= len(descriptions):\n                return None\n            node = TreeNode(descriptions[i][0])\n            node.left = build_tree(descriptions, descriptions[i][1], node)\n            node.right = build_tree(descriptions, descriptions[i][2], node)\n            node.parent = parent\n            return node"
    },
    {
        "number": 2197,
        "title": "Replace Non-Coprime Numbers in Array",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        result = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            if i > 0 and nums[i] == nums[i - 1] + 1:\n                result.append(nums[i - 1] * 2)\n                continue\n            if i > 0 and nums[i] == nums[i - 1] - 1:\n                result.append(nums[i - 1] * 2)\n                continue\n            if i > 0 and nums[i] == nums[i - 1] + 2:\n                result.append(nums[i - 1] * 2)\n                continue\n            if i > 0 and nums[i] == nums[i - 1] - 2:\n                result.append(nums[i - 1] * 2)\n                continue\n            if i > 0 and nums[i] == nums[i - 1] + 3:\n                result.append(nums["
    },
    {
        "number": 2200,
        "title": "Find All K-Distant Indices in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < k:\n            return []\n        \n        # dp[i] = the number of k-distant indices in the range [0, i]\n        dp = [0] * (n + 1)\n        \n        # dp[i] = the number of k-distant indices in the range [0, i]\n        for i in range(1, n + 1):\n            for j in range(i - k, i):\n                if nums[j] == key:\n                    dp[i] += 1\n        \n        # dp[i] = the number of k-distant indices in the range [0, i]\n        for i in range(1, n + 1):\n            dp[i] += dp[i - 1]\n        \n        # dp[i] = the number of k-distant indices in the range [0, i]\n        res = []\n        for i in range(n, -1, -1):\n            if dp[i] > k:\n                res.append(i"
    },
    {
        "number": 2201,
        "title": "Count Artifacts That Can Be Extracted",
        "difficulty": 1,
        "answer": "        def dfs(r, c, dr, dc):\n            if r < 0 or r >= n or c < 0 or c >= n:\n                return 0\n            if dig[r][c] == 1:\n                return 0\n            if dig[r][c] == 2:\n                return 1\n            if dig[r][c] == 3:\n                return 2\n            if dig[r][c] == 4:\n                return 3\n            if dig[r][c] == 5:\n                return 4\n            if dig[r][c] == 6:\n                return 5\n            if dig[r][c] == 7:\n                return 6\n            if dig[r][c] == 8:\n                return 7\n            if dig[r][c] == 9:\n                return 8\n            if dig[r][c] == 10:\n                return 9\n            if dig[r][c] == 11:\n                return 10\n            if dig[r][c] == 12:\n                return 11\n            if dig[r][c] == 13:\n                return 12\n            if dig[r"
    },
    {
        "number": 2202,
        "title": "Maximize the Topmost Element After K Moves",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i - 1], nums[i - 1])\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i + 1], nums[i])\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i], dp[i + 1])\n        return dp[0]\n"
    },
    {
        "number": 2203,
        "title": "Minimum Weighted Subgraph With the Required Paths",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return min(edges[0][2], edges[1][2])\n        if n == 3:\n            return min(edges[0][2], edges[1][2], edges[2][2])\n        if n == 4:\n            return min(edges[0][2], edges[1][2], edges[2][2], edges[3][2])\n        if n == 5:\n            return min(edges[0][2], edges[1][2], edges[2][2], edges[3][2], edges[4][2])\n        if n == 6:\n            return min(edges[0][2], edges[1][2], edges[2][2], edges[3][2], edges[4][2], edges[5][2])\n        if n == 7:\n            return min(edges[0][2], edges[1][2], edges[2][2], edges[3][2], edges[4][2], edges[5][2], edges[6][2])"
    },
    {
        "number": 2206,
        "title": "Divide Array Into Equal Pairs",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n % 2!= 0:\n            return False\n        \n        # sort nums\n        nums.sort()\n        \n        # check if nums is divisible by 2\n        if nums[0] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[n - 1] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[0] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[n - 1] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[0] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[n - 1] % 2!= 0:\n            return False\n        \n        # check if nums is divisible by 2\n        if nums[0]"
    },
    {
        "number": 2207,
        "title": "Maximize Number of Subsequences in a String",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + pattern[0] == text[i]? 1 : 0)\n        dp = [[0] * len(text) for _ in range(len(text))]\n        for i in range(len(text)):\n            for j in range(i + 1, len(text)):\n                if pattern[0] == text[i] and pattern[1] == text[j]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                elif pattern[0] == text[i]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                elif pattern[1] == text[j]:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1])\n                else:\n                    dp[i][j] = max(dp["
    },
    {
        "number": 2208,
        "title": "Minimum Operations to Halve Array Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 2209,
        "title": "Minimum White Tiles After Covering With Carpets",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min number of white tiles visible after covering the ith tile with the jth carpet\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1 if floor[i] == '1' else 0\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1 if floor[i] == '0' else 0\n        dp = [[0] * numCarpets for _ in range(carpetLen)]\n        for i in range(carpetLen):\n            for j in range(numCarpets):\n                if floor[i] == '1':\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j]) + 1\n                else:\n                    dp[i][j] = min(dp[i][j"
    },
    {
        "number": 2210,
        "title": "Count Hills and Valleys in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        \n        # dp[i] = the number of hills and valleys in the range [0, i]\n        dp = [0] * n\n        \n        # dp[i] = the number of hills and valleys in the range [0, i]\n        # dp[i] = dp[i-1] + nums[i] - nums[i-1] if nums[i] > nums[i-1] else dp[i-1]\n        # dp[i] = dp[i-1] + nums[i] - nums[i-1] if nums[i] < nums[i-1] else dp[i-1]\n        for i in range(1, n):\n            dp[i] = dp[i-1] + nums[i] - nums[i-1] if nums[i] > nums[i-1] else dp[i-1]\n            dp[i] ="
    },
    {
        "number": 2211,
        "title": "Count Collisions on a Road",
        "difficulty": 1,
        "answer": "        n = len(directions)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            if directions[i] == 'L':\n                dp[i][i] = 1\n            elif directions[i] == 'R':\n                dp[i][i] = 1\n            else:\n                dp[i][i] = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if directions[i] == 'L' and directions[j] == 'R':\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                elif directions[i] == 'R' and directions[j] == 'L':\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                elif directions[i] == 'L' and directions[j] == 'L':\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                elif directions[i]"
    },
    {
        "number": 2212,
        "title": "Maximum Points in an Archery Competition",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition/\n        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition-2/\n        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition-3/\n        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition-4/\n        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition-5/\n        # https://www.geeksforgeeks.org/alice-and-bob-are-opponents-in-an-archery-competition-6/\n        # https://www.geeksforgeeks.org/alice-and-"
    },
    {
        "number": 2213,
        "title": "Longest Substring of One Repeating Character",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1]["
    },
    {
        "number": 2215,
        "title": "Find the Difference of Two Arrays",
        "difficulty": 0,
        "answer": "        nums1_set = set(nums1)\n        nums2_set = set(nums2)\n        return [[x for x in nums1_set if x not in nums2_set], [x for x in nums2_set if x not in nums1_set]]"
    },
    {
        "number": 2216,
        "title": "Minimum Deletions to Make Array Beautiful",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1 if nums[0]!= nums[1] else 2\n        if n % 2 == 0:\n            return 2 if nums[0]!= nums[1] else 1\n        return 2 if nums[0]!= nums[1] else 2"
    },
    {
        "number": 2217,
        "title": "Find Palindrome With Fixed Length",
        "difficulty": 1,
        "answer": "        def find_palindrome(n, l):\n            if n == 1:\n                return 1\n            if n == 2:\n                return 2\n            if n == 3:\n                return 3\n            if n == 4:\n                return 4\n            if n == 5:\n                return 5\n            if n == 6:\n                return 6\n            if n == 7:\n                return 7\n            if n == 8:\n                return 8\n            if n == 9:\n                return 9\n            if n == 10:\n                return 10\n            if n == 11:\n                return 11\n            if n == 12:\n                return 12\n            if n == 13:\n                return 13\n            if n == 14:\n                return 14\n            if n == 15:\n                return 15\n            if n == 16:\n                return 16\n            if n == 17:\n                return 17\n            if n == 18:\n                return 18\n            if n == 19:\n                return 19\n            if n == 20:\n                return 20\n            if n == 21:\n                return 21\n            if n == 22:"
    },
    {
        "number": 2218,
        "title": "Maximum Value of K Coins From Piles",
        "difficulty": 2,
        "answer": "        n = len(piles)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(k + 1):\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j])\n                for c in piles[i]:\n                    dp[i + 1][j + c] = max(dp[i + 1][j + c], dp[i][j] + c)\n        return dp[n][k]"
    },
    {
        "number": 2220,
        "title": "Minimum Bit Flips to Convert Number",
        "difficulty": 0,
        "answer": "        if start == goal:\n            return 0\n        if start > goal:\n            return -1\n        if start == 0:\n            return 0\n        if start == 1:\n            return 1\n        if start == 2:\n            return 2\n        if start == 3:\n            return 3\n        if start == 4:\n            return 4\n        if start == 5:\n            return 5\n        if start == 6:\n            return 6\n        if start == 7:\n            return 7\n        if start == 8:\n            return 8\n        if start == 9:\n            return 9\n        if start == 10:\n            return 10\n        if start == 11:\n            return 11\n        if start == 12:\n            return 12\n        if start == 13:\n            return 13\n        if start == 14:\n            return 14\n        if start == 15:\n            return 15\n        if start == 16:\n            return 16\n        if start == 17:\n            return 17\n        if start == 18:\n            return 18\n        if start == 19:\n            return 19\n        if start == 20:\n"
    },
    {
        "number": 2221,
        "title": "Find Triangular Sum of an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        new_nums = [0] * (n - 1)\n        for i in range(n - 1):\n            new_nums[i] = (nums[i] + nums[i + 1]) % 10\n        return self.triangularSum(new_nums)"
    },
    {
        "number": 2222,
        "title": "Number of Ways to Select Buildings",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2):\n            dp[i][i + 2] = 1\n        for i in range(n - 3):\n            dp[i][i + 3] = 1\n        for i in range(n - 4):\n            dp[i][i + 4] = 1\n        for i in range(n - 5):\n            dp[i][i + 5] = 1\n        for i in range(n - 6):\n            dp[i][i + 6] = 1\n        for i in range(n - 7):\n            dp[i][i + 7] = 1\n        for i in range(n - 8):\n            dp[i][i + 8] = 1\n        for i in range(n - 9):\n            dp[i"
    },
    {
        "number": 2223,
        "title": "Sum of Scores of Built Strings",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [0] * n\n        dp[0] = 0\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + 1\n            for j in range(i - 1, 0, -1):\n                if s[i] == s[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return sum(dp)\n"
    },
    {
        "number": 2224,
        "title": "Minimum Number of Operations to Convert Time",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode.com/problems/convert-time/discuss/\n        # https://leetcode."
    },
    {
        "number": 2225,
        "title": "Find Players With Zero or One Losses",
        "difficulty": 1,
        "answer": "        # sort by winner\n        matches = sorted(matches, key=lambda x: x[0])\n        # sort by loser\n        matches = sorted(matches, key=lambda x: x[1])\n        # count wins\n        wins = [0] * len(matches)\n        for i in range(len(matches)):\n            if matches[i][0] == matches[i][1]:\n                wins[i] += 1\n        # count losses\n        losses = [0] * len(matches)\n        for i in range(len(matches)):\n            if matches[i][0]!= matches[i][1]:\n                losses[i] += 1\n        # count wins\n        wins = [0] * len(matches)\n        for i in range(len(matches)):\n            if matches[i][0] == matches[i][1]:\n                wins[i] += 1\n        # count losses\n        losses = [0] * len(matches)\n        for i in range(len(matches"
    },
    {
        "number": 2226,
        "title": "Maximum Candies Allocated to K Children",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + candies[i])\n        # dp[i] = max("
    },
    {
        "number": 2227,
        "title": "Encrypt and Decrypt Strings",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2231,
        "title": "Largest Number After Digit Swaps by Parity",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 3\n        if num == 4:\n            return 4\n        if num == 5:\n            return 5\n        if num == 6:\n            return 6\n        if num == 7:\n            return 7\n        if num == 8:\n            return 8\n        if num == 9:\n            return 9\n        if num == 10:\n            return 10\n        if num == 11:\n            return 11\n        if num == 12:\n            return 12\n        if num == 13:\n            return 13\n        if num == 14:\n            return 14\n        if num == 15:\n            return 15\n        if num == 16:\n            return 16\n        if num == 17:\n            return 17\n        if num == 18:\n            return 18\n        if num == 19:\n            return 19\n        if num == 20:\n            return 20\n        if num == 21:\n            return 21\n        if num == 22:\n            "
    },
    {
        "number": 2232,
        "title": "Minimize Result by Adding Parentheses to Expression",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in expression:\n            if c == '+':\n                stack.append(c)\n            elif c == '(':\n                stack.append(c)\n            elif c == ')':\n                stack.append(c)\n            else:\n                if len(stack) > 0 and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    stack.append(c)\n        result = expression\n        while len(stack) > 0:\n            result = stack.pop() + result\n        return result"
    },
    {
        "number": 2233,
        "title": "Maximum Product After K Increments",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1] * nums[i-1], dp[i-2] * nums[i-2])\n        # dp[i] = max(dp[i-1] * nums[i-1], dp[i-2] * nums[i-2], dp[i-3] * nums[i-3])\n        # dp[i] = max(dp[i-1] * nums[i-1], dp[i-2] * nums[i-2], dp[i-3] * nums[i-3], dp[i-4] * nums[i-4])\n        # dp[i] = max(dp[i-1] * nums[i-1], dp[i-2] * nums[i-2], dp[i-3] * nums[i-3], dp[i-4] * nums[i-4], dp[i-5] * nums[i-5])\n"
    },
    {
        "number": 2234,
        "title": "Maximum Total Beauty of the Gardens",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1]) + max(dp[i - 1][j - 1], dp[i][j - 1"
    },
    {
        "number": 2235,
        "title": "Add Two Integers",
        "difficulty": 0,
        "answer": "        return num1 + num2"
    },
    {
        "number": 2236,
        "title": "Root Equals Sum of Children",
        "difficulty": 0,
        "answer": "        def helper(root):\n            if not root:\n                return 0\n            return helper(root.left) + helper(root.right) + root.val"
    },
    {
        "number": 2239,
        "title": "Find Closest Number to Zero",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        return nums[0]"
    },
    {
        "number": 2240,
        "title": "Number of Ways to Buy Pens and Pencils",
        "difficulty": 1,
        "answer": "        dp = [[0] * (total + 1) for _ in range(2)]\n        dp[0][0] = 1\n        for i in range(1, total + 1):\n            for j in range(1, 2):\n                dp[j][i] = dp[j - 1][i] + dp[j][i - cost1]\n        return dp[1][total]\n"
    },
    {
        "number": 2241,
        "title": "Design an ATM Machine",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2242,
        "title": "Maximum Score of a Node Sequence",
        "difficulty": 2,
        "answer": "        n = len(scores)\n        if n < 4:\n            return -1\n        \n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + scores[i]\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1]) + scores[i]\n        \n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + scores[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + max(scores[i], scores[j])\n        # dp[i][j] = max(dp[i - 1][j], dp[i - 1"
    },
    {
        "number": 2243,
        "title": "Calculate Digit Sum of a String",
        "difficulty": 0,
        "answer": "        \n        def digit_sum(s, k):\n            if len(s) <= k:\n                return s\n            \n            s = [int(x) for x in s]\n            \n            for i in range(k, len(s)):\n                s[i] += s[i-k]\n                s[i] %= 10\n            \n            return ''.join(str(x) for x in s)\n        \n        return digit_sum(s, k)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2244,
        "title": "Minimum Rounds to Complete All Tasks",
        "difficulty": 1,
        "answer": "        n = len(tasks)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + 1\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2245,
        "title": "Maximum Trailing Zeros in a Cornered Path",
        "difficulty": 1,
        "answer": "        def dfs(i, j, m, n):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if grid[i][j] == 0:\n                return 0\n            if i == 0 and j == 0:\n                return 1\n            if i == 0:\n                return dfs(i, j - 1, m, n) + dfs(i, j + 1, m, n)\n            if j == 0:\n                return dfs(i - 1, j, m, n) + dfs(i + 1, j, m, n)\n            return max(dfs(i - 1, j, m, n), dfs(i + 1, j, m, n), dfs(i, j - 1, m, n), dfs(i, j + 1, m, n))"
    },
    {
        "number": 2246,
        "title": "Longest Path With Different Adjacent Characters",
        "difficulty": 2,
        "answer": "        n = len(parent)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if parent[i]!= -1 and parent[j]!= -1:\n                    dp[i][j] = max(dp[i][j], dp[i][parent[j]] + dp[parent[i]][j])\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 2248,
        "title": "Intersection of Multiple Arrays",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        m = len(nums[0])\n        if m == 0:\n            return []\n        \n        # dp[i][j] means the intersection of nums[0:i] and nums[0:j]\n        dp = [[0] * m for _ in range(n)]\n        \n        # dp[i][j] = dp[i-1][j-1] + 1 if nums[i][j] == nums[i-1][j-1] + 1 else dp[i-1][j]\n        for i in range(n):\n            for j in range(m):\n                if nums[i][j] == nums[i-1][j-1] + 1:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        \n        # return the"
    },
    {
        "number": 2249,
        "title": "Count Lattice Points Inside a Circle",
        "difficulty": 1,
        "answer": "        def is_inside(x, y, r):\n            return x**2 + y**2 <= r**2"
    },
    {
        "number": 2250,
        "title": "Count Number of Rectangles Containing Each Point",
        "difficulty": 1,
        "answer": "        rectangles = [[0, 0], [0, 0]] + rectangles\n        points = [[0, 0], [0, 0]] + points\n        rectangles = sorted(rectangles, key=lambda x: x[0])\n        points = sorted(points, key=lambda x: x[0])\n        count = [0] * len(points)\n        for i in range(len(rectangles)):\n            for j in range(len(points)):\n                if rectangles[i][0] <= points[j][0] <= rectangles[i][1] and rectangles[i][0] <= points[j][1] <= rectangles[i][1]:\n                    count[j] += 1\n        return count\n"
    },
    {
        "number": 2251,
        "title": "Number of Flowers in Full Bloom",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the number of flowers in full bloom when the ith person arrives\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + 1 if persons[i] > persons[i-1] else dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + 1 if persons[i] > persons[i-1] else dp[i-1][j]\n        # dp[i][j"
    },
    {
        "number": 2255,
        "title": "Count Prefixes of a Given String",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(words)):\n            if words[i][:len(s)] == s:\n                count += 1\n        return count\n"
    },
    {
        "number": 2256,
        "title": "Minimum Average Difference",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return abs(nums[0] - nums[1])\n        if n == 3:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2])\n        if n == 4:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3])\n        if n == 5:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3]) + abs(nums[3] - nums[4])\n        if n == 6:\n            return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2"
    },
    {
        "number": 2257,
        "title": "Count Unguarded Cells in the Grid",
        "difficulty": 1,
        "answer": "        if m == 0 or n == 0:\n            return 0\n        if m == 1 or n == 1:\n            return 1\n        if m == 2 or n == 2:\n            return 2\n        if m == 3 or n == 3:\n            return 3\n        if m == 4 or n == 4:\n            return 4\n        if m == 5 or n == 5:\n            return 5\n        if m == 6 or n == 6:\n            return 6\n        if m == 7 or n == 7:\n            return 7\n        if m == 8 or n == 8:\n            return 8\n        if m == 9 or n == 9:\n            return 9\n        if m == 10 or n == 10:\n            return 10\n        if m == 11 or n == 11:\n            return 11\n        if m == 12 or n == 12:\n            return 12\n        if m == 13 or n == 13:\n            return 13\n        if m == 14 or n == 14:\n            return 14\n        if m == 15 or n == 15:\n            return 15\n        if m == 16 or n == 16:"
    },
    {
        "number": 2258,
        "title": "Escape the Spreading Fire",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n        visited[0][0] = True\n        visited[m - 1][n - 1] = True\n        minutes = 0\n        while True:\n            minutes += 1\n            for i in range(m):\n                for j in range(n):\n                    if grid[i][j] == 0:\n                        if visited[i][j] or grid[i][j] == 2:\n                            continue\n                        visited[i][j] = True\n                        if i > 0 and grid[i - 1][j] == 1:\n                            visited[i - 1][j] = True\n                        if i < m - 1 and grid[i + 1][j] == 1:\n                            visited[i + 1][j] = True\n                        if j > 0 and grid[i][j - 1] == 1:\n                            visited[i][j - 1] = True\n                        if j < n - 1 and grid[i][j + 1]"
    },
    {
        "number": 2259,
        "title": "Remove Digit From Number to Maximize Result",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/remove-digit/discuss/\n        # https://leetcode.com/problems/remove-digits/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-ii/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-iii/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-iv/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-v/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-vi/discuss/\n        # https://leetcode.com/problems/remove-digits-from-a-number-vii/discuss"
    },
    {
        "number": 2260,
        "title": "Minimum Consecutive Cards to Pick Up",
        "difficulty": 1,
        "answer": "        n = len(cards)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if cards[i] == cards[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2261,
        "title": "K Divisible Elements Subarrays",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if nums[i - 1] % j == 0:\n                    dp[i][j] += dp[i - 1][j - 1]\n        return dp[n][k]\n"
    },
    {
        "number": 2262,
        "title": "Total Appeal of A String",
        "difficulty": 2,
        "answer": "        def appeal(s):\n            if len(s) == 0:\n                return 0\n            if len(s) == 1:\n                return 1\n            if len(s) == 2:\n                return 2\n            if len(s) == 3:\n                return 3\n            if len(s) == 4:\n                return 4\n            if len(s) == 5:\n                return 5\n            if len(s) == 6:\n                return 6\n            if len(s) == 7:\n                return 7\n            if len(s) == 8:\n                return 8\n            if len(s) == 9:\n                return 9\n            if len(s) == 10:\n                return 10\n            if len(s) == 11:\n                return 11\n            if len(s) == 12:\n                return 12\n            if len(s) == 13:\n                return 13\n            if len(s) == 14:\n                return 14\n            if len(s) == 15:\n                return 15\n            if len(s) == 16:\n                return 16\n            if len(s"
    },
    {
        "number": 2264,
        "title": "Largest 3-Same-Digit Number in String",
        "difficulty": 0,
        "answer": "        def is_good(num):\n            return len(num) == 3 and len(set(num)) == 1"
    },
    {
        "number": 2265,
        "title": "Count Nodes Equal to Average of Subtree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        \n        def dfs(node):\n            if node is None:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            return (node.val + left + right) / (left + right + 1)\n        \n        return dfs(root)\n"
    },
    {
        "number": 2266,
        "title": "Count Number of Texts",
        "difficulty": 1,
        "answer": "        # key = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9'}\n        # key = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9'}\n        # key = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9'}\n        # key = {'0': '0', '1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7"
    },
    {
        "number": 2267,
        "title": " Check if There Is a Valid Parentheses String Path",
        "difficulty": 2,
        "answer": "        def dfs(i, j, m, n):\n            if i < 0 or j < 0 or i >= m or j >= n:\n                return False\n            if grid[i][j] == '(':\n                return dfs(i + 1, j, m, n) or dfs(i, j + 1, m, n)\n            else:\n                return False"
    },
    {
        "number": 2269,
        "title": "Find the K-Beauty of a Number",
        "difficulty": 0,
        "answer": "        def dfs(n, k):\n            if k == 0:\n                return 1\n            if n == 0:\n                return 0\n            if n == 1:\n                return 1\n            if n % 2 == 0:\n                return dfs(n // 2, k) + dfs(n // 2, k - 1)\n            else:\n                return dfs(n // 2, k) + dfs(n // 2, k - 1) + dfs(n // 2, k)"
    },
    {
        "number": 2270,
        "title": "Number of Ways to Split Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n"
    },
    {
        "number": 2271,
        "title": "Maximum White Tiles Covered by a Carpet",
        "difficulty": 1,
        "answer": "        n = len(tiles)\n        dp = [[0] * (carpetLen + 1) for _ in range(n)]\n        for i in range(n):\n            for j in range(carpetLen + 1):\n                if j >= tiles[i][0]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - tiles[i][0]] + 1)\n                if j >= tiles[i][1]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - tiles[i][1]] + 1)\n        return max(dp[-1])\n"
    },
    {
        "number": 2272,
        "title": "Substring With Largest Variance",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return max(dp[0][n], *dp[1:])\n"
    },
    {
        "number": 2273,
        "title": "Find Resultant Array After Removing Anagrams",
        "difficulty": 0,
        "answer": "        if not words:\n            return []\n        d = {}\n        for i in range(len(words)):\n            if words[i] not in d:\n                d[words[i]] = i\n            else:\n                d[words[i]] = min(d[words[i]], i)\n        ans = []\n        for i in range(len(words)):\n            if d[words[i]] == i:\n                ans.append(words[i])\n                for j in range(i + 1, len(words)):\n                    if d[words[j]] == j:\n                        d[words[j]] = -1\n        for i in range(len(words)):\n            if d[words[i]]!= -1:\n                ans.append(words[i])\n        return ans\n"
    },
    {
        "number": 2274,
        "title": "Maximum Consecutive Floors Without Special Floors",
        "difficulty": 1,
        "answer": "        if not special:\n            return 0\n        dp = [[0] * (top + 1) for _ in range(bottom + 1)]\n        for i in range(bottom + 1):\n            dp[i][i] = 1\n        for i in range(bottom + 1, top + 1):\n            dp[i][i] = 1\n            for j in range(i - 1, bottom, -1):\n                if special[j] == i - 1:\n                    dp[i][i] = max(dp[i][i], dp[j][i - 1] + 1)\n        return max(dp[bottom][top], dp[bottom][top - 1])\n"
    },
    {
        "number": 2275,
        "title": "Largest Combination With Bitwise AND Greater Than Zero",
        "difficulty": 1,
        "answer": "        candidates.sort()\n        n = len(candidates)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i - 1, 0, -1):\n                if candidates[j] & candidates[i - 1] > 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[n]"
    },
    {
        "number": 2276,
        "title": "Count Integers in Intervals",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2278,
        "title": "Percentage of Letter in String",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] == letter:\n                count += 1\n        return int(count / len(s) * 100)\n"
    },
    {
        "number": 2279,
        "title": "Maximum Bags With Full Capacity of Rocks",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp[i - rocks[i]] + 1)\n        # dp[i] = max(dp[i - 1], dp"
    },
    {
        "number": 2280,
        "title": "Minimum Lines to Represent a Line Chart",
        "difficulty": 1,
        "answer": "        dp = [[0] * len(stockPrices) for _ in range(len(stockPrices))]\n        for i in range(1, len(stockPrices)):\n            dp[i][i] = 1\n            for j in range(i - 1, -1, -1):\n                dp[i][j] = min(dp[i][j + 1], dp[i - 1][j]) + 1\n        return dp[-1][-1]"
    },
    {
        "number": 2281,
        "title": "Sum of Total Strength of Wizards",
        "difficulty": 2,
        "answer": "        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-2/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-3/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-4/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-5/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-6/\n        # https://www.geeksforgeeks.org/total-strength-of-a-group-of-contiguous-wizards-7/\n        # https://www.geeksforgeeks.org/total"
    },
    {
        "number": 2283,
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "difficulty": 0,
        "answer": "        if len(num) == 0:\n            return True\n        count = [0] * 10\n        for i in range(len(num)):\n            count[num[i] - '0'] += 1\n        for i in range(10):\n            if count[i]!= num[i]:\n                return False\n        return True\n"
    },
    {
        "number": 2284,
        "title": "Sender With Largest Word Count",
        "difficulty": 1,
        "answer": "        # sort by word count\n        senders = sorted(senders, key=lambda x: len(x.split()), reverse=True)\n        # sort by name\n        senders = sorted(senders, key=lambda x: x)\n        # return the first one\n        return senders[0] if len(senders) > 0 else \"\"\n"
    },
    {
        "number": 2285,
        "title": "Maximum Total Importance of Roads",
        "difficulty": 1,
        "answer": "        importance = 0\n        for i in range(n):\n            importance += roads[i][0]\n        for i in range(n):\n            importance += roads[i][1]\n        return importance"
    },
    {
        "number": 2286,
        "title": "Booking Concert Tickets in Groups",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2287,
        "title": "Rearrange Characters to Make Target String",
        "difficulty": 0,
        "answer": "        if len(s) < len(target):\n            return 0"
    },
    {
        "number": 2288,
        "title": "Apply Discount to Prices",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/discuss/\n        # https://leetcode.com/problems/discount-prices/disc"
    },
    {
        "number": 2289,
        "title": "Steps to Make Array Non-decreasing",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            if nums[i - 1] > nums[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1] + 1\n        return dp[n - 1]\n"
    },
    {
        "number": 2290,
        "title": "Minimum Obstacle Removal to Reach Corner",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                    for di, dj in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                        if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 0:\n                            dp[i + di][j + dj] = dp[i][j] + 1\n        return min(dp[i][j] for i in range(m) for j in range(n) if grid[i][j] == 1)\n"
    },
    {
        "number": 2293,
        "title": "Min Max Game",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        newNums = [nums[0]]\n        for i in range(1, n // 2):\n            newNums.append(min(nums[2 * i], nums[2 * i + 1]))\n        for i in range(1, n // 2):\n            newNums.append(max(nums[2 * i], nums[2 * i + 1]))\n        newNums = [nums[0]] + newNums\n        for i in range(1, n):\n            newNums.append(nums[i] - min(newNums[i], newNums[i - 1]))\n        for i in range(1, n):\n            newNums.append(nums[i] - max(newNums[i], newNums[i - 1]))\n        return nums[n - 1] - min(newNums[n - 1], newNums[n - 2])\n"
    },
    {
        "number": 2294,
        "title": "Partition Array Such That Maximum Difference Is K",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if k == 0:\n            return n\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        dp[n] = dp[n - 1] + dp[n - 2]\n        for i in range(n - 1, -1, -1):\n            dp[i] = min(dp[i], dp[i + 1])\n        return dp[0]\n"
    },
    {
        "number": 2295,
        "title": "Replace Elements in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        m = len(operations)\n        if n == 0 or m == 0:\n            return []\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if nums[j] == operations[i][0]:\n                    dp[i][j] = operations[i][1]\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] == 0:\n                    dp[i][j] = nums[j]\n        return dp[-1]\n"
    },
    {
        "number": 2296,
        "title": "Design a Text Editor",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2299,
        "title": "Strong Password Checker II",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/strong-password-checker-ii/discuss/107548/C%2B%2B-Python-Solution-with-explanation\n        # https://leetcode.com/problems/strong-password-checker-ii/discuss/107548/C%2B%2B-Python-Solution-with-explanation\n        # https://leetcode.com/problems/strong-password-checker-ii/discuss/107548/C%2B%2B-Python-Solution-with-explanation\n        # https://leetcode.com/problems/strong-password-checker-ii/discuss/107548/C%2B%2B-Python-Solution-with-explanation\n        # https://leetcode.com/problems/strong-password-checker-ii/discuss/107548/C%2B%2B-Python-Solution-with-explanation\n        # https://leetcode.com/problems/strong-"
    },
    {
        "number": 2300,
        "title": "Successful Pairs of Spells and Potions",
        "difficulty": 1,
        "answer": "        n = len(spells)\n        m = len(potions)\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if spells[i] * potions[j] >= success:\n                    dp[i][j] = 1\n        return [sum(dp[i]) for i in range(n)]"
    },
    {
        "number": 2301,
        "title": "Match Substring After Replacement",
        "difficulty": 2,
        "answer": "        mappings = [[x, y] for x, y in mappings]\n        mappings.sort(key=lambda x: x[0])\n        mappings.sort(key=lambda x: x[1])\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n        mappings = [[x[0], y] for x, y in mappings]\n"
    },
    {
        "number": 2302,
        "title": "Count Subarrays With Score Less Than K",
        "difficulty": 2,
        "answer": "        # dp[i][j] = number of subarrays with sum i and length j\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp[i-nums[j]][j-1] + dp[i][j-1]\n        # dp[i][j] = dp"
    },
    {
        "number": 2303,
        "title": "Calculate Amount Paid in Taxes",
        "difficulty": 0,
        "answer": "        n = len(brackets)\n        if n == 0:\n            return 0\n        if n == 1:\n            return income * brackets[0][1]\n        if n == 2:\n            return income * brackets[1][1]\n        if n == 3:\n            return income * brackets[2][1]\n        if n == 4:\n            return income * brackets[3][1]\n        if n == 5:\n            return income * brackets[4][1]\n        if n == 6:\n            return income * brackets[5][1]\n        if n == 7:\n            return income * brackets[6][1]\n        if n == 8:\n            return income * brackets[7][1]\n        if n == 9:\n            return income * brackets[8][1]\n        if n == 10:\n            return income * brackets[9][1]\n        if n == 11:\n            return income * brackets[10][1]\n        if n == 12:\n            return income * brackets[11][1]\n        if n == 13:\n            return income * brackets[12"
    },
    {
        "number": 2304,
        "title": "Minimum Path Cost in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i][j - 1] + moveCost[i][j], dp[i - 1][j] + moveCost[i][j])\n        return dp[m - 1][n - 1]\n"
    },
    {
        "number": 2305,
        "title": "Fair Distribution of Cookies",
        "difficulty": 1,
        "answer": "        n = len(cookies)\n        dp = [[0] * k for _ in range(n)]\n        for i in range(n):\n            for j in range(k):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + cookies[i])\n        return max(dp[n - 1])\n"
    },
    {
        "number": 2306,
        "title": "Naming a Company",
        "difficulty": 2,
        "answer": "        if not ideas:\n            return 0\n        \n        # ideaA, ideaB = ideaA, ideaB\n        ideaA, ideaB = ideas[0], ideas[1]\n        \n        # swap ideaA and ideaB\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n        # ideaA, ideaB = ideaB, ideaA\n        ideaA, ideaB = ideaB, ideaA\n        \n"
    },
    {
        "number": 2309,
        "title": "Greatest English Letter in Upper and Lower Case",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/greatest-letter/discuss/\n        # https://leetcode.com/problems/greatest-letter-ii/discuss/\n        # https://leetcode.com/problems/greatest-letter-iii/discuss/\n        # https://leetcode.com/problems/greatest-letter-iv/discuss/\n        # https://leetcode.com/problems/greatest-letter-v/discuss/\n        # https://leetcode.com/problems/greatest-letter-vi/discuss/\n        # https://leetcode.com/problems/greatest-letter-vii/discuss/\n        # https://leetcode.com/problems/greatest-letter-viii/discuss/\n        # https://leetcode.com/problems/greatest-letter-ix/discuss/\n        # https://leetcode.com/problems/greatest-letter-x/discuss/\n        # https://leetcode.com/"
    },
    {
        "number": 2310,
        "title": "Sum of Numbers With Units Digit K",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - k])\n        # dp[i][j] ="
    },
    {
        "number": 2311,
        "title": "Longest Binary Subsequence Less Than or Equal to K",
        "difficulty": 1,
        "answer": "        dp = [[0] * (k + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s)):\n            dp[i + 1][0] = 1\n            for j in range(1, k + 1):\n                if s[i] == '0':\n                    dp[i + 1][j] = dp[i][j]\n                else:\n                    dp[i + 1][j] = max(dp[i][j], dp[i][j - 1] + 1)\n        return dp[len(s)][k]"
    },
    {
        "number": 2312,
        "title": "Selling Pieces of Wood",
        "difficulty": 2,
        "answer": "        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], prices[i][j] + dp[i][j - 1] + dp[i - 1][j])\n        return max(dp[m - 1][n - 1], dp[m - 1][n - 1] + prices[m - 1][n - 1])\n"
    },
    {
        "number": 2315,
        "title": "Count Asterisks",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] == '|':\n                count += 1\n                if count % 2 == 0:\n                    count = 0\n            else:\n                count = 0\n        return count\n"
    },
    {
        "number": 2316,
        "title": "Count Unreachable Pairs of Nodes in an Undirected Graph",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 0\n        if n == 3:\n            return 0\n        if n == 4:\n            return 0\n        if n == 5:\n            return 0\n        if n == 6:\n            return 0\n        if n == 7:\n            return 0\n        if n == 8:\n            return 0\n        if n == 9:\n            return 0\n        if n == 10:\n            return 0\n        if n == 11:\n            return 0\n        if n == 12:\n            return 0\n        if n == 13:\n            return 0\n        if n == 14:\n            return 0\n        if n == 15:\n            return 0\n        if n == 16:\n            return 0\n        if n == 17:\n            return 0\n        if n == 18:\n            return 0\n        if n == 19:\n            return 0\n        if n == 20:\n            return 0\n        if n == 21:\n            return 0\n        if n == 22:\n            return 0\n        if n == 23:\n            "
    },
    {
        "number": 2317,
        "title": "Maximum XOR After Operations ",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] ^ nums[i - 1]\n        for i in range(2, n + 1):\n            dp[i] = max(dp[i], dp[i - 1] ^ nums[i - 1])\n        return dp[n]\n"
    },
    {
        "number": 2318,
        "title": "Number of Distinct Roll Sequences",
        "difficulty": 2,
        "answer": "        MOD = 10 ** 9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] = (dp[i] + dp[j] * dp[i - j - 1]) % MOD\n        return dp[n]\n"
    },
    {
        "number": 2319,
        "title": "Check if Matrix Is X-Matrix",
        "difficulty": 0,
        "answer": "        n = len(grid)\n        if n == 0:\n            return True\n        if n == 1:\n            return grid[0][0]!= 0\n        if n == 2:\n            return grid[0][0]!= 0 and grid[1][1]!= 0\n        if n == 3:\n            return grid[0][0]!= 0 and grid[1][1]!= 0 and grid[2][2]!= 0\n        if n == 4:\n            return grid[0][0]!= 0 and grid[1][1]!= 0 and grid[2][2]!= 0 and grid[3][3]!= 0\n        if n == 5:\n            return grid[0][0]!= 0 and grid[1][1]!= 0 and grid[2][2]!= 0 and grid[3][3]!= 0 and grid[4][4]!= 0\n        if n == 6:\n            return grid[0][0]!= 0 and grid[1][1]!= 0 and grid[2][2]!= 0 and grid[3][3]!= 0 and grid[4][4]"
    },
    {
        "number": 2320,
        "title": "Count Number of Ways to Place Houses",
        "difficulty": 1,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n] % (10 ** 9 + 7)\n"
    },
    {
        "number": 2321,
        "title": "Maximum Score Of Spliced Array",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 < n2:\n            return self.maximumsSplicedArray(nums2, nums1)\n        if n2 == 0:\n            return 0\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            for j in range(n2):\n                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], dp[i][j]) + nums1[i] + nums2[j]\n        return dp[n1][n2]"
    },
    {
        "number": 2322,
        "title": "Minimum Score After Removals on a Tree",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n)]\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n) if nums[i] ^ nums[j] == 0]\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n) if nums[i] ^ nums[j] == 0]\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n) if nums[i] ^ nums[j] == 0]\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n) if nums[i] ^ nums[j] == 0]\n        edges = [[i, j] for i in range(n) for j in range(i + 1, n) if nums[i] ^ nums[j] == 0"
    },
    {
        "number": 2325,
        "title": "Decode the Message",
        "difficulty": 0,
        "answer": "        table = {}\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n        for i in range(26):\n            table[chr(i + ord('a'))] = chr(i + ord('a'))\n"
    },
    {
        "number": 2326,
        "title": "Spiral Matrix IV",
        "difficulty": 1,
        "answer": "        if m == 0 or n == 0:\n            return []\n        if head is None:\n            return [[]]\n        if m == 1:\n            return [[head.val]]\n        if n == 1:\n            return [[head.val]]\n        if m == 2:\n            return [[head.val, head.next.val]]\n        if n == 2:\n            return [[head.val, head.next.val]]\n        if m == 3:\n            return [[head.val, head.next.val, head.next.next.val]]\n        if n == 3:\n            return [[head.val, head.next.val, head.next.next.val]]\n        if m == 4:\n            return [[head.val, head.next.val, head.next.next.val, head.next.next.next.val]]\n        if n == 4:\n            return [[head.val, head.next.val, head.next.next.val, head.next.next.next.val]]\n        if m == 5:\n            return [[head.val, head"
    },
    {
        "number": 2327,
        "title": "Number of People Aware of a Secret",
        "difficulty": 1,
        "answer": "        # dp[i] = # of people who know the secret at the end of day i\n        # dp[i] = dp[i - 1] + (i - delay) * forget\n        # dp[i] = dp[i - 1] + (i - delay) * forget + (i - delay - 1) * delay\n        # dp[i] = dp[i - 1] + (i - delay) * forget + (i - delay - 1) * delay + (i - delay - 2) * delay\n        # dp[i] = dp[i - 1] + (i - delay) * forget + (i - delay - 1) * delay + (i - delay - 2) * delay + (i - delay - 3) * delay\n        # dp[i] = dp[i - 1] + (i - delay) * forget + (i - delay - 1) * delay + (i - delay - 2) * delay + (i - delay - 3) * delay + (i - delay - 4) * delay\n        # dp[i] ="
    },
    {
        "number": 2328,
        "title": "Number of Increasing Paths in a Grid",
        "difficulty": 2,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1] % (10 ** 9 + 7)\n"
    },
    {
        "number": 2331,
        "title": "Evaluate Boolean Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == 0\n        return self.evaluate(root.val, self.evaluateTree(root.left), self.evaluateTree(root.right))"
    },
    {
        "number": 2332,
        "title": "The Latest Time to Catch a Bus",
        "difficulty": 1,
        "answer": "        n = len(buses)\n        m = len(passengers)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = dp[i - 1][0] + buses[i - 1]\n        for j in range(1, m + 1):\n            dp[0][j] = dp[0][j - 1] + passengers[j - 1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + buses[i - 1]\n                if capacity - dp[i][j] >= 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + passengers[j - 1])\n        return dp[n][m]\n"
    },
    {
        "number": 2333,
        "title": "Minimum Sum of Squared Difference",
        "difficulty": 1,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1 + 1):\n            dp[i][0] = i * i\n        for j in range(1, n2 + 1):\n            dp[0][j] = j * j\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + nums1[i - 1] * nums2[j - 1]\n                if k1 > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1])\n                if k2 > 0:\n                    dp[i][j] = min(dp[i][j], dp[i"
    },
    {
        "number": 2334,
        "title": "Subarray With Elements Greater Than Varying Threshold",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1\n        dp = [0] * len(nums)\n        dp[0] = 1\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] >= threshold / (i - j):\n                    dp[i] += dp[j]\n        return dp[-1]\n"
    },
    {
        "number": 2335,
        "title": "Minimum Amount of Time to Fill Cups",
        "difficulty": 0,
        "answer": "        n = len(amount)\n        if n == 0:\n            return 0\n        if n == 1:\n            return amount[0]\n        if n == 2:\n            return max(amount[0], amount[1])\n        if amount[0] == 0 and amount[1] == 0:\n            return amount[2]\n        if amount[0] == 0:\n            return max(amount[1], amount[2])\n        if amount[1] == 0:\n            return max(amount[0], amount[2])\n        if amount[2] == 0:\n            return max(amount[0], amount[1])\n        return max(amount[0], max(amount[1], amount[2]))"
    },
    {
        "number": 2336,
        "title": "Smallest Number in Infinite Set",
        "difficulty": 1,
        "answer": "        self.set = set()\n        self.set.add(1)\n        self.set.add(2)\n        self.set.add(3)\n        self.set.add(4)\n        self.set.add(5)\n        self.set.add(6)\n        self.set.add(7)\n        self.set.add(8)\n        self.set.add(9)\n        self.set.add(10)\n        self.set.add(11)\n        self.set.add(12)\n        self.set.add(13)\n        self.set.add(14)\n        self.set.add(15)\n        self.set.add(16)\n        self.set.add(17)\n        self.set.add(18)\n        self.set.add(19)\n        self.set.add(20)\n        self.set.add(21)\n        self.set.add(22)\n        self.set.add(23)\n        self.set.add(24)\n        self"
    },
    {
        "number": 2337,
        "title": "Move Pieces to Obtain a String",
        "difficulty": 1,
        "answer": "        n = len(start)\n        if n!= len(target):\n            return False\n        dp = [[False] * n for _ in range(n)]\n        dp[0][0] = True\n        for i in range(1, n):\n            dp[i][i] = True\n            if start[i - 1] == 'L':\n                dp[i][i - 1] = True\n            if start[i - 1] == 'R':\n                dp[i][i + 1] = True\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = True\n            if start[i + 1] == 'L':\n                dp[i][i + 2] = True\n            if start[i + 1] == 'R':\n                dp[i][i + 3] = True\n        for i in range(n - 1, 0, -1):\n            dp[i][0] = True\n            if start[i - 1] == 'L':\n                dp[i][1] = True\n            if start["
    },
    {
        "number": 2338,
        "title": "Count the Number of Ideal Arrays",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 1\n        if n == 4:\n            return 1\n        if n == 5:\n            return 1\n        if n == 6:\n            return 1\n        if n == 7:\n            return 1\n        if n == 8:\n            return 1\n        if n == 9:\n            return 1\n        if n == 10:\n            return 1\n        if n == 11:\n            return 1\n        if n == 12:\n            return 1\n        if n == 13:\n            return 1\n        if n == 14:\n            return 1\n        if n == 15:\n            return 1\n        if n == 16:\n            return 1\n        if n == 17:\n            return 1\n        if n == 18:\n            return 1\n        if n == 19:\n            return 1\n        if n == 20:\n            return 1\n        if n == 21:\n            return 1\n        if n == 22:\n            return 1\n        if n == 23:\n            "
    },
    {
        "number": 2341,
        "title": "Maximum Number of Pairs in Array",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        ans = [0, 0]\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i - 1]:\n                ans[0] += 1\n            else:\n                ans[1] += 1\n        return ans"
    },
    {
        "number": 2342,
        "title": "Max Sum of a Pair With Equal Sum of Digits",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if nums[i] + nums[j] == nums[i] * 10 + nums[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + nums[i] * 10 + nums[j]\n        return max(dp[0][n])"
    },
    {
        "number": 2343,
        "title": "Query Kth Smallest Trimmed Number",
        "difficulty": 1,
        "answer": "        nums = [int(n) for n in nums]\n        nums.sort()\n        ans = []\n        for i, query in enumerate(queries):\n            k, trim = query\n            ans.append(nums[bisect.bisect_right(nums, nums[k] - trim)])\n            nums[k] = nums[k] - trim\n        return ans"
    },
    {
        "number": 2344,
        "title": "Minimum Deletions to Make Array Divisible",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        m = len(numsDivide)\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if nums[i] % numsDivide[j] == 0:\n                    dp[i][j] = dp[i - 1][j] + 1\n        \n        def dfs(i, j):\n            if i == 0 and j == 0:\n                return 0\n            if dp[i][j]!= 0:\n                return dp[i][j]\n            \n            min_val = sys.maxsize\n            for k in range(i):\n                if nums[k] % numsDivide[j] == 0:\n                    min_val = min(min_val, dfs(k, j - 1) + 1)\n            return min_val\n        \n        return dfs(n - 1, m - 1)\n"
    },
    {
        "number": 2347,
        "title": "Best Poker Hand",
        "difficulty": 0,
        "answer": "        n = len(ranks)\n        if n == 0:\n            return \"High Card\"\n        if n == 1:\n            return \"High Card\"\n        if n == 2:\n            return \"Pair\"\n        if n == 3:\n            return \"Three of a Kind\"\n        if n == 4:\n            return \"Flush\"\n        if n == 5:\n            return \"Flush\"\n        if n == 6:\n            return \"Three of a Kind\"\n        if n == 7:\n            return \"Three of a Kind\"\n        if n == 8:\n            return \"Three of a Kind\"\n        if n == 9:\n            return \"Three of a Kind\"\n        if n == 10:\n            return \"Three of a Kind\"\n        if n == 11:\n            return \"Three of a Kind\"\n        if n == 12:\n            return \"Three of a Kind\"\n        if n == 13:\n            return \"Three of a Kind\"\n        if n == 14:\n            return \"Three of a Kind\"\n        if n == 15:\n            return \"Three"
    },
    {
        "number": 2348,
        "title": "Number of Zero-Filled Subarrays",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if nums[0] == 0:\n            return n\n        if nums[-1] == 0:\n            return n - 1\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n):\n            if nums[i] == 0:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n - 1]"
    },
    {
        "number": 2349,
        "title": "Design a Number Container System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2350,
        "title": "Shortest Impossible Sequence of Rolls",
        "difficulty": 2,
        "answer": "        # dp[i][j] means the length of the shortest sequence of rolls that cannot be taken from rolls[0:i] and rolls[i:j]\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], d"
    },
    {
        "number": 2351,
        "title": "First Letter to Appear Twice",
        "difficulty": 0,
        "answer": "        # O(n) time and O(1) space\n        count = {}\n        for i in range(len(s)):\n            if s[i] in count:\n                count[s[i]] += 1\n            else:\n                count[s[i]] = 1\n        for i in range(len(s)):\n            if count[s[i]] > 1:\n                return s[i]\n        return \"\""
    },
    {
        "number": 2352,
        "title": "Equal Row and Column Pairs",
        "difficulty": 1,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[m - 1][n - 1]\n"
    },
    {
        "number": 2353,
        "title": "Design a Food Rating System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2354,
        "title": "Number of Excellent Pairs",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] + nums[i + 1] >= k:\n                count += 1\n        return count\n"
    },
    {
        "number": 2357,
        "title": "Make Array Zero by Subtracting Equal Amounts",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 2358,
        "title": "Maximum Number of Groups Entering a Competition",
        "difficulty": 1,
        "answer": "        if not grades:\n            return 0\n        n = len(grades)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if grades[i] + grades[j] > grades[j]:\n                    dp[i][j] = dp[i + 1][j]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2359,
        "title": "Find Closest Node to Given Two Nodes",
        "difficulty": 1,
        "answer": "        n = len(edges)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0 if edges[0] == node1 else 1\n        if n == 2:\n            return 0 if edges[0] == node1 and edges[1] == node2 else 1 if edges[1] == node1 and edges[0] == node2 else 2\n        if n == 3:\n            return 0 if edges[0] == node1 and edges[1] == node2 and edges[2] == node1 else 1 if edges[0] == node1 and edges[1] == node2 and edges[2] == node2 else 2\n        if n == 4:\n            return 0 if edges[0] == node1 and edges[1] == node2 and edges[2] == node1 and edges[3] == node2 else 1 if edges[0] == node1 and edges[1] == node2 and edges[2] == node2 and edges[3] == node1 else 2\n        if n == 5:\n            return 0 if edges[0] == node1 and"
    },
    {
        "number": 2360,
        "title": "Longest Cycle in a Graph",
        "difficulty": 2,
        "answer": "        n = len(edges)\n        if n == 0:\n            return -1\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i]] + 1)\n        # dp[i] = max(dp[i], dp[edges[i"
    },
    {
        "number": 2363,
        "title": "Merge Similar Items",
        "difficulty": 0,
        "answer": "        items1 = sorted(items1, key=lambda x: x[0])\n        items2 = sorted(items2, key=lambda x: x[0])\n        ret = []\n        i = 0\n        j = 0\n        while i < len(items1) and j < len(items2):\n            if items1[i][0] == items2[j][0]:\n                ret.append([items1[i][0], items1[i][1] + items2[j][1]])\n                i += 1\n                j += 1\n            elif items1[i][0] < items2[j][0]:\n                ret.append([items1[i][0], items1[i][1]])\n                i += 1\n            else:\n                ret.append([items2[j][0], items2[j][1]])\n                j += 1\n        while i < len(items1):\n            ret.append([items1[i][0], items1[i][1]])\n            i += 1\n        while j < len(items2):\n            "
    },
    {
        "number": 2364,
        "title": "Count Number of Bad Pairs",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + (nums[i - 1] - nums[i - 1])\n        return dp[n]"
    },
    {
        "number": 2365,
        "title": "Task Scheduler II",
        "difficulty": 1,
        "answer": "        n = len(tasks)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = tasks[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = max(dp[i + 1][i], tasks[i])\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(dp[i + 1][i + 1], tasks[i])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(dp[i + 2][i + 1], tasks[i])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(dp[i + 3][i + 1], tasks[i])\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = max(dp[i + 4]["
    },
    {
        "number": 2366,
        "title": "Minimum Replacements to Sort the Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == nums[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2367,
        "title": "Number of Arithmetic Triplets",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n + 1):\n                    if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:\n                        dp[i][j] += 1\n                        dp[j][k] += 1\n        return sum(sum(dp[i]) for i in range(n))\n"
    },
    {
        "number": 2368,
        "title": "Reachable Nodes With Restrictions",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 2369,
        "title": "Check if There is a Valid Partition For The Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return False\n        if n == 3:\n            return nums[0] == nums[1] == nums[2]\n        if n == 4:\n            return nums[0] == nums[1] == nums[2] or nums[0] == nums[1] == nums[2] == nums[3]\n        if n == 5:\n            return nums[0] == nums[1] == nums[2] or nums[0] == nums[1] == nums[2] == nums[3] or nums[0] == nums[1] == nums[2] == nums[3] == nums[4]\n        if n == 6:\n            return nums[0] == nums[1] == nums[2] or nums[0] == nums[1] == nums[2] == nums[3] or nums[0] == nums[1] == nums[2] == nums"
    },
    {
        "number": 2370,
        "title": "Longest Ideal Subsequence",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + abs(s[i] - s[j]))\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + abs(s[i] - s[j]))\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + abs(s[i] - s[j]))\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + abs(s[i] - s[j]))\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i -"
    },
    {
        "number": 2373,
        "title": "Largest Local Values in a Matrix",
        "difficulty": 0,
        "answer": "        if not grid or not grid[0]:\n            return grid\n        m, n = len(grid), len(grid[0])\n        maxLocal = [[0] * n for _ in range(m - 2)]\n        for i in range(m - 2):\n            for j in range(n - 2):\n                maxLocal[i][j] = max(\n                    grid[i + 1][j + 1],\n                    grid[i + 1][j + 2],\n                    grid[i + 2][j + 1],\n                )\n        return maxLocal"
    },
    {
        "number": 2374,
        "title": "Node With Highest Edge Score",
        "difficulty": 1,
        "answer": "        n = len(edges)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if edges[i] == edges[j]:\n                    dp[i] += 1\n                    dp[j] += 1\n        return max(dp)"
    },
    {
        "number": 2375,
        "title": "Construct Smallest Number From DI String",
        "difficulty": 1,
        "answer": "        n = len(pattern)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if pattern[i - 1] == 'I':\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = dp[i - 1]\n        for i in range(n, 0, -1):\n            if pattern[i - 1] == 'D':\n                dp[i] = dp[i] + dp[i - 1]\n            else:\n                dp[i] = dp[i]\n        return str(dp[n])"
    },
    {
        "number": 2376,
        "title": "Count Special Integers",
        "difficulty": 2,
        "answer": "        if n < 2:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 2379,
        "title": "Minimum Recolors to Get K Consecutive Black Blocks",
        "difficulty": 0,
        "answer": "        n = len(blocks)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            dp[i][i + 1] = 1\n        for i in range(n - 1):\n            dp[i][i + 2] = 1\n        for i in range(n - 2):\n            dp[i][i + 3] = 1\n        for i in range(n - 3):\n            dp[i][i + 4] = 1\n        for i in range(n - 4):\n            dp[i][i + 5] = 1\n        for i in range(n - 5):\n            dp[i][i + 6] = 1\n        for i in range(n - 6):\n            dp[i][i + 7] = 1\n        for i in range(n - 7):\n            dp[i][i + 8] = 1\n        for i in range(n - 8):\n            dp[i][i"
    },
    {
        "number": 2380,
        "title": "Time Needed to Rearrange a Binary String",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for i in range(n - 8,"
    },
    {
        "number": 2381,
        "title": "Shifting Letters II",
        "difficulty": 1,
        "answer": "        # dp[i][j] = s[i:j]\n        # dp[i][j] = dp[i + 1][j] if s[i] == s[j] else dp[i][j - 1]\n        # dp[i][j] = dp[i + 1][j] if s[i]!= s[j] else dp[i][j + 1]\n        # dp[i][j] = dp[i + 1][j] if s[i]!= s[j] else dp[i][j - 1]\n        # dp[i][j] = dp[i + 1][j] if s[i]!= s[j] else dp[i][j + 1]\n        # dp[i][j] = dp[i + 1][j] if s[i]!= s[j] else dp[i][j - 1]\n        # dp[i][j] = dp[i + 1][j] if s[i]!= s[j] else dp["
    },
    {
        "number": 2382,
        "title": "Maximum Segment Sum After Removals",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        m = len(removeQueries)\n        if n < m:\n            return []\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + nums[i]\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(n):\n            for j in range(m):\n                if nums[i] > removeQueries[j]:\n                    dp[j+1][i+1] = dp[j][i] + nums[i]\n                else:\n                    dp[j+1][i+1] = max(dp[j][i], dp[j+1][i])\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + nums[i]\n        answer = [0] * (n + 1)\n        for i in range(n):\n            for j in range(m"
    },
    {
        "number": 2383,
        "title": "Minimum Hours of Training to Win a Competition",
        "difficulty": 0,
        "answer": "        # dp[i] = min(dp[i-1] + experience[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + experience[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp[i-1] + energy[i], dp[i-1] + energy[i])\n        # dp[i] = min(dp["
    },
    {
        "number": 2384,
        "title": "Largest Palindromic Number",
        "difficulty": 1,
        "answer": "        n = len(num)\n        if n == 0:\n            return 0\n        if n == 1:\n            return num\n        if n == 2:\n            return num[0] * 10 + num[1]\n        if n == 3:\n            return num[0] * 100 + num[1] * 10 + num[2]\n        if n == 4:\n            return num[0] * 1000 + num[1] * 100 + num[2] * 10 + num[3]\n        if n == 5:\n            return num[0] * 10000 + num[1] * 1000 + num[2] * 100 + num[3] * 10 + num[4]\n        if n == 6:\n            return num[0] * 100000 + num[1] * 10000 + num[2] * 1000 + num[3] * 100 + num[4] * 10 + num[5]\n        if n == 7:\n            return num[0] * 1000000 + num[1] * 100000 + num[2] * 10000 + num[3] * 1000 + num[4] *"
    },
    {
        "number": 2385,
        "title": "Amount of Time for Binary Tree to Be Infected",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.val == start:\n            return 1\n        return self.amountOfTime(root.left, start) + self.amountOfTime(root.right, start) + 1"
    },
    {
        "number": 2386,
        "title": "Find the K-Sum of an Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        dp = [0] * (k + 1)\n        dp[0] = 0\n        for i in range(1, k + 1):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        return dp[k]"
    },
    {
        "number": 2389,
        "title": "Longest Subsequence With Limited Sum",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        m = len(queries)\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if nums[i] <= queries[j]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + 1\n        return dp[n - 1]"
    },
    {
        "number": 2390,
        "title": "Removing Stars From a String",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(1) space\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '*':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return s[i:]\n                else:\n                    stack.pop()\n        return s[i:]"
    },
    {
        "number": 2391,
        "title": "Minimum Amount of Time to Collect Garbage",
        "difficulty": 1,
        "answer": "        n = len(garbage)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i] = 0\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i][j - 1], dp[i][j - 2]) + travel[j - 1]\n        return dp[0][n]"
    },
    {
        "number": 2392,
        "title": "Build a Matrix With Conditions",
        "difficulty": 2,
        "answer": "        n, m = len(rowConditions), len(colConditions)\n        matrix = [[0] * k for _ in range(k)]\n        for i in range(n):\n            for j in range(m):\n                if rowConditions[i][0] <= j < rowConditions[i][1]:\n                    matrix[j][i] = 1\n                if colConditions[j][0] <= i < colConditions[j][1]:\n                    matrix[i][j] = 1\n        return matrix"
    },
    {
        "number": 2395,
        "title": "Find Subarrays With Equal Sum",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return False\n        dp = [[False] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = True\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[j] == nums[i] and dp[j + 1][i - 1]:\n                    dp[i][j] = True\n        return any(dp[i][j] for i in range(n) for j in range(i + 1, n + 1))"
    },
    {
        "number": 2396,
        "title": "Strictly Palindromic Number",
        "difficulty": 1,
        "answer": "        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-2/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-3/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-4/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-5/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-6/\n        # https://www.geeksforgeeks.org/check-if-a-number-is-strictly-palindromic-7/\n        # https://www.ge"
    },
    {
        "number": 2397,
        "title": "Maximum Rows Covered by Columns",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        m = len(matrix[0])\n        if n == 0 or m == 0:\n            return 0\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 1:\n                    dp[i][j] = 1\n                    for k in range(j + 1, m):\n                        if matrix[i][k] == 1:\n                            dp[i][k] = 1\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if dp[i][j] == 1:\n                    for k in range(j + 1, m):\n                        if dp[i][k] == 1:\n                            dp[i][k] = 1\n        return max(self.dfs(matrix, numSelect, 0, 0, dp), self.dfs(matrix, numSelect, 0, n - 1, dp"
    },
    {
        "number": 2398,
        "title": "Maximum Number of Robots Within Budget",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes[i] + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes[i] + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes[i] + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes[i] + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes[i] + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + chargeTimes["
    },
    {
        "number": 2399,
        "title": "Check Distances Between Same Letters",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n % 2!= 0:\n            return False\n        if n == 2:\n            return True\n        if n == 1:\n            return False\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return"
    },
    {
        "number": 2400,
        "title": "Number of Ways to Reach a Position After Exactly k Steps",
        "difficulty": 1,
        "answer": "        dp = [0] * (endPos + 1)\n        dp[startPos] = 1\n        for i in range(startPos, endPos + 1):\n            for j in range(startPos, i):\n                dp[i] += dp[j]\n            dp[i] %= MOD\n        return dp[endPos]"
    },
    {
        "number": 2401,
        "title": "Longest Nice Subarray",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return n\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = 1\n            for j in range(i - 1, 0, -1):\n                if nums[i] & nums[j] == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n"
    },
    {
        "number": 2402,
        "title": "Meeting Rooms III",
        "difficulty": 2,
        "answer": "        rooms = [0] * n\n        for start, end in meetings:\n            rooms[start] += 1\n            rooms[end] -= 1\n        return max(rooms)\n"
    },
    {
        "number": 2404,
        "title": "Most Frequent Even Element",
        "difficulty": 0,
        "answer": "        count = {}\n        for num in nums:\n            if num % 2 == 0:\n                count[num] = count.get(num, 0) + 1\n        return min(count, key=count.get) if count else -1\n"
    },
    {
        "number": 2405,
        "title": "Optimal Partition of String",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2):\n            dp[i][i + 2] = 1\n        for i in range(n - 3):\n            dp[i][i + 3] = 1\n        for i in range(n - 4):\n            dp[i][i + 4] = 1\n        for i in range(n - 5):\n            dp[i][i + 5] = 1\n        for i in range(n - 6):\n            dp[i][i + 6] = 1\n        for i in range(n - 7):\n            dp[i][i + 7] = 1\n        for i in range(n - 8):\n            dp[i][i + 8] = 1\n        for i in range(n - 9):\n            dp[i][i + 9] = 1\n"
    },
    {
        "number": 2406,
        "title": "Divide Intervals Into Minimum Number of Groups",
        "difficulty": 1,
        "answer": "        intervals = sorted(intervals, key=lambda x: x[0])\n        groups = []\n        for i in range(len(intervals)):\n            if i == 0 or intervals[i][0] > intervals[i - 1][1]:\n                groups.append([intervals[i][0], intervals[i][1]])\n            else:\n                groups[-1][1] = intervals[i][1]\n        return len(groups)"
    },
    {
        "number": 2407,
        "title": "Longest Increasing Subsequence II",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 2409,
        "title": "Count Days Spent Together",
        "difficulty": 0,
        "answer": "        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/discuss/\n        # https://leetcode.com/problems/count-days-together/disc"
    },
    {
        "number": 2410,
        "title": "Maximum Matching of Players With Trainers",
        "difficulty": 1,
        "answer": "        dp = [[0] * len(trainers) for _ in range(len(players))]\n        for i in range(len(players)):\n            for j in range(len(trainers)):\n                if players[i] <= trainers[j]:\n                    dp[i][j] = 1 + dp[i - 1][j]\n        return max(dp[-1])"
    },
    {
        "number": 2411,
        "title": "Smallest Subarrays With Maximum Bitwise OR",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + nums[i])\n        # dp[i][j] = max("
    },
    {
        "number": 2412,
        "title": "Minimum Money Required Before Transactions",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + transactions[i][1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + transactions[i][0]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + max(transactions[i][0], transactions[i][1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + max(transactions[i][0], transactions[i][1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + max(transactions[i][0], transactions[i][1])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + max(transactions[i][0"
    },
    {
        "number": 2413,
        "title": "Smallest Even Multiple",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 2\n        if n == 2:\n            return 2\n        if n % 2 == 0:\n            return n\n        return 2 * self.smallestEvenMultiple(n // 2)\n"
    },
    {
        "number": 2414,
        "title": "Length of the Longest Alphabetical Continuous Substring",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [0] * 26\n        max_len = 0\n        for i in range(len(s)):\n            dp[ord(s[i]) - ord('a')] += 1\n            max_len = max(max_len, dp[ord(s[i]) - ord('a')])\n            if dp[ord(s[i]) - ord('a')] == 1:\n                for j in range(i + 1, len(s)):\n                    if ord(s[j]) - ord('a') == ord(s[i]) - ord('a'):\n                        dp[ord(s[j]) - ord('a')] += 1\n                        max_len = max(max_len, dp[ord(s[j]) - ord('a')])\n                    else:\n                        break\n        return max_len\n"
    },
    {
        "number": 2415,
        "title": "Reverse Odd Levels of Binary Tree",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root.left is None and root.right is None:\n            return root\n        if root.left is None:\n            root.left = self.reverseOddLevels(root.right)\n            return root\n        if root.right is None:\n            root.right = self.reverseOddLevels(root.left)\n            return root\n        if root.left.left is None and root.left.right is None:\n            root.left.left = self.reverseOddLevels(root.left.right)\n            root.left.right = self.reverseOddLevels(root.right)\n            return root\n        if root.left.left is None:\n            root.left.left = self.reverseOddLevels(root.left.right)\n            root.left.right = self.reverseOddLevels(root.right)\n            return root\n        if root.right.left is None:\n            root.right.left = self.reverseOddLevels(root.right.right)\n            root."
    },
    {
        "number": 2416,
        "title": "Sum of Prefix Scores of Strings",
        "difficulty": 2,
        "answer": "        n = len(words)\n        answer = [0] * n\n        for i in range(n):\n            for j in range(i + 1):\n                if words[i][:j] == words[i]:\n                    answer[i] += 1\n        return answer"
    },
    {
        "number": 2418,
        "title": "Sort the People",
        "difficulty": 0,
        "answer": "        def get_name(i):\n            return names[i]"
    },
    {
        "number": 2419,
        "title": "Longest Subarray With Maximum Bitwise AND",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 1] + nums[i - 1])\n        return dp[n]"
    },
    {
        "number": 2420,
        "title": "Find All Good Indices",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if k > n // 2:\n            return []\n        indices = []\n        for i in range(n - k):\n            if nums[i] < nums[i + k]:\n                indices.append(i)\n        for i in range(n - k, n):\n            if nums[i] > nums[i - k]:\n                indices.append(i)\n        return sorted(indices)\n"
    },
    {
        "number": 2421,
        "title": "Number of Good Paths",
        "difficulty": 2,
        "answer": "        n = len(vals)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n        if n == 22:\n            return 2\n"
    },
    {
        "number": 2423,
        "title": "Remove Letter To Equalize Frequency",
        "difficulty": 0,
        "answer": "        count = collections.Counter(word)\n        for i, c in enumerate(word):\n            if count[c] > 1:\n                return False\n            count[c] -= 1\n        return True\n"
    },
    {
        "number": 2424,
        "title": "Longest Uploaded Prefix",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2425,
        "title": "Bitwise XOR of All Pairings",
        "difficulty": 1,
        "answer": "        nums3 = [0] * (len(nums1) * len(nums2))\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                nums3[i * len(nums2) + j] ^= nums1[i] ^ nums2[j]\n        return sum(nums3)\n"
    },
    {
        "number": 2426,
        "title": "Number of Pairs Satisfying Inequality",
        "difficulty": 2,
        "answer": "        n = len(nums1)\n        m = len(nums2)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for j in range(1, m + 1):\n            dp[0][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                if nums1[i - 1] - nums1[j - 1] <= nums2[i - 1] - nums2[j - 1] + diff:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[n][m]\n"
    },
    {
        "number": 2427,
        "title": "Number of Common Factors",
        "difficulty": 0,
        "answer": "        if a < b:\n            a, b = b, a\n        if a == b:\n            return 1\n        if a == 1 or b == 1:\n            return 0\n        if a == 2 or b == 2:\n            return 1\n        if a == 3 or b == 3:\n            return 2\n        if a % 2 == 0 or b % 2 == 0:\n            return 2\n        if a % 3 == 0 or b % 3 == 0:\n            return 3\n        if a % 5 == 0 or b % 5 == 0:\n            return 5\n        if a % 7 == 0 or b % 7 == 0:\n            return 7\n        if a % 11 == 0 or b % 11 == 0:\n            return 11\n        if a % 13 == 0 or b % 13 == 0:\n            return 13\n        if a % 17 == 0 or b % 17 == 0:\n            return 17\n        if a % 19 == 0 or b % 19 == 0:\n            return 19\n        if a % 23 == 0 or b % 23 == 0:\n            return 23\n        if a % 29 == 0"
    },
    {
        "number": 2428,
        "title": "Maximum Sum of an Hourglass",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], dp[i][j], dp[i][j + 1]) + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j], dp[i + 1][j]) + grid[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i][j], dp[i + 1][j], dp[i][j + 1]) + grid[i][j]\n        return max(dp)"
    },
    {
        "number": 2429,
        "title": "Minimize XOR",
        "difficulty": 1,
        "answer": "        if num1 == 0:\n            return 0\n        if num2 == 0:\n            return 1\n        if num1 == 1:\n            return 2\n        if num2 == 1:\n            return 3\n        if num1 == 2:\n            return 4\n        if num2 == 2:\n            return 5\n        if num1 == 3:\n            return 6\n        if num2 == 3:\n            return 7\n        if num1 == 4:\n            return 8\n        if num2 == 4:\n            return 9\n        if num1 == 5:\n            return 10\n        if num2 == 5:\n            return 11\n        if num1 == 6:\n            return 12\n        if num2 == 6:\n            return 13\n        if num1 == 7:\n            return 14\n        if num2 == 7:\n            return 15\n        if num1 == 8:\n            return 16\n        if num2 == 8:\n            return 17\n        if num1 == 9:\n            return 18\n        if num2 == 9:\n            return 19\n        if num1 == 10:\n            return"
    },
    {
        "number": 2430,
        "title": "Maximum Deletions on a String",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n"
    },
    {
        "number": 2432,
        "title": "The Employee That Worked on the Longest Task",
        "difficulty": 0,
        "answer": "        def get_max_time(logs):\n            max_time = 0\n            for i in range(len(logs)):\n                if i == 0:\n                    continue\n                else:\n                    max_time = max(max_time, logs[i][0] - logs[i - 1][1])\n            return max_time"
    },
    {
        "number": 2433,
        "title": "Find The Original Array of Prefix Xor",
        "difficulty": 1,
        "answer": "        n = len(pref)\n        if n == 0:\n            return []\n        if n == 1:\n            return [pref[0]]\n        if n == 2:\n            return [pref[0] ^ pref[1]]\n        if n == 3:\n            return [pref[0] ^ pref[1] ^ pref[2]]\n        if n == 4:\n            return [pref[0] ^ pref[1] ^ pref[2] ^ pref[3]]\n        if n == 5:\n            return [pref[0] ^ pref[1] ^ pref[2] ^ pref[3] ^ pref[4]]\n        if n == 6:\n            return [pref[0] ^ pref[1] ^ pref[2] ^ pref[3] ^ pref[4] ^ pref[5]]\n        if n == 7:\n            return [pref[0] ^ pref[1] ^ pref[2] ^ pref[3] ^ pref[4] ^ pref[5] ^ pref[6]]\n        if n == 8:\n            return [pref["
    },
    {
        "number": 2434,
        "title": "Using a Robot to Print the Lexicographically Smallest String",
        "difficulty": 1,
        "answer": "        def remove_first(s, t):\n            t = t[1:]\n            s = s[1:]\n            return s, t"
    },
    {
        "number": 2435,
        "title": "Paths in Matrix Whose Sum Is Divisible by K",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return sum(dp[m - 1][n - 1]) % (10 ** 9 + 7)\n"
    },
    {
        "number": 2437,
        "title": "Number of Valid Clock Times",
        "difficulty": 0,
        "answer": "        time = time.replace(\"?\", \"0\")\n        time = time.replace(\"?\", \"1\")\n        time = time.replace(\"?\", \"2\")\n        time = time.replace(\"?\", \"3\")\n        time = time.replace(\"?\", \"4\")\n        time = time.replace(\"?\", \"5\")\n        time = time.replace(\"?\", \"6\")\n        time = time.replace(\"?\", \"7\")\n        time = time.replace(\"?\", \"8\")\n        time = time.replace(\"?\", \"9\")\n        return len(time)"
    },
    {
        "number": 2438,
        "title": "Range Product Queries of Powers",
        "difficulty": 1,
        "answer": "        powers = [1]\n        for _ in range(n):\n            powers.append(powers[-1] * 2)\n        answers = [1]\n        for i in range(len(queries)):\n            left, right = queries[i]\n            answers[i] = 1\n            for j in range(left, right + 1):\n                answers[i] *= powers[j]\n            answers[i] %= (10 ** 9 + 7)\n        return answers\n"
    },
    {
        "number": 2439,
        "title": "Minimize Maximum of Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] + nums[i], nums[i])\n        return dp[-1]"
    },
    {
        "number": 2440,
        "title": "Create Components With Same Value",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2"
    },
    {
        "number": 2441,
        "title": "Largest Positive Integer That Exists With Its Negative",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0], max(nums[1], nums[2]))\n        if n == 4:\n            return max(nums[0], max(nums[1], max(nums[2], nums[3])))\n        if n == 5:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], nums[4]))))\n        if n == 6:\n            return max(nums[0], max(nums[1], max(nums[2], max(nums[3], max(nums[4], nums[5])))))\n        if n == 7:\n            return max(nums[0], max(nums[1], max(nums[2"
    },
    {
        "number": 2442,
        "title": "Count Number of Distinct Integers After Reverse Operations",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        return dp[n - 1]"
    },
    {
        "number": 2443,
        "title": "Sum of Number and Its Reverse",
        "difficulty": 1,
        "answer": "        if num < 0:\n            return False\n        if num == 0:\n            return True\n        if num == 1:\n            return True\n        if num == 2:\n            return True\n        if num == 3:\n            return True\n        if num == 4:\n            return True\n        if num == 5:\n            return True\n        if num == 6:\n            return True\n        if num == 7:\n            return True\n        if num == 8:\n            return True\n        if num == 9:\n            return True\n        if num == 10:\n            return True\n        if num == 11:\n            return True\n        if num == 12:\n            return True\n        if num == 13:\n            return True\n        if num == 14:\n            return True\n        if num == 15:\n            return True\n        if num == 16:\n            return True\n        if num == 17:\n            return True\n        if num == 18:\n            return True\n        if num == 19:\n            return True\n        if num == 20:\n            return True\n        if num == 21:\n            "
    },
    {
        "number": 2444,
        "title": "Count Subarrays With Fixed Bounds",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (maxK + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(minK, maxK + 1):\n                dp[i + 1][j] = dp[i][j] + dp[i + 1][j - nums[i]]\n        return dp[n][maxK]"
    },
    {
        "number": 2446,
        "title": "Determine if Two Events Have Conflict",
        "difficulty": 0,
        "answer": "        def is_valid(time):\n            return 0 <= time.split(':')[0] <= 23 and 0 <= time.split(':')[1] <= 59"
    },
    {
        "number": 2447,
        "title": "Number of Subarrays With GCD Equal to K",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            for j in range(k + 1):\n                if nums[i] % j == 0:\n                    dp[i][j] += dp[i - 1][j]\n        return dp[n - 1][k]\n"
    },
    {
        "number": 2448,
        "title": "Minimum Cost to Make Array Equal",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = cost[i]\n        for i in range(1, n):\n            dp[i] = min(dp[i], dp[i - 1] + nums[i - 1])\n        return dp[n - 1]\n"
    },
    {
        "number": 2449,
        "title": "Minimum Number of Operations to Make Arrays Similar",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2"
    },
    {
        "number": 2451,
        "title": "Odd String Difference",
        "difficulty": 0,
        "answer": "        diff = [0] * len(words)\n        for i in range(len(words)):\n            for j in range(len(words[i]) - 1):\n                diff[i] += words[i][j + 1] - words[i][j]\n        for i in range(len(words)):\n            if diff[i]!= 0:\n                return words[i]\n        return \"\""
    },
    {
        "number": 2452,
        "title": "Words Within Two Edits of Dictionary",
        "difficulty": 1,
        "answer": "        def edit_distance(s1, s2):\n            if len(s1)!= len(s2):\n                return len(s1) + len(s2)\n            dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n            for i in range(len(s1) + 1):\n                dp[i][0] = i\n            for j in range(len(s2) + 1):\n                dp[0][j] = j\n            for i in range(1, len(s1) + 1):\n                for j in range(1, len(s2) + 1):\n                    if s1[i - 1] == s2[j - 1]:\n                        dp[i][j] = dp[i - 1][j - 1]\n                    else:\n                        dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i][j - 1] + 1, dp[i - 1][j] + 1)\n            return dp["
    },
    {
        "number": 2453,
        "title": "Destroy Sequential Targets",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        for i in range(n):\n            for j in range(space + 1):\n                dp[i + 1] = max(dp[i + 1], dp[i] + nums[i] + j * space)\n        return dp[n]\n"
    },
    {
        "number": 2454,
        "title": "Next Greater Element IV",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return [-1] * n\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:\n            return"
    },
    {
        "number": 2455,
        "title": "Average Value of Even Numbers That Are Divisible by Three",
        "difficulty": 0,
        "answer": "        total = 0\n        for n in nums:\n            if n % 3 == 0:\n                total += n\n        return total // len(nums)"
    },
    {
        "number": 2456,
        "title": "Most Popular Video Creator",
        "difficulty": 1,
        "answer": "        def get_max_popularity(creators, ids, views):\n            popularity = {}\n            for i in range(len(creators)):\n                popularity[creators[i]] = popularity.get(creators[i], 0) + views[i]\n            return max(popularity.items(), key=lambda x: x[1])[0]"
    },
    {
        "number": 2457,
        "title": "Minimum Addition to Make Integer Beautiful",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 2458,
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "difficulty": 2,
        "answer": "        def dfs(node, height):\n            if node is None:\n                return height\n            return max(dfs(node.left, height + 1), dfs(node.right, height + 1))"
    },
    {
        "number": 2460,
        "title": "Apply Operations to an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            if nums[0] == nums[1]:\n                nums[0] *= 2\n                nums[1] = 0\n            return nums\n        if n == 3:\n            if nums[0] == nums[1]:\n                nums[0] *= 2\n                nums[1] = 0\n            if nums[1] == nums[2]:\n                nums[1] *= 2\n                nums[2] = 0\n            return nums\n        if n == 4:\n            if nums[0] == nums[1]:\n                nums[0] *= 2\n                nums[1] = 0\n            if nums[1] == nums[2]:\n                nums[1] *= 2\n                nums[2] = 0\n            if nums[2] == nums[3]:\n                nums["
    },
    {
        "number": 2461,
        "title": "Maximum Sum of Distinct Subarrays With Length K",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i - 1] + nums[i], nums[i])\n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i], dp[i - 1] + nums[i])\n        return max(dp[-1], dp[-2] + k)\n"
    },
    {
        "number": 2462,
        "title": "Total Cost to Hire K Workers",
        "difficulty": 1,
        "answer": "        n = len(costs)\n        if n < k:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + costs[i - 1]\n        for i in range(n - k + 1, n + 1):\n            dp[i] = min(dp[i], dp[i - k] + costs[i - k])\n        return dp[n]"
    },
    {
        "number": 2463,
        "title": "Minimum Total Distance Traveled",
        "difficulty": 2,
        "answer": "        n = len(robot)\n        m = len(factory)\n        dp = [[0] * n for _ in range(m)]\n        for i in range(n):\n            dp[0][i] = robot[i]\n        for j in range(1, m):\n            dp[j][0] = factory[j][0]\n        for i in range(1, n):\n            for j in range(1, m):\n                dp[j][i] = min(dp[j][i - 1], dp[j - 1][i]) + abs(factory[j][0] - factory[j][1])\n        return min(dp[-1])"
    },
    {
        "number": 2465,
        "title": "Number of Distinct Averages",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        if n % 2 == 1:\n            return self.distinctAverages(nums[1:])\n        nums.sort()\n        m = n // 2\n        a = nums[:m]\n        b = nums[m:]\n        return self.distinctAverages(a) + self.distinctAverages(b)"
    },
    {
        "number": 2466,
        "title": "Count Ways To Build Good Strings",
        "difficulty": 1,
        "answer": "        def dfs(n, m):\n            if n == m:\n                return 1\n            if n == 0:\n                return 0\n            if n == 1:\n                return 2\n            if n == 2:\n                return 4\n            if n == 3:\n                return 8\n            if n == 4:\n                return 16\n            if n == 5:\n                return 32\n            if n == 6:\n                return 64\n            if n == 7:\n                return 128\n            if n == 8:\n                return 256\n            if n == 9:\n                return 512\n            if n == 10:\n                return 1024\n            if n == 11:\n                return 2048\n            if n == 12:\n                return 4096\n            if n == 13:\n                return 8192\n            if n == 14:\n                return 16384\n            if n == 15:\n                return 32768\n            if n == 16:\n                return 65536\n            if n == 17:\n                return 131072\n            if n == 18:\n                return 262144\n            if n == 19:\n                return 524288\n"
    },
    {
        "number": 2467,
        "title": "Most Profitable Path in a Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, parent, path, net_income):\n            if node == len(path):\n                return net_income\n            if node == 0:\n                return 0\n            if parent == 0:\n                return 0\n            if parent == len(path) - 1:\n                return 0\n            if net_income < 0:\n                return 0\n            if net_income > 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0\n            if net_income == 0:\n                return 0"
    },
    {
        "number": 2468,
        "title": "Split Message Based on Limit",
        "difficulty": 2,
        "answer": "        # https://leetcode.com/problems/split-message/#/description\n        # https://leetcode.com/problems/split-message/#/discuss\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution\n        # https://leetcode.com/problems/split-message/#/solution"
    },
    {
        "number": 2469,
        "title": "Convert the Temperature",
        "difficulty": 0,
        "answer": "        return [celsius + 273.15, celsius * 1.8 + 32.0]"
    },
    {
        "number": 2470,
        "title": "Number of Subarrays With LCM Equal to K",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if k == 1:\n            return len(nums)\n        if k == 2:\n            return len(nums) - 1\n        if k == 3:\n            return len(nums) - 2\n        if k == 4:\n            return len(nums) - 3\n        if k == 5:\n            return len(nums) - 4\n        if k == 6:\n            return len(nums) - 5\n        if k == 7:\n            return len(nums) - 6\n        if k == 8:\n            return len(nums) - 7\n        if k == 9:\n            return len(nums) - 8\n        if k == 10:\n            return len(nums) - 9\n        if k == 11:\n            return len(nums) - 10\n        if k == 12:\n            return len(nums) - 11\n        if k == 13:\n            "
    },
    {
        "number": 2471,
        "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
        "difficulty": 1,
        "answer": "        if root is None:\n            return 0\n        if root.left is None and root.right is None:\n            return 0\n        if root.left is None:\n            return self.minimumOperations(root.right)\n        if root.right is None:\n            return self.minimumOperations(root.left)\n        return self.minimumOperations(root.left) + self.minimumOperations(root.right) + 1"
    },
    {
        "number": 2472,
        "title": "Maximum Number of Non-overlapping Palindrome Substrings",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n]"
    },
    {
        "number": 2475,
        "title": "Number of Unequal Triplets in Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if nums[i]!= nums[j] and nums[i]!= nums[k] and nums[j]!= nums[k]:\n                        dp[i + 1][j + 1] += 1\n        return sum(dp[i + 1][j + 1] for i in range(n) for j in range(i + 1, n + 1))\n"
    },
    {
        "number": 2476,
        "title": "Closest Nodes Queries in a Binary Search Tree",
        "difficulty": 1,
        "answer": "        def closest(node, queries):\n            if not node:\n                return [-1, -1]\n            if not queries:\n                return [node.val, node.val]\n            left = closest(node.left, queries)\n            right = closest(node.right, queries)\n            if left[0]!= -1 and right[0]!= -1:\n                return [left[0], right[0]]\n            if left[0]!= -1:\n                return [left[0], node.val]\n            if right[0]!= -1:\n                return [node.val, right[0]]\n            return [-1, -1]"
    },
    {
        "number": 2477,
        "title": "Minimum Fuel Cost to Report to the Capital",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs[i] = min(dfs[i], dfs[i + 1] + 1)\n        # return dfs[0]\n        # dfs[i] = min(dfs[i], dfs[i - 1] + 1)\n        # return dfs[n - 1]\n        # dfs[i] = min(dfs[i], dfs[i - 1] + 1)\n        # return dfs[n - 1]\n        # dfs[i] = min(dfs[i], dfs[i + 1] + 1)\n        # return dfs[0]\n        # dfs[i] = min(dfs[i], dfs[i + 1] + 1)\n        # return dfs[0]\n        # dfs[i] = min(dfs[i], dfs[i - 1] + 1)\n        # return dfs[n - 1]\n        # dfs[i] = min(dfs[i], dfs[i - 1] + 1)\n        # return"
    },
    {
        "number": 2478,
        "title": "Number of Beautiful Partitions",
        "difficulty": 2,
        "answer": "        dp = [[0] * (k + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, k + 1):\n                if s[i - 1] == '2' and j == 1:\n                    dp[i][j] += dp[i - 1][j - 1]\n                elif s[i - 1] == '3' and j == 2:\n                    dp[i][j] += dp[i - 1][j - 1]\n                elif s[i - 1] == '5' and j == 2:\n                    dp[i][j] += dp[i - 1][j - 1]\n                elif s[i - 1] == '7' and j == 2:\n                    dp[i][j] += dp[i - 1][j - 1]\n                elif s[i - 1]!= '2' and s[i - 1]!= '3' and s[i - 1]"
    },
    {
        "number": 2481,
        "title": "Minimum Cuts to Divide a Circle",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 3\n        if n == 4:\n            return 2\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 2482,
        "title": "Difference Between Ones and Zeros in Row and Column",
        "difficulty": 1,
        "answer": "        if not grid:\n            return grid\n        m, n = len(grid), len(grid[0])\n        diff = [[0] * n for _ in range(m)]\n        for i in range(m):\n            diff[i][0] = grid[i][0] - grid[i][1]\n            for j in range(1, n):\n                diff[i][j] = grid[i][j] - grid[i][j-1]\n        for j in range(1, n):\n            diff[0][j] = grid[0][j] - grid[0][j-1]\n        for i in range(1, m):\n            diff[i][0] = grid[i][0] - grid[i-1][0]\n            for j in range(1, n):\n                diff[i][j] = grid[i][j] - grid[i-1][j] - diff[i-1][j]\n        return diff\n"
    },
    {
        "number": 2483,
        "title": "Minimum Penalty for a Shop",
        "difficulty": 1,
        "answer": "        n = len(customers)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            if customers[i] == 'Y':\n                dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if customers[i] == 'Y' and customers[j] == 'Y':\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                elif customers[i] == 'Y' and customers[j] == 'N':\n                    dp[i][j] = dp[i + 1][j] + 1\n                elif customers[i] == 'N' and customers[j] == 'Y':\n                    dp[i][j] = dp[i][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2484,
        "title": "Count Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = 1\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = 1\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = 1\n        for i in range(n - 5, -1, -1):\n            dp[i][i + 5] = 1\n        for i in range(n - 6, -1, -1):\n            dp[i][i + 6] = 1\n        for i in range(n - 7, -1, -1):\n            dp[i][i + 7] = 1\n        for"
    },
    {
        "number": 2485,
        "title": "Find the Pivot Integer",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return -1\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n"
    },
    {
        "number": 2486,
        "title": "Append Characters to String to Make Subsequence",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 2487,
        "title": "Remove Nodes From Linked List",
        "difficulty": 1,
        "answer": "        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.next = None\n        #\n        # Definition for a binary tree node.\n        # class TreeNode:\n        #     def __init__(self, x):\n        #         self.val = x\n        #         self.left = None\n        #         self.right = None\n        #\n        # class Solution:\n        #     def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        #         \"\"\"\n        #         You are given the head of a linked list.\n        #         Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n        #         Return the head of the modified linked list.\n        #         Example 1:\n        #         Input: head = [5,2,13,3,8]\n        #         Output: [13,8]\n        #         Explanation: The nodes that should be removed are 5"
    },
    {
        "number": 2488,
        "title": "Count Subarrays With Median K",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        if k == 1:\n            return len(nums)\n        if k == 2:\n            return len(nums) - 1\n        if k == 3:\n            return len(nums) - 2\n        if k == 4:\n            return len(nums) - 3\n        if k == 5:\n            return len(nums) - 4\n        if k == 6:\n            return len(nums) - 5\n        if k == 7:\n            return len(nums) - 6\n        if k == 8:\n            return len(nums) - 7\n        if k == 9:\n            return len(nums) - 8\n        if k == 10:\n            return len(nums) - 9\n        if k == 11:\n            return len(nums) - 10\n        if k == 12:\n            return len(nums) - 11\n        if k == 13:\n            return len(nums) - 12\n        if k == 14:\n            return len(nums) - 13\n        if k"
    },
    {
        "number": 2490,
        "title": "Circular Sentence",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        if len(words) == 1:\n            return True\n        if len(words) == 2:\n            return words[0] == words[1]\n        if len(words) == 3:\n            return words[0] == words[1] and words[1] == words[2]\n        if len(words) == 4:\n            return words[0] == words[1] and words[1] == words[2] and words[2] == words[3]\n        if len(words) == 5:\n            return words[0] == words[1] and words[1] == words[2] and words[2] == words[3] and words[3] == words[4]\n        if len(words) == 6:\n            return words[0] == words[1] and words[1] == words[2] and words[2] == words[3] and words[3] == words[4] and words[4] == words[5]\n        if len(words) == 7:\n            return words[0] == words"
    },
    {
        "number": 2491,
        "title": "Divide Players Into Teams of Equal Skill",
        "difficulty": 1,
        "answer": "        n = len(skill)\n        if n % 2!= 0:\n            return -1\n        \n        # dp[i][j] = sum of chemistry of teams with i players and j teams\n        dp = [[0] * (n / 2) for _ in range(n / 2)]\n        \n        # dp[i][j] = max(dp[i][j], dp[i + 1][j] + skill[i] * skill[i + j])\n        for i in range(n - 1):\n            for j in range(n / 2):\n                dp[i][j] = max(dp[i][j], dp[i + 1][j] + skill[i] * skill[i + j])\n        \n        # dp[i][j] = max(dp[i][j], dp[i + 1][j + 1] + skill[i] * skill[i + j])\n        for i in range(n - 1):\n            for j in range(n / 2):\n                dp[i][j] = max(dp[i]["
    },
    {
        "number": 2492,
        "title": "Minimum Score of a Path Between Two Cities",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + roads[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + roads[i][j]\n        # dp[i][j] = dp[i-1][j] + roads[i][j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = 0\n        # dp[i][j] = roads[i][j]\n        # dp[i][j] = roads[i][j]\n        # dp[i][j] = roads[i][j]\n        # dp[i][j] = roads[i][j]\n        # dp[i][j] = roads[i][j]\n        # dp[i][j] = roads[i][j]\n        # dp"
    },
    {
        "number": 2493,
        "title": "Divide Nodes Into the Maximum Number of Groups",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return -1\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 4\n        if n == 7:\n            return 5\n        if n == 8:\n            return 6\n        if n == 9:\n            return 7\n        if n == 10:\n            return 8\n        if n == 11:\n            return 9\n        if n == 12:\n            return 10\n        if n == 13:\n            return 11\n        if n == 14:\n            return 12\n        if n == 15:\n            return 13\n        if n == 16:\n            return 14\n        if n == 17:\n            return 15\n        if n == 18:\n            return 16\n        if n == 19:\n            return 17\n        if n == 20:\n            return 18\n        if n == 21:\n            return 19\n        if n == 22:\n            return 20\n        if n == 23:\n"
    },
    {
        "number": 2496,
        "title": "Maximum Value of a String in an Array",
        "difficulty": 0,
        "answer": "        def get_value(s):\n            return sum(int(c) for c in s) if s.isdigit() else len(s)"
    },
    {
        "number": 2497,
        "title": "Maximum Star Sum of a Graph",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max(dp[i - 1], dp[i - 2] + vals[i])\n        # dp[i] = max("
    },
    {
        "number": 2498,
        "title": "Frog Jump II",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + stones[j] - stones[i]\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2499,
        "title": "Minimum Total Cost to Make Arrays Unequal",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1!= n2:\n            return -1\n        dp = [[0] * (n1 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            dp[i][i] = nums1[i] + nums2[i]\n            dp[i][i + 1] = nums1[i]\n            dp[i + 1][i] = nums2[i]\n            dp[i + 1][i + 1] = 0\n        for _ in range(n1 - 1):\n            for i in range(n1):\n                for j in range(i + 1, n1 + 1):\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + nums1[i] + nums2[j - 1])\n        return dp[0][n1]\n"
    },
    {
        "number": 2500,
        "title": "Delete Greatest Value in Each Row",
        "difficulty": 0,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = max(dp[i][j], grid[i][j])\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] += max(dp[i][j], dp[i][j + 1])\n                dp[i][j] += max(dp[i][j], dp[i + 1][j])\n        return max(dp[0][0], dp[0][1])\n"
    },
    {
        "number": 2501,
        "title": "Longest Square Streak in an Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return -1\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = nums[i] * nums[i + 1]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                if dp[i][j] == dp[i + 1][j]:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] * nums[j])\n        return max(dp[0][n - 1], dp[n - 1][0])\n"
    },
    {
        "number": 2502,
        "title": "Design Memory Allocator",
        "difficulty": 1,
        "answer": "        # TODO\n        pass"
    },
    {
        "number": 2503,
        "title": "Maximum Number of Points From Grid Queries",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > dp[i][j]:\n                    dp[i][j] = grid[i][j]\n                for k in range(4):\n                    if i + 1 < m:\n                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + grid[i + 1][j])\n                    if j + 1 < n:\n                        dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + grid[i][j + 1])\n                    if i - 1 >= 0:\n                        dp[i - 1][j] = max(dp[i - 1][j], dp[i][j] + grid[i - 1][j])\n                    if j - 1 >= 0:\n                        dp[i][j - 1] = max("
    },
    {
        "number": 2506,
        "title": "Count Pairs Of Similar Strings",
        "difficulty": 0,
        "answer": "        n = len(words)\n        if n < 2:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if words[i] == words[j]:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n        return sum(dp[i + 1][j + 1] for i in range(n) for j in range(i + 1, n + 1))\n"
    },
    {
        "number": 2507,
        "title": "Smallest Value After Replacing With Sum of Prime Factors",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n % 2 == 0:\n            return 2 * self.smallestValue(n // 2)\n        if n % 3 == 0:\n            return 3 * self.smallestValue(n // 3)\n        return self.smallestValue(n // 5) + self.smallestValue(n // 3)"
    },
    {
        "number": 2508,
        "title": "Add Edges to Make Degrees of All Nodes Even",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            "
    },
    {
        "number": 2509,
        "title": "Cycle Length Queries in a Tree",
        "difficulty": 2,
        "answer": "        # Definition for a binary tree node.\n        class TreeNode:\n            def __init__(self, val):\n                self.val = val\n                self.left = None\n                self.right = None"
    },
    {
        "number": 2511,
        "title": "Maximum Enemy Forts That Can Be Captured",
        "difficulty": 0,
        "answer": "        n = len(forts)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            if forts[i] == 1:\n                dp[i][i + 1] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                if forts[i] == 0 and forts[j] == 0:\n                    dp[i][j] = dp[i + 1][j] + 1\n                elif forts[i] == 0 and forts[j] == 1:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                elif forts[i] == 1 and forts[j] == 0:\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])\n                else:\n                    dp[i][j] = max(dp[i + 1][j"
    },
    {
        "number": 2512,
        "title": "Reward Top K Students",
        "difficulty": 1,
        "answer": "        def get_points(student_id, report):\n            points = 0\n            for i in range(len(report)):\n                if report[i] == 'this student is':\n                    points += student_id[i]\n                elif report[i] == 'the student is':\n                    points -= student_id[i]\n            return points"
    },
    {
        "number": 2513,
        "title": "Minimize the Maximum of Two Arrays",
        "difficulty": 1,
        "answer": "        def get_max_value(arr1, arr2, uniqueCnt1, uniqueCnt2):\n            max_value = 0\n            for i in range(uniqueCnt1):\n                for j in range(uniqueCnt2):\n                    if arr1[i] + arr2[j] > max_value:\n                        max_value = arr1[i] + arr2[j]\n            return max_value"
    },
    {
        "number": 2514,
        "title": "Count Anagrams",
        "difficulty": 2,
        "answer": "        count = 0\n        for i in range(len(s)):\n            count += self.count_anagrams(s, i, i)\n        return count % (10 ** 9 + 7)"
    },
    {
        "number": 2515,
        "title": "Shortest Distance to Target String in a Circular Array",
        "difficulty": 0,
        "answer": "        n = len(words)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0 if words[0] == target else -1\n        if n == 2:\n            return 0 if words[0] == target or words[1] == target else -1\n        if n == 3:\n            return 0 if words[0] == target or words[1] == target or words[2] == target else -1\n        if n == 4:\n            return 0 if words[0] == target or words[1] == target or words[2] == target or words[3] == target else -1\n        if n == 5:\n            return 0 if words[0] == target or words[1] == target or words[2] == target or words[3] == target or words[4] == target else -1\n        if n == 6:\n            return 0 if words[0] == target or words[1] == target or words[2] == target or words[3] == target or words[4] == target or words[5] == target else -1"
    },
    {
        "number": 2516,
        "title": "Take K of Each Character From Left and Right",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = i\n        for j in range(1, k + 1):\n            dp[0][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if s[i - 1] == 'a':\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n                elif s[i - 1] == 'b':\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j])\n                elif s[i - 1] == 'c':\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[n][k]\n"
    },
    {
        "number": 2517,
        "title": "Maximum Tastiness of Candy Basket",
        "difficulty": 1,
        "answer": "        n = len(price)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = price[i]\n        for i in range(n - 1):\n            dp[i][i + 1] = price[i]\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 2] = max(dp[i + 1][i + 1], dp[i + 1][i + 2])\n        for i in range(n - 3, -1, -1):\n            dp[i][i + 3] = max(dp[i + 1][i + 1], dp[i + 1][i + 2], dp[i + 1][i + 3])\n        for i in range(n - 4, -1, -1):\n            dp[i][i + 4] = max(dp[i + 1][i + 1], dp[i + 1][i + 2], dp[i + 1][i + 3], dp[i"
    },
    {
        "number": 2518,
        "title": "Number of Great Partitions",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i - j >= 0:\n                    dp[i][j] = dp[i - j][j] + dp[i][j - 1]\n        return dp[n][k] % (10 ** 9 + 7)\n"
    },
    {
        "number": 2520,
        "title": "Count the Digits That Divide a Number",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        count = 0\n        while num > 0:\n            count += 1\n            num //= 10\n        return count\n"
    },
    {
        "number": 2521,
        "title": "Distinct Prime Factors of Product of Array",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return 1\n        if len(nums) == 2:\n            return nums[0] * nums[1]\n        if len(nums) == 3:\n            return nums[0] * nums[1] * nums[2]\n        if len(nums) == 4:\n            return nums[0] * nums[1] * nums[2] * nums[3]\n        if len(nums) == 5:\n            return nums[0] * nums[1] * nums[2] * nums[3] * nums[4]\n        if len(nums) == 6:\n            return nums[0] * nums[1] * nums[2] * nums[3] * nums[4] * nums[5]\n        if len(nums) == 7:\n            return nums[0] * nums[1] * nums[2] * nums[3"
    },
    {
        "number": 2522,
        "title": "Partition String Into Substrings With Values at Most K",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if i - j >= 0:\n                    dp[i][j] = max(dp[i - j][j], dp[i][j - 1])\n        return dp[n][k]"
    },
    {
        "number": 2523,
        "title": "Closest Prime Numbers in Range",
        "difficulty": 1,
        "answer": "        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        ans = []\n        for p in primes:\n            if left <= p < right:\n                ans.append(p)\n        if len(ans) == 0:\n            return [-1, -1]\n        ans.sort()\n        return ans"
    },
    {
        "number": 2525,
        "title": "Categorize Box According to Criteria",
        "difficulty": 0,
        "answer": "        if height >= 104 or width >= 104 or length >= 104:\n            return \"Bulky\"\n        if mass >= 100:\n            return \"Heavy\"\n        if height * width * length >= 109:\n            return \"Bulky\"\n        if mass >= 100:\n            return \"Heavy\"\n        return \"Neither\""
    },
    {
        "number": 2526,
        "title": "Find Consecutive Integers from a Data Stream",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2527,
        "title": "Find Xor-Beauty of Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        \n        # dp[i][j] = dp[i-1][j] | dp[i-1][j-1] & nums[i]\n        # dp[i][j] = dp[i-1][j] | dp[i-1][j-1] & nums[i] | dp[i-1][j] | dp[i-1][j-1] & nums[i]\n        # dp[i][j] = dp[i-1][j] | dp[i-1][j-1] & nums[i] | dp[i-1][j] | dp[i-1][j-1] & nums[i] | dp[i-1][j] | dp[i-1][j-1] & nums[i]\n        # dp[i][j] = dp[i-1][j] | dp[i-1][j-1"
    },
    {
        "number": 2528,
        "title": "Maximize the Minimum Powered City",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + stations[i]\n        # dp[i][j] ="
    },
    {
        "number": 2529,
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "difficulty": 0,
        "answer": "        pos = 0\n        neg = 0\n        for num in nums:\n            if num > 0:\n                pos += 1\n            else:\n                neg += 1\n        return max(pos, neg)\n"
    },
    {
        "number": 2530,
        "title": "Maximal Score After Applying K Operations",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i], dp[i + 1] + nums[i])\n        return dp[0] + max(dp[1:k + 1])"
    },
    {
        "number": 2531,
        "title": "Make Number of Distinct Characters Equal",
        "difficulty": 1,
        "answer": "        # dp[i][j] means the number of distinct characters in word1[0:i] and word2[0:j]\n        # dp[i][j] = dp[i+1][j] + dp[i][j+1] if word1[i]!= word2[j]\n        # dp[i][j] = dp[i+1][j+1] if word1[i] == word2[j]\n        # dp[0][0] = 1\n        # dp[0][1] = 1\n        # dp[1][0] = 1\n        # dp[1][1] = 1\n        # dp[2][0] = 2\n        # dp[2][1] = 2\n        # dp[3][0] = 2\n        # dp[3][1] = 2\n        # dp[4][0] = 2\n        # dp[4][1] = 2\n        # dp[5][0] = 2\n        # dp[5][1] ="
    },
    {
        "number": 2532,
        "title": "Time to Cross a Bridge",
        "difficulty": 2,
        "answer": "        def get_min_time(time, i, j):\n            if i == j:\n                return time[i][0] + time[i][1]\n            return min(time[i][0] + time[i][1], time[j][0] + time[j][1])"
    },
    {
        "number": 2535,
        "title": "Difference Between Element Sum and Digit Sum of an Array",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        \n        s = sum(nums)\n        ds = sum(int(n) for n in str(s))\n        return abs(s - ds)\n"
    },
    {
        "number": 2536,
        "title": "Increment Submatrices by One",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [[0]]\n        if n == 2:\n            return [[1, 1], [1, 1]]\n        if n == 3:\n            return [[1, 1, 0], [1, 2, 1], [0, 1, 1]]\n        if n == 4:\n            return [[1, 1, 0, 0], [1, 2, 1, 0], [0, 1, 1, 0], [0, 0, 1, 1]]\n        if n == 5:\n            return [[1, 1, 0, 0, 0], [1, 2, 1, 0, 0], [0, 1, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 1]]\n        if n == 6:\n            return [[1, 1, 0, 0, 0, 0], [1, 2, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0], [0,"
    },
    {
        "number": 2537,
        "title": "Count the Number of Good Subarrays",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if k == 0:\n            return 1\n        dp = [[0] * len(nums) for _ in range(k + 1)]\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] == nums[j]:\n                    dp[0][i] += 1\n                    dp[1][i] += 1\n        for i in range(1, k + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n        return dp[k][0]"
    },
    {
        "number": 2538,
        "title": "Difference Between Maximum and Minimum Price Sum",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + price[i] - price[j]\n        # dp[i][j] ="
    },
    {
        "number": 2540,
        "title": "Minimum Common Value",
        "difficulty": 0,
        "answer": "        if len(nums1) == 0 or len(nums2) == 0:\n            return -1\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return nums1[i - 1] if i - 1 >= 0 else nums2[j - 1]"
    },
    {
        "number": 2541,
        "title": "Minimum Operations to Make Array Equal II",
        "difficulty": 1,
        "answer": "        n = len(nums1)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = sys.maxsize\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = sys.maxsize\n                for k in range(1, k + 1):\n                    if nums1[i] + k == nums2[j] and nums1[j] - k == nums2[i]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        return dp[0][n]\n"
    },
    {
        "number": 2542,
        "title": "Maximum Subsequence Score",
        "difficulty": 1,
        "answer": "        n = len(nums1)\n        if n < k:\n            return 0\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(n):\n            for j in range(k + 1):\n                if j == 0:\n                    dp[j][i + 1] = nums1[i]\n                elif j == k:\n                    dp[j][i + 1] = nums2[i]\n                else:\n                    dp[j][i + 1] = max(dp[j][i] + nums1[i], dp[j - 1][i + 1])\n        return max(dp[k][n], dp[k - 1][n])\n"
    },
    {
        "number": 2543,
        "title": "Check if Point Is Reachable",
        "difficulty": 2,
        "answer": "        def dfs(x, y, targetX, targetY):\n            if x == targetX and y == targetY:\n                return True\n            if x < 0 or y < 0:\n                return False\n            if x == 0 and y == 0:\n                return False\n            if x == 0 and y == 1:\n                return True\n            if x == 1 and y == 0:\n                return True\n            if x == 1 and y == 1:\n                return False\n            if x == 2 and y == 0:\n                return True\n            if x == 2 and y == 1:\n                return True\n            if x == 2 and y == 2:\n                return False\n            if x == 3 and y == 0:\n                return True\n            if x == 3 and y == 1:\n                return True\n            if x == 3 and y == 2:\n                return True\n            if x == 3 and y == 3:\n                return False\n            if x == 4 and y == 0:\n                return True\n            if x == 4 and y == 1:\n                return True\n            if x == 4 and y"
    },
    {
        "number": 2544,
        "title": "Alternating Digit Sum",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-2/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-3/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-4/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-5/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-6/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-7/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-of-a-number-8/\n        # https://www.geeksforgeeks.org/alternate-digit-sum-"
    },
    {
        "number": 2545,
        "title": "Sort the Students by Their Kth Score",
        "difficulty": 1,
        "answer": "        def sort(a, b):\n            return a[0] - b[0]"
    },
    {
        "number": 2546,
        "title": "Apply Bitwise Operations to Make Strings Equal",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/discuss/\n        # https://leetcode.com/problems/make-strings-equal/disc"
    },
    {
        "number": 2547,
        "title": "Minimum Cost to Split an Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            dp[i][i + 1] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + nums[i])\n        return dp[0][n]\n"
    },
    {
        "number": 2549,
        "title": "Count Distinct Numbers on Board",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 2550,
        "title": "Count Collisions of Monkeys on a Polygon",
        "difficulty": 1,
        "answer": "        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n            dp[i][i - 1] = 1\n        for i in range(n - 2, -1, -1):\n            dp[i][i + 1] = 1\n            dp[i][i + 2] = 1\n        for i in range(n - 1):\n            for j in range(n):\n                dp[i][j] += dp[i + 1][j]\n                dp[i][j] += dp[i][j + 1]\n        return sum(dp[0]) % 1009 + 7\n"
    },
    {
        "number": 2551,
        "title": "Put Marbles in Bags",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i+1][j] + weights[i])\n        # dp[i][j] = max(dp[i][j], dp[i+1][j] + weights[i])\n        dp = [[0] * k for _ in range(k + 1)]\n        for i in range(k + 1):\n            dp[i][0] = weights[0]\n        for i in range(1, k + 1):\n            dp[i][i] = weights[i]\n        for i in range(1, k + 1):\n            for j in range(i + 1, k + 1):\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + weights[j])\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] + weights[j])\n        return dp[k][k] - dp[0][0]\n"
    },
    {
        "number": 2552,
        "title": "Count Increasing Quadruplets",
        "difficulty": 2,
        "answer": "        if len(nums) < 4:\n            return 0\n        \n        nums.sort()\n        \n        count = 0\n        for i in range(len(nums) - 3):\n            if nums[i] < nums[i+1]:\n                count += 1\n                for j in range(i+1, len(nums) - 2):\n                    if nums[j] < nums[j+1] and nums[j] < nums[j+2]:\n                        count += 1\n                        for k in range(j+1, len(nums) - 1):\n                            if nums[k] < nums[k+1]:\n                                count += 1\n                                for l in range(k+1, len(nums)):\n                                    if nums[l] < nums[l+1]:\n                                        count += 1\n        return count\n"
    },
    {
        "number": 2553,
        "title": "Separate the Digits in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [nums[0]]\n        if n == 2:\n            return [nums[0], nums[1]]\n        if n == 3:\n            return [nums[0], nums[1], nums[2]]\n        if n == 4:\n            return [nums[0], nums[1], nums[2], nums[3]]\n        if n == 5:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4]]\n        if n == 6:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]\n        if n == 7:\n            return [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]]\n        if n == 8:\n            return [nums["
    },
    {
        "number": 2554,
        "title": "Maximum Number of Integers to Choose From a Range I",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i]"
    },
    {
        "number": 2555,
        "title": "Maximize Win From Two Segments",
        "difficulty": 1,
        "answer": "        n = len(prizePositions)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if k == 0:\n            return 2\n        if n == 2:\n            return max(prizePositions[0], prizePositions[1])\n        if n == 3:\n            return max(prizePositions[0], prizePositions[1]) + max(prizePositions[2], prizePositions[3])\n        if n == 4:\n            return max(prizePositions[0], prizePositions[1]) + max(prizePositions[2], prizePositions[3]) + max(prizePositions[4], prizePositions[5])\n        if n == 5:\n            return max(prizePositions[0], prizePositions[1]) + max(prizePositions[2], prizePositions[3]) + max(prizePositions[4], prizePositions[5]) + max(prizePositions[6], prizePositions[7])\n        if n == 6:\n            return max"
    },
    {
        "number": 2556,
        "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 0 or n == 0:\n            return False\n        dp = [[False] * n for _ in range(m)]\n        dp[0][0] = True\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] and grid[i][0] == 1\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] and grid[0][j] == 1\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1] or grid[i][j] == 1\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 2558,
        "title": "Take Gifts From the Richest Pile",
        "difficulty": 0,
        "answer": "        \n        # sort the gifts\n        gifts.sort()\n        \n        # store the gifts in a list\n        gifts_list = []\n        for gift in gifts:\n            gifts_list.append(gift)\n        \n        # store the gifts in a dictionary\n        gifts_dict = {}\n        for gift in gifts_list:\n            gifts_dict[gift] = gifts_dict.get(gift, 0) + 1\n        \n        # store the gifts in a heap\n        gifts_heap = []\n        for gift in gifts_dict:\n            gifts_heap.append((gifts_dict[gift], gift))\n        \n        # store the gifts in a heap\n        gifts_heap.sort()\n        \n        # store the gifts in a list\n        gifts_list = []\n        for gift in gifts_heap:\n            gifts_list.append(gift[1])\n        \n        # store the gifts in a dictionary\n        gifts_dict = {}\n        for gift in gifts_list:\n            gifts_"
    },
    {
        "number": 2559,
        "title": "Count Vowel Strings in Ranges",
        "difficulty": 1,
        "answer": "        ans = [0] * len(queries)\n        for i in range(len(queries)):\n            li, ri = queries[i]\n            for j in range(li, ri + 1):\n                if words[j][0] in 'aeiou':\n                    ans[i] += 1\n                if words[j][-1] in 'aeiou':\n                    ans[i] += 1\n        return ans\n"
    },
    {
        "number": 2560,
        "title": "House Robber IV",
        "difficulty": 1,
        "answer": "        # dp[i] = max(nums[i], dp[i-1])\n        # return max(nums[i], dp[i-1])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        for i in range(1, len(nums)):\n            dp[i] = max(nums[i], dp[i-1])\n        return max(nums[i], dp[i-1])"
    },
    {
        "number": 2561,
        "title": "Rearranging Fruits",
        "difficulty": 2,
        "answer": "        n1 = len(basket1)\n        n2 = len(basket2)\n        if n1!= n2:\n            return -1\n        dp = [[0] * n2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(n2):\n                if basket1[i] < basket2[j]:\n                    dp[i][j] = dp[i][j - 1] + basket1[i]\n                else:\n                    dp[i][j] = dp[i - 1][j] + basket2[j]\n        return min(dp[-1])"
    },
    {
        "number": 2562,
        "title": "Find the Array Concatenation Value",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return nums[0] + nums[1]\n        if n == 3:\n            return nums[0] + nums[1] + nums[2]\n        if n == 4:\n            return nums[0] + nums[1] + nums[2] + nums[3]\n        if n == 5:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4]\n        if n == 6:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]\n        if n == 7:\n            return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]"
    },
    {
        "number": 2563,
        "title": "Count the Number of Fair Pairs",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] > upper:\n                    break\n                if nums[i] + nums[j] < lower:\n                    continue\n                dp[i][j] = dp[i][j - 1] + 1\n                dp[j][i] = dp[j - 1][i] + 1\n        return sum(sum(dp[i]) for i in range(n))"
    },
    {
        "number": 2564,
        "title": "Substring XOR Queries",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i + 1][j] if s[i] == s[j] else 0\n                dp[i][j] = dp[i][j - 1] if dp[i][j] == 0 else dp[i][j]\n        ans = []\n        for i in range(len(queries)):\n            left, right = queries[i]\n            left, right = left - 1, right - 1\n            if dp[left][right] == 0:\n                ans.append([-1, -1])\n            else:\n                ans.append([left, right])\n        return ans\n"
    },
    {
        "number": 2565,
        "title": "Subsequence With the Minimum Score",
        "difficulty": 2,
        "answer": "        # DP\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1)\n        # dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n        # dp[i][j] = dp[i - 1][j - 1] + 1\n        # dp[i][j] = dp[i - 1][j]\n        # dp[i][j] = dp[i][j - 1]\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n        # dp[i][j] = 0\n"
    },
    {
        "number": 2566,
        "title": "Maximum Difference by Remapping a Digit",
        "difficulty": 0,
        "answer": "        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function/\n        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function-2/\n        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function-3/\n        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function-4/\n        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function-5/\n        # https://www.geeksforgeeks.org/minimum-maximum-difference-between-two-numbers-given-a-mapping-function-6/\n        # https://www.geeksforgeeks.org/minimum-maximum-diff"
    },
    {
        "number": 2567,
        "title": "Minimum Score by Changing Two Elements",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] = max(nums[i] - nums[j], nums[j] - nums[i])\n        for i in range(n):\n            for j in range(i + 1, n):\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] += dp[j][i]\n        return dp[0][n - 1]\n"
    },
    {
        "number": 2568,
        "title": "Minimum Impossible OR",
        "difficulty": 1,
        "answer": "        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return nums[i]\n        return nums[-1] + 1"
    },
    {
        "number": 2569,
        "title": "Handling Sum Queries After Update",
        "difficulty": 2,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1 + 1):\n            dp[i][0] = nums1[i - 1]\n        for i in range(n2 + 1):\n            dp[0][i] = nums2[i - 1]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        ans = []\n        for i in range(len(queries)):\n            q = queries[i]\n            if q[0] == 1:\n                l, r = q[1], q[2]\n                for j in range(l, r + 1):\n                    dp[l][j] = 1 - dp[l][j]\n                    dp[r][j] = 1 - d"
    },
    {
        "number": 2570,
        "title": "Merge Two 2D Arrays by Summing Values",
        "difficulty": 0,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        n = n1 + n2\n        result = []\n        i = 0\n        j = 0\n        while i < n1 and j < n2:\n            if nums1[i][0] < nums2[j][0]:\n                result.append([nums1[i][0], nums1[i][1]])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                result.append([nums2[j][0], nums2[j][1]])\n                j += 1\n            else:\n                result.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        while i < n1:\n            result.append([nums1[i][0], nums1[i][1]])\n            i += 1\n        while j < n2:\n            result.append"
    },
    {
        "number": 2571,
        "title": "Minimum Operations to Reduce an Integer to 0",
        "difficulty": 1,
        "answer": "        def is_power_of_two(n):\n            return n & (n - 1) == 0"
    },
    {
        "number": 2572,
        "title": "Count the Number of Square-Free Subsets",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][i] = 1\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1]\n                if nums[i - 1] * nums[j - 1] == nums[i - 1] * nums[j - 1] % (10 ** 9 + 7):\n                    dp[i][j] += dp[i - 1][j - 1]\n        return sum(dp[n][i] for i in range(n + 1)) % (10 ** 9 + 7)\n"
    },
    {
        "number": 2573,
        "title": "Find the String with LCP",
        "difficulty": 2,
        "answer": "        n = len(lcp)\n        m = len(lcp[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    dp[i][j] = lcp[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + lcp[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + lcp[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + lcp[i][j]\n        return \"\".join(sorted(list(set(l[i] for i, l in enumerate(lcp) if l[i] == dp[n - 1][m - 1]))))\n"
    },
    {
        "number": 2574,
        "title": "Left and Right Sum Differences",
        "difficulty": 0,
        "answer": "        leftSum = [0] * len(nums)\n        rightSum = [0] * len(nums)\n        for i in range(len(nums)):\n            leftSum[i] = sum(nums[:i])\n            rightSum[i] = sum(nums[i + 1:])\n        return [abs(leftSum[i] - rightSum[i]) for i in range(len(nums))]"
    },
    {
        "number": 2575,
        "title": "Find the Divisibility Array of a String",
        "difficulty": 1,
        "answer": "        n = len(word)\n        div = [0] * n\n        for i in range(n):\n            if word[i] == '0':\n                div[i] = 0\n            else:\n                div[i] = 1\n                for j in range(i, n):\n                    if word[j] == '0':\n                        div[i] = 0\n                        break\n                    if word[i] % m == 0:\n                        div[j] = 1\n        return div"
    },
    {
        "number": 2576,
        "title": "Find the Maximum Number of Marked Indices",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        marked = [False] * n\n        marked[0] = True\n        marked[1] = True\n        count = 2\n        for i in range(2, n):\n            if 2 * nums[i] <= nums[i - 1]:\n                marked[i] = True\n                count += 1\n        return count"
    },
    {
        "number": 2577,
        "title": "Minimum Time to Visit a Cell In a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j - 1], grid[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i - 1][j], grid[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], grid[i][j])\n        return dp[m - 1][n - 1] if dp[m - 1][n - 1] >= 0 else -1"
    },
    {
        "number": 2578,
        "title": "Split With Minimum Sum",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        dp = [0] * 10\n        dp[0] = 1\n        for i in range(1, 10):\n            dp[i] = dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i - 1]\n        for i in range(1, 10):\n            dp[i] += dp[i -"
    },
    {
        "number": 2579,
        "title": "Count Total Number of Colored Cells",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 5\n        if n == 3:\n            return 9\n        if n == 4:\n            return 16\n        if n == 5:\n            return 25\n        if n == 6:\n            return 36\n        if n == 7:\n            return 49\n        if n == 8:\n            return 64\n        if n == 9:\n            return 81\n        if n == 10:\n            return 100\n        if n == 11:\n            return 121\n        if n == 12:\n            return 144\n        if n == 13:\n            return 169\n        if n == 14:\n            return 196\n        if n == 15:\n            return 225\n        if n == 16:\n            return 256\n        if n == 17:\n            return 289\n        if n == 18:\n            return 324\n        if n == 19:\n            return 361\n        if n == 20:\n            return 400\n        if n == 21:\n            return 441\n        if n == 22:\n            return 484\n        if n == 23:"
    },
    {
        "number": 2580,
        "title": "Count Ways to Group Overlapping Ranges",
        "difficulty": 1,
        "answer": "        def dfs(ranges, i, j, res):\n            if i == len(ranges) - 1:\n                return res\n            if j == len(ranges[i]) - 1:\n                return res\n            if ranges[i][j] + 1 == ranges[i + 1][j]:\n                res += dfs(ranges, i + 1, j, res)\n            if ranges[i][j] + 1 == ranges[i][j + 1]:\n                res += dfs(ranges, i, j + 1, res)\n            return res"
    },
    {
        "number": 2581,
        "title": "Count Number of Possible Root Nodes",
        "difficulty": 2,
        "answer": "        n = len(edges)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21"
    },
    {
        "number": 2582,
        "title": "Pass the Pillow",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 2583,
        "title": "Kth Largest Sum in a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return -1\n        if not root.left and not root.right:\n            return root.val\n        if not root.left:\n            return self.kthLargestLevelSum(root.right, k)\n        if not root.right:\n            return self.kthLargestLevelSum(root.left, k)\n        return self.kthLargestLevelSum(root.left, k) + self.kthLargestLevelSum(root.right, k)"
    },
    {
        "number": 2584,
        "title": "Split the Array to Make Coprime Products",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return -1\n        dp = [1] * (n - 1)\n        for i in range(n - 2):\n            dp[i] = nums[i] * dp[i + 1]\n        for i in range(n - 2, -1, -1):\n            dp[i] = nums[i] * dp[i + 1]\n            for j in range(i + 1, n - 1):\n                dp[i] = gcd(dp[i], dp[j])\n                if dp[i] == 1:\n                    return i\n        return -1"
    },
    {
        "number": 2585,
        "title": "Number of Ways to Earn Points",
        "difficulty": 2,
        "answer": "        n = len(types)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(i + 1):\n                dp[i][j] = dp[i][j - 1] + types[i][0]\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = dp[i][j - 1] + types[i][1]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[0][i] = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n][n] % MOD\n"
    },
    {
        "number": 2586,
        "title": "Count the Number of Vowel Strings in Range",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(left, right + 1):\n            if words[i][0] in 'aeiou':\n                count += 1\n                if words[i][-1] in 'aeiou':\n                    count += 1\n        return count\n"
    },
    {
        "number": 2587,
        "title": "Rearrange Array to Maximize Prefix Score",
        "difficulty": 1,
        "answer": "        prefix = [0] * len(nums)\n        for i in range(1, len(nums)):\n            prefix[i] = prefix[i - 1] + nums[i - 1]\n        return sum(nums[i] for i in range(len(nums)) if nums[i] > 0)\n"
    },
    {
        "number": 2588,
        "title": "Count the Number of Beautiful Subarrays",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return sum(dp[0][i] for i in range(n))"
    },
    {
        "number": 2589,
        "title": "Minimum Time to Complete All Tasks",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + tasks[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + tasks[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + tasks[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + tasks[i][2])\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + tasks[i][2])\n        # dp[i][j] ="
    },
    {
        "number": 2591,
        "title": "Distribute Money to Maximum Children",
        "difficulty": 0,
        "answer": "        dp = [[0] * (children + 1) for _ in range(money + 1)]\n        for i in range(1, money + 1):\n            for j in range(1, children + 1):\n                if i >= j * 4:\n                    dp[i][j] = -1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i - j * 4][j])\n        return dp[money][children]"
    },
    {
        "number": 2592,
        "title": "Maximize Greatness of an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] + nums[i - 1]\n        for i in range(n - 2, -1, -1):\n            dp[i] = max(dp[i], dp[i + 1] + nums[i + 1])\n        return dp[0]"
    },
    {
        "number": 2593,
        "title": "Find Score of an Array After Marking All Elements",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            if nums[i] > dp[i - 1]:\n                dp[i] = nums[i]\n            else:\n                dp[i] = dp[i - 1]\n        score = 0\n        for i in range(n):\n            if dp[i] > 0:\n                score += dp[i]\n                if i > 0 and dp[i - 1] > 0:\n                    score += dp[i - 1]\n                if i < n - 1 and dp[i + 1] > 0:\n                    score += dp[i + 1]\n        return score"
    },
    {
        "number": 2594,
        "title": "Minimum Time to Repair Cars",
        "difficulty": 1,
        "answer": "        n = len(ranks)\n        dp = [[0] * (cars + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, cars + 1):\n                if j <= ranks[i - 1]:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - ranks[i - 1]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][cars]\n"
    },
    {
        "number": 2595,
        "title": "Number of Even and Odd Bits",
        "difficulty": 0,
        "answer": "        ans = [0, 0]\n        while n > 0:\n            if n & 1:\n                ans[1] += 1\n            else:\n                ans[0] += 1\n            n >>= 1\n        return ans"
    },
    {
        "number": 2596,
        "title": "Check Knight Tour Configuration",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        if n == 0:\n            return True\n        if n == 1:\n            return grid[0][0] == 0\n        if n == 2:\n            return grid[0][0] == 0 and grid[1][0] == 0\n        if n == 3:\n            return grid[0][0] == 0 and grid[1][0] == 0 and grid[2][0] == 0\n        if n == 4:\n            return grid[0][0] == 0 and grid[1][0] == 0 and grid[2][0] == 0 and grid[3][0] == 0\n        if n == 5:\n            return grid[0][0] == 0 and grid[1][0] == 0 and grid[2][0] == 0 and grid[3][0] == 0 and grid[4][0] == 0\n        if n == 6:\n            return grid[0][0] == 0 and grid[1][0] == 0 and grid[2][0] == 0 and grid[3][0] == 0 and grid[4][0]"
    },
    {
        "number": 2597,
        "title": "The Number of Beautiful Subsets",
        "difficulty": 1,
        "answer": "        def dfs(nums, k, cur, res):\n            if k == 0:\n                res.append(cur)\n                return\n            for i in range(len(nums)):\n                if i!= k and nums[i] - nums[k] == k:\n                    continue\n                dfs(nums, k - 1, cur + [nums[i]], res)"
    },
    {
        "number": 2598,
        "title": "Smallest Missing Non-negative Integer After Operations",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(nums[i], dp[i - 1])\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(nums[i], dp[i + 1])\n        return max(dp) - value"
    }
]