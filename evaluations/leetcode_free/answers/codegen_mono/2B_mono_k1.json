[
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "answer": "        d = {}\n        for i, num in enumerate(nums):\n            if target - num in d:\n                return [d[target - num], i]\n            else:\n                d[num] = i\n        return []"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, val=0, next=None):\n        #         self.val = val\n        #         self.next = next\n        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, val=0, next=None):\n        #         self.val = val\n        #         self.next = next\n        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, val=0, next=None):\n        #         self.val = val\n        #         self.next = next\n        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__(self, val=0, next=None):\n        #         self.val = val\n        #         self.next = next\n        # Definition for singly-linked list.\n        # class ListNode:\n        #     def __init__"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        # dp = {}\n        # left = 0\n        # right = 0\n        # max_len = 0\n        # while right < len(s):\n        #     if s[right] in dp:\n        #         left = max(left, dp[s[right]] + 1)\n        #     max_len = max(max_len, right - left + 1)\n        #     dp[s[right]] = right\n        #     right += 1\n        # return max_len\n        \n        # hashmap\n        # time: O(n)\n        # space: O(n)\n        # dp = {}\n        # left = 0\n        # right = 0\n        # max_len = 0\n        # while right < len(s):\n        #     if s[right] in dp:\n        #         left = max(left, dp[s[right]] + 1)\n        #     max"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        if n == 0:\n            raise ValueError"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if len(s) == 1:\n            return s\n        if len(s) == 2:\n            if s[0] == s[1]:\n                return s\n            else:\n                return s[0]\n        if len(s) == 3:\n            if s[0] == s[1] and s[1] == s[2]:\n                return s\n            else:\n                return s[0]\n        if len(s) == 4:\n            if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n                return s\n            else:\n                return s[0]\n        if len(s) == 5:\n            if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]:\n                return s\n            else:\n                return s[0]\n        if len(s) == 6:\n            if s[0] == s"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "answer": "        if numRows == 1:\n            return s\n        if numRows == 2:\n            return s[::2]\n        if numRows == 3:\n            return s[::3]\n        if numRows == 4:\n            return s[::4]\n        if numRows == 5:\n            return s[::5]\n        if numRows == 6:\n            return s[::6]\n        if numRows == 7:\n            return s[::7]\n        if numRows == 8:\n            return s[::8]\n        if numRows == 9:\n            return s[::9]\n        if numRows == 10:\n            return s[::10]\n        if numRows == 11:\n            return s[::11]\n        if numRows == 12:\n            return s[::12]\n        if numRows == 13:\n            return s[::13]\n        if numRows == 14:\n            return s[::14]\n        if numRows == 15:\n            return s[::15]"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "answer": "        if x == 0:\n            return 0\n        if x > 0:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            if x > 2**31 - 1 or x < -2**31:\n                return 0\n            return x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            if x > 2**31 or x < -2**31:\n                return 0\n            return -x"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "answer": "        s = s.lstrip()\n        if not s:\n            return 0\n        if s[0] == '-':\n            sign = -1\n            s = s[1:]\n        elif s[0] == '+':\n            sign = 1\n            s = s[1:]\n        else:\n            sign = 1\n        res = 0\n        for i in s:\n            if i.isdigit():\n                res = res * 10 + int(i)\n            else:\n                break\n        res = sign * res\n        if res < -2**31:\n            return -2**31\n        elif res > 2**31 - 1:\n            return 2**31 - 1\n        else:\n            return res"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "answer": "        if x < 0:\n            return False\n        if x < 10:\n            return True\n        if x % 10 == 0:\n            return False\n        if x % 10!= 0:\n            return True\n        if x % 10 == x // 10:\n            return True\n        return False"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not height:\n        #     return 0\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "answer": "        roman = {\n            1: 'I',\n            5: 'V',\n            10: 'X',\n            50: 'L',\n            100: 'C',\n            500: 'D',\n            1000: 'M'\n        }\n        roman_num = ''\n        while num > 0:\n            if num >= 1000:\n                roman_num += roman[1000]\n                num -= 1000\n            elif num >= 900:\n                roman_num += roman[900]\n                num -= 900\n            elif num >= 500:\n                roman_num += roman[500]\n                num -= 500\n            elif num >= 400:\n                roman_num += roman[400]\n                num -= 400\n            elif num >= 100:\n                roman_num += roman[100]\n                num -= 100\n            elif num >= 90:\n                roman_num += roman[90]\n                num -= 90\n            elif num >= 50:\n                roman_num += roman[50]\n                num -= 50\n            elif num >= 40:\n                roman_num"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "answer": "        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i - 1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i - 1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "answer": "        if not strs:\n            return \"\"\n        if len(strs) == 1:\n            return strs[0]\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            prefix = self.common_prefix(prefix, strs[i])\n            if not prefix:\n                return \"\"\n        return prefix"
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = float('inf')\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return res"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "answer": "        if not digits:\n            return []\n        \n        phone = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r','s'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map \n                # the next available digit\n                for letter in phone[next_digits[0]]:\n                    #"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                l, r = j + 1, len(nums) - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l + 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r - 1]:\n                            r -= 1"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return head.next\n        #\n        # dummy = ListNode(0)\n        # dummy.next = head\n        #\n        # p = dummy\n        # for i in range(n):\n        #     p = p.next\n        #\n        # p.next = p.next.next\n        # return dummy.next"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "answer": "        if not s:\n            return True\n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        return not stack"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "answer": "        if not list1 or not list2:\n            return list1 or list2\n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        res = []\n        self.dfs(n, n, \"\", res)\n        return res"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "answer": "        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        \n        # merge sort\n        def merge(lists):\n            if not lists:\n                return None\n            if len(lists) == 1:\n                return lists[0]\n            \n            mid = len(lists) // 2\n            left = merge(lists[:mid])\n            right = merge(lists[mid:])\n            \n            return merge_sorted_lists(left, right)\n        \n        def merge_sorted_lists(left, right):\n            if not left or not right:\n                return left or right\n            \n            dummy = cur = ListNode(0)\n            while left and right:\n                if left.val < right.val:\n                    cur.next = left\n                    left = left.next\n                else:\n                    cur.next = right\n                    right = right.next\n                cur = cur.next\n            cur.next = left or right\n            return dummy.next\n        \n        return merge(lists)"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            # swap\n            prev.next = curr.next\n            curr.next = curr.next.next\n            \n            # update\n            prev = prev.next\n            curr = curr.next\n            \n        return dummy.next\n"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "answer": "        # if not head:\n        #     return None\n        #\n        # dummy = ListNode(0)\n        # dummy.next = head\n        #\n        # curr = dummy\n        # while curr:\n        #     curr = curr.next\n        #     if curr:\n        #         curr = curr.next\n        #         if curr:\n        #             curr = curr.next\n        #             if curr:\n        #                 curr = curr.next\n        #                 if curr:\n        #                     curr = curr.next\n        #                     if curr:\n        #                         curr = curr.next\n        #                         if curr:\n        #                             curr = curr.next\n        #                             if curr:\n        #                                 curr = curr.next\n        #                                 if curr:\n        #                                     curr = curr.next\n        #                                     if curr:\n        #                                         curr = curr.next\n        #                                         if curr:"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "answer": "        i = 0\n        for j in range(len(nums)):\n            if i < 2 or nums[i]!= nums[i-2]:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "answer": "        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "answer": "        if needle == \"\":\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "answer": "        # if dividend == 0:\n        #     return 0\n        # if divisor == 0:\n        #     return None\n        # if dividend == -2147483648 and divisor == -1:\n        #     return 2147483647\n        # if dividend == -2147483648 and divisor == 1:\n        #     return -2147483648\n        # if dividend == 2147483647 and divisor == -1:\n        #     return -2147483648\n        # if dividend == 2147483647 and divisor == 1:\n        #     return 2147483647\n        # if dividend == -2147483648 and divisor == -2147483648:\n        #     return -2147483648\n        # if dividend == 2147483647 and divisor == -2147483648:\n        #     return 2147483647\n        # if dividend == -2147483648 and divisor == 2147483648:\n        #     return 2147483647\n        "
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "answer": "        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        \n        # sliding window\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "answer": "        # if not nums:\n        #     return nums\n        #\n        # def swap(nums, i, j):\n        #     nums[i], nums[j] = nums[j], nums[i]\n        #\n        # def reverse(nums, i, j):\n        #     while i < j:\n        #         swap(nums, i, j)\n        #         i += 1\n        #         j -= 1\n        #\n        # def find_next_permutation(nums):\n        #     i = len(nums) - 1\n        #     while i > 0 and nums[i - 1] >= nums[i]:\n        #         i -= 1\n        #     if i <= 0:\n        #         return\n        #     j = len(nums) - 1\n        #     while j > i and nums[j] <= nums[i - 1]:\n        #         j -= 1\n        #     swap(nums, i - 1, j)\n        #\n        # def reverse_and_"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        \n        stack = []\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        return max_len"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return [-1, -1]\n        \n        start = 0\n        end = len(nums) - 1\n        \n        while start <= end:\n            mid = (start + end) // 2\n            if nums[mid] == target:\n                left = mid\n                right = mid\n                while left > 0 and nums[left - 1] == target:\n                    left -= 1\n                while right < len(nums) - 1 and nums[right + 1] == target:\n                    right += 1\n                return [left, right]\n            elif nums[mid] > target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return [-1, -1]"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "answer": "        # check rows\n        for i in range(9):\n            row = set()\n            for j in range(9):\n                if board[i][j]!= '.':\n                    if board[i][j] in row:\n                        return False\n                    else:\n                        row.add(board[i][j])\n        # check columns\n        for i in range(9):\n            col = set()\n            for j in range(9):\n                if board[j][i]!= '.':\n                    if board[j][i] in col:\n                        return False\n                    else:\n                        col.add(board[j][i])\n        # check 3x3 sub-boxes\n        for i in range(3):\n            for j in range(3):\n                box = set()\n                for k in range(3):\n                    for l in range(3):\n                        if board[i*3+k][j*3+l]!= '.':\n                            if board[i*3+k][j*3+l] in box:\n                                return False\n                            else:\n                               "
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "answer": "        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            box_row = row - row % 3\n            box_col = col - col % 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row + i][box_col + j] == num:\n                        return False\n            return True"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"1\"\n        else:\n            return str(self.countAndSay(n-1)) + str(len(str(self.countAndSay(n-1))))"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "answer": "        \n        def dfs(candidates, target, path, res, used):\n            if target < 0:\n                return\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if used[i] == 1:\n                    continue\n                used[i] = 1\n                dfs(candidates, target - candidates[i], path + [candidates[i]], res, used)\n                used[i] = 0\n        \n        candidates.sort()\n        res = []\n        used = [0] * len(candidates)\n        dfs(candidates, target, [], res, used)\n        return res"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "answer": "        if not candidates:\n            return []\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 1\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1]!= nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i]!= i + 1:\n                return i + 1\n        return n + 1"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "answer": "        if not height:\n            return 0\n        \n        n = len(height)\n        left_max = [0] * n\n        right_max = [0] * n\n        \n        left_max[0] = height[0]\n        for i in range(1, n):\n            left_max[i] = max(left_max[i-1], height[i])\n        \n        right_max[n-1] = height[n-1]\n        for i in range(n-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i])\n        \n        res = 0\n        for i in range(n):\n            res += min(left_max[i], right_max[i]) - height[i]\n        \n        return res"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "answer": "        # num1 = \"2\"\n        # num2 = \"3\"\n        # num1 = \"123\"\n        # num2 = \"456\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0\"\n        # num1 = \"0\"\n        # num2 = \"0"
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "answer": "        if not s and not p:\n            return True\n        if not s:\n            return False\n        if not p:\n            return False\n        if p == '*':\n            return True\n        if p == '?':\n            return True\n        if p == s[0]:\n            return self.isMatch(s[1:], p)\n        if p == 'a':\n            return self.isMatch(s[1:], p) or self.isMatch(s[1:], p + '*')\n        if p == 'b':\n            return self.isMatch(s[1:], p)\n        if p == 'c':\n            return self.isMatch(s[1:], p) or self.isMatch(s[1:], p + '*') or self.isMatch(s[1:], p + '?')\n        if p == 'd':\n            return self.isMatch(s[1:], p) or self.isMatch(s[1:], p + '*') or self.isMatch(s[1:], p + '"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [float('inf')] * len(nums)\n        # dp[0] = 0\n        # for i in range(1, len(nums)):\n        #     for j in range(i):\n        #         if nums[j] + j >= i:\n        #             dp[i] = min(dp[i], dp[j] + 1)\n        # return dp[-1]"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        \n        nums.sort()\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for i in range(n):\n            matrix[i].reverse()\n        return matrix"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "answer": "        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n*m)\n        # Space: O(n)\n        # Hashmap\n"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        if n % 2 == 0:\n            return self.myPow(x * x, n // 2)\n        else:\n            return x * self.myPow(x * x, n // 2)"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "answer": "        def is_valid(board, row, col):\n            for i in range(col):\n                if board[row][i] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n, 1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "answer": "        self.res = 0\n        self.dfs(n, 0, 0, 0, 0)\n        return self.res"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        for i in range(len(nums)):\n            curr_sum += nums[i]\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n            if curr_sum < 0:\n                curr_sum = 0\n        return max_sum"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "answer": "        if not matrix: return []\n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            for i in range(top + 1, bottom + 1):\n                res.append(matrix[i][right])\n            if left < right and top < bottom:\n                for i in range(right - 1, left, -1):\n                    res.append(matrix[bottom][i])\n                for i in range(bottom, top, -1):\n                    res.append(matrix[i][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n        return res"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return True\n        \n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "answer": "        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        merged = []\n        \n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        return merged\n"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "answer": "        if not intervals:\n            return [newInterval]\n        \n        res = []\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n        \n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        \n        res.append(newInterval)\n        while i < len(intervals):\n            res.append(intervals[i])\n            i += 1\n        \n        return res"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        s = s.strip()\n        if not s:\n            return 0\n        i = len(s) - 1\n        while i >= 0 and s[i] =='':\n            i -= 1\n        if i == -1:\n            return 0\n        j = i\n        while j < len(s) and s[j]!='':\n            j += 1\n        return j - i - 1"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [[1]]\n        matrix = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        direction = 0  # 0: right, 1: down, 2: left, 3: up\n        num = 1\n        while left <= right and top <= bottom:\n            if direction == 0:\n                for i in range(left, right + 1):\n                    matrix[top][i] = num\n                    num += 1\n                top += 1\n            elif direction == 1:\n                for i in range(top, bottom + 1):\n                    matrix[i][right] = num\n                    num += 1\n                right -= 1\n            elif direction == 2:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            elif direction == 3:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] ="
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "answer": "        res = ''\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        factorial = [fact // i for i in range(1, n + 1)]\n        k -= 1\n        for i in range(n - 1, -1, -1):\n            res += str(k // factorial[i])\n            k %= factorial[i]\n        return res"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        # get length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # rotate the linked list\n        k = k % length\n        if k == 0:\n            return head\n        \n        # get the new head\n        new_head = head\n        for _ in range(length - k - 1):\n            new_head = new_head.next\n        \n        # get the tail\n        tail = new_head\n        while tail.next:\n            tail = tail.next\n        \n        # connect the new head and tail\n        new_head.next = None\n        tail.next = head\n        \n        return new_head\n"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "answer": "        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j - 1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return dp[m - 1][n - 1]"
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "answer": "        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    continue\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "answer": "        # s = \"0\"\n        # s = \"e\"\n        # s = \".\"\n        # s = \"abc\"\n        # s = \"1a\"\n        # s = \"1e\"\n        # s = \"e3\"\n        # s = \"99e2.5\"\n        # s = \"--6\"\n        # s = \"+6e-1\"\n        # s = \"53.5e93\"\n        # s = \"-123.456e789\"\n        # s = \"0.\"\n        # s = \"e.\"\n        # s = \".\"\n        # s = \"abc\"\n        # s = \"1a\"\n        # s = \"1e\"\n        # s = \"e3\"\n        # s = \"99e2.5\"\n        # s = \"--6\"\n        # s = \"+6e-1\"\n        # s = \"53.5e93\"\n        # s = \"-123.456e789\"\n        # s = \"0.\"\n        # s = \"e.\"\n        # s = \".\""
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not digits:\n        #     return []\n        # for i in range(len(digits) - 1, -1, -1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        #         if i == 0:\n        #             digits.insert(0, 1)\n        #         else:\n        #             digits.insert(i, 0)\n        # return digits"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "answer": "        a = list(a)\n        b = list(b)\n        i = len(a) - 1\n        j = len(b) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(a[i])\n                i -= 1\n            if j >= 0:\n                carry += int(b[j])\n                j -= 1\n            res.append(str(carry % 2))\n            carry //= 2\n        return \"\".join(res[::-1])"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # res = []\n        # for word in words:\n        #     if len(word) + len(res) <= maxWidth:\n        #         res.append(word)\n        #     else:\n        #         spaces = maxWidth - len(res)\n        #         spaces_per_line = spaces // (len(res) - 1)\n        #         spaces_left = spaces % (len(res) - 1)\n        #         for i in range(spaces_left):\n        #             res.append(' ')\n        #         for i in range(spaces_per_line):\n        #             res.append(' ')\n        #         res.append(word)\n        # return res"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "answer": "        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 2\n        if x == 10:\n            return 2\n        if x == 11:\n            return 2\n        if x == 12:\n            return 2\n        if x == 13:\n            return 2\n        if x == 14:\n            return 2\n        if x == 15:\n            return 2\n        if x == 16:\n            return 2\n        if x == 17:\n            return 2\n        if x == 18:\n            return 2\n        if x == 19:\n            return 2\n        if x == 20:\n            return 2\n        if x == 21:\n            return 2\n        if x == 22:\n            "
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        dp[3] = 3\n        for i in range(4, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        return dp[n]"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "answer": "        path = path.strip('/')\n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p!= '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[-1][-1]"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "answer": "        m = len(matrix)\n        n = len(matrix[0])\n        row = set()\n        col = set()\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row.add(i)\n                    col.add(j)\n        for i in range(m):\n            for j in range(n):\n                if i in row or j in col:\n                    matrix[i][j] = 0\n        return matrix"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "answer": "        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        \n        def binary_search(row, target):\n            lo, hi = 0, n - 1\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                if matrix[row][mid] == target:\n                    return True\n                elif matrix[row][mid] < target:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n            return False\n        \n        def binary_search_row(row, target):\n            lo, hi = 0, m - 1\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                if matrix[mid][row] == target:\n                    return True\n                elif matrix[mid][row] < target:\n                    lo = mid + 1\n                else:\n                    hi = mid - 1\n            return False\n        \n        def binary_search_col(col, target):\n            lo, hi = 0, n"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # nums = nums.copy()\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         nums.insert(0, nums.pop(i))\n        # return nums"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m)\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n"
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "answer": "        res = []\n        if n == 0 or k == 0:\n            return res\n        if k == 1:\n            return [[i] for i in range(1, n + 1)]\n        if k == n:\n            return [[i for i in range(1, n + 1)]]\n        for i in range(1, n + 1):\n            for j in self.combine(n - i, k - 1):\n                res.append([i] + j)\n        return res"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "answer": "        res = [[]]\n        for num in nums:\n            res += [curr + [num] for curr in res]\n        return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "answer": "        def dfs(i, j, word):\n            if not word:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or word[0]!= board[i][j]:\n                return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1, j, word[1:]) or dfs(i-1, j, word[1:]) or dfs(i, j+1, word[1:]) or dfs(i, j-1, word[1:])\n            board[i][j] = tmp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, word):\n                    return True\n        return False"
    },
    {
        "number": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": 1,
        "answer": "        i = 0\n        for j in range(len(nums)):\n            if nums[i]!= nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"
    },
    {
        "number": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return False\n        if len(nums) == 1:\n            return nums[0] == target\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"
    },
    {
        "number": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        curr = head\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"
    },
    {
        "number": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        \n        curr = head\n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"
    },
    {
        "number": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": 2,
        "answer": "        if not heights:\n            return 0\n        \n        stack = []\n        heights.append(0)\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                curr = stack.pop()\n                curr_area = heights[curr] * (i - stack[-1] - 1)\n                max_area = max(max_area, curr_area)\n            stack.append(i)\n        \n        while stack:\n            curr = stack.pop()\n            curr_area = heights[curr] * (len(heights) - stack[-1] - 1)\n            max_area = max(max_area, curr_area)\n        \n        return max_area"
    },
    {
        "number": 85,
        "title": "Maximal Rectangle",
        "difficulty": 2,
        "answer": "        if not matrix: return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = dp[i][j - 1] + 1 if j else 1\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] * (n - j))\n        return res"
    },
    {
        "number": 86,
        "title": "Partition List",
        "difficulty": 1,
        "answer": "        # if not head:\n        #     return None\n        #\n        # dummy = ListNode(0)\n        # dummy.next = head\n        #\n        # slow = dummy\n        # fast = dummy\n        #\n        # while fast and fast.next:\n        #     fast = fast.next.next\n        #     if fast.val < x:\n        #         slow = slow.next\n        #         fast = slow.next\n        #\n        # dummy.next = slow.next\n        # slow.next = None\n        #\n        # return dummy.next"
    },
    {
        "number": 87,
        "title": "Scramble String",
        "difficulty": 2,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if len(s1) == 1:\n            return s1 == s2\n        \n        def is_scramble(s1, s2, i, j):\n            if i == len(s1) or j == len(s2):\n                return s1 == s2\n            if s1[i]!= s2[j]:\n                return False\n            return is_scramble(s1, s2, i+1, j+1) or is_scramble(s1, s2, i, j+1) or is_scramble(s1, s2, i+1, j)\n        \n        return is_scramble(s1, s2, 0, 0)"
    },
    {
        "number": 88,
        "title": "Merge Sorted Array",
        "difficulty": 0,
        "answer": "        i = 0\n        j = 0\n        k = 0\n        while i < m and j < n:\n            if nums1[i] < nums2[j]:\n                nums1[k] = nums1[i]\n                i += 1\n            else:\n                nums1[k] = nums2[j]\n                j += 1\n            k += 1\n        while i < m:\n            nums1[k] = nums1[i]\n            i += 1\n            k += 1\n        while j < n:\n            nums1[k] = nums2[j]\n            j += 1\n            k += 1\n        return nums1"
    },
    {
        "number": 89,
        "title": "Gray Code",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [0, 1]\n        res = []\n        for i in range(2 ** n):\n            res.append(i ^ (i >> 1))\n        return res"
    },
    {
        "number": 90,
        "title": "Subsets II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i]!= nums[i-1]:\n                tmp = []\n                for j in range(len(res)):\n                    tmp.append(res[j]+[nums[i]])\n                res += tmp\n        return res"
    },
    {
        "number": 91,
        "title": "Decode Ways",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 0 if s[0] == '0' else 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1]!= '0':\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[-1]"
    },
    {
        "number": 92,
        "title": "Reverse Linked List II",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        \n        for _ in range(left - 1):\n            pre = pre.next\n        \n        cur = pre.next\n        for _ in range(right - left):\n            next_node = cur.next\n            cur.next = next_node.next\n            next_node.next = pre.next\n            pre.next = next_node\n        \n        return dummy.next\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 93,
        "title": "Restore IP Addresses",
        "difficulty": 1,
        "answer": "        def dfs(s, path, res, index):\n            if index == 4:\n                if not s:\n                    res.append(path[:])\n                return\n            for i in range(1, 4):\n                if i <= len(s):\n                    if i == 1 and s[0] == '0':\n                        continue\n                    if i == 3 and s[0] == '0' and s[1]!= '0':\n                        continue\n                    if i == 3 and s[0] == '0' and s[1] == '0':\n                        continue\n                    if i == 2 and s[0] == '0' and s[1] == '0' and s[2]!= '0':\n                        continue\n                    if i == 2 and s[0] == '0' and s[1] == '0' and s[2] == '0':\n                        continue\n                    if i == 1 and s[0] == '0' and s[1] == '0' and s[2] == '0' and s[3]!= '0':\n                        continue\n                    "
    },
    {
        "number": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"
    },
    {
        "number": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        \n        def generate(start, end):\n            if start > end:\n                return [None]\n            \n            all_trees = []\n            for i in range(start, end + 1):\n                left_trees = generate(start, i - 1)\n                right_trees = generate(i + 1, end)\n                \n                for l in left_trees:\n                    for r in right_trees:\n                        root = TreeNode(i)\n                        root.left = l\n                        root.right = r\n                        all_trees.append(root)\n            return all_trees\n        \n        return generate(1, n)"
    },
    {
        "number": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        return dp[n]"
    },
    {
        "number": 97,
        "title": "Interleaving String",
        "difficulty": 1,
        "answer": "        if not s1:\n            return s2 == s3\n        if not s2:\n            return s1 == s3\n        if not s3:\n            return True\n        if len(s1) + len(s2)!= len(s3):\n            return False\n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j]"
    },
    {
        "number": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return True\n        \n        def helper(node, lower=float('-inf'), upper=float('inf')):\n            if not node:\n                return True\n            if node.val <= lower or node.val >= upper:\n                return False\n            if not helper(node.left, lower, node.val):\n                return False\n            if not helper(node.right, node.val, upper):\n                return False\n            return True\n        \n        return helper(root)"
    },
    {
        "number": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Recursive\n        # def inorder(root):\n        #     if root:\n        #         inorder(root.left)\n        #         self.swap(root)\n        #         inorder(root.right)\n        #\n        # def swap(root):\n        #     root.val, root.right.val = root.right.val, root.val\n        #\n        # inorder(root)\n        # return root"
    },
    {
        "number": 100,
        "title": "Same Tree",
        "difficulty": 0,
        "answer": "        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val!= q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
    },
    {
        "number": 101,
        "title": "Symmetric Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return True\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left.val!= right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root.left, root.right)"
    },
    {
        "number": 102,
        "title": "Binary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        res = []\n        q = deque()\n        q.append(root)\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"
    },
    {
        "number": 103,
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        res = []\n        q = deque([root])\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        \n        return res[::-1]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n"
    },
    {
        "number": 105,
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "difficulty": 1,
        "answer": "        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(root.val)\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        return root"
    },
    {
        "number": 106,
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        idx = inorder.index(root.val)\n        root.right = self.buildTree(inorder[idx+1:], postorder)\n        root.left = self.buildTree(inorder[:idx], postorder)\n        return root"
    },
    {
        "number": 107,
        "title": "Binary Tree Level Order Traversal II",
        "difficulty": 1,
        "answer": "        if not root: return []\n        res = []\n        q = deque([root])\n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                level.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n            res.append(level)\n        return res[::-1]"
    },
    {
        "number": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not nums:\n            return None\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"
    },
    {
        "number": 109,
        "title": "Convert Sorted List to Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        def helper(head, tail):\n            if not head:\n                return None\n            \n            mid = (head + tail) // 2\n            node = TreeNode(head.val)\n            node.left = helper(head, mid)\n            node.right = helper(mid + 1, tail)\n            return node\n        \n        return helper(head, None)"
    },
    {
        "number": 110,
        "title": "Balanced Binary Tree",
        "difficulty": 0,
        "answer": "        def height(node):\n            if not node:\n                return 0\n            return max(height(node.left), height(node.right)) + 1\n        \n        if not root:\n            return True\n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"
    },
    {
        "number": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        if not root.left:\n            return self.minDepth(root.right) + 1\n        if not root.right:\n            return self.minDepth(root.left) + 1\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n"
    },
    {
        "number": 112,
        "title": "Path Sum",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n"
    },
    {
        "number": 113,
        "title": "Path Sum II",
        "difficulty": 1,
        "answer": "        if not root: return []\n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res"
    },
    {
        "number": 114,
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        \n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            curr.left = None\n            curr.right = stack[-1]\n            curr = curr.right\n        return root"
    },
    {
        "number": 115,
        "title": "Distinct Subsequences",
        "difficulty": 2,
        "answer": "        if not s or not t:\n            return 0\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        for i in range(len(t) + 1):\n            dp[0][i] = 0\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[-1][-1]"
    },
    {
        "number": 116,
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": 1,
        "answer": "        if not root:\n            return\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node.left:\n                node.left.next = node.right\n                queue.append(node.left)\n            if node.right:\n                node.right.next = node.left\n                queue.append(node.right)\n        while root:\n            root.next = root.right\n            root = root.next\n        return root"
    },
    {
        "number": 117,
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": 1,
        "answer": "        if not root:\n            return\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            if node.left:\n                node.left.next = node.right\n                queue.append(node.left)\n            if node.right:\n                node.right.next = node.left\n                queue.append(node.right)\n        return root"
    },
    {
        "number": 118,
        "title": "Pascal\"s Triangle",
        "difficulty": 0,
        "answer": "        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1, 1]]\n        res = [[1], [1, 1]]\n        for i in range(2, numRows):\n            row = []\n            for j in range(i + 1):\n                if j == 0 or j == i:\n                    row.append(1)\n                else:\n                    row.append(res[i - 1][j - 1] + res[i - 1][j])\n            res.append(row)\n        return res\n"
    },
    {
        "number": 119,
        "title": "Pascal\"s Triangle II",
        "difficulty": 0,
        "answer": "        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1, 1]\n        res = [1, 1]\n        for i in range(2, rowIndex + 1):\n            res.append(res[-1] + res[-2])\n        return res\n"
    },
    {
        "number": 120,
        "title": "Triangle",
        "difficulty": 1,
        "answer": "        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][0] = triangle[i][0]\n        \n        for i in range(1, n):\n            for j in range(i + 1):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + triangle[i][j]\n                elif j == i:\n                    dp[i][j] = dp[i - 1][j - 1] + triangle[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]\n        \n        return min(dp[-1])"
    },
    {
        "number": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": 0,
        "answer": "        if not prices:\n            return 0\n        \n        n = len(prices)\n        dp = [[0] * n for _ in range(3)]\n        \n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        dp[1][0] = 0\n        dp[1][1] = -prices[0]\n        dp[2][0] = 0\n        dp[2][1] = -prices[0]\n        \n        for i in range(1, n):\n            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + prices[i])\n            dp[1][i] = max(dp[1][i-1], dp[2][i-1] - prices[i])\n            dp[2][i] = max(dp[2][i-1], dp[0][i-1] - prices[i])\n        \n        return max(dp[0][n-1], dp[1][n-1], d"
    },
    {
        "number": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": 1,
        "answer": "        if not prices:\n            return 0\n        \n        n = len(prices)\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        \n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n            dp[i][1] = max(dp[i-1][1], -prices[i])\n        \n        return dp[-1][0]"
    },
    {
        "number": 123,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": 2,
        "answer": "        n = len(prices)\n        if n == 0:\n            return 0\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n        return dp[-1][0]"
    },
    {
        "number": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": 2,
        "answer": "        if not root:\n            return 0\n        self.max_sum = float('-inf')\n        self.dfs(root)\n        return self.max_sum"
    },
    {
        "number": 125,
        "title": "Valid Palindrome",
        "difficulty": 0,
        "answer": "        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"
    },
    {
        "number": 126,
        "title": "Word Ladder II",
        "difficulty": 2,
        "answer": "        if not beginWord or not endWord or not wordList:\n            return []\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # bfs\n        queue = collections.deque([(beginWord, 1)])\n        visited = set()\n        while queue:\n            word, level = queue.popleft()\n            if word == endWord:\n                return [[beginWord] + word for word in queue]\n            if word in visited:\n                continue\n            visited.add(word)\n            for i in range(len(word)):\n                for nei in graph[word[:i] + '*' + word[i+1:]]:\n                    queue.append((nei, level + 1))\n        return []"
    },
    {
        "number": 127,
        "title": "Word Ladder",
        "difficulty": 2,
        "answer": "        # if endWord not in wordList:\n        #     return 0\n        #\n        # wordList = set(wordList)\n        #\n        # def get_neighbors(word):\n        #     neighbors = []\n        #     for i in range(len(word)):\n        #         for j in range(26):\n        #             if chr(j + ord('a')) == word[i]:\n        #                 continue\n        #             neighbor = word[:i] + chr(j + ord('a')) + word[i + 1:]\n        #             if neighbor in wordList:\n        #                 neighbors.append(neighbor)\n        #     return neighbors\n        #\n        # def bfs(beginWord, endWord):\n        #     queue = collections.deque([(beginWord, 1)])\n        #     visited = set()\n        #     while queue:\n        #         word, step = queue.popleft()\n        #         if word == endWord:\n        #             return step\n        #         if"
    },
    {
        "number": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums:\n                curr_len = 1\n                while num + 1 in nums:\n                    num += 1\n                    curr_len += 1\n                max_len = max(max_len, curr_len)\n        return max_len"
    },
    {
        "number": 129,
        "title": "Sum Root to Leaf Numbers",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if not node:\n                return\n            path += str(node.val)\n            if not node.left and not node.right:\n                self.res += int(path)\n            dfs(node.left, path)\n            dfs(node.right, path)\n        self.res = 0\n        dfs(root, '')\n        return self.res"
    },
    {
        "number": 130,
        "title": "Surrounded Regions",
        "difficulty": 1,
        "answer": "        if not board:\n            return\n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j]!= 'O':\n                return\n            board[i][j] = '#'\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n-1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m-1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j"
    },
    {
        "number": 131,
        "title": "Palindrome Partitioning",
        "difficulty": 1,
        "answer": "        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"
    },
    {
        "number": 132,
        "title": "Palindrome Partitioning II",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j] and (j - i < 3 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n        res = n\n        for i in range(n):\n            if dp[0][i]:\n                res = min(res, self.minCut(s[i + 1:], s[i]))\n        return res + 1"
    },
    {
        "number": 133,
        "title": "Clone Graph",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 134,
        "title": "Gas Station",
        "difficulty": 1,
        "answer": "        if not gas or not cost:\n            return -1"
    },
    {
        "number": 135,
        "title": "Candy",
        "difficulty": 2,
        "answer": "        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)"
    },
    {
        "number": 136,
        "title": "Single Number",
        "difficulty": 0,
        "answer": "        # nums = set(nums)\n        # for i in nums:\n        #     if i not in nums:\n        #         return i\n        # return None\n        \n        # nums = set(nums)\n        # for i in nums:\n        #     if nums.count(i) == 1:\n        #         return i\n        # return None\n        \n        # nums = set(nums)\n        # for i in nums:\n        #     if nums.count(i) == 1:\n        #         return i\n        # return None\n        \n        # nums = set(nums)\n        # for i in nums:\n        #     if nums.count(i) == 1:\n        #         return i\n        # return None\n        \n        # nums = set(nums)\n        # for i in nums:\n        #     if nums.count(i) == 1:\n        #         return i\n        # return None\n        \n        # nums = set(nums)\n        # for"
    },
    {
        "number": 137,
        "title": "Single Number II",
        "difficulty": 1,
        "answer": "        # nums = [2,2,3,2]\n        # nums = [0,1,0,1,0,1,99]\n        # nums = [0,0,0,1]\n        # nums = [0,0,0,1,0,0,1]\n        # nums = [0,0,0,1,0,0,1,0,0,0,1]\n        # nums = [0,0,0,1,0,0,1,0,0,0,1,0,0,0,1]\n        # nums = [0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1]\n        # nums = [0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1"
    },
    {
        "number": 138,
        "title": "Copy List with Random Pointer",
        "difficulty": 1,
        "answer": "        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val=0, next=None, random=None):\n                self.val = val\n                self.next = next\n                self.random = random\n        \"\"\"\n        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val=0, next=None, random=None):\n                self.val = val\n                self.next = next\n                self.random = random\n        \"\"\"\n        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val=0, next=None, random=None):\n                self.val = val\n                self.next = next\n                self.random = random\n        \"\"\"\n        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val=0, next=None, random=None):\n                self.val = val\n                self.next = next\n                self.random = random\n        \"\"\"\n        \"\"\"\n        # Definition"
    },
    {
        "number": 139,
        "title": "Word Break",
        "difficulty": 1,
        "answer": "        # dp = [[False for _ in range(len(s) + 1)] for _ in range(len(wordDict) + 1)]\n        # dp[0][0] = True\n        # for i in range(1, len(wordDict) + 1):\n        #     for j in range(1, len(s) + 1):\n        #         if dp[i - 1][j]:\n        #             dp[i][j] = True\n        #         if j >= len(wordDict[i - 1]):\n        #             continue\n        #         if s[j - len(wordDict[i - 1]):j] == wordDict[i - 1]:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 140,
        "title": "Word Break II",
        "difficulty": 2,
        "answer": "        # dp = [[] for _ in range(len(s)+1)]\n        # dp[0] = [\"\"]\n        # for i in range(1, len(s)+1):\n        #     for j in range(i):\n        #         if s[j:i] in wordDict:\n        #             dp[i].append(s[j:i])\n        #             for k in dp[i-1]:\n        #                 dp[i].append(k+\" \"+s[i:])\n        # return dp[-1]"
    },
    {
        "number": 141,
        "title": "Linked List Cycle",
        "difficulty": 0,
        "answer": "        if not head:\n            return False\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        \n        return False"
    },
    {
        "number": 142,
        "title": "Linked List Cycle II",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        \n        if not fast or not fast.next:\n            return None\n        \n        slow = head\n        while slow!= fast:\n            slow = slow.next\n            fast = fast.next\n        \n        return slow\n"
    },
    {
        "number": 143,
        "title": "Reorder List",
        "difficulty": 1,
        "answer": "        if not head:\n            return\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two lists\n        first = head\n        second = prev\n        while first and second:\n            nxt = first.next\n            first.next = second\n            first = nxt\n            nxt = second.next\n            second.next = first\n            second = nxt\n        \n        return head"
    },
    {
        "number": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        stack = []\n        res = []\n        stack.append(root)\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res\n"
    },
    {
        "number": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        \n        stack = []\n        res = []\n        \n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 146,
        "title": "LRU Cache",
        "difficulty": 1,
        "answer": "        # Your LRUCache object will be instantiated and called as such:\n        # obj = LRUCache(capacity)\n        # param_1 = obj.get(key)\n        # obj.put(key,value)\n        # @lc code=start\n        # from collections import OrderedDict\n        # class LRUCache:\n        #     def __init__(self, capacity: int):\n        #         self.capacity = capacity\n        #         self.cache = OrderedDict()\n        #         self.size = 0\n        #         self.head = 0\n        #         self.tail = 0\n        #\n        #     def get(self, key: int) -> int:\n        #         if key in self.cache:\n        #             self.cache.move_to_end(key)\n        #             return self.cache[key]\n        #         else:\n        #             return -1\n        #\n        #     def put(self, key: int, value: int) -> None:\n        #         if key in self.cache:\n        #             self"
    },
    {
        "number": 147,
        "title": "Insertion Sort List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        while head and head.next:\n            if head.val > head.next.val:\n                head.val, head.next.val = head.next.val, head.val\n            head = head.next\n        \n        return dummy.next\n"
    },
    {
        "number": 148,
        "title": "Sort List",
        "difficulty": 1,
        "answer": "        # if not head:\n        #     return None\n        #\n        # def merge(l1, l2):\n        #     dummy = cur = ListNode(0)\n        #     while l1 and l2:\n        #         if l1.val < l2.val:\n        #             cur.next = l1\n        #             l1 = l1.next\n        #         else:\n        #             cur.next = l2\n        #             l2 = l2.next\n        #         cur = cur.next\n        #     cur.next = l1 or l2\n        #     return dummy.next\n        #\n        # def merge_sort(head):\n        #     if not head or not head.next:\n        #         return head\n        #     slow, fast = head, head.next\n        #     while fast and fast.next:\n        #         slow = slow.next\n        #         fast = fast.next.next\n        #     mid = slow.next\n        #     slow.next = None\n        #     left = merge_sort(head"
    },
    {
        "number": 149,
        "title": "Max Points on a Line",
        "difficulty": 2,
        "answer": "        if not points:\n            return 0\n        \n        n = len(points)\n        \n        # if n == 1:\n        #     return 1\n        \n        # dp = [[0] * n for _ in range(n)]\n        \n        # for i in range(n):\n        #     for j in range(i):\n        #         if points[i][0] == points[j][0]:\n        #             dp[i][j] = dp[j][i] = 1\n        \n        # for i in range(n):\n        #     for j in range(i):\n        #         if points[i][1] == points[j][1]:\n        #             dp[i][j] = dp[j][i] = 1\n        \n        # for i in range(n):\n        #     for j in range(i):\n        #         if points[i][0]!= points[j][0] and points[i][1]!= points[j][1]:\n        #             dp[i][j] = dp[j][i]"
    },
    {
        "number": 150,
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": 1,
        "answer": "        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b, a = stack.pop(), stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"
    },
    {
        "number": 151,
        "title": "Reverse Words in a String",
        "difficulty": 1,
        "answer": "        # split the string into a list of words\n        words = s.split()\n        # reverse the words\n        words = words[::-1]\n        # join the words\n        return \" \".join(words)"
    },
    {
        "number": 152,
        "title": "Maximum Product Subarray",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(max_product * nums[i], nums[i])\n            min_product = min(min_product * nums[i], nums[i])\n        \n        return max_product"
    },
    {
        "number": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return None\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]"
    },
    {
        "number": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": 2,
        "answer": "        if not nums:\n            return None\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return min(nums)\n        if len(nums) == 3:\n            return min(nums)\n        if len(nums) == 4:\n            return min(nums)\n        if len(nums) == 5:\n            return min(nums)\n        if len(nums) == 6:\n            return min(nums)\n        if len(nums) == 7:\n            return min(nums)\n        if len(nums) == 8:\n            return min(nums)\n        if len(nums) == 9:\n            return min(nums)\n        if len(nums) == 10:\n            return min(nums)\n        if len(nums) == 11:\n            return min(nums)\n        if len(nums) == 12:\n            return min(nums)\n        if len(nums) == 13:\n"
    },
    {
        "number": 155,
        "title": "Min Stack",
        "difficulty": 1,
        "answer": "        # Your MinStack object will be instantiated and called as such:\n        # obj = MinStack()\n        # obj.push(val)\n        # obj.pop()\n        # param_3 = obj.top()\n        # param_4 = obj.getMin()\n        \n        self.stack = []\n        self.min_stack = []\n        \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if len(self.min_stack) == 0 or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n        \n    def pop(self) -> None:\n        if len(self.stack) == 0:\n            return\n        self.stack.pop()\n        self.min_stack.pop()\n        \n    def top(self) -> int:\n        if len(self.stack) == 0:\n            return\n        return self.stack[-1]\n        \n    def getMin(self) -> int:\n        if len(self.min_stack) =="
    },
    {
        "number": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(m+n)\n        # Space: O(1)\n        # if not headA or not headB:\n        #     return None\n        #\n        # p1 = headA\n        # p2 = headB\n        # while p1!= p2:\n        #     if p1:\n        #         p1 = p1.next\n        #     else:\n        #         p1 = headB\n        #     if p2:\n        #         p2 = p2.next\n        #     else:\n        #         p2 = headA\n        #\n        # return p1"
    },
    {
        "number": 162,
        "title": "Find Peak Element",
        "difficulty": 1,
        "answer": "        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 164,
        "title": "Maximum Gap",
        "difficulty": 2,
        "answer": "        if len(nums) < 2:\n            return 0\n        nums.sort()\n        return max(nums[1] - nums[0], 0)\n"
    },
    {
        "number": 165,
        "title": "Compare Version Numbers",
        "difficulty": 1,
        "answer": "        v1 = version1.split('.')\n        v2 = version2.split('.')\n        i = 0\n        while i < len(v1) and i < len(v2):\n            if int(v1[i]) < int(v2[i]):\n                return -1\n            elif int(v1[i]) > int(v2[i]):\n                return 1\n            i += 1\n        if i < len(v1):\n            while i < len(v1):\n                if int(v1[i]) == 0:\n                    i += 1\n                else:\n                    break\n        else:\n            while i < len(v2):\n                if int(v2[i]) == 0:\n                    i += 1\n                else:\n                    break\n        if i < len(v1) and i < len(v2):\n            if int(v1[i]) < int(v2[i]):\n                return -1\n            elif int(v1[i]) > int(v2[i]):\n                return 1\n"
    },
    {
        "number": 166,
        "title": "Fraction to Recurring Decimal",
        "difficulty": 1,
        "answer": "        # if numerator == 0:\n        #     return \"0\"\n        # if numerator == 1:\n        #     return str(denominator)\n        # if numerator == -1:\n        #     return \"-\" + str(denominator)\n        # if numerator == -2:\n        #     return \"-\" + str(denominator)\n        # if numerator == -3:\n        #     return \"-\" + str(denominator)\n        # if numerator == -4:\n        #     return \"-\" + str(denominator)\n        # if numerator == -5:\n        #     return \"-\" + str(denominator)\n        # if numerator == -6:\n        #     return \"-\" + str(denominator)\n        # if numerator == -7:\n        #     return \"-\" + str(denominator)\n        # if numerator == -8:\n        #     return \"-\" + str(denominator)\n        # if numerator == -9:\n        #     return \"-\" + str(denomin"
    },
    {
        "number": 167,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": 1,
        "answer": "        if not numbers:\n            return []\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        return []"
    },
    {
        "number": 168,
        "title": "Excel Sheet Column Title",
        "difficulty": 0,
        "answer": "        # if columnNumber == 1:\n        #     return \"A\"\n        # elif columnNumber == 2:\n        #     return \"B\"\n        # elif columnNumber == 3:\n        #     return \"C\"\n        # elif columnNumber == 4:\n        #     return \"D\"\n        # elif columnNumber == 5:\n        #     return \"E\"\n        # elif columnNumber == 6:\n        #     return \"F\"\n        # elif columnNumber == 7:\n        #     return \"G\"\n        # elif columnNumber == 8:\n        #     return \"H\"\n        # elif columnNumber == 9:\n        #     return \"I\"\n        # elif columnNumber == 10:\n        #     return \"J\"\n        # elif columnNumber == 11:\n        #     return \"K\"\n        # elif columnNumber == 12:\n        #     return \"L\"\n        # elif columnNumber == 13:\n        #     return \"M\"\n        # elif columnNumber == 14:\n        #     return \"N\""
    },
    {
        "number": 169,
        "title": "Majority Element",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # for num in count:\n        #     if count[num] > len(nums) // 2:\n        #         return num\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # return max(count, key=count.get)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # return max(count, key=count.get)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n"
    },
    {
        "number": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": 0,
        "answer": "        # return ord(columnTitle[0]) - 64 + (ord(columnTitle[1]) - 64) * 26\n        # return ord(columnTitle[0]) - 64 + (ord(columnTitle[1]) - 64) * 26 + (ord(columnTitle[2]) - 64) * 26 * 26\n        # return ord(columnTitle[0]) - 64 + (ord(columnTitle[1]) - 64) * 26 + (ord(columnTitle[2]) - 64) * 26 * 26 + (ord(columnTitle[3]) - 64) * 26 * 26 * 26\n        # return ord(columnTitle[0]) - 64 + (ord(columnTitle[1]) - 64) * 26 + (ord(columnTitle[2]) - 64) * 26 * 26 + (ord(columnTitle[3]) - 64) * 26 * 26 * 26 + (ord(columnTitle[4]) - 64) * 26 * 26 * 26 * 26\n        # return ord(columnTitle[0]) - 64 + (ord(columnTitle[1]) - 64) * 26 + (ord(columnTitle[2]) - 64)"
    },
    {
        "number": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        count = 0\n        while n > 0:\n            count += n // 5\n            n = n // 5\n        return count"
    },
    {
        "number": 173,
        "title": "Binary Search Tree Iterator",
        "difficulty": 1,
        "answer": "        # Your BSTIterator object will be instantiated and called as such:\n        # obj = BSTIterator(root)\n        # param_1 = obj.next()\n        # param_2 = obj.hasNext()\n        # @lc code=end"
    },
    {
        "number": 174,
        "title": "Dungeon Game",
        "difficulty": 2,
        "answer": "        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = dungeon[0][0]\n        for i in range(1, m):\n            dp[i][0] = max(0, dp[i - 1][0] - dungeon[i][0])\n        for j in range(1, n):\n            dp[0][j] = max(0, dp[0][j - 1] - dungeon[0][j])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(min(dp[i - 1][j], dp[i][j - 1]) - dungeon[i][j], 1)\n        return dp[-1][-1]"
    },
    {
        "number": 179,
        "title": "Largest Number",
        "difficulty": 1,
        "answer": "        def compare(a, b):\n            if a + b > b + a:\n                return 1\n            elif a + b < b + a:\n                return -1\n            else:\n                return 0\n        \n        nums = map(str, nums)\n        nums = sorted(nums, key=cmp_to_key(compare))\n        return \"\".join(nums)"
    },
    {
        "number": 187,
        "title": "Repeated DNA Sequences",
        "difficulty": 1,
        "answer": "        if not s:\n            return []\n        \n        res = set()\n        n = len(s)\n        for i in range(n-9):\n            if s[i:i+10] in res:\n                res.remove(s[i:i+10])\n            else:\n                res.add(s[i:i+10])\n        return list(res)"
    },
    {
        "number": 188,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[j"
    },
    {
        "number": 189,
        "title": "Rotate Array",
        "difficulty": 1,
        "answer": "        k = k % len(nums)\n        nums[:] = nums[-k:] + nums[:-k]\n        return nums"
    },
    {
        "number": 190,
        "title": "Reverse Bits",
        "difficulty": 0,
        "answer": "        return int(bin(n)[2:].zfill(32)[::-1], 2)"
    },
    {
        "number": 191,
        "title": "Number of 1 Bits",
        "difficulty": 0,
        "answer": "        count = 0\n        while n:\n            count += 1\n            n = n & (n - 1)\n        return count"
    },
    {
        "number": 198,
        "title": "House Robber",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]\n"
    },
    {
        "number": 199,
        "title": "Binary Tree Right Side View",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        queue = deque([root])\n        res = []\n        \n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == size - 1:\n                    res.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return res\n"
    },
    {
        "number": 200,
        "title": "Number of Islands",
        "difficulty": 1,
        "answer": "        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        def dfs(i, j):\n            if (i, j) in visited: return\n            visited.add((i, j))\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': return\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and (i, j) not in visited:\n                    dfs(i, j)\n                    count += 1\n        return count"
    },
    {
        "number": 201,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": 1,
        "answer": "        while left < right:\n            left = left << 1\n            right = right << 1\n        return left"
    },
    {
        "number": 202,
        "title": "Happy Number",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        seen = set()\n        while n!= 1:\n            seen.add(n)\n            n = sum([int(i) ** 2 for i in str(n)])\n            if n in seen:\n                return False\n        return True"
    },
    {
        "number": 203,
        "title": "Remove Linked List Elements",
        "difficulty": 0,
        "answer": "        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while head:\n            if head.val == val:\n                prev.next = head.next\n            else:\n                prev = head\n            head = head.next\n        return dummy.next"
    },
    {
        "number": 204,
        "title": "Count Primes",
        "difficulty": 1,
        "answer": "        if n <= 1:\n            return 0\n        primes = [True] * n\n        primes[0] = primes[1] = False\n        for i in range(2, int(n ** 0.5) + 1):\n            if primes[i]:\n                primes[i * i:n:i] = [False] * len(primes[i * i:n:i])\n        return sum(primes)"
    },
    {
        "number": 205,
        "title": "Isomorphic Strings",
        "difficulty": 0,
        "answer": "        if len(s)!= len(t):\n            return False\n        \n        d = {}\n        for i in range(len(s)):\n            if s[i] not in d:\n                if t[i] in d.values():\n                    return False\n                else:\n                    d[s[i]] = t[i]\n            else:\n                if d[s[i]]!= t[i]:\n                    return False\n        return True"
    },
    {
        "number": 206,
        "title": "Reverse Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        \n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev"
    },
    {
        "number": 207,
        "title": "Course Schedule",
        "difficulty": 1,
        "answer": "        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n        \n        def dfs(course):\n            if visited[course] == -1:\n                return False\n            if visited[course] == 1:\n                return True\n            visited[course] = -1\n            for pre in graph[course]:\n                if not dfs(pre):\n                    return False\n            visited[course] = 1\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        return True"
    },
    {
        "number": 208,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": 1,
        "answer": "\nclass Trie:\n    def __init__(self):\n    def insert(self, word: str) -> None:\n    def search(self, word: str) -> bool:\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"\n        A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n        Implement the Trie class:\n            Trie() Initializes the trie object.\n            void insert(String word) Inserts the string word into the trie.\n            boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\n            boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n        Example 1:\n        Input\n        [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n        "
    },
    {
        "number": 209,
        "title": "Minimum Size Subarray Sum",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        left, right = 0, 0\n        curr_sum = 0\n        min_len = float('inf')\n        \n        while right < len(nums):\n            curr_sum += nums[right]\n            while curr_sum >= target:\n                min_len = min(min_len, right - left + 1)\n                curr_sum -= nums[left]\n                left += 1\n            right += 1\n        \n        return min_len if min_len!= float('inf') else 0\n"
    },
    {
        "number": 210,
        "title": "Course Schedule II",
        "difficulty": 1,
        "answer": "        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n        \n        def dfs(course):\n            if visited[course] == -1:\n                return False\n            if visited[course] == 1:\n                return True\n            visited[course] = -1\n            for pre in graph[course]:\n                if not dfs(pre):\n                    return False\n            visited[course] = 1\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return []\n        \n        order = []\n        for course in range(numCourses):\n            if visited[course] == 1:\n                order.append(course)\n        return order"
    },
    {
        "number": 211,
        "title": "Design Add and Search Words Data Structure",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # TLE\n        # if not word:\n        #     return False\n        # self.words = set()\n        # self.words.add(word)\n        # for i in range(1, len(word)):\n        #     for j in range(len(word)):\n        #         if word[:j] + '.' + word[j:] in self.words:\n        #             return True\n        # return False"
    },
    {
        "number": 212,
        "title": "Word Search II",
        "difficulty": 2,
        "answer": "        def dfs(i, j, word, visited, board):\n            if word not in word_set:\n                return\n            if word == \"\":\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word not in word_set:\n                return\n            if word"
    },
    {
        "number": 213,
        "title": "House Robber II",
        "difficulty": 1,
        "answer": "        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        return dp[-1]"
    },
    {
        "number": 214,
        "title": "Shortest Palindrome",
        "difficulty": 2,
        "answer": "        # if s == s[::-1]:\n        #     return s\n        #\n        # for i in range(len(s)):\n        #     if s[i]!= s[-i - 1]:\n        #         s = s[:i] + s[i + 1:]\n        #         break\n        # return s + s[::-1]"
    },
    {
        "number": 215,
        "title": "Kth Largest Element in an Array",
        "difficulty": 1,
        "answer": "        # return self.quickSelect(nums, 0, len(nums) - 1, k - 1)\n        return self.quickSelect(nums, 0, len(nums) - 1, k)"
    },
    {
        "number": 216,
        "title": "Combination Sum III",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return [[n]]\n        if k == 2:\n            return [[i, n - i] for i in range(1, n + 1)]\n        if k == 3:\n            return [[i, j, n - i - j] for i in range(1, n + 1) for j in range(1, n + 1) if i + j <= n]\n        if k == 4:\n            return [[i, j, k, n - i - j - k] for i in range(1, n + 1) for j in range(1, n + 1) for k in range(1, n + 1) if i + j + k <= n]\n        if k == 5:\n            return [[i, j, k, n - i - j - k] for i in range(1, n + 1) for j in range(1, n + 1) for k in range(1, n + 1) if i + j + k + n <= n]\n        if k == 6:\n            return [[i, j, k, n - i - j - k"
    },
    {
        "number": 217,
        "title": "Contains Duplicate",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O(1) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return len(nums)!= len(nums)\n        # O(n) time | O("
    },
    {
        "number": 218,
        "title": "The Skyline Problem",
        "difficulty": 2,
        "answer": "        # sort by left\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by right\n        # merge\n        # sort by height\n        # merge\n        # sort by left\n        # merge\n        # sort by"
    },
    {
        "number": 219,
        "title": "Contains Duplicate II",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in hashmap and i - hashmap[nums[i]] <= k:\n        #         return True\n        #     hashmap[nums[i]] = i\n        # return False\n        \n        # O(n) time | O(n) space\n        # if len(nums) < 2:\n        #     return False\n        # for i in range(len(nums)):\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[i] == nums[j]:\n        #             if j - i <= k:\n        #                 return True\n        # return False\n        \n        # O(n) time | O(1) space\n        # if len(nums) < 2:\n        #     return False\n        # for i in range(len(nums)):\n        #     if nums[i] in"
    },
    {
        "number": 220,
        "title": "Contains Duplicate III",
        "difficulty": 2,
        "answer": "        # O(n)\n        # for i in range(len(nums)):\n        #     for j in range(i + 1, len(nums)):\n        #         if abs(i - j) <= indexDiff and abs(nums[i] - nums[j]) <= valueDiff:\n        #             return True\n        # return False"
    },
    {
        "number": 221,
        "title": "Maximal Square",
        "difficulty": 1,
        "answer": "        if not matrix: return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                    max_area = max(max_area, dp[i][j])\n        return max_area * max_area"
    },
    {
        "number": 222,
        "title": "Count Complete Tree Nodes",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            return left + right + 1\n        \n        return dfs(root)"
    },
    {
        "number": 223,
        "title": "Rectangle Area",
        "difficulty": 1,
        "answer": "        area_1 = (ax2 - ax1) * (ay2 - ay1)\n        area_2 = (bx2 - bx1) * (by2 - by1)\n        area_intersection = max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))\n        return area_1 + area_2 - area_intersection"
    },
    {
        "number": 224,
        "title": "Basic Calculator",
        "difficulty": 2,
        "answer": "        # stack = []\n        # num = 0\n        # sign = \"+\"\n        # for i in range(len(s)):\n        #     if s[i].isdigit():\n        #         num = num * 10 + int(s[i])\n        #     if s[i] in \"+-*/\":\n        #         if sign == \"+\":\n        #             stack.append(num)\n        #         elif sign == \"-\":\n        #             stack.append(-num)\n        #         elif sign == \"*\":\n        #             stack.append(stack.pop() * num)\n        #         elif sign == \"/\":\n        #             stack.append(int(stack.pop() / num))\n        #         num = 0\n        #         sign = s[i]\n        # return sum(stack)\n        \n        # stack = []\n        # num = 0\n        # sign = \"+\"\n        # for i in range(len(s)):\n        #     if s[i].isdigit():\n        #         num = num * 10 + int("
    },
    {
        "number": 225,
        "title": "Implement Stack using Queues",
        "difficulty": 0,
        "answer": "        # Your MyStack object will be instantiated and called as such:\n        # obj = MyStack()\n        # obj.push(x)\n        # param_2 = obj.pop()\n        # param_3 = obj.top()\n        # param_4 = obj.empty()\n        # @lc code=start\n        class MyStack:\n            def __init__(self):\n                self.q1 = []\n                self.q2 = []"
    },
    {
        "number": 226,
        "title": "Invert Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return root\n        \n        def invert(node):\n            if not node:\n                return\n            \n            node.left, node.right = node.right, node.left\n            invert(node.left)\n            invert(node.right)\n        \n        invert(root)\n        return root"
    },
    {
        "number": 227,
        "title": "Basic Calculator II",
        "difficulty": 1,
        "answer": "        # stack = []\n        # num = 0\n        # sign = \"+\"\n        # for i in range(len(s)):\n        #     if s[i].isdigit():\n        #         num = num * 10 + int(s[i])\n        #     if s[i] in \"+-*/\":\n        #         if sign == \"+\":\n        #             stack.append(num)\n        #         elif sign == \"-\":\n        #             stack.append(-num)\n        #         elif sign == \"*\":\n        #             stack.append(stack.pop() * num)\n        #         elif sign == \"/\":\n        #             stack.append(int(stack.pop() / num))\n        #         num = 0\n        #         sign = s[i]\n        # return sum(stack)\n        \n        # stack = []\n        # num = 0\n        # sign = \"+\"\n        # for i in range(len(s)):\n        #     if s[i].isdigit():\n        #         num = num * 10 + int("
    },
    {
        "number": 228,
        "title": "Summary Ranges",
        "difficulty": 0,
        "answer": "        ranges = []\n        start = 0\n        for i in range(len(nums)):\n            if i == len(nums) - 1 or nums[i + 1]!= nums[i] + 1:\n                ranges.append(str(nums[start]) + \"->\" + str(nums[i]))\n                start = i + 1\n        return ranges"
    },
    {
        "number": 229,
        "title": "Majority Element II",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # return [k for k, v in count.items() if v > len(nums) // 3]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # return [k for k, v in count.items() if v > len(nums) // 3]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = {}\n        # for num in nums:\n        #     count[num] = count.get(num, 0) + 1\n        # return [k for k, v in count.items() if v > len(nums) // 3]\n        \n        #"
    },
    {
        "number": 230,
        "title": "Kth Smallest Element in a BST",
        "difficulty": 1,
        "answer": "        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.k -= 1\n                if self.k == 0:\n                    return root.val\n                inorder(root.right)\n        self.k = k\n        return inorder(root)"
    },
    {
        "number": 231,
        "title": "Power of Two",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n // 2\n        return n == 1"
    },
    {
        "number": 232,
        "title": "Implement Queue using Stacks",
        "difficulty": 0,
        "answer": "        self.stack1 = []\n        self.stack2 = []\n        \n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n    def pop(self) -> int:\n        if len(self.stack2) == 0:\n            while len(self.stack1) > 0:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n        \n    def peek(self) -> int:\n        if len(self.stack2) == 0:\n            while len(self.stack1) > 0:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n        \n    def empty(self) -> bool:\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n        "
    },
    {
        "number": 233,
        "title": "Number of Digit One",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 5\n        if n == 5:\n            return 6\n        if n == 6:\n            return 7\n        if n == 7:\n            return 8\n        if n == 8:\n            return 9\n        if n == 9:\n            return 10\n        if n == 10:\n            return 11\n        if n == 11:\n            return 12\n        if n == 12:\n            return 13\n        if n == 13:\n            return 14\n        if n == 14:\n            return 15\n        if n == 15:\n            return 16\n        if n == 16:\n            return 17\n        if n == 17:\n            return 18\n        if n == 18:\n            return 19\n        if n == 19:\n            return 20\n        if n == 20:\n            return 21\n        if n == 21:\n            return 22\n        if n == 22:\n            "
    },
    {
        "number": 234,
        "title": "Palindrome Linked List",
        "difficulty": 0,
        "answer": "        # if head is None:\n        #     return True\n        #\n        # stack = []\n        # while head:\n        #     stack.append(head.val)\n        #     head = head.next\n        #\n        # while len(stack) > 1:\n        #     if stack.pop()!= stack.pop(0):\n        #         return False\n        # return True"
    },
    {
        "number": 235,
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if p == root or q == root:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right\n"
    },
    {
        "number": 236,
        "title": "Lowest Common Ancestor of a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if p == root or q == root:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right"
    },
    {
        "number": 237,
        "title": "Delete Node in a Linked List",
        "difficulty": 1,
        "answer": "        if not node:\n            return\n        node.val = node.next.val\n        node.next = node.next.next\n        return"
    },
    {
        "number": 238,
        "title": "Product of Array Except Self",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        left = [0] * n\n        right = [0] * n\n        left[0] = 1\n        right[n - 1] = 1\n        for i in range(1, n):\n            left[i] = left[i - 1] * nums[i - 1]\n        for i in range(n - 2, -1, -1):\n            right[i] = right[i + 1] * nums[i + 1]\n        for i in range(n):\n            left[i] = left[i] * right[i]\n        return left"
    },
    {
        "number": 239,
        "title": "Sliding Window Maximum",
        "difficulty": 2,
        "answer": "        if not nums:\n            return []\n        if k == 1:\n            return nums\n        \n        # sliding window\n        # use a stack to keep track of the max value in the window\n        # when the window moves right, pop the top element from the stack\n        # when the window moves left, push the top element to the stack\n        # when the window moves right, push the top element to the stack\n        # when the window moves left, pop the top element from the stack\n        # when the window moves right, pop the top element from the stack\n        # when the window moves left, pop the top element from the stack\n        # when the window moves right, pop the top element from the stack\n        # when the window moves left, pop the top element from the stack\n        # when the window moves right, pop the top element from the stack\n        # when the window moves left, pop the top element from the stack\n        # when the window moves right, pop the top element from the stack\n        # when the window moves left, pop the top element from the stack\n        # when the window moves right, pop the top element"
    },
    {
        "number": 240,
        "title": "Search a 2D Matrix II",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return False\n        m, n = len(matrix), len(matrix[0])\n        i, j = 0, n - 1\n        while i < m and j >= 0:\n            if matrix[i][j] == target:\n                return True\n            elif matrix[i][j] > target:\n                j -= 1\n            else:\n                i += 1\n        return False\n"
    },
    {
        "number": 241,
        "title": "Different Ways to Add Parentheses",
        "difficulty": 1,
        "answer": "        def dfs(expression, i, j, res):\n            if i >= j:\n                return res\n            if expression[i] == '+':\n                res1 = dfs(expression, i + 1, j, res)\n                res2 = dfs(expression, i + 2, j, res)\n                return res1 + res2\n            elif expression[i] == '-':\n                res1 = dfs(expression, i + 1, j, res)\n                res2 = dfs(expression, i + 2, j, res)\n                return res1 - res2\n            elif expression[i] == '*':\n                res1 = dfs(expression, i + 1, j, res)\n                res2 = dfs(expression, i + 2, j, res)\n                return res1 * res2\n            else:\n                return int(expression[i])"
    },
    {
        "number": 242,
        "title": "Valid Anagram",
        "difficulty": 0,
        "answer": "        if len(s)!= len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n            \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n        \n        for i in s_dict:\n            if i not in t_dict:\n                return False\n            elif s_dict[i]!= t_dict[i]:\n                return False\n        \n        return True"
    },
    {
        "number": 257,
        "title": "Binary Tree Paths",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        res = []\n        self.dfs(root, \"\", res)\n        return res"
    },
    {
        "number": 258,
        "title": "Add Digits",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        while num > 9:\n            num = sum([int(i) for i in str(num)])\n        return num"
    },
    {
        "number": 260,
        "title": "Single Number III",
        "difficulty": 1,
        "answer": "        # nums = [1,2,1,3,2,5]\n        # nums = [-1,0]\n        # nums = [0,1]\n        # nums = [1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5,5]\n        # nums = [-1,0,1,1,2,2,3,3,4,4,5"
    },
    {
        "number": 263,
        "title": "Ugly Number",
        "difficulty": 0,
        "answer": "        if n <= 0:\n            return False\n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        return n == 1"
    },
    {
        "number": 264,
        "title": "Ugly Number II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        ugly = [1]\n        i2, i3, i5 = 0, 0, 0\n        while n > 1:\n            n -= 1\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\n            if ugly[-1] == ugly[i2] * 2:\n                i2 += 1\n            if ugly[-1] == ugly[i3] * 3:\n                i3 += 1\n            if ugly[-1] == ugly[i5] * 5:\n                i5 += 1\n        return ugly[-1]"
    },
    {
        "number": 268,
        "title": "Missing Number",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)"
    },
    {
        "number": 273,
        "title": "Integer to English Words",
        "difficulty": 2,
        "answer": "        def one(num):\n            if num == 0:\n                return ''\n            elif num < 10:\n                return self.numberToWords(num)\n            else:\n                return self.numberToWords(num // 10) +'' + self.numberToWords(num % 10)"
    },
    {
        "number": 274,
        "title": "H-Index",
        "difficulty": 1,
        "answer": "        n = len(citations)\n        citations.sort()\n        for i in range(n):\n            if citations[i] >= n - i:\n                return n - i\n        return 0"
    },
    {
        "number": 275,
        "title": "H-Index II",
        "difficulty": 1,
        "answer": "        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if citations[mid] >= n - mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return n - left"
    },
    {
        "number": 278,
        "title": "First Bad Version",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        left, right = 1, n\n        while left < right:\n            mid = (left + right) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 279,
        "title": "Perfect Squares",
        "difficulty": 1,
        "answer": "        if n <= 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 1\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 3\n        if n == 7:\n            return 2\n        if n == 8:\n            return 3\n        if n == 9:\n            return 3\n        if n == 10:\n            return 4\n        if n == 11:\n            return 3\n        if n == 12:\n            return 4\n        if n == 13:\n            return 4\n        if n == 14:\n            return 5\n        if n == 15:\n            return 5\n        if n == 16:\n            return 6\n        if n == 17:\n            return 5\n        if n == 18:\n            return 6\n        if n == 19:\n            return 6\n        if n == 20:\n            return 7\n        if n == 21:\n            return 7\n        if n == 22:\n            "
    },
    {
        "number": 282,
        "title": "Expression Add Operators",
        "difficulty": 2,
        "answer": "        def dfs(num, idx, path, res, target):\n            if idx == len(num):\n                if target == 0:\n                    res.append(\"\".join(path))\n                return\n            \n            for i in range(idx, len(num)):\n                if i > idx and num[idx] == '0':\n                    break\n                path.append(num[idx])\n                dfs(num, i+1, path, res, target)\n                path.pop()\n        \n        res = []\n        dfs(num, 0, [], res, target)\n        return res"
    },
    {
        "number": 283,
        "title": "Move Zeroes",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        i = 0\n        for j in range(n):\n            if nums[j]!= 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n        return nums"
    },
    {
        "number": 284,
        "title": "Peeking Iterator",
        "difficulty": 1,
        "answer": "        # Your PeekingIterator object will be instantiated and called as such:\n        # iter = PeekingIterator(Iterator(nums))\n        # while iter.hasNext():\n        #     val = iter.peek()   # Get the next element but not advance the iterator.\n        #     iter.next()         # Should return the same value as [val]."
    },
    {
        "number": 287,
        "title": "Find the Duplicate Number",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # HashMap\n        # nums = set()\n        # for num in nums:\n        #     if num in nums:\n        #         return num\n        #     else:\n        #         nums.add(num)\n        # return -1"
    },
    {
        "number": 289,
        "title": "Game of Life",
        "difficulty": 1,
        "answer": "        if not board:\n            return board\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                live_neighbors = self.get_live_neighbors(board, i, j)\n                if board[i][j] == 1:\n                    if live_neighbors < 2 or live_neighbors > 3:\n                        board[i][j] = 0\n                else:\n                    if live_neighbors == 3:\n                        board[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                board[i][j] = int(board[i][j])\n        return board"
    },
    {
        "number": 290,
        "title": "Word Pattern",
        "difficulty": 0,
        "answer": "        if len(pattern)!= len(s):\n            return False\n        \n        pattern_dict = {}\n        s_dict = {}\n        \n        for i in range(len(pattern)):\n            if pattern[i] in pattern_dict:\n                if pattern_dict[pattern[i]]!= s[i]:\n                    return False\n            else:\n                pattern_dict[pattern[i]] = s[i]\n            \n            if s[i] in s_dict:\n                if s_dict[s[i]]!= pattern[i]:\n                    return False\n            else:\n                s_dict[s[i]] = pattern[i]\n        \n        return True"
    },
    {
        "number": 292,
        "title": "Nim Game",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n == 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return False\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return False\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return False\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return False\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return False\n        if n == 23:\n            "
    },
    {
        "number": 295,
        "title": "Find Median from Data Stream",
        "difficulty": 2,
        "answer": "        # Your MedianFinder object will be instantiated and called as such:\n        # obj = MedianFinder()\n        # obj.addNum(num)\n        # param_2 = obj.findMedian()"
    },
    {
        "number": 297,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": 2,
        "answer": "        if not root:\n            return []\n        \n        def serialize(node, lst):\n            if not node:\n                lst.append(None)\n                return\n            lst.append(node.val)\n            serialize(node.left, lst)\n            serialize(node.right, lst)\n        \n        lst = []\n        serialize(root, lst)\n        return lst\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 299,
        "title": "Bulls and Cows",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # bulls = 0\n        # cows = 0\n        # for i in range(len(secret)):\n        #     if secret[i] == guess[i]:\n        #         bulls += 1\n        #     else:\n        #         if guess.index(secret[i]) < guess.index(guess[i]):\n        #             cows += 1\n        # return str(bulls) + \"A\" + str(cows) + \"B\""
    },
    {
        "number": 300,
        "title": "Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 301,
        "title": "Remove Invalid Parentheses",
        "difficulty": 2,
        "answer": "        def isValid(s):\n            stack = []\n            for c in s:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if stack:\n                        stack.pop()\n                    else:\n                        return False\n            return not stack\n        \n        def dfs(s, path, res, count):\n            if count == 0:\n                res.append(path)\n                return\n            for i in range(1, len(s) + 1):\n                if isValid(s[:i]):\n                    dfs(s[i:], path + s[:i], res, count - 1)\n        \n        res = []\n        dfs(s, \"\", res, 3)\n        return res"
    },
    {
        "number": 303,
        "title": "Range Sum Query - Immutable",
        "difficulty": 0,
        "answer": "        self.nums = nums\n        self.sum_range = []\n        for i in range(len(nums)):\n            self.sum_range.append(self.sum_range[i] + nums[i])\n        return self.sum_range[left] + self.sum_range[right]"
    },
    {
        "number": 304,
        "title": "Range Sum Query 2D - Immutable",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n        return dp[row2 + 1][col2 + 1]"
    },
    {
        "number": 306,
        "title": "Additive Number",
        "difficulty": 1,
        "answer": "        def is_valid(num):\n            if not num:\n                return False\n            if len(num) == 1:\n                return False\n            if num[0] == '0':\n                return False\n            if num[-1] == '0':\n                return False\n            return True"
    },
    {
        "number": 307,
        "title": "Range Sum Query - Mutable",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 309,
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": 1,
        "answer": "        n = len(prices)\n        if n == 0:\n            return 0\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n        return dp[-1][0]"
    },
    {
        "number": 310,
        "title": "Minimum Height Trees",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # if n == 1:\n        #     return [0]\n        # graph = defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, graph, visited, res):\n        #     visited.add(node)\n        #     for nei in graph[node]:\n        #         if nei not in visited:\n        #             dfs(nei, graph, visited, res)\n        #     res.append(node)\n        #\n        # res = []\n        # for i in range(n):\n        #     if i not in visited:\n        #         dfs(i, graph, set(), res)\n        # return res"
    },
    {
        "number": 312,
        "title": "Burst Balloons",
        "difficulty": 2,
        "answer": "        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + nums[i] * nums[j] * nums[j + 1]\n        return dp[0][-1]"
    },
    {
        "number": 313,
        "title": "Super Ugly Number",
        "difficulty": 1,
        "answer": "        # dp[i] = the nth super ugly number with i primes\n        # dp[i] = min(dp[i-1] * p1, dp[i-1] * p2, dp[i-1] * p3)\n        # dp[i] = min(dp[i-1] * p1, dp[i-1] * p2, dp[i-1] * p3)\n        # dp[i] = min(dp[i-1] * p1, dp[i-1] * p2, dp[i-1] * p3)\n        # dp[i] = min(dp[i-1] * p1, dp[i-1] * p2, dp[i-1] * p3)\n        # dp[i] = min(dp[i-1] * p1, dp[i-1] * p2, dp[i-1] * p3)\n        # dp[i] = min(dp[i-1]"
    },
    {
        "number": 315,
        "title": "Count of Smaller Numbers After Self",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # res = []\n        # for i in range(len(nums)):\n        #     count = 0\n        #     for j in range(i, len(nums)):\n        #         if nums[j] < nums[i]:\n        #             count += 1\n        #     res.append(count)\n        # return res"
    },
    {
        "number": 316,
        "title": "Remove Duplicate Letters",
        "difficulty": 1,
        "answer": "        # if not s:\n        #     return s\n        #\n        # seen = set()\n        # stack = []\n        #\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         while stack and s[i] < stack[-1] and i < len(s):\n        #             seen.remove(stack.pop())\n        #         seen.add(s[i])\n        #         stack.append(s[i])\n        #\n        # return ''.join(stack)"
    },
    {
        "number": 318,
        "title": "Maximum Product of Word Lengths",
        "difficulty": 1,
        "answer": "        # words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\n        # words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\n        # words = [\"a\",\"aa\",\"aaa"
    },
    {
        "number": 319,
        "title": "Bulb Switcher",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # if n == 2:\n        #     return 1\n        \n        # if n == 3:\n        #     return 2\n        \n        # if n == 4:\n        #     return 3\n        \n        # if n == 5:\n        #     return 4\n        \n        # if n == 6:\n        #     return 5\n        \n        # if n == 7:\n        #     return 6\n        \n        # if n == 8:\n        #     return 7\n        \n        # if n == 9:\n        #     return 8\n        \n        # if n == 10:\n        #     return 9\n        \n        # if n == 11:\n        #     return 10\n        \n        # if n == 12:\n        #     return 11\n        \n        # if n == 13:\n        #     return 12\n        \n        # if n == 14:\n        #     return 13\n        \n        # if n == 15:\n        #     return 14\n        \n        #"
    },
    {
        "number": 321,
        "title": "Create Maximum Number",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(m + n)\n        # Space: O(m + n)\n        # m = len(nums1)\n        # n = len(nums2)\n        # if m + n < k:\n        #     return []\n        #\n        # nums1 = sorted(nums1)\n        # nums2 = sorted(nums2)\n        #\n        # res = []\n        #\n        # for i in range(k):\n        #     if i < m:\n        #         res.append(nums1[i])\n        #     if i < n:\n        #         res.append(nums2[i])\n        #\n        # return res"
    },
    {
        "number": 322,
        "title": "Coin Change",
        "difficulty": 1,
        "answer": "        # dp = [0] * (amount + 1)\n        # dp[0] = 0\n        # for i in range(1, amount + 1):\n        #     for coin in coins:\n        #         if i >= coin:\n        #             dp[i] = min(dp[i], dp[i - coin] + 1)\n        # return dp[-1] if dp[-1]!= 0 else -1"
    },
    {
        "number": 324,
        "title": "Wiggle Sort II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        nums[::2], nums[1::2] = nums[:len(nums)//2], nums[len(nums)//2:]\n        return nums"
    },
    {
        "number": 326,
        "title": "Power of Three",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n // 3\n        return n == 1"
    },
    {
        "number": 327,
        "title": "Count of Range Sum",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 328,
        "title": "Odd Even Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        odd = head\n        even = head.next\n        even_head = even\n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        odd.next = even_head\n        return head"
    },
    {
        "number": 329,
        "title": "Longest Increasing Path in a Matrix",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        \n        def dfs(i, j):\n            if not dp[i][j]:\n                dp[i][j] = 1 + max(\n                    dfs(i - 1, j) if i > 0 and matrix[i - 1][j] < matrix[i][j] else 0,\n                    dfs(i + 1, j) if i < m - 1 and matrix[i + 1][j] < matrix[i][j] else 0,\n                    dfs(i, j - 1) if j > 0 and matrix[i][j - 1] < matrix[i][j] else 0,\n                    dfs(i, j + 1) if j < n - 1 and matrix[i][j + 1] < matrix[i][j] else 0\n                )\n            return dp[i][j]\n        \n        dp = [[0] * n for _ in range(m)]\n        return max(dfs(i, j) for i in"
    },
    {
        "number": 330,
        "title": "Patching Array",
        "difficulty": 2,
        "answer": "        i = 0\n        j = 0\n        while i < len(nums) and j < n:\n            if nums[i] <= n:\n                nums[i] += 1\n                i += 1\n            else:\n                nums[j] += 1\n                j += 1\n        return i"
    },
    {
        "number": 331,
        "title": "Verify Preorder Serialization of a Binary Tree",
        "difficulty": 1,
        "answer": "        # preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n        # preorder = \"1,#\"\n        # preorder = \"9,#,#,1\"\n        # preorder = \"9,#,#,1,#,#,2,#,#,#,3,#,#,4,#,#,5,#,#,6,#,#,7,#,#,8,#,#,9,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#,#"
    },
    {
        "number": 332,
        "title": "Reconstruct Itinerary",
        "difficulty": 2,
        "answer": "        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # tickets.sort(key=lambda x: x[1])\n        # graph = collections.defaultdict(list)\n        # for a, b in tickets:\n        #     graph[a].append(b)\n        #\n        # def dfs(airport):\n        #     while graph[airport]:\n        #         dfs(graph[airport].pop(0))\n        #     res.append(airport)\n        #\n        # res = []\n        # dfs(\"JFK\")\n        # return res"
    },
    {
        "number": 334,
        "title": "Increasing Triplet Subsequence",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if len(nums) < 3:\n        #     return False\n        # for i in range(len(nums) - 2):\n        #     for j in range(i + 1, len(nums) - 1):\n        #         for k in range(j + 1, len(nums)):\n        #             if nums[i] < nums[j] < nums[k]:\n        #                 return True\n        # return False"
    },
    {
        "number": 335,
        "title": "Self Crossing",
        "difficulty": 2,
        "answer": "        if len(distance) < 4:\n            return False\n        \n        for i in range(3, len(distance)):\n            if distance[i] + distance[i-1] > distance[i-2]:\n                return True\n        return False"
    },
    {
        "number": 336,
        "title": "Palindrome Pairs",
        "difficulty": 2,
        "answer": "        def is_palindrome(s):\n            return s == s[::-1]"
    },
    {
        "number": 337,
        "title": "House Robber III",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node):\n            if not node:\n                return (0, 0)\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            rob = node.val + left[1] + right[1]\n            not_rob = max(left) + max(right)\n            \n            return (rob, not_rob)\n        \n        return max(dfs(root))"
    },
    {
        "number": 338,
        "title": "Counting Bits",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return [0]\n        if n == 1:\n            return [0, 1]\n        if n == 2:\n            return [0, 1, 1]\n        if n == 3:\n            return [0, 1, 1, 1]\n        if n == 4:\n            return [0, 1, 1, 2, 1]\n        if n == 5:\n            return [0, 1, 1, 2, 1, 2]\n        if n == 6:\n            return [0, 1, 1, 2, 1, 2, 1]\n        if n == 7:\n            return [0, 1, 1, 2, 1, 2, 1, 2]\n        if n == 8:\n            return [0, 1, 1, 2, 1, 2, 1, 2, 1]\n        if n == 9:\n            return [0, 1, 1, 2, 1, 2, 1, 2, 1, 2]\n        if n == 10:\n            return [0, 1, 1, 2, 1, 2, 1, 2, 1, 2,"
    },
    {
        "number": 341,
        "title": "Flatten Nested List Iterator",
        "difficulty": 1,
        "answer": "        res = []\n        while nestedList:\n            if isinstance(nestedList[0], list):\n                nestedList = nestedList[0]\n            else:\n                res.append(nestedList[0])\n                nestedList = []\n        return res"
    },
    {
        "number": 342,
        "title": "Power of Four",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        if n == 0:\n            return False\n        while n!= 1:\n            if n % 4!= 0:\n                return False\n            n = n // 4\n        return True"
    },
    {
        "number": 343,
        "title": "Integer Break",
        "difficulty": 1,
        "answer": "        if n <= 3:\n            return n - 1\n        dp = [0] * (n + 1)\n        dp[2] = 1\n        dp[3] = 2\n        for i in range(4, n + 1):\n            for j in range(1, i // 2 + 1):\n                dp[i] = max(dp[i], dp[j] * (i - j) * dp[i - j])\n        return dp[-1]"
    },
    {
        "number": 344,
        "title": "Reverse String",
        "difficulty": 0,
        "answer": "        s.reverse()\n        return s"
    },
    {
        "number": 345,
        "title": "Reverse Vowels of a String",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"
    },
    {
        "number": 347,
        "title": "Top K Frequent Elements",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 349,
        "title": "Intersection of Two Arrays",
        "difficulty": 0,
        "answer": "        nums1 = set(nums1)\n        nums2 = set(nums2)\n        return list(nums1 & nums2)"
    },
    {
        "number": 350,
        "title": "Intersection of Two Arrays II",
        "difficulty": 0,
        "answer": "        \n        # nums1 = sorted(nums1)\n        # nums2 = sorted(nums2)\n        # i = j = 0\n        # res = []\n        # while i < len(nums1) and j < len(nums2):\n        #     if nums1[i] == nums2[j]:\n        #         res.append(nums1[i])\n        #         i += 1\n        #         j += 1\n        #     elif nums1[i] < nums2[j]:\n        #         i += 1\n        #     else:\n        #         j += 1\n        # return res\n        \n        # nums1 = sorted(nums1)\n        # nums2 = sorted(nums2)\n        # i = j = 0\n        # res = []\n        # while i < len(nums1) and j < len(nums2):\n        #     if nums1[i] == nums2[j]:\n        #         res.append(nums1[i])\n        #"
    },
    {
        "number": 352,
        "title": "Data Stream as Disjoint Intervals",
        "difficulty": 2,
        "answer": "    def __init__(self):\n    def addNum(self, value: int) -> None:\n    def getIntervals(self) -> List[List[int]]:\n    def addNum(self, value: int) -> None:\n    def getIntervals(self) -> List[List[int]]:\n        \"\"\"\n        Given a data stream input of non-negative integers a1, a2,..., an, summarize the numbers seen so far as a list of disjoint intervals.\n        Implement the SummaryRanges class:\n            SummaryRanges() Initializes the object with an empty stream.\n            void addNum(int value) Adds the integer value to the stream.\n            int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n        Example 1:\n        Input\n        [\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \""
    },
    {
        "number": 354,
        "title": "Russian Doll Envelopes",
        "difficulty": 2,
        "answer": "        # sort by width\n        envelopes.sort(key=lambda x: x[0])\n        # sort by height\n        envelopes.sort(key=lambda x: x[1], reverse=True)\n        # print(envelopes)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 355,
        "title": "Design Twitter",
        "difficulty": 1,
        "answer": "        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
    },
    {
        "number": 357,
        "title": "Count Numbers with Unique Digits",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return 10\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 10\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "number": 363,
        "title": "Max Sum of Rectangle No Larger Than K",
        "difficulty": 2,
        "answer": "        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                dp[i][j] = matrix[i][j]\n        for i in range(m):\n            for j in range(n):\n                for k in range(i, m):\n                    dp[k][j] += dp[i][j]\n        res = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                cur = dp[i][j]\n                for k in range(i, m):\n                    cur -= dp[k][j]\n                res = max(res, cur)\n        return res if res > k else 0"
    },
    {
        "number": 365,
        "title": "Water and Jug Problem",
        "difficulty": 1,
        "answer": "        # if targetCapacity == 0:\n        #     return True\n        # if jug1Capacity == 0 or jug2Capacity == 0:\n        #     return False\n        # if jug1Capacity > targetCapacity or jug2Capacity > targetCapacity:\n        #     return False\n        # if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity:\n        #     return True\n        # if jug1Capacity == targetCapacity:\n        #     return self.canMeasureWater(jug2Capacity, targetCapacity - jug1Capacity, 0)\n        # if jug2Capacity == targetCapacity:\n        #     return self.canMeasureWater(jug1Capacity, targetCapacity - jug2Capacity, 0)\n        # if jug1Capacity > targetCapacity:\n        #     return self.canMeasureWater(jug1Capacity - targetCapacity, jug2Capacity, targetCapacity)\n        # if jug2Capacity > targetCapacity:\n        #     return self.canMeasureWater(jug1Capacity, jug2Capacity"
    },
    {
        "number": 367,
        "title": "Valid Perfect Square",
        "difficulty": 0,
        "answer": "        if num == 1:\n            return True\n        left, right = 1, num\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"
    },
    {
        "number": 368,
        "title": "Largest Divisible Subset",
        "difficulty": 1,
        "answer": "        nums.sort()\n        dp = [[] for _ in range(len(nums))]\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    dp[i].append(nums[j])\n            if not dp[i]:\n                dp[i] = nums[i]\n            else:\n                dp[i] = max(dp[i], dp[i] + nums[i])\n        return max(dp, key=len)"
    },
    {
        "number": 371,
        "title": "Sum of Two Integers",
        "difficulty": 1,
        "answer": "        # a = 1\n        # b = 2\n        # a = 2\n        # b = 3\n        # a = 3\n        # b = 4\n        # a = 4\n        # b = 5\n        # a = 5\n        # b = 6\n        # a = 6\n        # b = 7\n        # a = 7\n        # b = 8\n        # a = 8\n        # b = 9\n        # a = 9\n        # b = 10\n        # a = 10\n        # b = 11\n        # a = 11\n        # b = 12\n        # a = 12\n        # b = 13\n        # a = 13\n        # b = 14\n        # a = 14\n        # b = 15\n        # a = 15\n        # b = 16\n        # a = 16\n        # b = 17\n        # a = 17\n        # b = 18\n        # a = 18\n        # b = 19\n        # a = 19\n        # b = 20\n        # a = 20\n        # b = 21\n        # a = 21\n        # b ="
    },
    {
        "number": 372,
        "title": "Super Pow",
        "difficulty": 1,
        "answer": "        # a = 2\n        # b = [3]\n        # a = 2\n        # b = [1,0]\n        # a = 1\n        # b = [4,3,3,8,5,2]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a = 1\n        # b = [1,0,0,1,0,0,1,0,0,1]\n        # a ="
    },
    {
        "number": 373,
        "title": "Find K Pairs with Smallest Sums",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return []\n        if len(nums1) == 0 or len(nums2) == 0:\n            return []\n        if k == 1:\n            return [[nums1[0], nums2[0]]]\n        if k == 2:\n            return [[nums1[0], nums2[0]], [nums1[0], nums2[1]]]\n        if k == 3:\n            return [[nums1[0], nums2[0]], [nums1[0], nums2[1]], [nums1[0], nums2[2]]]\n        if k == 4:\n            return [[nums1[0], nums2[0]], [nums1[0], nums2[1]], [nums1[0], nums2[2]],\n                    [nums1[0], nums2[3]],\n                    [nums1[1], nums2[0]], [nums1[1], nums2[1]],\n                    ["
    },
    {
        "number": 374,
        "title": "Guess Number Higher or Lower",
        "difficulty": 0,
        "answer": "        low, high = 1, n\n        while low <= high:\n            mid = (low + high) // 2\n            if guess(mid) == 0:\n                return mid\n            elif guess(mid) == 1:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1"
    },
    {
        "number": 375,
        "title": "Guess Number Higher or Lower II",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                if i!= j:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n        return dp[n][n]"
    },
    {
        "number": 376,
        "title": "Wiggle Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        if n < 2:\n            return n\n        \n        dp = [1] * n\n        \n        for i in range(1, n):\n            if nums[i] > nums[i-1]:\n                dp[i] = dp[i-1] + 1\n            elif nums[i] < nums[i-1]:\n                dp[i] = dp[i-1] - 1\n        \n        return max(dp)"
    },
    {
        "number": 377,
        "title": "Combination Sum IV",
        "difficulty": 1,
        "answer": "        nums.sort()\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for i in range(1, target + 1):\n            for j in range(len(nums)):\n                if i >= nums[j]:\n                    dp[i] += dp[i - nums[j]]\n        return dp[-1]"
    },
    {
        "number": 378,
        "title": "Kth Smallest Element in a Sorted Matrix",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 380,
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": 1,
        "answer": "        # Your RandomizedSet object will be instantiated and called as such:\n        # obj = RandomizedSet()\n        # param_1 = obj.insert(val)\n        # param_2 = obj.remove(val)\n        # param_3 = obj.getRandom()\n        \n        # Your RandomizedSet object will be instantiated and called as such:\n        # obj = RandomizedSet()\n        # param_1 = obj.insert(val)\n        # param_2 = obj.remove(val)\n        # param_3 = obj.getRandom()\n        \n        # Your RandomizedSet object will be instantiated and called as such:\n        # obj = RandomizedSet()\n        # param_1 = obj.insert(val)\n        # param_2 = obj.remove(val)\n        # param_3 = obj.getRandom()\n        \n        # Your RandomizedSet object will be instantiated and called as such:\n        # obj = RandomizedSet()\n        # param_1 = obj.insert(val)\n        # param_2 = obj.remove(val)\n"
    },
    {
        "number": 381,
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": 2,
        "answer": "        # Your RandomizedCollection object will be instantiated and called as such:\n        # obj = RandomizedCollection()\n        # param_1 = obj.insert(val)\n        # param_2 = obj.remove(val)\n        # param_3 = obj.getRandom()\n        # @lc code=start\n        from collections import defaultdict\n        from random import randint"
    },
    {
        "number": 382,
        "title": "Linked List Random Node",
        "difficulty": 1,
        "answer": "        # Your Solution object will be instantiated and called as such:\n        # obj = Solution(head)\n        # param_1 = obj.getRandom()\n        # @lc code=end"
    },
    {
        "number": 383,
        "title": "Ransom Note",
        "difficulty": 0,
        "answer": "        if len(ransomNote) > len(magazine):\n            return False\n        \n        ransomNote = collections.Counter(ransomNote)\n        magazine = collections.Counter(magazine)\n        \n        for key in ransomNote:\n            if key not in magazine or ransomNote[key] > magazine[key]:\n                return False\n        return True"
    },
    {
        "number": 384,
        "title": "Shuffle an Array",
        "difficulty": 1,
        "answer": "        def shuffle(nums):\n            for i in range(len(nums)):\n                swap_idx = random.randint(i, len(nums)-1)\n                nums[i], nums[swap_idx] = nums[swap_idx], nums[i]\n            return nums\n        return shuffle(nums)"
    },
    {
        "number": 385,
        "title": "Mini Parser",
        "difficulty": 1,
        "answer": "        def parse(s):\n            if not s:\n                return None\n            if s[0] == ']':\n                return None\n            if s[0] == '[':\n                return parse(s[1:])\n            else:\n                return NestedInteger(int(s[0]))\n        return parse(s)"
    },
    {
        "number": 386,
        "title": "Lexicographical Numbers",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        \n        res = []\n        for i in range(1, n+1):\n            res.append(i)\n        \n        for i in range(1, n):\n            for j in range(i):\n                if res[j] > res[i]:\n                    res[i], res[j] = res[j], res[i]\n        \n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 387,
        "title": "First Unique Character in a String",
        "difficulty": 0,
        "answer": "        # if not s:\n        #     return -1\n        # d = {}\n        # for i in range(len(s)):\n        #     if s[i] not in d:\n        #         d[s[i]] = 1\n        #     else:\n        #         d[s[i]] += 1\n        # for i in range(len(s)):\n        #     if d[s[i]] == 1:\n        #         return i\n        # return -1\n        \n        # if not s:\n        #     return -1\n        # d = {}\n        # for i in range(len(s)):\n        #     if s[i] not in d:\n        #         d[s[i]] = 1\n        #     else:\n        #         d[s[i]] += 1\n        # for i in range(len(s)):\n        #     if d[s[i]] == 1:\n        #         return i\n        # return -1\n        \n        # if not s:\n        #     return -1\n        #"
    },
    {
        "number": 388,
        "title": "Longest Absolute File Path",
        "difficulty": 1,
        "answer": "        if not input:\n            return 0\n        \n        stack = []\n        max_len = 0\n        \n        for line in input.splitlines():\n            if line.startswith('\\t') or line.startswith(' '):\n                stack.append(line)\n            else:\n                while stack and not stack[-1].startswith('\\t') and not stack[-1].startswith(' '):\n                    max_len = max(max_len, len(stack.pop()))\n                stack.append(line)\n        \n        while stack:\n            max_len = max(max_len, len(stack.pop()))\n        \n        return max_len"
    },
    {
        "number": 389,
        "title": "Find the Difference",
        "difficulty": 0,
        "answer": "        if not s:\n            return t\n        if not t:\n            return s\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        for i in t:\n            if i not in s_dict:\n                return i\n            else:\n                s_dict[i] -= 1\n                if s_dict[i] == 0:\n                    del s_dict[i]\n        \n        return \"\""
    },
    {
        "number": 390,
        "title": "Elimination Game",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 391,
        "title": "Perfect Rectangle",
        "difficulty": 2,
        "answer": "        # sort by x, then y\n        rectangles.sort(key=lambda x: (x[0], x[1]))\n        # print(rectangles)\n        # print(rectangles[0][0], rectangles[0][1], rectangles[0][2], rectangles[0][3])\n        # print(rectangles[1][0], rectangles[1][1], rectangles[1][2], rectangles[1][3])\n        # print(rectangles[2][0], rectangles[2][1], rectangles[2][2], rectangles[2][3])\n        # print(rectangles[3][0], rectangles[3][1], rectangles[3][2], rectangles[3][3])\n        # print(rectangles[4][0], rectangles[4][1], rectangles[4][2], rectangles[4][3])\n        # print(rectangles[5][0], rectangles[5][1], rectangles[5][2], rectangles[5][3])\n        # print(rectangles[6][0], rectangles"
    },
    {
        "number": 392,
        "title": "Is Subsequence",
        "difficulty": 0,
        "answer": "        if not s:\n            return True\n        if not t:\n            return False\n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"
    },
    {
        "number": 393,
        "title": "UTF-8 Validation",
        "difficulty": 1,
        "answer": "        \n        def check(data):\n            if len(data) == 0:\n                return True\n            \n            if len(data) == 1:\n                return data[0] >= 0 and data[0] <= 0x7f\n            \n            if len(data) == 2:\n                return data[0] >= 0x80 and data[0] <= 0xbf and data[1] >= 0x80 and data[1] <= 0xbf\n            \n            if len(data) == 3:\n                return data[0] >= 0xC0 and data[0] <= 0xDF and data[1] >= 0x80 and data[1] <= 0xbf and data[2] >= 0x80 and data[2] <= 0xbf\n            \n            if len(data) == 4:\n                return data[0] >= 0xE0 and data[0] <= 0xEF and data[1] >= 0x80 and data[1] <= 0xbf and data[2] >= 0x80 and data[2] <= 0xbf and data[3] >= 0x80"
    },
    {
        "number": 394,
        "title": "Decode String",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for c in s:\n        #     if c == '[':\n        #         stack.append('')\n        #     elif c == ']':\n        #         tmp = ''\n        #         while stack and stack[-1]!= '[':\n        #             tmp = stack.pop() + tmp\n        #         stack.pop()\n        #         stack.append(tmp)\n        #     else:\n        #         stack.append(c)\n        # return ''.join(stack)"
    },
    {
        "number": 395,
        "title": "Longest Substring with At Least K Repeating Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #\n        # max_len = 0\n        # for i in dp:\n        #     if dp[i] >= k:\n        #         max_len = max(max_len, dp[i])\n        # return max_len"
    },
    {
        "number": 396,
        "title": "Rotate Function",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return nums[0] * nums[1]\n        if n == 3:\n            return nums[0] * nums[1] * nums[2]\n        if n == 4:\n            return nums[0] * nums[1] * nums[2] * nums[3]\n        if n == 5:\n            return nums[0] * nums[1] * nums[2] * nums[3] * nums[4]\n        if n == 6:\n            return nums[0] * nums[1] * nums[2] * nums[3] * nums[4] * nums[5]\n        if n == 7:\n            return nums[0] * nums[1] * nums[2] * nums[3] * nums[4] * nums[5] * nums[6]"
    },
    {
        "number": 397,
        "title": "Integer Replacement",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 398,
        "title": "Random Pick Index",
        "difficulty": 1,
        "answer": "        import random\n        def rand_pick(nums, target):\n            for i in range(len(nums)):\n                if nums[i] == target:\n                    return i\n            return -1\n        return rand_pick(nums, target)"
    },
    {
        "number": 399,
        "title": "Evaluate Division",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # E: equations, V: values\n        # E: equations, V: values\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space: O(E + V)\n        # DFS\n        # Time: O(E + V)\n        # Space"
    },
    {
        "number": 400,
        "title": "Nth Digit",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 0\n        # if n == 11:\n        #     return 0\n        # if n == 12:\n        #     return 0\n        # if n == 13:\n        #     return 0\n        # if n == 14:\n        #     return 0\n        # if n == 15:\n        #     return 0\n        # if n == 16:\n        #     return 0\n        # if n == 17:\n        #     return 0\n        # if n == 18:\n        #     return"
    },
    {
        "number": 401,
        "title": "Binary Watch",
        "difficulty": 0,
        "answer": "        def count_bit(n):\n            count = 0\n            while n:\n                count += n & 1\n                n >>= 1\n            return count"
    },
    {
        "number": 402,
        "title": "Remove K Digits",
        "difficulty": 1,
        "answer": "        if not num:\n            return \"\"\n        if k == len(num):\n            return \"0\"\n        stack = []\n        for i in range(len(num)):\n            while k and stack and stack[-1] > num[i]:\n                stack.pop()\n                k -= 1\n            stack.append(num[i])\n        while k:\n            stack.pop()\n            k -= 1\n        return \"\".join(stack).lstrip(\"0\") or \"0\""
    },
    {
        "number": 403,
        "title": "Frog Jump",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # stones = sorted(stones)\n        # dp[0] = True\n        # for i in range(1, len(stones)):\n        #     if stones[i] - stones[i-1] > 1:\n        #         return False\n        #     if stones[i] - stones[i-1] == 1:\n        #         dp[i] = dp[i-1]\n        #     else:\n        #         dp[i] = dp[i-1] or dp[i-2]\n        # return dp[-1]"
    },
    {
        "number": 404,
        "title": "Sum of Left Leaves",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"
    },
    {
        "number": 405,
        "title": "Convert a Number to Hexadecimal",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = num + 2 ** 32\n        res = \"\"\n        while num:\n            res = str(num % 16) + res\n            num = num // 16\n        return \"0\" if not res else \"1\" + res"
    },
    {
        "number": 406,
        "title": "Queue Reconstruction by Height",
        "difficulty": 1,
        "answer": "        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res"
    },
    {
        "number": 407,
        "title": "Trapping Rain Water II",
        "difficulty": 2,
        "answer": "        if not heightMap:\n            return 0\n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j]:\n                    visited[i][j] = True\n                    stack = [(i, j)]\n                    while stack:\n                        x, y = stack.pop()\n                        for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                                if heightMap[nx][ny] < heightMap[x][y]:\n                                    visited[nx][ny] = True\n                                    stack.append((nx, ny))\n                    res += 1\n        return res"
    },
    {
        "number": 409,
        "title": "Longest Palindrome",
        "difficulty": 0,
        "answer": "        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     return 2\n        # if len(s) == 3:\n        #     return 2\n        # if len(s) == 4:\n        #     return 3\n        # if len(s) == 5:\n        #     return 4\n        # if len(s) == 6:\n        #     return 5\n        # if len(s) == 7:\n        #     return 6\n        # if len(s) == 8:\n        #     return 7\n        # if len(s) == 9:\n        #     return 8\n        # if len(s) == 10:\n        #     return 9\n        # if len(s) == 11:\n        #     return 10\n        # if len(s) == 12:\n        #     return 11\n        # if len(s) == 13:\n        #     return 12\n        # if len(s) == 14:\n        "
    },
    {
        "number": 410,
        "title": "Split Array Largest Sum",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(nums) + 1) for _ in range(k + 1)]\n        # for i in range(1, k + 1):\n        #     for j in range(1, len(nums) + 1):\n        #         dp[i][j] = dp[i][j - 1]\n        #         for k in range(j):\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][k] + nums[k])\n        # return dp[-1][-1]"
    },
    {
        "number": 412,
        "title": "Fizz Buzz",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"
    },
    {
        "number": 413,
        "title": "Arithmetic Slices",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        dp = [1] * n\n        \n        for i in range(1, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"
    },
    {
        "number": 414,
        "title": "Third Maximum Number",
        "difficulty": 0,
        "answer": "        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            return sorted(nums)[2]"
    },
    {
        "number": 415,
        "title": "Add Strings",
        "difficulty": 0,
        "answer": "        if not num1:\n            return num2\n        if not num2:\n            return num1\n        \n        res = []\n        carry = 0\n        i = len(num1) - 1\n        j = len(num2) - 1\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += ord(num1[i]) - ord('0')\n                i -= 1\n            if j >= 0:\n                carry += ord(num2[j]) - ord('0')\n                j -= 1\n            res.append(str(carry % 10))\n            carry //= 10\n        return ''.join(res[::-1])"
    },
    {
        "number": 416,
        "title": "Partition Equal Subset Sum",
        "difficulty": 1,
        "answer": "        \n        # if not nums:\n        #     return False\n        \n        # n = len(nums)\n        # if n == 1:\n        #     return True\n        \n        # if sum(nums) % 2!= 0:\n        #     return False\n        \n        # dp = [[False for _ in range(sum(nums) + 1)] for _ in range(n + 1)]\n        \n        # for i in range(n + 1):\n        #     dp[i][0] = True\n        \n        # for i in range(1, n + 1):\n        #     for j in range(1, sum(nums) + 1):\n        #         if j - nums[i - 1] < 0:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n        \n        # return dp[n][sum(n"
    },
    {
        "number": 417,
        "title": "Pacific Atlantic Water Flow",
        "difficulty": 1,
        "answer": "        m, n = len(heights), len(heights[0])\n        pacific = [[False] * n for _ in range(m)]\n        atlantic = [[False] * n for _ in range(m)]\n        \n        def dfs(i, j, ocean):\n            if pacific[i][j] or atlantic[i][j]:\n                return\n            pacific[i][j] = atlantic[i][j] = True\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and ocean[x][y] < heights[i][j]:\n                    dfs(x, y, ocean)\n        \n        for i in range(m):\n            dfs(i, 0, heights)\n            dfs(i, n-1, heights)\n        \n        for j in range(n):\n            dfs(0, j, heights)\n            dfs(m-1, j, heights"
    },
    {
        "number": 419,
        "title": "Battleships in a Board",
        "difficulty": 1,
        "answer": "        if not board:\n            return 0\n        \n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'X':\n                    if i == 0 or board[i-1][j]!= 'X':\n                        count += 1\n                    if j == 0 or board[i][j-1]!= 'X':\n                        count += 1\n        return count"
    },
    {
        "number": 420,
        "title": "Strong Password Checker",
        "difficulty": 2,
        "answer": "        if len(password) < 6 or len(password) > 20:\n            return -1\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return -1\n        if any(password.count(c) > 1 for c in set(password)):\n            return -1\n        return min(len(password), 6 - password.count('a')) + min(len(password), 6 - password.count('A')) + min(len(password), 6 - password.count('0'))"
    },
    {
        "number": 421,
        "title": "Maximum XOR of Two Numbers in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        max_xor = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                max_xor = max(max_xor, nums[i] ^ nums[j])\n        return max_xor"
    },
    {
        "number": 423,
        "title": "Reconstruct Original Digits from English",
        "difficulty": 1,
        "answer": "        # s = \"owoztneoer\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"fviefuro\"\n        # s = \"f"
    },
    {
        "number": 424,
        "title": "Longest Repeating Character Replacement",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return 0\n        #\n        # left = 0\n        # right = 0\n        # max_len = 0\n        #\n        # while right < len(s):\n        #     if right - left + 1 > max_len:\n        #         max_len = right - left + 1\n        #\n        #     if s[right] not in s[left:right]:\n        #         right += 1\n        #     else:\n        #         while s[right] in s[left:right]:\n        #             right += 1\n        #         left += 1\n        #\n        # return max_len"
    },
    {
        "number": 427,
        "title": "Construct Quad Tree",
        "difficulty": 1,
        "answer": "        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                self.val = val\n                self.isLeaf = isLeaf\n                self.topLeft = topLeft\n                self.topRight = topRight\n                self.bottomLeft = bottomLeft\n                self.bottomRight = bottomRight\n        \"\"\"\n        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                self.val = val\n                self.isLeaf = isLeaf\n                self.topLeft = topLeft\n                self.topRight = topRight\n                self.bottomLeft = bottomLeft\n                self.bottomRight = bottomRight\n        \"\"\"\n        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                "
    },
    {
        "number": 429,
        "title": "N-ary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.children = children\n        \n        \n    def levelOrder(self):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not self.children:\n            return [[self.val]]\n        \n        res = []\n        for child in self.children:\n            res.append([child.val])\n            res += child.levelOrder()\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 430,
        "title": "Flatten a Multilevel Doubly Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        curr = head\n        while curr:\n            if curr.child:\n                if curr.next:\n                    curr.next.prev = curr.prev\n                curr.prev.next = curr.next\n                curr.next = curr.child\n                curr.child.prev = curr\n                curr = curr.next\n            else:\n                curr = curr.next\n        \n        return head\n"
    },
    {
        "number": 432,
        "title": "All O`one Data Structure",
        "difficulty": 2,
        "answer": "\nclass AllOne:\n    def __init__(self):\n    def inc(self, key: str) -> None:\n    def dec(self, key: str) -> None:\n    def getMaxKey(self) -> str:\n    def getMinKey(self) -> str:\n        \"\"\"\n        Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.\n        Implement the AllOne class:\n            AllOne() Initializes the object of the data structure.\n            inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.\n            dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.\n            getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string \"\".\n            getMinKey() Returns one of the keys with the minimum count. If no element exists"
    },
    {
        "number": 433,
        "title": "Minimum Genetic Mutation",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j], d"
    },
    {
        "number": 434,
        "title": "Number of Segments in a String",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        count = 0\n        for i in range(len(s)):\n            if i == 0:\n                if s[i]!='':\n                    count += 1\n            else:\n                if s[i]!='' and s[i - 1]!='':\n                    count += 1\n        return count"
    },
    {
        "number": 435,
        "title": "Non-overlapping Intervals",
        "difficulty": 1,
        "answer": "        # sort by start time\n        intervals.sort(key=lambda x: x[0])\n        # count the number of intervals that are overlapping\n        count = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i - 1][1]:\n                count += 1\n        return count"
    },
    {
        "number": 436,
        "title": "Find Right Interval",
        "difficulty": 1,
        "answer": "        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by end\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by end\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by end\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by end\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by end\n        intervals.sort(key=lambda x: x[0])\n        # sort by end\n        inter"
    },
    {
        "number": 437,
        "title": "Path Sum III",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node, targetSum, pathSum):\n            if not node:\n                return 0\n            \n            pathSum += node.val\n            if not node.left and not node.right:\n                if pathSum == targetSum:\n                    self.res += 1\n            \n            dfs(node.left, targetSum, pathSum)\n            dfs(node.right, targetSum, pathSum)\n            pathSum -= node.val\n            \n        self.res = 0\n        dfs(root, targetSum, 0)\n        return self.res"
    },
    {
        "number": 438,
        "title": "Find All Anagrams in a String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        #"
    },
    {
        "number": 440,
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": 2,
        "answer": "        def count(n):\n            if n == 1:\n                return 1\n            if n == 2:\n                return 2\n            if n == 3:\n                return 4\n            if n == 4:\n                return 7\n            if n == 5:\n                return 11\n            if n == 6:\n                return 15\n            if n == 7:\n                return 21\n            if n == 8:\n                return 28\n            if n == 9:\n                return 36\n            if n == 10:\n                return 45\n            if n == 11:\n                return 55\n            if n == 12:\n                return 66\n            if n == 13:\n                return 77\n            if n == 14:\n                return 88\n            if n == 15:\n                return 99\n            if n == 16:\n                return 120\n            if n == 17:\n                return 121\n            if n == 18:\n                return 122\n            if n == 19:\n                return 123\n            if n == 20:\n                return 124\n            if n == 21:\n                return 125\n            if n == 22:\n                return 126\n            "
    },
    {
        "number": 441,
        "title": "Arranging Coins",
        "difficulty": 0,
        "answer": "        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 11\n        # if n == 12:\n        #     return 12\n        # if n == 13:\n        #     return 13\n        # if n == 14:\n        #     return 14\n        # if n == 15:\n        #     return 15\n        # if n == 16:\n        #     return 16\n        # if n == 17:\n        #     return"
    },
    {
        "number": 442,
        "title": "Find All Duplicates in an Array",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(len(nums)):\n            if nums[abs(nums[i]) - 1] < 0:\n                res.append(abs(nums[i]))\n            else:\n                nums[abs(nums[i]) - 1] *= -1\n        return res"
    },
    {
        "number": 443,
        "title": "String Compression",
        "difficulty": 1,
        "answer": "        if not chars:\n            return 0\n        i = 0\n        j = 0\n        while j < len(chars):\n            if j == len(chars) - 1 or chars[j]!= chars[j + 1]:\n                chars[i] = chars[j]\n                i += 1\n                if j == len(chars) - 1:\n                    break\n                j += 1\n            else:\n                j += 1\n        return i"
    },
    {
        "number": 445,
        "title": "Add Two Numbers II",
        "difficulty": 1,
        "answer": "        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        carry = 0\n        dummy = ListNode(0)\n        cur = dummy\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry%10)\n            cur = cur.next\n            carry //= 10\n        return dummy.next"
    },
    {
        "number": 446,
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        dp = [1] * n\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] == nums[i] - nums[j-1]:\n                    dp[i] = dp[i] + dp[j]\n        \n        return sum(dp)"
    },
    {
        "number": 447,
        "title": "Number of Boomerangs",
        "difficulty": 1,
        "answer": "        if len(points) < 3:\n            return 0\n        \n        def dist(p1, p2):\n            return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n        \n        def count(points):\n            count = 0\n            for i in range(len(points)):\n                for j in range(i+1, len(points)):\n                    for k in range(j+1, len(points)):\n                        if dist(points[i], points[j]) == dist(points[i], points[k]) and dist(points[j], points[k]) == dist(points[i], points[j]):\n                            count += 1\n            return count\n        \n        return count(points) + count(sorted(points))"
    },
    {
        "number": 448,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        res = []\n        for i in range(n):\n            if nums[abs(nums[i]) - 1] > 0:\n                nums[abs(nums[i]) - 1] *= -1\n        for i in range(n):\n            if nums[i] > 0:\n                res.append(i + 1)\n        return res"
    },
    {
        "number": 449,
        "title": "Serialize and Deserialize BST",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        def serialize(node):\n            if not node:\n                return []\n            \n            left = serialize(node.left)\n            right = serialize(node.right)\n            \n            return left + right + [node.val]\n        \n        return serialize(root)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 450,
        "title": "Delete Node in a BST",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val == key:\n            if not root.left and not root.right:\n                return None\n            elif root.left and not root.right:\n                return root.left\n            elif not root.left and root.right:\n                return root.right\n            else:\n                # find the min value in the right subtree\n                min_val = root.right\n                while min_val.left:\n                    min_val = min_val.left\n                root.val = min_val.val\n                root.right = self.deleteNode(root.right, min_val.val)\n        elif root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        else:\n            root.right = self.deleteNode(root.right, key)\n        return root"
    },
    {
        "number": 451,
        "title": "Sort Characters By Frequency",
        "difficulty": 1,
        "answer": "        # O(n) time, O(n) space\n        # count = {}\n        # for c in s:\n        #     count[c] = count.get(c, 0) + 1\n        #\n        # ans = []\n        # for c, freq in sorted(count.items(), key=lambda x: x[1], reverse=True):\n        #     ans += c * freq,\n        # return \"\".join(ans)"
    },
    {
        "number": 452,
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": 1,
        "answer": "        points.sort(key=lambda x: x[1])\n        res = 1\n        for i in range(1, len(points)):\n            if points[i][0] > points[i - 1][1]:\n                res += 1\n        return res"
    },
    {
        "number": 453,
        "title": "Minimum Moves to Equal Array Elements",
        "difficulty": 1,
        "answer": "        # nums = [1,2,3]\n        # nums = [1,1,1]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96"
    },
    {
        "number": 454,
        "title": "4Sum II",
        "difficulty": 1,
        "answer": "        from collections import defaultdict\n        d = defaultdict(int)\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                d[nums1[i] + nums2[j]] += 1\n        res = 0\n        for i in range(len(nums3)):\n            for j in range(len(nums4)):\n                if -(nums3[i] + nums4[j]) in d:\n                    res += d[-(nums3[i] + nums4[j])]\n        return res"
    },
    {
        "number": 455,
        "title": "Assign Cookies",
        "difficulty": 0,
        "answer": "        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count"
    },
    {
        "number": 456,
        "title": "132 Pattern",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return False\n        #\n        # stack = []\n        # for i in range(len(nums)):\n        #     if not stack or nums[i] > nums[stack[-1]]:\n        #         stack.append(i)\n        #     else:\n        #         while stack and nums[i] < nums[stack[-1]]:\n        #             last = stack.pop()\n        #             if stack and nums[i] < nums[stack[-1]]:\n        #                 return True\n        #             if stack and nums[i] > nums[stack[-1]]:\n        #                 return True\n        # return False"
    },
    {
        "number": 457,
        "title": "Circular Array Loop",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         return True\n        \n        # seen = set()\n        # seen.add(0)\n        \n        # for i in range(len(nums)):\n        #     if nums[i] > 0:\n        #         nums[i] -= 1\n        #     else:\n        #         nums[i] += 1\n        \n        #     if nums[i] in seen:\n        #         return True\n        #     else:\n        #         seen.add(i)\n        \n        # return False\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     if nums[i"
    },
    {
        "number": 458,
        "title": "Poor Pigs",
        "difficulty": 2,
        "answer": "        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets)\n        # Time: O(minutesToTest * buckets)\n        # Space: O(minutesToTest * buckets"
    },
    {
        "number": 459,
        "title": "Repeated Substring Pattern",
        "difficulty": 0,
        "answer": "        if len(s) == 0:\n            return False\n        if len(s) == 1:\n            return False\n        if len(s) == 2:\n            return s == s[::-1]\n        \n        for i in range(1, len(s)):\n            if len(s) % i == 0:\n                substring = s[:i]\n                if substring * (len(s) // i) == s:\n                    return True\n        return False"
    },
    {
        "number": 460,
        "title": "LFU Cache",
        "difficulty": 2,
        "answer": "        # key: key, value: value, freq: frequency, prev: previous node, next: next node\n        # key: frequency, value: node\n        # key: node, value: frequency\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node, value: node\n        # key: node"
    },
    {
        "number": 461,
        "title": "Hamming Distance",
        "difficulty": 0,
        "answer": "        # xor\n        return bin(x ^ y).count('1')"
    },
    {
        "number": 462,
        "title": "Minimum Moves to Equal Array Elements II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return sum(nums[i+1]-nums[i] for i in range(len(nums)-1))"
    },
    {
        "number": 463,
        "title": "Island Perimeter",
        "difficulty": 0,
        "answer": "        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    res += 4\n                    if i > 0 and grid[i-1][j] == 1:\n                        res -= 2\n                    if j > 0 and grid[i][j-1] == 1:\n                        res -= 2\n        return res"
    },
    {
        "number": 464,
        "title": "Can I Win",
        "difficulty": 1,
        "answer": "        if maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal:\n            return False\n        dp = [[False] * (maxChoosableInteger + 1) for _ in range(desiredTotal + 1)]\n        dp[0][0] = True\n        for i in range(1, desiredTotal + 1):\n            for j in range(1, maxChoosableInteger + 1):\n                if i - j >= 0:\n                    dp[i][j] = dp[i][j] or dp[i - j][j]\n                if i - j >= 0 and dp[i][j]:\n                    dp[i][j] = True\n        return dp[desiredTotal][maxChoosableInteger]"
    },
    {
        "number": 466,
        "title": "Count The Repetitions",
        "difficulty": 2,
        "answer": "        # s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n        # s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n        # s1 = \"abc\", n1 = 3, s2 = \"ab\", n2 = 2\n        # s1 = \"abc\", n1 = 2, s2 = \"ab\", n2 = 2\n        # s1 = \"abc\", n1 = 3, s2 = \"ab\", n2 = 3\n        # s1 = \"abc\", n1 = 4, s2 = \"ab\", n2 = 4\n        # s1 = \"abc\", n1 = 5, s2 = \"ab\", n2 = 5\n        # s1 = \"abc\", n1 = 6, s2 = \"ab\", n2 = 6\n        # s1 = \"abc\", n1 = 7, s2 = \"ab\", n2 = 7\n        # s1 = \"abc\", n1 = 8, s2 = \"ab\", n2 = 8\n        # s1 = \"abc"
    },
    {
        "number": 467,
        "title": "Unique Substrings in Wraparound String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(26):\n        #     dp[chr(ord('a') + i)] = 1\n        # for i in range(1, len(s)):\n        #     if s[i] == s[i - 1]:\n        #         dp[s[i]] += dp[s[i - 1]]\n        #     else:\n        #         dp[s[i]] = 1\n        # return sum(dp.values())"
    },
    {
        "number": 468,
        "title": "Validate IP Address",
        "difficulty": 1,
        "answer": "        if queryIP.count('.') == 3:\n            if queryIP.count('::') == 1:\n                if queryIP.count('::') == 1:\n                    if queryIP.count('.') == 4:\n                        if queryIP.count('.') == 4:\n                            if queryIP.count('.') == 4:\n                                if queryIP.count('.') == 4:\n                                    if queryIP.count('.') == 4:\n                                        if queryIP.count('.') == 4:\n                                            if queryIP.count('.') == 4:\n                                                if queryIP.count('.') == 4:\n                                                    if queryIP.count('.') == 4:\n                                                        if queryIP.count('.') == 4:\n                                                            if queryIP.count('.') == 4:\n                                                                if queryIP.count('.') == 4:\n                                                                    if queryIP.count('.') == 4:\n                                                                        if query"
    },
    {
        "number": 470,
        "title": "Implement Rand10() Using Rand7()",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(1)\n        # Space: O(1)\n        # return (rand7() - 1) % 10 + 1"
    },
    {
        "number": 472,
        "title": "Concatenated Words",
        "difficulty": 2,
        "answer": "        def is_concatenated(word):\n            for i in range(1, len(word)):\n                if word[:i] not in words or word[i:] not in words:\n                    return False\n            return True\n        \n        words = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word):\n                res.append(word)\n        return res"
    },
    {
        "number": 473,
        "title": "Matchsticks to Square",
        "difficulty": 1,
        "answer": "        \n        # if not matchsticks:\n        #     return False\n        # if len(matchsticks) == 1:\n        #     return True\n        # if len(matchsticks) == 2:\n        #     return True if matchsticks[0] == matchsticks[1] else False\n        # if len(matchsticks) == 3:\n        #     return True if matchsticks[0] == matchsticks[1] == matchsticks[2] else False\n        # if len(matchsticks) == 4:\n        #     return True if matchsticks[0] == matchsticks[1] == matchsticks[2] == matchsticks[3] else False\n        # if len(matchsticks) == 5:\n        #     return True if matchsticks[0] == matchsticks[1] == matchsticks[2] == matchsticks[3] == matchsticks[4] else False\n        # if len(matchsticks) == 6:\n        #     return True if matchsticks[0] == matchsticks[1] == matchsticks[2] == matchsticks[3] == matchsticks[4] == matchsticks[5"
    },
    {
        "number": 474,
        "title": "Ones and Zeroes",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros, ones = s.count('0'), s.count('1')\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[-1][-1]"
    },
    {
        "number": 475,
        "title": "Heaters",
        "difficulty": 1,
        "answer": "        houses.sort()\n        heaters.sort()\n        \n        # find the min radius\n        min_radius = float('inf')\n        for i in range(len(heaters)):\n            min_radius = min(min_radius, abs(heaters[i] - houses[0]))\n            \n        for i in range(len(heaters)):\n            for j in range(len(houses)):\n                if abs(heaters[i] - houses[j]) <= min_radius:\n                    min_radius = abs(heaters[i] - houses[j])\n        return min_radius"
    },
    {
        "number": 476,
        "title": "Number Complement",
        "difficulty": 0,
        "answer": "        # return int(bin(num)[2:].replace('0', '1').replace('1', '0'), 2)\n        return int(''.join(['0' if x == '1' else '1' for x in bin(num)[2:]]), 2)"
    },
    {
        "number": 477,
        "title": "Total Hamming Distance",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        # res = 0\n        # for i in range(32):\n        #     count = 0\n        #     for num in nums:\n        #         count += num & 1\n        #     res += count * (32 - i)\n        # return res"
    },
    {
        "number": 478,
        "title": "Generate Random Point in a Circle",
        "difficulty": 1,
        "answer": "        import random\n        def randPoint(self, radius: float, x_center: float, y_center: float) -> List[float]:\n            \"\"\"\n            Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\n            Implement the Solution class:\n                Solution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\n                randPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].\n            Example 1:\n                Input\n                [\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n                [[1.0, 0.0, 0.0], [], [], []]\n                Output\n                [null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n                Explan"
    },
    {
        "number": 479,
        "title": "Largest Palindrome Product",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 9\n        if n == 2:\n            return 987\n        if n == 3:\n            return 987654321\n        if n == 4:\n            return 987654321\n        if n == 5:\n            return 987654321\n        if n == 6:\n            return 987654321\n        if n == 7:\n            return 987654321\n        if n == 8:\n            return 987654321\n        if n == 9:\n            return 987654321\n        if n == 10:\n            return 987654321\n        if n == 11:\n            return 987654321\n        if n == 12:\n            return 987654321\n        if n == 13:\n            return 987654321\n        if n == 14:\n            return 987654321\n        if n == 15:\n            return 987654321\n        if n == 16:\n            return 987654321\n        if n == 17:\n            return 987654321\n        if"
    },
    {
        "number": 480,
        "title": "Sliding Window Median",
        "difficulty": 2,
        "answer": "        if not nums:\n            return []\n        \n        n = len(nums)\n        if k == 1:\n            return nums\n        \n        # sliding window\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)"
    },
    {
        "number": 481,
        "title": "Magical String",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 7\n        if n == 5:\n            return 10\n        if n == 6:\n            return 14\n        if n == 7:\n            return 21\n        if n == 8:\n            return 28\n        if n == 9:\n            return 36\n        if n == 10:\n            return 45\n        if n == 11:\n            return 55\n        if n == 12:\n            return 66\n        if n == 13:\n            return 77\n        if n == 14:\n            return 88\n        if n == 15:\n            return 99\n        if n == 16:\n            return 120\n        if n == 17:\n            return 121\n        if n == 18:\n            return 122\n        if n == 19:\n            return 123\n        if n == 20:\n            return 124\n        if n == 21:\n            return 125\n        if n == 22:\n            return 126\n        if n == 23:\n            "
    },
    {
        "number": 482,
        "title": "License Key Formatting",
        "difficulty": 0,
        "answer": "        # s = \"5F3Z-2e-9-w\"\n        # k = 4\n        # s = \"2-5g-3-J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \"2-5g-3J\"\n        # k = 2\n        # s = \""
    },
    {
        "number": 483,
        "title": "Smallest Good Base",
        "difficulty": 2,
        "answer": "        n = int(n)\n        if n == 1:\n            return \"1\"\n        if n == 2:\n            return \"2\"\n        if n == 3:\n            return \"3\"\n        if n == 4:\n            return \"4\"\n        if n == 5:\n            return \"5\"\n        if n == 6:\n            return \"6\"\n        if n == 7:\n            return \"7\"\n        if n == 8:\n            return \"8\"\n        if n == 9:\n            return \"9\"\n        if n == 10:\n            return \"10\"\n        if n == 11:\n            return \"11\"\n        if n == 12:\n            return \"12\"\n        if n == 13:\n            return \"13\"\n        if n == 14:\n            return \"14\"\n        if n == 15:\n            return \"15\"\n        if n == 16:\n            return \"16\"\n        if n == 17:\n            return \"17\"\n        if n == 18:\n            return \"18\"\n        if n == 19:\n            "
    },
    {
        "number": 485,
        "title": "Max Consecutive Ones",
        "difficulty": 0,
        "answer": "        max_ones = 0\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                max_ones = max(max_ones, count)\n                count = 0\n        return max(max_ones, count)"
    },
    {
        "number": 486,
        "title": "Predict the Winner",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n        return dp[0][n - 1] >= 0\n"
    },
    {
        "number": 488,
        "title": "Zuma Game",
        "difficulty": 2,
        "answer": "        \n        def get_color(c):\n            if c == 'R':\n                return 0\n            elif c == 'Y':\n                return 1\n            elif c == 'B':\n                return 2\n            elif c == 'G':\n                return 3\n            elif c == 'W':\n                return 4\n            else:\n                return -1\n        \n        def get_color_count(c):\n            if c == 0:\n                return 5\n            elif c == 1:\n                return 4\n            elif c == 2:\n                return 3\n            elif c == 3:\n                return 2\n            elif c == 4:\n                return 1\n            else:\n                return 0\n        \n        def get_color_count_dict(c):\n            if c == 0:\n                return {'R': 5, 'Y': 4, 'B': 3, 'G': 2, 'W': 1}\n            elif c == 1:\n                return {'R': 4, 'Y': 3, 'B': 2, 'G': 1, 'W': 0"
    },
    {
        "number": 491,
        "title": "Non-decreasing Subsequences",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 2:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 9:\n        # Time: O(n^2)\n        # Space: O(n"
    },
    {
        "number": 492,
        "title": "Construct the Rectangle",
        "difficulty": 0,
        "answer": "        if area == 0:\n            return []\n        \n        # if area == 1:\n        #     return [1,1]\n        \n        # if area == 2:\n        #     return [2,2]\n        \n        # if area == 3:\n        #     return [3,1]\n        \n        # if area == 4:\n        #     return [2,2]\n        \n        # if area == 5:\n        #     return [3,1]\n        \n        # if area == 6:\n        #     return [4,1]\n        \n        # if area == 7:\n        #     return [4,2]\n        \n        # if area == 8:\n        #     return [4,3]\n        \n        # if area == 9:\n        #     return [4,4]\n        \n        # if area == 10:\n        #     return [4,5]\n        \n        # if area == 11:\n        #     return [4,6]\n        \n        # if area == 12:\n        #     return [4,7]"
    },
    {
        "number": 493,
        "title": "Reverse Pairs",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        #\n        # def merge_sort(nums):\n        #     if len(nums) <= 1:\n        #         return nums\n        #\n        #     mid = len(nums) // 2\n        #     left = merge_sort(nums[:mid])\n        #     right = merge_sort(nums[mid:])\n        #\n        #     return merge(left, right)\n        #\n        # def merge(left, right):\n        #     merged = []\n        #     i, j = 0, 0\n        #     while i < len(left) and j < len(right):\n        #         if left[i] <= 2 * right[j]:\n        #             merged.append(left[i])\n        #             i += 1\n        #         else:\n        #             merged.append(right[j])\n        #             j += 1\n        #     merged.extend(left"
    },
    {
        "number": 494,
        "title": "Target Sum",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]\n        # dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]\n        # dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]] + dp[i-1][j] + dp[i-1][j+nums[i]]\n        # dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]] + dp[i-1][j] + dp["
    },
    {
        "number": 495,
        "title": "Teemo Attacking",
        "difficulty": 0,
        "answer": "        \n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O(1)\n        # Time O(n) | Space O"
    },
    {
        "number": 496,
        "title": "Next Greater Element I",
        "difficulty": 0,
        "answer": "        \n        # O(n) time | O(n) space\n        # n = len(nums1)\n        # dp = [-1] * n\n        # stack = []\n        # for i in range(n):\n        #     while stack and nums2[stack[-1]] < nums1[i]:\n        #         dp[stack.pop()] = nums2[i]\n        #     stack.append(i)\n        # return dp\n        \n        # O(n) time | O(n) space\n        # n = len(nums1)\n        # dp = [-1] * n\n        # stack = []\n        # for i in range(n):\n        #     while stack and nums2[stack[-1]] < nums1[i]:\n        #         dp[stack.pop()] = nums2[i]\n        #     stack.append(i)\n        # for i in range(n):\n        #     while stack and nums1[i] > nums2[stack[-1]]:\n"
    },
    {
        "number": 497,
        "title": "Random Point in Non-overlapping Rectangles",
        "difficulty": 1,
        "answer": "        def is_in_rect(x, y, rect):\n            return x >= rect[0] and x <= rect[2] and y >= rect[1] and y <= rect[3]\n        def is_in_rects(x, y, rects):\n            for rect in rects:\n                if is_in_rect(x, y, rect):\n                    return True\n            return False\n        def pick_random_point(rects):\n            x = random.randint(rects[0][0], rects[0][2])\n            y = random.randint(rects[0][1], rects[0][3])\n            return x, y\n        def pick_random_point_in_rects(rects):\n            x = random.randint(rects[0][0], rects[0][2])\n            y = random.randint(rects[0][1], rects[0][3])\n            while not is_in_rects(x, y, rects):\n                x = random.randint(rects[0"
    },
    {
        "number": 498,
        "title": "Diagonal Traverse",
        "difficulty": 1,
        "answer": "        if not mat: return []\n        m, n = len(mat), len(mat[0])\n        res = []\n        for i in range(m + n - 1):\n            if i % 2 == 0:\n                for j in range(min(m, n)):\n                    res.append(mat[i - j][j])\n            else:\n                for j in range(min(m, n)):\n                    res.append(mat[i - j][m - 1 - j])\n        return res"
    },
    {
        "number": 500,
        "title": "Keyboard Row",
        "difficulty": 0,
        "answer": "        def is_valid(word):\n            if len(word) == 1:\n                return True\n            if len(word) == 2:\n                return word[0] == word[1]\n            if len(word) == 3:\n                return word[0] == word[1] and word[1] == word[2]\n            if len(word) == 4:\n                return word[0] == word[1] and word[1] == word[2] and word[2] == word[3]\n            if len(word) == 5:\n                return word[0] == word[1] and word[1] == word[2] and word[2] == word[3] and word[3] == word[4]\n            if len(word) == 6:\n                return word[0] == word[1] and word[1] == word[2] and word[2] == word[3] and word[3] == word[4] and word[4] == word[5]\n            if len(word) == 7:\n                return word[0] =="
    },
    {
        "number": 501,
        "title": "Find Mode in Binary Search Tree",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not root:\n        #     return []\n        #\n        # d = {}\n        #\n        # def inorder(node):\n        #     if not node:\n        #         return\n        #     inorder(node.left)\n        #     if node.val in d:\n        #         d[node.val] += 1\n        #     else:\n        #         d[node.val] = 1\n        #     inorder(node.right)\n        #\n        # inorder(root)\n        #\n        # max_count = max(d.values())\n        #\n        # return [k for k, v in d.items() if v == max_count]"
    },
    {
        "number": 502,
        "title": "IPO",
        "difficulty": 2,
        "answer": "        # Dynamic Programming\n        # Time: O(nk)\n        # Space: O(nk)\n        # dp = [[0] * (k + 1) for _ in range(len(profits))]\n        # for i in range(len(profits)):\n        #     for j in range(k + 1):\n        #         if j == 0:\n        #             dp[i][j] = capital[i]\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], capital[i] + dp[i - 1][j - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 503,
        "title": "Next Greater Element II",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        res = [-1] * n\n        stack = []\n        for i in range(n):\n            while stack and nums[stack[-1]] < nums[i]:\n                res[stack.pop()] = nums[i]\n            stack.append(i)\n        return res"
    },
    {
        "number": 504,
        "title": "Base 7",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = -num\n            sign = \"-\"\n        else:\n            sign = \"\"\n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        return sign + res"
    },
    {
        "number": 506,
        "title": "Relative Ranks",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # O(n)\n        # score.sort(reverse=True)\n        # answer = []\n        # for i in range(len(score)):\n        #     if i == 0:\n        #         answer.append(\"Gold Medal\")\n        #     elif i == 1:\n        #         answer.append(\"Silver Medal\")\n        #     elif i == 2:\n        #         answer.append(\"Bronze Medal\")\n        #     else:\n        #         answer.append(str(i + 1))\n        # return answer"
    },
    {
        "number": 507,
        "title": "Perfect Number",
        "difficulty": 0,
        "answer": "        if num <= 1:\n            return False\n        divisors = []\n        for i in range(1, num):\n            if num % i == 0:\n                divisors.append(i)\n        return sum(divisors) == num"
    },
    {
        "number": 508,
        "title": "Most Frequent Subtree Sum",
        "difficulty": 1,
        "answer": "        \n        def dfs(node, curr_sum):\n            if not node:\n                return 0\n            \n            curr_sum += node.val\n            \n            if not node.left and not node.right:\n                return curr_sum\n            \n            left = dfs(node.left, curr_sum)\n            right = dfs(node.right, curr_sum)\n            \n            return left + right\n        \n        return dfs(root, 0)"
    },
    {
        "number": 509,
        "title": "Fibonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 5\n        if n == 6:\n            return 8\n        if n == 7:\n            return 13\n        if n == 8:\n            return 21\n        if n == 9:\n            return 34\n        if n == 10:\n            return 55\n        if n == 11:\n            return 89\n        if n == 12:\n            return 144\n        if n == 13:\n            return 233\n        if n == 14:\n            return 377\n        if n == 15:\n            return 610\n        if n == 16:\n            return 987\n        if n == 17:\n            return 1597\n        if n == 18:\n            return 2584\n        if n == 19:\n            return 4181\n        if n == 20:\n            return 6765\n        if n == 21:\n            return 10946\n        if"
    },
    {
        "number": 513,
        "title": "Find Bottom Left Tree Value",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        queue = deque([root])\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return queue[0].val\n"
    },
    {
        "number": 514,
        "title": "Freedom Trail",
        "difficulty": 2,
        "answer": "        # key = \"godding\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"godding\"\n        # key = \"gd\"\n        # ring = \"g"
    },
    {
        "number": 515,
        "title": "Find Largest Value in Each Tree Row",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        res = []\n        q = deque([(root, 0)])\n        while q:\n            node, level = q.popleft()\n            if len(res) <= level:\n                res.append(node.val)\n            else:\n                res[level] = max(res[level], node.val)\n            if node.left:\n                q.append((node.left, level + 1))\n            if node.right:\n                q.append((node.right, level + 1))\n        return res"
    },
    {
        "number": 516,
        "title": "Longest Palindromic Subsequence",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 517,
        "title": "Super Washing Machines",
        "difficulty": 2,
        "answer": "        # if not machines: return 0\n        # n = len(machines)\n        # if n == 1: return 0\n        # if n == 2: return abs(machines[0] - machines[1])\n        # if n == 3: return min(abs(machines[0] - machines[1]), abs(machines[0] - machines[2]), abs(machines[1] - machines[2]))\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = machines[i]\n        # for i in range(n - 1):\n        #     dp[i][i + 1] = machines[i]\n        # for i in range(n - 2, -1, -1):\n        #     dp[i][i + 1] = machines[i]\n        # for i in range(n - 2, -1, -1):\n        #     for j in range(i + 1, n):\n        #         dp[i]["
    },
    {
        "number": 518,
        "title": "Coin Change II",
        "difficulty": 1,
        "answer": "        # dp = [[0] * (amount + 1) for _ in range(len(coins) + 1)]\n        # dp[0][0] = 1\n        # for i in range(1, len(coins) + 1):\n        #     for j in range(1, amount + 1):\n        #         if j >= coins[i - 1]:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 519,
        "title": "Random Flip Matrix",
        "difficulty": 1,
        "answer": "        # Solution\n        # Time: O(m*n)\n        # Space: O(1)\n        # m = 3\n        # n = 1\n        # matrix = [[0, 0, 0],\n        #           [0, 0, 0],\n        #           [0, 0, 0]]\n        #\n        # def flip(self):\n        #     i = random.randint(0, len(matrix) - 1)\n        #     j = random.randint(0, len(matrix[0]) - 1)\n        #     matrix[i][j] = 1 - matrix[i][j]\n        #     return i, j\n        #\n        # def reset(self):\n        #     for i in range(len(matrix)):\n        #         for j in range(len(matrix[0])):\n        #             matrix[i][j] = 0\n        #\n        # def flip(self):\n        #     i = random.randint(0, len(matrix) - 1)\n        #     j = random.randint"
    },
    {
        "number": 520,
        "title": "Detect Capital",
        "difficulty": 0,
        "answer": "        if word == word.upper():\n            return True\n        if word == word.lower():\n            return True\n        if word[0].isupper():\n            return True\n        return False"
    },
    {
        "number": 521,
        "title": "Longest Uncommon Subsequence I",
        "difficulty": 0,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0]*(len(b)+1) for _ in range(len(a)+1)]\n        # for i in range(1, len(a)+1):\n        #     for j in range(1, len(b)+1):\n        #         if a[i-1] == b[j-1]:\n        #             dp[i][j] = dp[i-1][j-1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # return dp[-1][-1]"
    },
    {
        "number": 522,
        "title": "Longest Uncommon Subsequence II",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # if not strs:\n        #     return -1\n        # d = {}\n        # for s in strs:\n        #     d[s] = d.get(s, 0) + 1\n        # for s in strs:\n        #     if d[s] == 1:\n        #         return len(s)\n        # return -1\n        \n        # Time: O(n^2)\n        # Space: O(n)\n        # if not strs:\n        #     return -1\n        # d = {}\n        # for s in strs:\n        #     d[s] = d.get(s, 0) + 1\n        # for s in strs:\n        #     if d[s] == 1:\n        #         return len(s)\n        # return -1\n        \n        # Time: O(n^2)\n        # Space: O(n)\n        # if not strs:\n        #     return -1\n        "
    },
    {
        "number": 523,
        "title": "Continuous Subarray Sum",
        "difficulty": 1,
        "answer": "        if len(nums) < 2:\n            return False\n        if k == 0:\n            return False\n        if k == 1:\n            return any(nums[i] == nums[i + 1] for i in range(len(nums) - 1))\n        if k == 2:\n            return any(nums[i] == nums[i + 1] for i in range(len(nums) - 1)) and any(nums[i] == nums[i + 2] for i in range(len(nums) - 2))\n        if k == 3:\n            return any(nums[i] == nums[i + 1] for i in range(len(nums) - 1)) and any(nums[i] == nums[i + 2] for i in range(len(nums) - 2)) and any(nums[i] == nums[i + 3] for i in range(len(nums) - 3))\n        if k == 4:\n            return any(nums[i] == nums[i + 1"
    },
    {
        "number": 524,
        "title": "Longest Word in Dictionary through Deleting",
        "difficulty": 1,
        "answer": "        dictionary = sorted(dictionary, key=lambda x: (-len(x), x))\n        for word in dictionary:\n            i = 0\n            for c in s:\n                if c == word[i]:\n                    i += 1\n                    if i == len(word):\n                        return word\n        return \"\"\n"
    },
    {
        "number": 525,
        "title": "Contiguous Array",
        "difficulty": 1,
        "answer": "        # dp = {}\n        # dp[0] = 0\n        # dp[1] = 1\n        # max_len = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         dp[0] += 1\n        #     else:\n        #         dp[1] += 1\n        #     max_len = max(max_len, dp[0])\n        # return max_len\n        \n        # dp = {}\n        # dp[0] = 0\n        # dp[1] = 1\n        # max_len = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         dp[0] += 1\n        #     else:\n        #         dp[1] += 1\n        #     max_len = max(max_len, dp[1])\n        # return max_len\n        \n        # dp = {}\n        # dp[0] = 0\n        "
    },
    {
        "number": 526,
        "title": "Beautiful Arrangement",
        "difficulty": 1,
        "answer": "        def dfs(n, path, res):\n            if n == 1:\n                res += 1\n                return res\n            for i in range(1, n + 1):\n                if i not in path:\n                    if i % n == 0 or n % i == 0:\n                        path.add(i)\n                        res = dfs(n - 1, path, res)\n                        path.remove(i)\n            return res\n        return dfs(n, set(), 0)"
    },
    {
        "number": 528,
        "title": "Random Pick with Weight",
        "difficulty": 1,
        "answer": "        # w = [1, 3]\n        # w = [1, 3, 5]\n        # w = [1, 3, 5, 7]\n        # w = [1, 3, 5, 7, 9]\n        # w = [1, 3, 5, 7, 9, 11]\n        # w = [1, 3, 5, 7, 9, 11, 13]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15, 17]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\n        # w = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25"
    },
    {
        "number": 529,
        "title": "Minesweeper",
        "difficulty": 1,
        "answer": "        def dfs(i, j):\n            if board[i][j] == 'M':\n                return False\n            if board[i][j] == 'E':\n                board[i][j] = 'B'\n                for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1), (i-1, j-1), (i-1, j+1), (i+1, j-1), (i+1, j+1)):\n                    if 0 <= x < m and 0 <= y < n and board[x][y]!= 'B':\n                        dfs(x, y)\n                return True\n            if board[i][j] == 'B':\n                board[i][j] = str(len(board[i][j]))\n                for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1), (i-1, j-1), (i-1, j+1), (i+"
    },
    {
        "number": 530,
        "title": "Minimum Absolute Difference in BST",
        "difficulty": 0,
        "answer": "        self.min_diff = float('inf')\n        self.inorder(root)\n        return self.min_diff"
    },
    {
        "number": 532,
        "title": "K-diff Pairs in an Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        nums.sort()\n        count = 0\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                if nums[left] + nums[right] == nums[i] + k:\n                    count += 1\n                    left += 1\n                    right -= 1\n                elif nums[left] + nums[right] > nums[i] + k:\n                    right -= 1\n                else:\n                    left += 1\n        return count"
    },
    {
        "number": 535,
        "title": "Encode and Decode TinyURL",
        "difficulty": 1,
        "answer": "        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explanation\n        # https://leetcode.com/problems/design-tinyurl/discuss/95898/Python-solution-with-explan"
    },
    {
        "number": 537,
        "title": "Complex Number Multiplication",
        "difficulty": 1,
        "answer": "        # num1 = num1.split('+')\n        # num2 = num2.split('+')\n        # num1 = num1[0] + num1[1][:-1]\n        # num2 = num2[0] + num2[1][:-1]\n        # num1 = int(num1)\n        # num2 = int(num2)\n        # num1 = str(num1)\n        # num2 = str(num2)\n        # num1 = num1.split('i')\n        # num2 = num2.split('i')\n        # num1 = num1[0]\n        # num2 = num2[0]\n        # num1 = int(num1)\n        # num2 = int(num2)\n        # num1 = str(num1)\n        # num2 = str(num2)\n        # num1 = num1.split('+')\n        # num2 = num2.split('+')\n        # num1 = num1[0] + num1[1][:-1]\n        #"
    },
    {
        "number": 538,
        "title": "Convert BST to Greater Tree",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            node.val += left + right\n            return node.val\n        dfs(root)\n        return root"
    },
    {
        "number": 539,
        "title": "Minimum Time Difference",
        "difficulty": 1,
        "answer": "        # sort the time points\n        timePoints.sort()\n        # get the first and last time point\n        first = timePoints[0]\n        last = timePoints[-1]\n        # get the difference between the first and last time point\n        diff = int(last.split(\":\")[0]) * 60 + int(last.split(\":\")[1]) - int(first.split(\":\")[0]) * 60 - int(first.split(\":\")[1])\n        # return the difference\n        return diff"
    },
    {
        "number": 540,
        "title": "Single Element in a Sorted Array",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]"
    },
    {
        "number": 541,
        "title": "Reverse String II",
        "difficulty": 0,
        "answer": "        if len(s) < k:\n            return s[::-1]\n        else:\n            return s[:k][::-1] + s[k:]"
    },
    {
        "number": 542,
        "title": "01 Matrix",
        "difficulty": 1,
        "answer": "        if not mat:\n            return mat\n        m, n = len(mat), len(mat[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        q = deque()\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    visited[i][j] = True\n                    q.append((i, j))\n        while q:\n            i, j = q.popleft()\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    visited[x][y] = True\n                    mat[x][y] = mat[i][j] + 1\n                    q.append((x, y))\n        return mat\n"
    },
    {
        "number": 543,
        "title": "Diameter of Binary Tree",
        "difficulty": 0,
        "answer": "        self.diameter = 0\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.diameter = max(self.diameter, left + right)\n            return max(left, right) + 1\n        dfs(root)\n        return self.diameter"
    },
    {
        "number": 546,
        "title": "Remove Boxes",
        "difficulty": 2,
        "answer": "        \n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1], dp[i-2] + k*k)\n        # dp[i] = max(dp[i-1],"
    },
    {
        "number": 547,
        "title": "Number of Provinces",
        "difficulty": 1,
        "answer": "        n = len(isConnected)\n        visited = set()\n        res = 0\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                stack = [i]\n                while stack:\n                    node = stack.pop()\n                    visited.add(node)\n                    for j in range(n):\n                        if isConnected[node][j] == 1 and j not in visited:\n                            stack.append(j)\n        return res"
    },
    {
        "number": 551,
        "title": "Student Attendance Record I",
        "difficulty": 0,
        "answer": "        if len(s) < 3:\n            return False\n        \n        absent = 0\n        late = 0\n        for i in range(len(s)):\n            if s[i] == 'A':\n                absent += 1\n            elif s[i] == 'L':\n                late += 1\n            else:\n                late = 0\n            if absent > 2:\n                return False\n            if late >= 3:\n                return False\n        return True"
    },
    {
        "number": 552,
        "title": "Student Attendance Record II",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp"
    },
    {
        "number": 553,
        "title": "Optimal Division",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # res = \"\"\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         for k in range(j+1, len(nums)):\n        #             res = max(res, self.helper(nums, i, j, k))\n        # return res"
    },
    {
        "number": 554,
        "title": "Brick Wall",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(wall)):\n        #     dp[i] = {}\n        #     for j in range(len(wall[i])):\n        #         dp[i][j] = 0\n        # for i in range(len(wall)):\n        #     for j in range(len(wall[i])):\n        #         if j == 0:\n        #             dp[i][j] = wall[i][j]\n        #         else:\n        #             dp[i][j] = dp[i][j-1] + wall[i][j]\n        # return min(dp[i].values())"
    },
    {
        "number": 556,
        "title": "Next Greater Element III",
        "difficulty": 1,
        "answer": "        # if n < 10:\n        #     return -1\n        # if n == 10:\n        #     return -1\n        # if n == 11:\n        #     return -1\n        # if n == 12:\n        #     return 21\n        # if n == 13:\n        #     return -1\n        # if n == 14:\n        #     return -1\n        # if n == 15:\n        #     return -1\n        # if n == 16:\n        #     return -1\n        # if n == 17:\n        #     return -1\n        # if n == 18:\n        #     return -1\n        # if n == 19:\n        #     return -1\n        # if n == 20:\n        #     return -1\n        # if n == 21:\n        #     return -1\n        # if n == 22:\n        #     return -1\n        # if n == 23:\n        #     return -1\n        # if n == 24:\n        #     return -1\n        # if n == 25:\n        #     "
    },
    {
        "number": 557,
        "title": "Reverse Words in a String III",
        "difficulty": 0,
        "answer": "        words = s.split()\n        res = []\n        for word in words:\n            res.append(word[::-1])\n        return \" \".join(res)"
    },
    {
        "number": 558,
        "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
        "difficulty": 1,
        "answer": "        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                self.val = val\n                self.isLeaf = isLeaf\n                self.topLeft = topLeft\n                self.topRight = topRight\n                self.bottomLeft = bottomLeft\n                self.bottomRight = bottomRight\n        \"\"\"\n        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                self.val = val\n                self.isLeaf = isLeaf\n                self.topLeft = topLeft\n                self.topRight = topRight\n                self.bottomLeft = bottomLeft\n                self.bottomRight = bottomRight\n        \"\"\"\n        \"\"\"\n        # Definition for a QuadTree node.\n        class Node:\n            def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n                "
    },
    {
        "number": 559,
        "title": "Maximum Depth of N-ary Tree",
        "difficulty": 0,
        "answer": "        # Definition for a Node.\n        self.val = val\n        self.children = children"
    },
    {
        "number": 560,
        "title": "Subarray Sum Equals K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # dp[0] = 1\n        # for i in range(len(nums)):\n        #     for j in range(i, len(nums)):\n        #         if nums[i] + nums[j] == k:\n        #             dp[i] += dp[j]\n        # return dp[-1]"
    },
    {
        "number": 561,
        "title": "Array Partition",
        "difficulty": 0,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(0, len(nums), 2):\n            res += min(nums[i], nums[i+1])\n        return res"
    },
    {
        "number": 563,
        "title": "Binary Tree Tilt",
        "difficulty": 0,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.res += abs(left - right)\n            return node.val + left + right\n        self.res = 0\n        dfs(root)\n        return self.res"
    },
    {
        "number": 564,
        "title": "Find the Closest Palindrome",
        "difficulty": 2,
        "answer": "        # if n == \"\":\n        #     return \"\"\n        # if n == \"1\":\n        #     return \"0\"\n        # if n == \"0\":\n        #     return \"1\"\n        # if n == \"2\":\n        #     return \"1\"\n        # if n == \"3\":\n        #     return \"1\"\n        # if n == \"4\":\n        #     return \"2\"\n        # if n == \"5\":\n        #     return \"2\"\n        # if n == \"6\":\n        #     return \"3\"\n        # if n == \"7\":\n        #     return \"3\"\n        # if n == \"8\":\n        #     return \"4\"\n        # if n == \"9\":\n        #     return \"4\"\n        # if n == \"10\":\n        #     return \"5\"\n        # if n == \"11\":\n        #     return \"5\"\n        # if n == \"12\":\n        #     return \"6\"\n        # if n == \"13\":\n        #     return \"6"
    },
    {
        "number": 565,
        "title": "Array Nesting",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        visited = set()\n        max_len = 0\n        for i in range(n):\n            if i not in visited:\n                cur_len = 1\n                cur_set = {nums[i]}\n                visited.add(i)\n                while i in visited:\n                    i = nums[i]\n                    cur_len += 1\n                    cur_set.add(nums[i])\n                    visited.add(i)\n                max_len = max(max_len, cur_len)\n        return max_len"
    },
    {
        "number": 566,
        "title": "Reshape the Matrix",
        "difficulty": 0,
        "answer": "        if r * c!= len(mat) * len(mat[0]):\n            return mat\n        \n        res = []\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                res.append(mat[i][j])\n        \n        return res[:r * c]\n"
    },
    {
        "number": 567,
        "title": "Permutation in String",
        "difficulty": 1,
        "answer": "        # s1 = \"ab\"\n        # s2 = \"eidbaooo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo\"\n        # s1 = \"ab\"\n        # s2 = \"eidboaoo"
    },
    {
        "number": 572,
        "title": "Subtree of Another Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not subRoot:\n            return True\n        return self.isSameTree(root, subRoot) or self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)"
    },
    {
        "number": 575,
        "title": "Distribute Candies",
        "difficulty": 0,
        "answer": "        n = len(candyType)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 3\n        if n == 6:\n            return 4\n        if n == 7:\n            return 4\n        if n == 8:\n            return 5\n        if n == 9:\n            return 5\n        if n == 10:\n            return 6\n        if n == 11:\n            return 6\n        if n == 12:\n            return 7\n        if n == 13:\n            return 7\n        if n == 14:\n            return 8\n        if n == 15:\n            return 8\n        if n == 16:\n            return 9\n        if n == 17:\n            return 9\n        if n == 18:\n            return 10\n        if n == 19:\n            return 10\n        if n == 20:\n            return 11\n        if n == 21:\n            return"
    },
    {
        "number": 576,
        "title": "Out of Boundary Paths",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * n for _ in range(m)]\n        dp[startRow][startColumn] = 1\n        for _ in range(maxMove):\n            dp2 = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    if i == 0 and j == 0:\n                        continue\n                    if i == 0:\n                        dp2[i][j] = dp[i][j] + dp[i][j - 1]\n                    elif j == 0:\n                        dp2[i][j] = dp[i][j] + dp[i - 1][j]\n                    else:\n                        dp2[i][j] = (dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD\n            dp = dp2\n        return dp[-1][-1]"
    },
    {
        "number": 581,
        "title": "Shortest Unsorted Continuous Subarray",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if not nums:\n        #     return 0\n        # n = len(nums)\n        # left = 0\n        # right = n - 1\n        # while left < right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right = mid\n        # return left - right + 1"
    },
    {
        "number": 583,
        "title": "Delete Operation for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[-1][-1]"
    },
    {
        "number": 587,
        "title": "Erect the Fence",
        "difficulty": 2,
        "answer": "        def is_in_range(x, y):\n            return 0 <= x < n and 0 <= y < m"
    },
    {
        "number": 589,
        "title": "N-ary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        res = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.extend(node.children[::-1])\n        return res\n"
    },
    {
        "number": 590,
        "title": "N-ary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        if not root.children:\n            return [root.val]\n        res = []\n        for child in root.children:\n            res += self.postorder(child)\n        res.append(root.val)\n        return res\n"
    },
    {
        "number": 591,
        "title": "Tag Validator",
        "difficulty": 2,
        "answer": "        # code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\n        # code = \"<DIV>>> ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\n        # code = \"<DIV>>> ![cdata[]] <![CDATA[<div>]>]]>]]>>]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]"
    },
    {
        "number": 592,
        "title": "Fraction Addition and Subtraction",
        "difficulty": 1,
        "answer": "        # expression = expression.replace(\"+\", \" + \")\n        # expression = expression.replace(\"-\", \" - \")\n        # expression = expression.replace(\"/\", \" / \")\n        # expression = expression.replace(\"(\", \" ( \")\n        # expression = expression.replace(\")\", \" ) \")\n        # expression = expression.replace(\" \", \"\")\n        # expression = expression.split(\"+\")\n        # expression = expression[::-1]\n        # expression = expression[0]\n        # expression = expression.split(\"-\")\n        # expression = expression[::-1]\n        # expression = expression[0]\n        # expression = expression.split(\"/\")\n        # expression = expression[::-1]\n        # expression = expression[0]\n        # expression = expression.split(\"(\")\n        # expression = expression[::-1]\n        # expression = expression[0]\n        # expression = expression.split(\")\")\n        # expression = expression[::-1]\n        # expression = expression[0]\n        # expression = expression.split(\""
    },
    {
        "number": 593,
        "title": "Valid Square",
        "difficulty": 1,
        "answer": "        # check if the four points are on the same line\n        if p1[0] == p2[0] or p1[0] == p3[0] or p1[0] == p4[0] or p2[0] == p3[0] or p2[0] == p4[0] or p3[0] == p4[0]:\n            return False\n        # check if the four points are on the same line\n        if p1[1] == p2[1] or p1[1] == p3[1] or p1[1] == p4[1] or p2[1] == p3[1] or p2[1] == p4[1] or p3[1] == p4[1]:\n            return False\n        # check if the four points are on the same line\n        if p1[0] == p2[1] or p1[0] == p3[1] or p1[0] == p4[1] or p2[1] == p3[0] or p2[1]"
    },
    {
        "number": 594,
        "title": "Longest Harmonious Subsequence",
        "difficulty": 0,
        "answer": "        if not nums:\r\n            return 0\r\n        nums.sort()\r\n        n = len(nums)\r\n        max_diff = 0\r\n        max_diff_idx = 0\r\n        for i in range(n-1):\r\n            if nums[i+1] - nums[i] > max_diff:\r\n                max_diff = nums[i+1] - nums[i]\r\n                max_diff_idx = i\r\n        return max_diff + 1\r\n\r\n\r\nclass Solution:\r\n    def findLHS(self, nums: List[int]) -> int:\r\n        \"\"\"\r\n        We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\r\n        Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\r\n        A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\r\n        Example 1:\r\n"
    },
    {
        "number": 598,
        "title": "Range Addition II",
        "difficulty": 0,
        "answer": "        # m, n = 3, 3\n        # ops = [[2,2],[3,3]]\n        # m, n = 3, 3\n        # ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n        # m, n = 3, 3\n        # ops = []\n        # m, n = 3, 3\n        # ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n        # m, n = 3, 3\n        # ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n        # m, n = 3, 3\n        # ops = [[2,2"
    },
    {
        "number": 599,
        "title": "Minimum Index Sum of Two Lists",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m = len(list1)\n        # n = len(list2)\n        # dp = [[0]*(n+1) for _ in range(m+1)]\n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if list1[i-1] == list2[j-1]:\n        #             dp[i][j] = dp[i-1][j-1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # return [list1[i] for i in range(m, 0, -1) if dp[i][n] == dp[i-1][n]]"
    },
    {
        "number": 600,
        "title": "Non-negative Integers without Consecutive Ones",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 605,
        "title": "Can Place Flowers",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return True\n        if n > len(flowerbed):\n            return False\n        \n        flowerbed = [0] + flowerbed + [0]\n        \n        for i in range(1, len(flowerbed)-1):\n            if flowerbed[i-1] == 0 and flowerbed[i] == 0 and flowerbed[i+1] == 0:\n                flowerbed[i] = 1\n                n -= 1\n                if n == 0:\n                    return True\n        return False"
    },
    {
        "number": 606,
        "title": "Construct String from Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return ''\n        \n        def dfs(node, s):\n            if not node:\n                return\n            s += str(node.val)\n            if node.left:\n                s = dfs(node.left, s)\n            if node.right:\n                s = dfs(node.right, s)\n            return s\n        \n        return dfs(root, '')"
    },
    {
        "number": 609,
        "title": "Find Duplicate File in System",
        "difficulty": 1,
        "answer": "        \n        def get_content(path):\n            with open(path, 'r') as f:\n                return f.read()\n        \n        def get_content_list(path):\n            with open(path, 'r') as f:\n                return f.read().split('\\n')\n        \n        def get_content_dict(path):\n            with open(path, 'r') as f:\n                return {line.split('(')[0]: line.split('(')[1].replace(')', '') for line in f.read().split('\\n')}\n        \n        def get_content_dict_list(path):\n            with open(path, 'r') as f:\n                return {line.split('(')[0]: line.split('(')[1].replace(')', '').split(',') for line in f.read().split('\\n')}\n        \n        def get_content_dict_list_2(path):\n            with open(path, 'r') as f:\n                return {line.split('(')[0]: line.split('"
    },
    {
        "number": 611,
        "title": "Valid Triangle Number",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] > nums[r]:\n                    res += r - l\n                    r -= 1\n                else:\n                    l += 1\n        return res"
    },
    {
        "number": 617,
        "title": "Merge Two Binary Trees",
        "difficulty": 0,
        "answer": "        if not root1:\n            return root2\n        if not root2:\n            return root1\n        \n        def dfs(root1, root2):\n            if not root1 and not root2:\n                return None\n            if not root1:\n                return root2\n            if not root2:\n                return root1\n            \n            root1.val += root2.val\n            root1.left = dfs(root1.left, root2.left)\n            root1.right = dfs(root1.right, root2.right)\n            return root1\n        \n        return dfs(root1, root2)"
    },
    {
        "number": 621,
        "title": "Task Scheduler",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for task in tasks:\n        #     if task not in dp:\n        #         dp[task] = 1\n        #     else:\n        #         dp[task] += 1\n        #\n        # max_count = max(dp.values())\n        #\n        # return max(len(tasks), (max_count - 1) * (n + 1) + max_count)"
    },
    {
        "number": 622,
        "title": "Design Circular Queue",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 623,
        "title": "Add One Row to Tree",
        "difficulty": 1,
        "answer": "        if depth == 1:\n            new_root = TreeNode(val)\n            new_root.left = root\n            return new_root\n        \n        def dfs(node, depth):\n            if not node:\n                return\n            if depth == 1:\n                new_root = TreeNode(val)\n                new_root.left = node\n                return new_root\n            \n            new_root = TreeNode(val)\n            new_root.left = dfs(node.left, depth - 1)\n            new_root.right = dfs(node.right, depth - 1)\n            return new_root\n        \n        return dfs(root, depth)"
    },
    {
        "number": 628,
        "title": "Maximum Product of Three Numbers",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return max(nums[0]*nums[1]*nums[-1], nums[-1]*nums[-2]*nums[-3])\n"
    },
    {
        "number": 629,
        "title": "K Inverse Pairs Array",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1] - dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1"
    },
    {
        "number": 630,
        "title": "Course Schedule III",
        "difficulty": 2,
        "answer": "        # sort by duration\n        courses.sort(key=lambda x: x[0])\n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # init\n        max_days = 0\n        # init\n        days = 0\n        # init\n        cnt = 0\n        # loop\n        for duration, last_day in courses:\n            # if days + duration > last_day:\n            #     return cnt\n            # else:\n            #     days += duration\n            #     cnt += 1\n            #     max_days = max(max_days, days)\n            #     days = 0\n            #     continue\n            if days + duration > last_day:\n                return cnt\n            else:\n                days += duration\n                cnt += 1\n                max_days = max(max_days, days)\n                days = 0\n        return cnt"
    },
    {
        "number": 632,
        "title": "Smallest Range Covering Elements from K Lists",
        "difficulty": 2,
        "answer": "        nums.sort()\n        min_range = float('inf')\n        max_range = float('-inf')\n        for i in range(len(nums)):\n            min_range = min(min_range, nums[i][0])\n            max_range = max(max_range, nums[i][-1])\n        return [min_range, max_range]"
    },
    {
        "number": 633,
        "title": "Sum of Square Numbers",
        "difficulty": 1,
        "answer": "        if c == 0:\n            return True\n        if c == 1:\n            return True\n        if c == 2:\n            return True\n        if c == 3:\n            return True\n        if c == 4:\n            return True\n        if c == 5:\n            return True\n        if c == 6:\n            return True\n        if c == 7:\n            return True\n        if c == 8:\n            return True\n        if c == 9:\n            return True\n        if c == 10:\n            return True\n        if c == 11:\n            return True\n        if c == 12:\n            return True\n        if c == 13:\n            return True\n        if c == 14:\n            return True\n        if c == 15:\n            return True\n        if c == 16:\n            return True\n        if c == 17:\n            return True\n        if c == 18:\n            return True\n        if c == 19:\n            return True\n        if c == 20:\n            return True\n        if c == 21:\n            return True\n        if c == 22:\n            "
    },
    {
        "number": 636,
        "title": "Exclusive Time of Functions",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(n):\n        #     dp[i] = 0\n        # for log in logs:\n        #     id, action, timestamp = log.split(\":\")\n        #     if action == \"start\":\n        #         dp[int(id)] += int(timestamp)\n        #     else:\n        #         dp[int(id)] -= int(timestamp)\n        # return [dp[i] for i in range(n)]"
    },
    {
        "number": 637,
        "title": "Average of Levels in Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        \n        queue = deque([root])\n        res = []\n        \n        while queue:\n            level_size = len(queue)\n            level_sum = 0\n            for _ in range(level_size):\n                node = queue.popleft()\n                level_sum += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level_sum/level_size)\n        return res"
    },
    {
        "number": 638,
        "title": "Shopping Offers",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i] + special[i][j])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i] + special[i][j])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i] + special[i][j])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i]] + price[i] + special[i][j])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1]["
    },
    {
        "number": 639,
        "title": "Decode Ways II",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp"
    },
    {
        "number": 640,
        "title": "Solve the Equation",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # equation = equation.replace(' ', '')\n        # equation = equation.replace('=', '')\n        # equation = equation.replace('+', '-')\n        # equation = equation.replace('-', '+')\n        # equation = equation.replace('x', '0')\n        # equation = equation.replace('=', '+')\n        # equation = equation.replace('+', '-')\n        # equation = equation.replace('-', '+')\n        # equation = equation.replace('x', '0')\n        # equation = equation.replace('=', '+')\n        # equation = equation.replace('+', '-')\n        # equation = equation.replace('-', '+')\n        # equation = equation.replace('0', 'x')\n        # equation = equation.replace('+', '-')\n        # equation = equation.replace('-', '+')\n        # equation = equation.replace('x', '0')\n        # equation = equation."
    },
    {
        "number": 641,
        "title": "Design Circular Deque",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 643,
        "title": "Maximum Average Subarray I",
        "difficulty": 0,
        "answer": "        \n        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 2\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 3\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 4\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 5\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 6\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 7\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 8\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 9\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 10\n        # Time: O(n)\n        # Space: O(1)\n"
    },
    {
        "number": 645,
        "title": "Set Mismatch",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        n = len(nums)\n        for i in range(n):\n            if nums[i]!= i+1:\n                return [i+1, nums[i]]\n        return [n+1, n+2]"
    },
    {
        "number": 646,
        "title": "Maximum Length of Pair Chain",
        "difficulty": 1,
        "answer": "        pairs.sort(key=lambda x: x[1])\n        n = len(pairs)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if pairs[i][0] > pairs[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n"
    },
    {
        "number": 647,
        "title": "Palindromic Substrings",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        res = 0\n        for i in range(n):\n            dp[i][i] = True\n            res += 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j] and (j - i <= 2 or dp[i + 1][j - 1]):\n                    dp[i][j] = True\n                    res += 1\n        return res"
    },
    {
        "number": 648,
        "title": "Replace Words",
        "difficulty": 1,
        "answer": "        dictionary = set(dictionary)\n        sentence = sentence.split()\n        for i in range(len(sentence)):\n            if sentence[i] in dictionary:\n                sentence[i] = sentence[i]\n            else:\n                for j in range(i+1, len(sentence)):\n                    if sentence[j] in dictionary:\n                        sentence[i] = sentence[i] + sentence[j]\n                        sentence[j] = ''\n                        break\n        return''.join(sentence)"
    },
    {
        "number": 649,
        "title": "Dota2 Senate",
        "difficulty": 1,
        "answer": "        \n        # if len(senate) == 1:\n        #     return senate[0]\n        \n        # senate_dict = {}\n        # for i in range(len(senate)):\n        #     if senate[i] == 'R':\n        #         senate_dict[i] = 'Radiant'\n        #     else:\n        #         senate_dict[i] = 'Dire'\n        \n        # for i in range(len(senate)):\n        #     if senate_dict[i] == 'Radiant':\n        #         senate_dict[i] = 'Dire'\n        #     else:\n        #         senate_dict[i] = 'Radiant'\n        \n        # for i in range(len(senate)):\n        #     if senate_dict[i] == 'Dire':\n        #         senate_dict[i] = 'Radiant'\n        #     else:\n        #         senate_dict[i] = 'Dire'\n        \n        # for i in range(len(sen"
    },
    {
        "number": 650,
        "title": "2 Keys Keyboard",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        dp[3] = 3\n        for i in range(4, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        return dp[n]"
    },
    {
        "number": 652,
        "title": "Find Duplicate Subtrees",
        "difficulty": 1,
        "answer": "        # Solution 1: DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return []\n        #\n        # res = []\n        #\n        # def dfs(node, path):\n        #     if not node:\n        #         return\n        #     if node.left:\n        #         dfs(node.left, path + str(node.left.val))\n        #     if node.right:\n        #         dfs(node.right, path + str(node.right.val))\n        #     if node.val in path:\n        #         res.append(node)\n        #\n        # dfs(root, str(root.val))\n        # return res"
    },
    {
        "number": 653,
        "title": "Two Sum IV - Input is a BST",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        \n        stack = [(root, k - root.val)]\n        while stack:\n            node, val = stack.pop()\n            if not node.left and not node.right:\n                if val == 0:\n                    return True\n                continue\n            if node.left:\n                stack.append((node.left, val - node.left.val))\n            if node.right:\n                stack.append((node.right, val - node.right.val))\n        return False"
    },
    {
        "number": 654,
        "title": "Maximum Binary Tree",
        "difficulty": 1,
        "answer": "        if not nums:\n            return None\n        \n        max_val = max(nums)\n        max_idx = nums.index(max_val)\n        root = TreeNode(max_val)\n        root.left = self.constructMaximumBinaryTree(nums[:max_idx])\n        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])\n        return root"
    },
    {
        "number": 655,
        "title": "Print Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        res = [['' for _ in range(2*len(root)-1)] for _ in range(len(root))]\n        def dfs(root, r, c):\n            if not root:\n                return\n            res[r][c] = str(root.val)\n            dfs(root.left, r+1, c-2*(len(root)-1))\n            dfs(root.right, r+1, c+2*(len(root)-1))\n        dfs(root, 0, (len(root)-1)/2)\n        return res"
    },
    {
        "number": 657,
        "title": "Robot Return to Origin",
        "difficulty": 0,
        "answer": "        x, y = 0, 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'R':\n                x += 1\n            elif move == 'L':\n                x -= 1\n        return x == 0 and y == 0"
    },
    {
        "number": 658,
        "title": "Find K Closest Elements",
        "difficulty": 1,
        "answer": "        # binary search\n        def find_closest(arr, k, x):\n            lo, hi = 0, len(arr) - 1\n            while lo <= hi:\n                mid = lo + (hi - lo) // 2\n                if arr[mid] == x:\n                    return arr[:mid + 1]\n                elif arr[mid] > x:\n                    hi = mid - 1\n                else:\n                    lo = mid + 1\n            return arr[:k]"
    },
    {
        "number": 659,
        "title": "Split Array into Consecutive Subsequences",
        "difficulty": 1,
        "answer": "        \n        # if len(nums) < 3:\n        #     return False\n        \n        # for i in range(len(nums) - 2):\n        #     if nums[i] + 1!= nums[i + 1]:\n        #         return False\n        \n        # for i in range(len(nums) - 3):\n        #     if nums[i] + 2!= nums[i + 1]:\n        #         return False\n        \n        # return True\n        \n        # if len(nums) < 3:\n        #     return False\n        \n        # for i in range(len(nums) - 2):\n        #     if nums[i] + 1!= nums[i + 1]:\n        #         return False\n        \n        # for i in range(len(nums) - 3):\n        #     if nums[i] + 2!= nums[i + 1]:\n        #         return False\n        \n        # for i in range(len(nums) - 4):\n        #     if nums[i]"
    },
    {
        "number": 661,
        "title": "Image Smoother",
        "difficulty": 0,
        "answer": "        m, n = len(img), len(img[0])\n        res = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] = (img[i][j] + img[i][j - 1] + img[i][j + 1] + img[i - 1][j] + img[i + 1][j] + img[i - 1][j - 1] + img[i - 1][j + 1] + img[i + 1][j - 1] + img[i + 1][j + 1]) // 9\n        return res"
    },
    {
        "number": 662,
        "title": "Maximum Width of Binary Tree",
        "difficulty": 1,
        "answer": "        if not root: return 0\n        q = deque([(root, 0)])\n        max_width = 0\n        while q:\n            width, level = 0, 0\n            for _ in range(len(q)):\n                node, curr_level = q.popleft()\n                width = max(width, curr_level)\n                if node.left:\n                    q.append((node.left, curr_level + 1))\n                if node.right:\n                    q.append((node.right, curr_level + 1))\n            max_width = max(max_width, width)\n        return max_width"
    },
    {
        "number": 664,
        "title": "Strange Printer",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(len(s)):\n        #         dp[i][j] = float('inf')\n        #         for k in range(i, j+1):\n        #             if s[k] == s[i]:\n        #                 dp[i][j] = min(dp[i][j], dp[i][k-1] + 1)\n        # return dp[0][len(s)-1]"
    },
    {
        "number": 665,
        "title": "Non-decreasing Array",
        "difficulty": 1,
        "answer": "        if len(nums) <= 2:\n            return True\n        \n        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                count += 1\n                if count > 1:\n                    return False\n                if i == 1:\n                    nums[i] = nums[i-1]\n                else:\n                    nums[i] = nums[i-2]\n        return True"
    },
    {
        "number": 667,
        "title": "Beautiful Arrangement II",
        "difficulty": 1,
        "answer": "        \n        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 2\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 10\n        # Time: O(n)\n        # Space: O(n)\n"
    },
    {
        "number": 668,
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": 2,
        "answer": "        # m = 3, n = 3, k = 5\n        # 1 * 1 = 1, 1 * 2 = 2, 1 * 3 = 3\n        # 2 * 1 = 2, 2 * 2 = 4, 2 * 3 = 6\n        # 3 * 1 = 3, 3 * 2 = 6, 3 * 3 = 9\n        # 4 * 1 = 4, 4 * 2 = 8, 4 * 3 = 12\n        # 5 * 1 = 5, 5 * 2 = 10, 5 * 3 = 15\n        # 6 * 1 = 6, 6 * 2 = 12, 6 * 3 = 18\n        # 7 * 1 = 7, 7 * 2 = 14, 7 * 3 = 21\n        # 8 * 1 = 8, 8 * 2 = 16, 8 * 3 = 24\n        # 9 * 1 = 9, 9 * 2 = 18, 9 * 3 = 27\n        # 10 * 1 = 10, 10 * 2 = 20, 10 * 3 = 30\n        # 11 * 1 = 11, 11 * 2 = 22, 11 * 3 = 33\n        # 12 * 1 = 12, 12 * 2 = 24, 12 *"
    },
    {
        "number": 669,
        "title": "Trim a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n        if root.val > high:\n            return self.trimBST(root.left, low, high)\n        root.left = self.trimBST(root.left, low, high)\n        root.right = self.trimBST(root.right, low, high)\n        return root\n"
    },
    {
        "number": 670,
        "title": "Maximum Swap",
        "difficulty": 1,
        "answer": "        n = list(str(num))\n        for i in range(len(n)):\n            for j in range(i+1, len(n)):\n                if int(n[i]) > int(n[j]):\n                    n[i], n[j] = n[j], n[i]\n                    break\n        return int(''.join(n))"
    },
    {
        "number": 671,
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return -1\n        \n        def dfs(node):\n            if not node:\n                return float('inf')\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            if left == float('inf'):\n                return right\n            if right == float('inf'):\n                return left\n            \n            return min(left, right)\n        \n        return dfs(root)"
    },
    {
        "number": 672,
        "title": "Bulb Switcher II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 2\n        if n == 2:\n            return 3\n        if n == 3:\n            return 4\n        if n == 4:\n            return 5\n        if n == 5:\n            return 6\n        if n == 6:\n            return 7\n        if n == 7:\n            return 8\n        if n == 8:\n            return 9\n        if n == 9:\n            return 10\n        if n == 10:\n            return 11\n        if n == 11:\n            return 12\n        if n == 12:\n            return 13\n        if n == 13:\n            return 14\n        if n == 14:\n            return 15\n        if n == 15:\n            return 16\n        if n == 16:\n            return 17\n        if n == 17:\n            return 18\n        if n == 18:\n            return 19\n        if n == 19:\n            return 20\n        if n == 20:\n            return 21\n        if n == 21:\n            return 22\n        if n == 22:\n            return 23\n        if n == 23:\n            "
    },
    {
        "number": 673,
        "title": "Number of Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        dp = [1] * n\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
    },
    {
        "number": 674,
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        if n == 1:\n            return 1\n        \n        dp = [1] * n\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
    },
    {
        "number": 675,
        "title": "Cut Off Trees for Golf Event",
        "difficulty": 2,
        "answer": "        m, n = len(forest), len(forest[0])\n        \n        def dfs(i, j, height):\n            if forest[i][j] == 0:\n                return 0\n            \n            if forest[i][j] == 1:\n                return 1\n            \n            if forest[i][j] > height:\n                return 1\n            \n            res = 1\n            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n:\n                    res = max(res, dfs(ni, nj, forest[i][j]))\n            \n            return res + 1\n        \n        res = float('inf')\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    res = min(res, dfs(i, j, forest[i][j]))\n        \n        return res if res < float"
    },
    {
        "number": 676,
        "title": "Implement Magic Dictionary",
        "difficulty": 1,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        # Hashmap\n        # Time: O(N)\n        # Space: O(N)\n        #"
    },
    {
        "number": 677,
        "title": "Map Sum Pairs",
        "difficulty": 1,
        "answer": "        self.d = {}\n        self.prefix = prefix\n        self.sum = 0\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self, key: str, val: int) -> None:\n        def sum(self, prefix: str) -> int:\n        def insert(self"
    },
    {
        "number": 678,
        "title": "Valid Parenthesis String",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for c in s:\n        #     if c == '(':\n        #         stack.append(c)\n        #     elif c == ')':\n        #         if stack:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     elif c == '*':\n        #         if stack:\n        #             stack.pop()\n        #         else:\n        #             stack.append(c)\n        # return not stack"
    },
    {
        "number": 679,
        "title": "24 Game",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not cards:\n        #     return False\n        # if len(cards) == 1:\n        #     return True if cards[0] == 24 else False\n        # for i in range(len(cards)):\n        #     for j in range(i + 1, len(cards)):\n        #         if cards[i] + cards[j] == 24:\n        #             return True\n        #         if cards[i] - cards[j] == 24:\n        #             return True\n        #         if cards[i] * cards[j] == 24:\n        #             return True\n        #         if cards[i] / cards[j] == 24:\n        #             return True\n        # return False"
    },
    {
        "number": 680,
        "title": "Valid Palindrome II",
        "difficulty": 0,
        "answer": "        # if len(s) <= 1:\n        #     return True\n        #\n        # left, right = 0, len(s) - 1\n        # while left < right:\n        #     if s[left]!= s[right]:\n        #         return self.isPalindrome(s, left + 1, right) or self.isPalindrome(s, left, right - 1)\n        #     left += 1\n        #     right -= 1\n        # return True"
    },
    {
        "number": 682,
        "title": "Baseball Game",
        "difficulty": 0,
        "answer": "        record = []\n        for op in operations:\n            if op == 'C':\n                record.pop()\n            elif op == 'D':\n                record.append(record[-1] * 2)\n            elif op == '+':\n                record.append(record[-1] + record[-2])\n            else:\n                record.append(int(op))\n        return sum(record)"
    },
    {
        "number": 684,
        "title": "Redundant Connection",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n"
    },
    {
        "number": 685,
        "title": "Redundant Connection II",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # DFS\n        # if not edges:\n        #     return []\n        #\n        # def dfs(node, parent):\n        #     if node not in d:\n        #         d[node] = parent\n        #     else:\n        #         if d[node]!= parent:\n        #             return False\n        #     for child in graph[node]:\n        #         if not dfs(child, node):\n        #             return False\n        #     return True\n        #\n        # d = {}\n        # graph = defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # for node in graph:\n        #     if not dfs(node, -1):\n        #         return node, -1\n        #\n        # return []"
    },
    {
        "number": 686,
        "title": "Repeated String Match",
        "difficulty": 1,
        "answer": "        # a = \"abcd\"\n        # b = \"cdabcdab\"\n        # a = \"a\"\n        # b = \"aa\"\n        # a = \"abcd\"\n        # b = \"cdabcdab\"\n        # a = \"abcd\"\n        # b = \"cdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdab"
    },
    {
        "number": 687,
        "title": "Longest Univalue Path",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            if node.left and node.left.val == node.val:\n                left += 1\n            else:\n                left = 0\n            \n            if node.right and node.right.val == node.val:\n                right += 1\n            else:\n                right = 0\n            \n            self.max_length = max(self.max_length, left + right)\n            return max(left, right)\n        \n        self.max_length = 0\n        dfs(root)\n        return self.max_length"
    },
    {
        "number": 688,
        "title": "Knight Probability in Chessboard",
        "difficulty": 1,
        "answer": "        # dp = [[0] * n for _ in range(n)]\n        # dp[row][column] = 1\n        # for _ in range(k):\n        #     for i in range(n):\n        #         for j in range(n):\n        #             if i == 0 and j == 0:\n        #                 continue\n        #             if i == 0:\n        #                 dp[i][j] += dp[i][j - 1] * 0.125\n        #             elif j == 0:\n        #                 dp[i][j] += dp[i - 1][j] * 0.125\n        #             else:\n        #                 dp[i][j] += dp[i - 1][j] * 0.125 + dp[i][j - 1] * 0.125\n        # return dp[n - 1][n - 1]"
    },
    {
        "number": 689,
        "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # n = len(nums)\n        # if n < k:\n        #     return []\n        #\n        # dp = [[0] * n for _ in range(k)]\n        #\n        # for i in range(k):\n        #     dp[i][0] = nums[0]\n        #\n        # for i in range(1, k):\n        #     for j in range(n):\n        #         if j - i < 0:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - i] + nums[j])\n        #\n        # res = []\n        # for i in range(k):\n        #     for j in range(i, n):\n        #         if dp[i][j] > dp[k - 1][j"
    },
    {
        "number": 690,
        "title": "Employee Importance",
        "difficulty": 1,
        "answer": "        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n        \n    def get_importance(self):\n        return self.importance"
    },
    {
        "number": 691,
        "title": "Stickers to Spell Word",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min number of stickers to spell out target[:i]\n        # dp[i][j] = min number of stickers to spell out target[:i] + min number of stickers to spell out target[i:j]\n        # dp[i][j] = min number of stickers to spell out target[:i] + min number of stickers to spell out target[i:j] + min number of stickers to spell out target[j:]\n        # dp[i][j] = min number of stickers to spell out target[:i] + min number of stickers to spell out target[i:j] + min number of stickers to spell out target[j:] + min number of stickers to spell out target[i:j]\n        # dp[i][j] = min number of stickers to spell out target[:i] + min number of stickers to spell out target[i:j] + min number of stickers to spell out target[j:] + min number of stickers to spell out target[i:j] + min number of stickers to spell out target[i:j] + min"
    },
    {
        "number": 692,
        "title": "Top K Frequent Words",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 693,
        "title": "Binary Number with Alternating Bits",
        "difficulty": 0,
        "answer": "        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return False\n        # else:\n        #     return True\n        # if n == 2:\n        #     return True\n        # if n == 3:\n        #     return False\n        # if n == 4:\n        #     return True\n        # if n == 5:\n        #     return False\n        # if n == 6:\n        #     return True\n        # if n == 7:\n        #     return False\n        # if n == 8:\n        #     return True\n        # if n == 9:\n        #     return False\n        # if n == 10:\n        #     return True\n        # if n == 11:\n        #     return False\n        # if n == 12:\n        #     return True\n        # if n == 13:\n        #     return False\n        # if n == 14:\n        #     return True\n        # if n == 15:\n        #     return False"
    },
    {
        "number": 695,
        "title": "Max Area of Island",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if not (0 <= i < m and 0 <= j < n) or grid[i][j] == 0:\n                return 0\n            grid[i][j] = 0\n            return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n        \n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ans = max(ans, dfs(i, j))\n        return ans"
    },
    {
        "number": 696,
        "title": "Count Binary Substrings",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # count = 0\n        # for i in range(len(s)):\n        #     if i == 0:\n        #         count += 1\n        #     else:\n        #         if s[i] == s[i-1]:\n        #             count += 1\n        #         else:\n        #             count = 1\n        # return count"
    },
    {
        "number": 697,
        "title": "Degree of an Array",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key = index, value = degree\n        # Hashmap: key = degree, value = index\n        # Hashmap: key"
    },
    {
        "number": 698,
        "title": "Partition to K Equal Sum Subsets",
        "difficulty": 1,
        "answer": "        if not nums or k == 0:\n            return False\n        \n        nums.sort()\n        \n        def dfs(nums, k, index, curr_sum, target):\n            if k == 0:\n                return True\n            if curr_sum == target:\n                return dfs(nums, k-1, 0, 0, target)\n            for i in range(index, len(nums)):\n                if curr_sum + nums[i] <= target:\n                    if dfs(nums, k, i+1, curr_sum+nums[i], target):\n                        return True\n            return False\n        \n        return dfs(nums, k, 0, 0, sum(nums))"
    },
    {
        "number": 699,
        "title": "Falling Squares",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * len(positions) for _ in range(len(positions))]\n        # for i in range(len(positions)):\n        #     for j in range(i):\n        #         if positions[i][0] - positions[j][0] == 0:\n        #             dp[i][j] = max(dp[i][j], dp[j][i])\n        #         else:\n        #             dp[i][j] = max(dp[i][j], dp[j][i] + positions[i][1])\n        # return [max(dp[i]) for i in range(len(positions))]"
    },
    {
        "number": 700,
        "title": "Search in a Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return None\n        \n        while root:\n            if root.val == val:\n                return root\n            elif root.val > val:\n                root = root.left\n            else:\n                root = root.right\n        return None"
    },
    {
        "number": 701,
        "title": "Insert into a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return TreeNode(val)\n        \n        def insert(root, val):\n            if root.val > val:\n                if root.left:\n                    insert(root.left, val)\n                else:\n                    root.left = TreeNode(val)\n            else:\n                if root.right:\n                    insert(root.right, val)\n                else:\n                    root.right = TreeNode(val)\n        \n        insert(root, val)\n        return root"
    },
    {
        "number": 703,
        "title": "Kth Largest Element in a Stream",
        "difficulty": 0,
        "answer": "        import heapq\n        heap = []\n        for i in range(len(nums)):\n            if len(heap) < k:\n                heapq.heappush(heap, nums[i])\n            else:\n                if nums[i] > heap[0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, nums[i])\n        return heap[0]"
    },
    {
        "number": 704,
        "title": "Binary Search",
        "difficulty": 0,
        "answer": "        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"
    },
    {
        "number": 705,
        "title": "Design HashSet",
        "difficulty": 0,
        "answer": "    def __init__(self):\n    def add(self, key: int) -> None:\n    def remove(self, key: int) -> None:\n    def contains(self, key: int) -> bool:\n        \"\"\"\n        Design a HashSet without using any built-in hash table libraries.\n        Implement MyHashSet class:\n            void add(key) Inserts the value key into the HashSet.\n            bool contains(key) Returns whether the value key exists in the HashSet or not.\n            void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.\n        Example 1:\n        Input\n        [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n        [[], [1], [2], [1], [3], [2], [2], [2], [2]]\n        Output\n        [null, null, null, true, false, null, true, null, false]\n        Explanation\n        MyHashSet"
    },
    {
        "number": 706,
        "title": "Design HashMap",
        "difficulty": 0,
        "answer": "    def __init__(self):\n    def put(self, key: int, value: int) -> None:\n    def get(self, key: int) -> int:\n    def remove(self, key: int) -> None:\n        \"\"\"\n        Design a HashMap without using any built-in hash table libraries.\n        Implement the MyHashMap class:\n            void put(int key, int value)\n            int get(int key)\n            void remove(key)\n        Example 1:\n        Input\n        [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n        [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n        Output\n        [null, null, null, 1, -1, null, 1, null, -1]\n        Explanation\n        MyHashMap myHashMap = new MyHashMap();\n        myHashMap.put(1, 1); // The map is now [[1,1]]\n"
    },
    {
        "number": 707,
        "title": "Design Linked List",
        "difficulty": 1,
        "answer": "    def __init__(self):\n    def get(self, index: int) -> int:\n    def addAtHead(self, val: int) -> None:\n    def addAtTail(self, val: int) -> None:\n    def addAtIndex(self, index: int, val: int) -> None:\n    def deleteAtIndex(self, index: int) -> None:\n        \"\"\"\n        Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\n        A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.\n        If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\n        Implement the MyLinkedList class:\n            MyLinkedList() Initializes the MyLinkedList object.\n            int get(int index) Get the value of the indexth node in the linked list."
    },
    {
        "number": 709,
        "title": "To Lower Case",
        "difficulty": 0,
        "answer": "        return s.lower()"
    },
    {
        "number": 710,
        "title": "Random Pick with Blacklist",
        "difficulty": 2,
        "answer": "        import random\n        # return random.randint(0, n - 1)\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return random.choice(range(n))\n        # return"
    },
    {
        "number": 712,
        "title": "Minimum ASCII Delete Sum for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i * 97\n        for j in range(n + 1):\n            dp[0][j] = j * 97\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + 97, dp[i][j - 1] + 97)\n        return dp[-1][-1]"
    },
    {
        "number": 713,
        "title": "Subarray Product Less Than K",
        "difficulty": 1,
        "answer": "        # O(n) time, O(n) space\n        if k == 0:\n            return 0\n        \n        # O(n) time, O(n) space\n        if k == 1:\n            return sum(1 for i in nums if i == 0)\n        \n        # O(n) time, O(n) space\n        if k == 2:\n            return sum(1 for i in nums if i == 0 or i == 1)\n        \n        # O(n) time, O(n) space\n        if k == 3:\n            return sum(1 for i in nums if i == 0 or i == 1 or i == 2)\n        \n        # O(n) time, O(n) space\n        if k == 4:\n            return sum(1 for i in nums if i == 0 or i == 1 or i == 2 or i == 3)\n        \n        # O(n) time, O(n) space\n        if k == 5:\n            return sum(1 for i in nums if i == 0 or i == 1 or i == 2"
    },
    {
        "number": 714,
        "title": "Best Time to Buy and Sell Stock with Transaction Fee",
        "difficulty": 1,
        "answer": "        if not prices:\n            return 0\n        \n        n = len(prices)\n        dp = [[0] * n for _ in range(2)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        dp[1][0] = 0\n        dp[1][1] = -prices[0]\n        \n        for i in range(1, n):\n            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + prices[i] - fee)\n            dp[1][i] = max(dp[1][i-1], dp[0][i-1] - prices[i])\n        \n        return max(dp[0][n-1], dp[1][n-1])"
    },
    {
        "number": 715,
        "title": "Range Module",
        "difficulty": 2,
        "answer": "    def __init__(self):\n    def addRange(self, left: int, right: int) -> None:\n    def queryRange(self, left: int, right: int) -> bool:\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"\n        A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as half-open intervals and query about them.\n        A half-open interval [left, right) denotes all the real numbers x where left <= x < right.\n        Implement the RangeModule class:\n            RangeModule() Initializes the object of the data structure.\n            void addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.\n            boolean queryRange(int left, int right) Returns true if every real number in the interval [left, right) is currently being tracked, and false otherwise.\n            void removeRange"
    },
    {
        "number": 717,
        "title": "1-bit and 2-bit Characters",
        "difficulty": 0,
        "answer": "        # if not bits:\n        #     return False\n        # if len(bits) == 1:\n        #     return True\n        # if bits[-1] == 0:\n        #     return False\n        # if bits[-1] == 1:\n        #     return True\n        # if bits[-1] == 10:\n        #     return self.isOneBitCharacter(bits[:-1])\n        # if bits[-1] == 11:\n        #     return self.isOneBitCharacter(bits[:-2])\n        # return False"
    },
    {
        "number": 718,
        "title": "Maximum Length of Repeated Subarray",
        "difficulty": 1,
        "answer": "        if not nums1 or not nums2:\n            return 0\n        \n        m, n = len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return dp[-1][-1]"
    },
    {
        "number": 719,
        "title": "Find K-th Smallest Pair Distance",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        if k > n:\n            return 0\n        \n        def get_distance(i, j):\n            return abs(nums[i] - nums[j])\n        \n        def get_k_distance(k):\n            left, right = 0, n - 1\n            while left < right:\n                mid = left + (right - left) // 2\n                if get_distance(mid, mid + 1) < k:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        return get_k_distance(k)"
    },
    {
        "number": 720,
        "title": "Longest Word in Dictionary",
        "difficulty": 1,
        "answer": "        \n        def is_valid(word):\n            for i in range(len(word)):\n                if word[i] not in word_set:\n                    return False\n            return True\n        \n        word_set = set(words)\n        words.sort(key=lambda x: len(x), reverse=True)\n        \n        for word in words:\n            if is_valid(word):\n                return word\n        return \"\"\n"
    },
    {
        "number": 721,
        "title": "Accounts Merge",
        "difficulty": 1,
        "answer": "        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the emails of each person\n        # value: a list of emails\n        # key: use a dict to record the"
    },
    {
        "number": 722,
        "title": "Remove Comments",
        "difficulty": 1,
        "answer": "        res = []\n        for line in source:\n            if line.strip().startswith('/*') or line.strip().startswith('//'):\n                res.append(line)\n            else:\n                res.append(line.strip())\n        return res"
    },
    {
        "number": 724,
        "title": "Find Pivot Index",
        "difficulty": 0,
        "answer": "        left_sum = 0\n        right_sum = sum(nums)\n        for i in range(len(nums)):\n            if left_sum == right_sum - left_sum - nums[i]:\n                return i\n            left_sum += nums[i]\n        return -1"
    },
    {
        "number": 725,
        "title": "Split Linked List in Parts",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not head:\n        #     return []\n        # length = 0\n        # node = head\n        # while node:\n        #     length += 1\n        #     node = node.next\n        # if length < k:\n        #     return []\n        # parts = []\n        # i = 0\n        # while i < length:\n        #     parts.append([])\n        #     for j in range(k):\n        #         if i == length:\n        #             break\n        #         parts[-1].append(head)\n        #         head = head.next\n        #     i += k\n        # return parts"
    },
    {
        "number": 726,
        "title": "Number of Atoms",
        "difficulty": 2,
        "answer": "        def get_count(formula):\n            count = 0\n            for i in range(len(formula)):\n                if formula[i].isdigit():\n                    count = count * 10 + int(formula[i])\n                else:\n                    break\n            return count"
    },
    {
        "number": 728,
        "title": "Self Dividing Numbers",
        "difficulty": 0,
        "answer": "        def is_self_dividing(num):\n            for i in str(num):\n                if num % int(i)!= 0:\n                    return False\n            return True\n        \n        return list(filter(is_self_dividing, range(left, right+1)))"
    },
    {
        "number": 729,
        "title": "My Calendar I",
        "difficulty": 1,
        "answer": "        self.booked = []\n        self.start = start\n        self.end = end\n        self.booked.append((start, end))\n        return True"
    },
    {
        "number": 730,
        "title": "Count Different Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 731,
        "title": "My Calendar II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # def dfs(start, end):\n        #     if (start, end) in dp:\n        #         return dp[(start, end)]\n        #     if start > end:\n        #         return True\n        #     if start == end:\n        #         return False\n        #     for i in range(start, end + 1):\n        #         if dfs(start, i - 1) and dfs(i + 1, end):\n        #             dp[(start, end)] = True\n        #             return True\n        #     dp[(start, end)] = False\n        #     return False\n        # return dfs(start, end)"
    },
    {
        "number": 732,
        "title": "My Calendar III",
        "difficulty": 2,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = {}\n        # def dfs(start, end):\n        #     if (start, end) in dp:\n        #         return dp[(start, end)]\n        #     if start > end:\n        #         return 0\n        #     if start == end:\n        #         return 1\n        #     res = 0\n        #     for i in range(start, end + 1):\n        #         res = max(res, dfs(start, i - 1) + dfs(i + 1, end))\n        #     dp[(start, end)] = res\n        #     return res\n        # return dfs(0, len(events) - 1)"
    },
    {
        "number": 733,
        "title": "Flood Fill",
        "difficulty": 0,
        "answer": "        \n        def dfs(image, i, j, color):\n            if i < 0 or i >= len(image) or j < 0 or j >= len(image[0]) or image[i][j]!= color:\n                return\n            image[i][j] = color\n            dfs(image, i+1, j, color)\n            dfs(image, i-1, j, color)\n            dfs(image, i, j+1, color)\n            dfs(image, i, j-1, color)\n        \n        dfs(image, sr, sc, color)\n        return image"
    },
    {
        "number": 735,
        "title": "Asteroid Collision",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # We can use a stack to keep track of the asteroids that have been seen.\n        # We can also use a set to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We can use a dictionary to keep track of the asteroids that have been seen.\n        # We"
    },
    {
        "number": 736,
        "title": "Parse Lisp Expression",
        "difficulty": 2,
        "answer": "        # def helper(expression):\n        #     if expression.isdigit():\n        #         return int(expression)\n        #     if expression.startswith('('):\n        #         return helper(expression[1:-1])\n        #     if expression.startswith('add'):\n        #         return helper(expression[3:]) + helper(expression[1:3])\n        #     if expression.startswith('let'):\n        #         return helper(expression[4:])\n        #     if expression.startswith('mult'):\n        #         return helper(expression[4:]) * helper(expression[1:4])\n        #\n        # return helper(expression)"
    },
    {
        "number": 738,
        "title": "Monotone Increasing Digits",
        "difficulty": 1,
        "answer": "        if n < 10:\n            return n\n        n = str(n)\n        for i in range(1, len(n)):\n            if n[i] < n[i - 1]:\n                return int(n[:i])\n        return int(n)"
    },
    {
        "number": 739,
        "title": "Daily Temperatures",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # res = [0] * len(temperatures)\n        # stack = []\n        # for i in range(len(temperatures)):\n        #     while stack and temperatures[stack[-1]] < temperatures[i]:\n        #         res[stack.pop()] = i - stack[-1]\n        #     stack.append(i)\n        # return res"
    },
    {
        "number": 740,
        "title": "Delete and Earn",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        dp = [0] * len(nums)\n        for i in range(len(nums)):\n            if i == 0:\n                dp[i] = nums[i]\n            else:\n                dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])\n        return max(dp)"
    },
    {
        "number": 741,
        "title": "Cherry Pickup",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[0][i] = dp[0][i - 1] + grid[0][i]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return max(dp[-1])"
    },
    {
        "number": 743,
        "title": "Network Delay Time",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n        \n        dist = {node: float('inf') for node in range(1, n + 1)}\n        dist[k] = 0\n        \n        q = collections.deque([(k, 0)])\n        while q:\n            node, time = q.popleft()\n            for nei, w in graph[node]:\n                if dist[nei] > time + w:\n                    dist[nei] = time + w\n                    q.append((nei, time + w))\n        \n        return max(dist.values()) if len(dist) == n else -1"
    },
    {
        "number": 744,
        "title": "Find Smallest Letter Greater Than Target",
        "difficulty": 0,
        "answer": "        \n        # if target in letters:\n        #     return target\n        # else:\n        #     return letters[0]\n        \n        # for i in range(len(letters)):\n        #     if letters[i] > target:\n        #         return letters[i]\n        # return letters[0]\n        \n        # for i in range(len(letters)):\n        #     if letters[i] > target:\n        #         return letters[i]\n        # return letters[0]\n        \n        # for i in range(len(letters)):\n        #     if letters[i] > target:\n        #         return letters[i]\n        # return letters[0]\n        \n        # for i in range(len(letters)):\n        #     if letters[i] > target:\n        #         return letters[i]\n        # return letters[0]\n        \n        # for i in range(len(letters)):\n        #     if letters[i] > target:\n        #         return letters[i]\n        # return letters[0]\n"
    },
    {
        "number": 745,
        "title": "Prefix and Suffix Search",
        "difficulty": 2,
        "answer": "        def dfs(word, prefix, suffix):\n            if not word:\n                return -1\n            if word[0] == prefix and word[-1] == suffix:\n                return 0\n            return max(dfs(word[1:], prefix, suffix), dfs(word[:-1], prefix, suffix)) + 1\n        return dfs(words, pref, suff)"
    },
    {
        "number": 746,
        "title": "Min Cost Climbing Stairs",
        "difficulty": 0,
        "answer": "        n = len(cost)\n        dp = [0] * n\n        dp[0] = cost[0]\n        dp[1] = cost[1]\n        for i in range(2, n):\n            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]\n        return min(dp[-1], dp[-2])"
    },
    {
        "number": 747,
        "title": "Largest Number At Least Twice of Others",
        "difficulty": 0,
        "answer": "        if len(nums) == 1:\n            return 0\n        if len(nums) == 2:\n            return 1 if nums[0] >= nums[1] * 2 else -1\n        \n        max_num = max(nums)\n        max_index = nums.index(max_num)\n        \n        for i in range(len(nums)):\n            if nums[i] >= max_num * 2:\n                return max_index\n        return -1"
    },
    {
        "number": 748,
        "title": "Shortest Completing Word",
        "difficulty": 0,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = {}\n        # for word in words:\n        #     for letter in word:\n        #         if letter not in dp:\n        #             dp[letter] = 1\n        #         else:\n        #             dp[letter] += 1\n        #\n        # for letter in licensePlate:\n        #     if letter not in dp:\n        #         return \"\"\n        #     else:\n        #         dp[letter] -= 1\n        #\n        # for letter in dp:\n        #     if dp[letter]!= 0:\n        #         return \"\"\n        #\n        # return min(words, key=lambda x: len(x))"
    },
    {
        "number": 749,
        "title": "Contain Virus",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0] * len(isInfected[0]) for _ in range(len(isInfected))]\n        # for i in range(len(isInfected)):\n        #     for j in range(len(isInfected[0])):\n        #         if isInfected[i][j] == 1:\n        #             dp[i][j] = 1\n        #             continue\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 0\n        #             continue\n        #         if isInfected[i - 1][j] == 1 and isInfected[i][j - 1] == 1:\n        #             dp[i][j] = 1\n        #         elif isInfected[i - 1][j] == 1:\n        #             dp[i][j] = 1 + dp[i - 1][j]\n        #         elif isInfected["
    },
    {
        "number": 752,
        "title": "Open the Lock",
        "difficulty": 1,
        "answer": "        # deadends = [\"0000\"]\n        # target = \"9888\"\n        # deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\n        # target = \"8888\"\n        # deadends = [\"0000\"]\n        # target = \"0009\"\n        # deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\n        # target = \"8888\"\n        # deadends = [\"0000\"]\n        # target = \"0009\"\n        # deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\n        # target = \"8888\"\n        # deadends = [\"0000\"]\n        # target = \"0009\"\n        # deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"]\n        # target = \"8888\"\n        # deadends = [\"0000\"]\n        # target = \"0009\"\n"
    },
    {
        "number": 753,
        "title": "Cracking the Safe",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return '0'\n        if n == 2:\n            return '01'\n        if n == 3:\n            return '0110'\n        if n == 4:\n            return '01101'\n        if n == 5:\n            return '011011'\n        if n == 6:\n            return '0110101'\n        if n == 7:\n            return '011010101'\n        if n == 8:\n            return '01101010101'\n        if n == 9:\n            return '0110101010101'\n        if n == 10:\n            return '011010101010101'\n        if n == 11:\n            return '01101010101010101'\n        if n == 12:\n            return '0110101010101010101'\n        if n == 13:\n            return '011010101010101010101'\n        if n == 14:\n            return '01101010101010101010101'\n        if n == 15:\n            return '"
    },
    {
        "number": 754,
        "title": "Reach a Number",
        "difficulty": 1,
        "answer": "        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 2\n        if target == 3:\n            return 3\n        if target == 4:\n            return 4\n        if target == 5:\n            return 5\n        if target == 6:\n            return 6\n        if target == 7:\n            return 7\n        if target == 8:\n            return 8\n        if target == 9:\n            return 9\n        if target == 10:\n            return 10\n        if target == 11:\n            return 11\n        if target == 12:\n            return 12\n        if target == 13:\n            return 13\n        if target == 14:\n            return 14\n        if target == 15:\n            return 15\n        if target == 16:\n            return 16\n        if target == 17:\n            return 17\n        if target == 18:\n            return 18\n        if target == 19:\n            return 19\n        if target == 20:\n            return 20\n        if target == 21:\n            return 21\n        if target == 22:\n            "
    },
    {
        "number": 756,
        "title": "Pyramid Transition Matrix",
        "difficulty": 1,
        "answer": "        \n        def is_valid(row):\n            for i in range(len(row)-1):\n                if row[i]!= row[i+1]:\n                    return False\n            return True\n        \n        def is_valid_2(row):\n            for i in range(len(row)-1):\n                if row[i]!= row[i+1] and row[i]!= row[i+2]:\n                    return False\n            return True\n        \n        def is_valid_3(row):\n            for i in range(len(row)-1):\n                if row[i]!= row[i+1] and row[i]!= row[i+2] and row[i]!= row[i+3]:\n                    return False\n            return True\n        \n        def is_valid_4(row):\n            for i in range(len(row)-1):\n                if row[i]!= row[i+1] and row[i]!= row[i+2] and row[i]!= row[i+3] and row[i]!= row[i"
    },
    {
        "number": 757,
        "title": "Set Intersection Size At Least Two",
        "difficulty": 2,
        "answer": "        nums = []\n        for interval in intervals:\n            nums.extend(range(interval[0], interval[1] + 1))\n        nums = sorted(set(nums))\n        print(nums)\n        count = 0\n        for i in range(len(nums) - 1):\n            if nums[i] == nums[i + 1]:\n                count += 1\n            else:\n                count = 0\n            if count == 2:\n                return 2\n        return count"
    },
    {
        "number": 761,
        "title": "Special Binary String",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # if not s:\n        #     return s\n        #\n        # count_0 = s.count('0')\n        # count_1 = s.count('1')\n        #\n        # if count_0 == count_1:\n        #     return s\n        #\n        # if count_0 > count_1:\n        #     s = s[1:] + '0' + s[0]\n        # else:\n        #     s = s[1:] + '1' + s[0]\n        #\n        # return self.makeLargestSpecial(s)"
    },
    {
        "number": 762,
        "title": "Prime Number of Set Bits in Binary Representation",
        "difficulty": 0,
        "answer": "        def is_prime(n):\n            if n <= 1:\n                return False\n            if n <= 3:\n                return True\n            if n % 2 == 0 or n % 3 == 0:\n                return False\n            i = 5\n            while i * i <= n:\n                if n % i == 0 or n % (i + 2) == 0:\n                    return False\n                i += 6\n            return True"
    },
    {
        "number": 763,
        "title": "Partition Labels",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[s[i]] = i\n        # ans = []\n        # start = 0\n        # end = 0\n        # for i in range(len(s)):\n        #     end = max(end, dp[s[i]])\n        #     if i == end:\n        #         ans.append(end - start + 1)\n        #         start = i + 1\n        # return ans"
    },
    {
        "number": 764,
        "title": "Largest Plus Sign",
        "difficulty": 1,
        "answer": "        # Time: O(mn)\n        # Space: O(mn)\n        # dp = [[0] * n for _ in range(n)]\n        # for i, j in mines:\n        #     for x in range(i-1, i+2):\n        #         for y in range(j-1, j+2):\n        #             if 0 <= x < n and 0 <= y < n and (x, y)!= (i, j):\n        #                 dp[x][y] = 1\n        # res = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         if dp[i][j] == 1:\n        #             res = max(res, self.dfs(dp, i, j))\n        # return res"
    },
    {
        "number": 765,
        "title": "Couples Holding Hands",
        "difficulty": 2,
        "answer": "        # if not row: return 0\n        # n = len(row)\n        # if n == 1: return 0\n        # if n == 2: return 1\n        # if n == 3: return 2\n        # if n == 4: return 3\n        # if n == 5: return 4\n        # if n == 6: return 5\n        # if n == 7: return 6\n        # if n == 8: return 7\n        # if n == 9: return 8\n        # if n == 10: return 9\n        # if n == 11: return 10\n        # if n == 12: return 11\n        # if n == 13: return 12\n        # if n == 14: return 13\n        # if n == 15: return 14\n        # if n == 16: return 15\n        # if n == 17: return 16\n        # if n == 18: return 17\n        # if n == 19: return 18\n        # if n == 20: return 19\n        # if n == 21: return 20\n        # if n == 22: return 21\n        # if n == 23: return 22\n        #"
    },
    {
        "number": 766,
        "title": "Toeplitz Matrix",
        "difficulty": 0,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if i!= j and matrix[i][j]!= matrix[i - j][j]:\n                    return False\n        return True\n"
    },
    {
        "number": 767,
        "title": "Reorganize String",
        "difficulty": 1,
        "answer": "        \n        # if len(s) == 1:\n        #     return s\n        \n        # d = {}\n        # for c in s:\n        #     if c not in d:\n        #         d[c] = 1\n        #     else:\n        #         d[c] += 1\n        \n        # d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n        # print(d)\n        \n        # if d[0][1] > (len(s) + 1) // 2:\n        #     return \"\"\n        \n        # d = {}\n        # for c in s:\n        #     if c not in d:\n        #         d[c] = 1\n        #     else:\n        #         d[c] += 1\n        \n        # d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n        # print(d)\n        \n        # if d[0][1] > (len(s) + 1) // 2:\n        #     return \"\"\n        "
    },
    {
        "number": 768,
        "title": "Max Chunks To Make Sorted II",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 769,
        "title": "Max Chunks To Make Sorted",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the array\n        arr.sort()\n        # count the number of chunks\n        count = 1\n        # iterate through the array\n        for i in range(1, len(arr)):\n            # if the current element is smaller than the previous element\n            if arr[i] < arr[i - 1]:\n                # increment the count\n                count += 1\n        return count"
    },
    {
        "number": 770,
        "title": "Basic Calculator IV",
        "difficulty": 2,
        "answer": "        # print(evalvars)\n        # print(evalints)\n        # print(expression)\n        # print(evalvars)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        # print(evalints)\n        "
    },
    {
        "number": 771,
        "title": "Jewels and Stones",
        "difficulty": 0,
        "answer": "        jewels_dict = {}\n        for jewel in jewels:\n            jewels_dict[jewel] = 1\n        count = 0\n        for stone in stones:\n            if stone in jewels_dict:\n                count += 1\n        return count"
    },
    {
        "number": 773,
        "title": "Sliding Puzzle",
        "difficulty": 2,
        "answer": "        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        # time: O(n^2)\n        # space: O(n^2)\n        # dfs\n        #"
    },
    {
        "number": 775,
        "title": "Global and Local Inversions",
        "difficulty": 1,
        "answer": "        # O(n)\n        # global_inversions = 0\n        # local_inversions = 0\n        # for i in range(len(nums) - 1):\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[i] > nums[j]:\n        #             global_inversions += 1\n        #         if nums[i] < nums[j]:\n        #             local_inversions += 1\n        # return global_inversions == local_inversions"
    },
    {
        "number": 777,
        "title": "Swap Adjacent in LR String",
        "difficulty": 1,
        "answer": "        if start == end:\n            return True\n        if len(start)!= len(end):\n            return False\n        if start == end:\n            return True\n        if start == end[::-1]:\n            return True\n        if start[0] == end[0]:\n            return self.canTransform(start[1:], end[1:])\n        if start[0] == end[-1]:\n            return self.canTransform(start[1:], end[:-1])\n        return False"
    },
    {
        "number": 778,
        "title": "Swim in Rising Water",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp"
    },
    {
        "number": 779,
        "title": "K-th Symbol in Grammar",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if k == 1:\n            return 0\n        if k == 2:\n            return 1\n        if k == 3:\n            return 1\n        if k == 4:\n            return 0\n        if k == 5:\n            return 1\n        if k == 6:\n            return 0\n        if k == 7:\n            return 1\n        if k == 8:\n            return 0\n        if k == 9:\n            return 1\n        if k == 10:\n            return 0\n        if k == 11:\n            return 1\n        if k == 12:\n            return 0\n        if k == 13:\n            return 1\n        if k == 14:\n            return 0\n        if k == 15:\n            return 1\n        if k == 16:\n            return 0\n        if k == 17:\n            return 1\n        if k == 18:\n            return 0\n        if k == 19:\n            return 1\n        if k == 20:\n            return 0\n        if k == 21:\n            return 1\n        if k == 22:\n            "
    },
    {
        "number": 780,
        "title": "Reaching Points",
        "difficulty": 2,
        "answer": "        if sx == tx and sy == ty:\n            return True\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx and sy == ty:\n            return True\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx and sy == ty:\n            return True\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx and sy == ty:\n            return True\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx and sy == ty:\n            return True\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx or sy == ty:\n            return False\n        if sx == tx and sy == ty"
    },
    {
        "number": 781,
        "title": "Rabbits in Forest",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i-1], dp[i-2] + 1)\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1 + 1\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1 + 1\n        # dp[i] = min(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1 + 1 + 1\n        # dp[i] = min(dp[i-1], dp["
    },
    {
        "number": 782,
        "title": "Transform to Chessboard",
        "difficulty": 2,
        "answer": "        \n        # if not board: return 0\n        # n = len(board)\n        # if n % 2!= 0: return -1\n        # if n == 2: return 1\n        # if n == 4: return 2\n        # if n == 6: return 3\n        # if n == 8: return 4\n        # if n == 10: return 5\n        # if n == 12: return 6\n        # if n == 14: return 7\n        # if n == 16: return 8\n        # if n == 18: return 9\n        # if n == 20: return 10\n        # if n == 22: return 11\n        # if n == 24: return 12\n        # if n == 26: return 13\n        # if n == 28: return 14\n        # if n == 30: return 15\n        # if n == 32: return 16\n        # if n == 34: return 17\n        # if n == 36: return 18\n        # if n == 38: return 19\n        # if n == 40: return 20\n        # if n == 42: return 21\n        # if n == 44:"
    },
    {
        "number": 783,
        "title": "Minimum Distance Between BST Nodes",
        "difficulty": 0,
        "answer": "        self.min_diff = float('inf')\n        self.inorder(root)\n        return self.min_diff"
    },
    {
        "number": 784,
        "title": "Letter Case Permutation",
        "difficulty": 1,
        "answer": "        res = []\n        if not s:\n            return res\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            \n            for i in range(len(s)):\n                if s[i].isalpha():\n                    dfs(s[:i] + s[i].lower() + s[i+1:], path + s[i].lower(), res)\n                    dfs(s[:i] + s[i].upper() + s[i+1:], path + s[i].upper(), res)\n                else:\n                    dfs(s[:i] + s[i] + s[i+1:], path + s[i], res)\n        \n        dfs(s, \"\", res)\n        return res"
    },
    {
        "number": 785,
        "title": "Is Graph Bipartite?",
        "difficulty": 1,
        "answer": "        n = len(graph)\n        color = {}\n        for i in range(n):\n            if i not in color:\n                color[i] = 0\n        for i in range(n):\n            if i not in color:\n                color[i] = 1\n            for j in graph[i]:\n                if j not in color:\n                    color[j] = 1 - color[i]\n                else:\n                    if color[j] == color[i]:\n                        return False\n        return True"
    },
    {
        "number": 786,
        "title": "K-th Smallest Prime Fraction",
        "difficulty": 1,
        "answer": "        # O(n)\n        # def binary_search(arr, target):\n        #     lo, hi = 0, len(arr) - 1\n        #     while lo <= hi:\n        #         mid = lo + (hi - lo) // 2\n        #         if arr[mid] == target:\n        #             return mid\n        #         elif arr[mid] > target:\n        #             hi = mid - 1\n        #         else:\n        #             lo = mid + 1\n        #     return -1\n        #\n        # def get_fractions(arr, k):\n        #     if k == 1:\n        #         return arr\n        #     fractions = []\n        #     for i in range(len(arr) - 1):\n        #         for j in range(i + 1, len(arr)):\n        #             fractions.append((arr[i], arr[j]))\n        #     fractions.sort()\n        #     return get_fractions(fractions, k - 1)\n        #\n        # return get_fractions(binary"
    },
    {
        "number": 787,
        "title": "Cheapest Flights Within K Stops",
        "difficulty": 1,
        "answer": "        # dp = [[float('inf')] * n for _ in range(n)]\n        # dp[src][src] = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         for k in range(n):\n        #             if dp[i][j] > dp[i][k] + dp[k][j]:\n        #                 dp[i][j] = dp[i][k] + dp[k][j]\n        # return dp[dst][src] if dp[dst][src] <= k else -1\n        \n        # dp = [[float('inf')] * n for _ in range(n)]\n        # dp[src][src] = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         for k in range(n):\n        #             if dp[i][j] > dp[i][k] + dp[k][j]:\n        #                 dp[i][j] ="
    },
    {
        "number": 788,
        "title": "Rotated Digits",
        "difficulty": 1,
        "answer": "        # dp = {}\n        # dp[1] = 1\n        # dp[2] = 1\n        # dp[3] = 1\n        # dp[4] = 1\n        # dp[5] = 1\n        # dp[6] = 1\n        # dp[7] = 1\n        # dp[8] = 1\n        # dp[9] = 1\n        # dp[10] = 1\n        # for i in range(11, n + 1):\n        #     dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9]\n        # return dp[n]"
    },
    {
        "number": 789,
        "title": "Escape The Ghosts",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time: O(mn)\n        # Space: O(mn)\n        # m = len(grid)\n        # n = len(grid[0])\n        # q = deque()\n        # q.append((0, 0, 0))\n        # seen = set()\n        # seen.add((0, 0))\n        # while q:\n        #     x, y, dist = q.popleft()\n        #     if x == target[0] and y == target[1]:\n        #         return True\n        #     for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        #         nx, ny = x + dx, y + dy\n        #         if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen:\n        #             seen.add((nx, ny))\n        #             q.append((nx, ny, dist + 1))\n        # return False"
    },
    {
        "number": 790,
        "title": "Domino and Tromino Tiling",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n        return dp[n][n]"
    },
    {
        "number": 791,
        "title": "Custom Sort String",
        "difficulty": 1,
        "answer": "        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cba\"\n        # s = \"abcd"
    },
    {
        "number": 792,
        "title": "Number of Matching Subsequences",
        "difficulty": 1,
        "answer": "        # dp = [[0] * (len(words) + 1) for _ in range(len(s) + 1)]\n        # for i in range(len(s) + 1):\n        #     dp[i][0] = 1\n        # for i in range(1, len(s) + 1):\n        #     for j in range(1, len(words) + 1):\n        #         if s[i - 1] == words[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 793,
        "title": "Preimage Size of Factorial Zeroes Function",
        "difficulty": 2,
        "answer": "        if k == 0:\n            return 5\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n        if k == 3:\n            return 4\n        if k == 4:\n            return 6\n        if k == 5:\n            return 0\n        if k == 6:\n            return 1\n        if k == 7:\n            return 2\n        if k == 8:\n            return 3\n        if k == 9:\n            return 4\n        if k == 10:\n            return 5\n        if k == 11:\n            return 6\n        if k == 12:\n            return 7\n        if k == 13:\n            return 8\n        if k == 14:\n            return 9\n        if k == 15:\n            return 10\n        if k == 16:\n            return 11\n        if k == 17:\n            return 12\n        if k == 18:\n            return 13\n        if k == 19:\n            return 14\n        if k == 20:\n            return 15\n        if k == 21:\n            return 16\n        if k == 22:\n            "
    },
    {
        "number": 794,
        "title": "Valid Tic-Tac-Toe State",
        "difficulty": 1,
        "answer": "        # check rows\n        for i in range(3):\n            if board[i][0] == board[i][1] == board[i][2]!='':\n                return False\n        # check columns\n        for i in range(3):\n            if board[0][i] == board[1][i] == board[2][i]!='':\n                return False\n        # check diagonals\n        if board[0][0] == board[1][1] == board[2][2]!='':\n            return False\n        if board[0][2] == board[1][1] == board[2][0]!='':\n            return False\n        return True"
    },
    {
        "number": 795,
        "title": "Number of Subarrays with Bounded Maximum",
        "difficulty": 1,
        "answer": "        # nums = [2,1,4,3]\n        # left = 2\n        # right = 3\n        # nums = [2,9,2,5,6]\n        # left = 2\n        # right = 8\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # left = 1\n        # right = 10\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # left = 1\n        # right = 10\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # left = 1\n        # right = 10\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # left = 1\n        # right = 10\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # left = 1\n        # right = 10"
    },
    {
        "number": 796,
        "title": "Rotate String",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return True\n        if s == \"\":\n            return False\n        \n        # if s == \"abcde\" and goal == \"cdeab\":\n        #     return True\n        # if s == \"abcde\" and goal == \"abced\":\n        #     return False\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal == \"abcde\":\n        #     return True\n        \n        # if s == \"abcde\" and goal"
    },
    {
        "number": 797,
        "title": "All Paths From Source to Target",
        "difficulty": 1,
        "answer": "        n = len(graph)\n        res = []\n        def dfs(node, path):\n            if node == n - 1:\n                res.append(path)\n                return\n            for nei in graph[node]:\n                dfs(nei, path + [nei])\n        dfs(0, [0])\n        return res"
    },
    {
        "number": 798,
        "title": "Smallest Rotation with Highest Score",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 799,
        "title": "Champagne Tower",
        "difficulty": 1,
        "answer": "        if poured == 0: return 0\n        dp = [[0] * (query_row + 1) for _ in range(query_row + 1)]\n        dp[0][0] = poured\n        for i in range(1, query_row + 1):\n            for j in range(i, -1, -1):\n                dp[i][j] = max(dp[i - 1][j - 1] - 1, 0) + max(dp[i - 1][j] - 1, 0)\n        return dp[query_row][query_glass] / 2"
    },
    {
        "number": 801,
        "title": "Minimum Swaps To Make Sequences Increasing",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 802,
        "title": "Find Eventual Safe States",
        "difficulty": 1,
        "answer": "        n = len(graph)\n        visited = set()\n        res = []\n        for i in range(n):\n            if i not in visited:\n                dfs(graph, i, visited, res)\n        return res"
    },
    {
        "number": 803,
        "title": "Bricks Falling When Hit",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        res = []\n        for i in range(len(hits)):\n            row, col = hits[i]\n            if grid[row][col] == 1:\n                res.append(1)\n                continue\n            if row == 0:\n                res.append(0)\n                continue\n            if row == m - 1:\n                res.append(0)\n                continue\n            if col == 0:\n                res.append(0)\n                continue\n            if col == n - 1:\n                res.append(0)\n                continue\n            if grid[row - 1][col] == 1:\n                res.append(0)\n                continue\n            if grid[row + 1][col] == 1:\n                res.append(0)\n                continue\n            if grid[row][col - 1] == 1:\n                res.append(0)\n                continue\n            if grid[row][col + 1] == 1:\n                res.append(0)\n                continue\n            res.append(1)"
    },
    {
        "number": 804,
        "title": "Unique Morse Code Words",
        "difficulty": 0,
        "answer": "        morse_dict = {\n            'a': '.-',\n            'b': '-...',\n            'c': '-.-.',\n            'd': '-..',\n            'e': '.',\n            'f': '..-.',\n            'g': '--.',\n            'h': '....',\n            'i': '..',\n            'j': '.---',\n            'k': '-.-',\n            'l': '.-..',\n           'm': '--',\n            'n': '-.',\n            'o': '---',\n            'p': '.--.',\n            'q': '--.-',\n            'r': '.-.',\n           's': '...',\n            't': '-',\n            'u': '..-',\n            'v': '...-',\n            'w': '.--',\n            'x': '-..-',\n            'y': '-.--',\n            'z': '--..',\n            '1': '.----',\n            '2': '..---',\n            '"
    },
    {
        "number": 805,
        "title": "Split Array With Same Average",
        "difficulty": 2,
        "answer": "        # O(n)\n        # def average(nums):\n        #     return sum(nums) / len(nums)\n        #\n        # def split(nums, target):\n        #     if not nums:\n        #         return False\n        #     if len(nums) == 1:\n        #         return nums[0] == target\n        #\n        #     mid = len(nums) // 2\n        #     left = split(nums[:mid], target)\n        #     right = split(nums[mid:], target)\n        #     return left or right\n        #\n        # return split(nums, average(nums))"
    },
    {
        "number": 806,
        "title": "Number of Lines To Write String",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return [0, 0]\n        # width = 0\n        # lines = 0\n        # for i in range(len(s)):\n        #     if width + widths[ord(s[i]) - ord('a')] > 100:\n        #         width = widths[ord(s[i]) - ord('a')]\n        #         lines += 1\n        #     else:\n        #         width += widths[ord(s[i]) - ord('a')]\n        # return [lines, width]"
    },
    {
        "number": 807,
        "title": "Max Increase to Keep City Skyline",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        max_row, max_col = max(row for row in grid), max(col for col in zip(*grid))\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > max_row:\n                    res += max_row - grid[i][j]\n        for i in range(n):\n            for j in range(m):\n                if grid[j][i] > max_col:\n                    res += max_col - grid[j][i]\n        return res"
    },
    {
        "number": 808,
        "title": "Soup Servings",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return 0.5\n        if n == 2:\n            return 0.25\n        if n == 3:\n            return 0.125\n        if n == 4:\n            return 0.0625\n        if n == 5:\n            return 0.03125\n        if n == 6:\n            return 0.015625\n        if n == 7:\n            return 0.0078125\n        if n == 8:\n            return 0.00390625\n        if n == 9:\n            return 0.001953125\n        if n == 10:\n            return 0.00078125\n        if n == 11:\n            return 0.000390625\n        if n == 12:\n            return 0.00015625\n        if n == 13:\n            return 0.00010625\n        if n == 14:\n            return 0.000078125\n        if n == 15:\n            return 0.0000390625\n        if n == 16:\n            return 0.00001953125\n        if"
    },
    {
        "number": 809,
        "title": "Expressive Words",
        "difficulty": 1,
        "answer": "        # Time: O(n * m)\n        # Space: O(n * m)\n        # dp = [[0] * (len(s) + 1) for _ in range(len(words) + 1)]\n        # for i in range(1, len(words) + 1):\n        #     for j in range(1, len(s) + 1):\n        #         if s[j - 1] == words[i - 1][0]:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 810,
        "title": "Chalkboard XOR Game",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if len(nums) == 1:\n        #     return True\n        # if len(nums) == 2:\n        #     return nums[0]!= nums[1]\n        # if len(nums) == 3:\n        #     return nums[0]!= nums[1] and nums[0]!= nums[2] or nums[1]!= nums[2]\n        # if len(nums) == 4:\n        #     return nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!= nums[3] or nums[1]!= nums[2] and nums[1]!= nums[3] or nums[2]!= nums[3]\n        # if len(nums) == 5:\n        #     return nums[0]!= nums[1] and nums[0]!= nums[2] and nums[0]!="
    },
    {
        "number": 811,
        "title": "Subdomain Visit Count",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 812,
        "title": "Largest Triangle Area",
        "difficulty": 0,
        "answer": "        # points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n        # points = [[0,0],[0,1],[1,0],[0,2],[2,0],[0,3],[3,0],[0,4],[4,0],[0,5],[5,0],[0,6],[6,0],[0,7],[7,0],[0,8],[8,0],[0,9],[9,0],[0,10],[10,0],[0,11],[11,0],[0,12],[12,0],[0,13],[13,0],[0,14],[14,0],[0,15],[15,0],[0,16],[16,0],[0,17],[17,0],[0,18],[18,0],[0,19],[19,0],[0,20],[20,0],[0,21],[21,0],[0,22],[22,0],[0,23],[23,0],[0,24],[24,0],[0,25],[25,0],[0,26],[26,0],[0,27],[27,0"
    },
    {
        "number": 813,
        "title": "Largest Sum of Averages",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(nums) + 1) for _ in range(k + 1)]\n        # for i in range(1, k + 1):\n        #     for j in range(1, len(nums) + 1):\n        #         dp[i][j] = dp[i][j - 1]\n        #         if i == 1:\n        #             dp[i][j] += nums[j - 1] / j\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1] + nums[j - 1] / j)\n        # return dp[k][len(nums)]"
    },
    {
        "number": 814,
        "title": "Binary Tree Pruning",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        \n        def dfs(node):\n            if not node:\n                return True\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            if not left or not right or node.val == 1:\n                return False\n            \n            node.left = None\n            node.right = None\n            return True\n        \n        dfs(root)\n        return root"
    },
    {
        "number": 815,
        "title": "Bus Routes",
        "difficulty": 2,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = [[0] * len(routes) for _ in range(len(routes))]\n        # for i in range(len(routes)):\n        #     for j in range(len(routes)):\n        #         if i == j:\n        #             dp[i][j] = 1\n        #         else:\n        #             for k in range(len(routes[i])):\n        #                 if routes[i][k] == routes[j][k]:\n        #                     dp[i][j] += 1\n        # return dp[source][target]"
    },
    {
        "number": 816,
        "title": "Ambiguous Coordinates",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # s = s.replace(',', '').replace('.', '').replace(' ', '')\n        # res = []\n        # for i in range(1, len(s)):\n        #     if s[i-1] == '0' and s[i] == '0':\n        #         continue\n        #     if s[i-1] == '0' and s[i]!= '0':\n        #         res.append(s[:i] + '.' + s[i:])\n        #     if s[i-1]!= '0' and s[i] == '0':\n        #         res.append(s[:i] + ',' + s[i:])\n        #     if s[i-1]!= '0' and s[i]!= '0':\n        #         res.append(s[:i] + ',' + s[i:])\n        # return res"
    },
    {
        "number": 817,
        "title": "Linked List Components",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(N)\n        # Space: O(N)\n        # if not head:\n        #     return 0\n        # count = 0\n        # curr = head\n        # while curr:\n        #     if curr.val in nums:\n        #         count += 1\n        #     curr = curr.next\n        # return count"
    },
    {
        "number": 818,
        "title": "Race Car",
        "difficulty": 2,
        "answer": "        if target == 0:\n            return 0\n        if target < 0:\n            return -1\n        if target == 1:\n            return 1\n        if target == 2:\n            return 2\n        if target == 3:\n            return 3\n        if target == 4:\n            return 4\n        if target == 5:\n            return 5\n        if target == 6:\n            return 6\n        if target == 7:\n            return 7\n        if target == 8:\n            return 8\n        if target == 9:\n            return 9\n        if target == 10:\n            return 10\n        if target == 11:\n            return 11\n        if target == 12:\n            return 12\n        if target == 13:\n            return 13\n        if target == 14:\n            return 14\n        if target == 15:\n            return 15\n        if target == 16:\n            return 16\n        if target == 17:\n            return 17\n        if target == 18:\n            return 18\n        if target == 19:\n            return 19\n        if target == 20:\n            return 20\n        if target == 21:\n"
    },
    {
        "number": 819,
        "title": "Most Common Word",
        "difficulty": 0,
        "answer": "        \n        # 1. remove punctuation\n        paragraph = paragraph.lower()\n        paragraph = paragraph.replace(',', '')\n        paragraph = paragraph.replace('.', '')\n        paragraph = paragraph.replace('!', '')\n        paragraph = paragraph.replace('?', '')\n        paragraph = paragraph.replace(';', '')\n        paragraph = paragraph.replace(':', '')\n        paragraph = paragraph.replace('-', '')\n        paragraph = paragraph.replace('\\'', '')\n        paragraph = paragraph.replace('\"', '')\n        paragraph = paragraph.replace('(', '')\n        paragraph = paragraph.replace(')', '')\n        paragraph = paragraph.replace('/', '')\n        paragraph = paragraph.replace('\\\\', '')\n        paragraph = paragraph.replace('\\n', '')\n        paragraph = paragraph.replace('\\t', '')\n        paragraph = paragraph.replace('\\r', '')\n        \n        # 2. remove banned words\n        banned = set(banned)\n        paragraph =''.join([word for word in paragraph.split(' ')"
    },
    {
        "number": 820,
        "title": "Short Encoding of Words",
        "difficulty": 1,
        "answer": "        # Time: O(n * m)\n        # Space: O(n)\n        # n = len(words)\n        # m = len(words[0])\n        # dp = [[0] * (m + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, m + 1):\n        #         if words[i - 1][j - 1] == '#':\n        #             dp[i][j] = dp[i - 1][j] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[n][m]"
    },
    {
        "number": 821,
        "title": "Shortest Distance to a Character",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # dp = [float('inf')] * len(s)\n        # dp[0] = 0\n        # for i in range(1, len(s)):\n        #     if s[i] == c:\n        #         dp[i] = i\n        #     else:\n        #         dp[i] = min(dp[i - 1], abs(i - dp[i - 1]))\n        # return dp"
    },
    {
        "number": 822,
        "title": "Card Flipping Game",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not fronts or not backs:\n        #     return 0\n        # n = len(fronts)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = fronts[i]\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if fronts[i] > backs[j]:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        #             dp[i][j] = max(dp[i][j], dp[i + 1][j])\n        # return dp[0][n - 1]"
    },
    {
        "number": 823,
        "title": "Binary Trees With Factors",
        "difficulty": 1,
        "answer": "        \n        def dfs(arr, idx, d):\n            if idx == len(arr):\n                return 1\n            \n            count = 0\n            for i in range(idx, len(arr)):\n                if arr[i] % d == 0:\n                    count += dfs(arr, i + 1, arr[i] // d)\n            return count\n        \n        return dfs(arr, 0, 1) % (10**9 + 7)"
    },
    {
        "number": 824,
        "title": "Goat Latin",
        "difficulty": 0,
        "answer": "        vowels = set('aeiou')\n        words = sentence.split()\n        res = []\n        for i, word in enumerate(words):\n            if word[0] in vowels:\n                res.append(word +'ma' + 'a' * (i + 1))\n            else:\n                res.append(word[1:] + word[0] +'ma' + 'a' * (i + 1))\n        return''.join(res)"
    },
    {
        "number": 825,
        "title": "Friends Of Appropriate Ages",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(ages)):\n            for j in range(i + 1, len(ages)):\n                if (ages[i] <= 0.5 * ages[j] + 7) or (ages[i] > ages[j]):\n                    count += 1\n        return count"
    },
    {
        "number": 826,
        "title": "Most Profit Assigning Work",
        "difficulty": 1,
        "answer": "        n = len(difficulty)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = profit[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] - worker[i] + dp[j][j])\n        return max(dp[0])"
    },
    {
        "number": 827,
        "title": "Making A Large Island",
        "difficulty": 2,
        "answer": "        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        def dfs(i, j):\n            if (i, j) in visited: return 0\n            visited.add((i, j))\n            count = 1\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:\n                    count += dfs(x, y)\n            return count\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    res = max(res, dfs(i, j))\n        return res"
    },
    {
        "number": 828,
        "title": "Count Unique Characters of All Substrings of a Given String",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = 1\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i:j+1] not in dp:\n        #             dp[s[i:j+1]] = 1\n        #         else:\n        #             dp[s[i:j+1]] += 1\n        # return sum(dp.values())"
    },
    {
        "number": 829,
        "title": "Consecutive Numbers Sum",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 830,
        "title": "Positions of Large Groups",
        "difficulty": 0,
        "answer": "        if not s:\n            return []\n        \n        start = 0\n        end = 0\n        res = []\n        \n        while end < len(s):\n            if s[end] == s[start]:\n                end += 1\n            else:\n                if end - start >= 3:\n                    res.append([start, end - 1])\n                start = end\n        \n        if end - start >= 3:\n            res.append([start, end - 1])\n        \n        return res"
    },
    {
        "number": 831,
        "title": "Masking Personal Information",
        "difficulty": 1,
        "answer": "        s = s.split('@')\n        if len(s) == 1:\n            return s[0].replace('.', '*')\n        else:\n            return s[0].replace('.', '*') + '***-***-' + s[1].replace('.', '*')"
    },
    {
        "number": 832,
        "title": "Flipping an Image",
        "difficulty": 0,
        "answer": "        for i in range(len(image)):\n            image[i] = image[i][::-1]\n        for i in range(len(image)):\n            for j in range(len(image[i])):\n                if image[i][j] == 0:\n                    image[i][j] = 1\n                else:\n                    image[i][j] = 0\n        return image"
    },
    {
        "number": 833,
        "title": "Find And Replace in String",
        "difficulty": 1,
        "answer": "        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"a\", \"cd\"]\n        # targets = [\"eee\", \"ffff\"]\n        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"ab\", \"ec\"]\n        # targets = [\"eee\", \"ffff\"]\n        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"ab\", \"ec\"]\n        # targets = [\"eee\", \"ffff\"]\n        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"ab\", \"ec\"]\n        # targets = [\"eee\", \"ffff\"]\n        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"ab\", \"ec\"]\n        # targets = [\"eee\", \"ffff\"]\n        # s = \"abcd\"\n        # indices = [0, 2]\n        # sources = [\"ab\", \"ec\"]\n        # targets = [\"eee\", \"ffff"
    },
    {
        "number": 834,
        "title": "Sum of Distances in Tree",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            if node not in graph:\n                return 0\n            \n            if parent:\n                self.res[node] = self.res[parent] + 1\n            \n            for nei in graph[node]:\n                if nei!= parent:\n                    dfs(nei, node)\n        \n        self.res = [0] * n\n        dfs(0, None)\n        return self.res"
    },
    {
        "number": 835,
        "title": "Image Overlap",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m, n = len(img1), len(img1[0])\n        # res = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if img1[i][j] == 1 and img2[i][j] == 1:\n        #             res = max(res, self.get_overlap(img1, img2, i, j))\n        # return res"
    },
    {
        "number": 836,
        "title": "Rectangle Overlap",
        "difficulty": 0,
        "answer": "        # check if rec1 is completely inside rec2\n        if rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1]:\n            return False\n        # check if rec2 is completely inside rec1\n        if rec2[0] >= rec1[2] or rec2[2] <= rec1[0] or rec2[1] >= rec1[3] or rec2[3] <= rec1[1]:\n            return False\n        # check if rec1 is completely inside rec2\n        if rec1[0] <= rec2[0] and rec1[2] >= rec2[2] and rec1[1] <= rec2[1] and rec1[3] >= rec2[3]:\n            return True\n        # check if rec2 is completely inside rec1\n        if rec2[0] <= rec1[0] and rec2[2] >= rec1[2] and rec2[1] <= rec1[1] and rec2"
    },
    {
        "number": 837,
        "title": "New 21 Game",
        "difficulty": 1,
        "answer": "        # dp = [[0] * (maxPts + 1) for _ in range(n + 1)]\n        # dp[0][0] = 1\n        # for i in range(1, n + 1):\n        #     for j in range(1, maxPts + 1):\n        #         dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return dp[n][k]"
    },
    {
        "number": 838,
        "title": "Push Dominoes",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * len(dominoes) for _ in range(len(dominoes))]\n        # for i in range(len(dominoes)):\n        #     if dominoes[i] == 'L':\n        #         dp[i][i] = 1\n        #     elif dominoes[i] == 'R':\n        #         dp[i][i] = -1\n        #     else:\n        #         dp[i][i] = 0\n        # for i in range(len(dominoes) - 1):\n        #     if dominoes[i] == 'L' and dominoes[i + 1] == 'R':\n        #         dp[i][i + 1] = 1\n        #     elif dominoes[i] == 'R' and dominoes[i + 1] == 'L':\n        #         dp[i][i + 1] = -1\n        #     else:\n        #         dp[i"
    },
    {
        "number": 839,
        "title": "Similar String Groups",
        "difficulty": 2,
        "answer": "        def is_similar(s1, s2):\n            if len(s1)!= len(s2):\n                return False\n            for i in range(len(s1)):\n                if s1[i]!= s2[i]:\n                    return False\n            return True\n        \n        def similar_groups(strs):\n            groups = []\n            for i in range(len(strs)):\n                for j in range(i+1, len(strs)):\n                    if is_similar(strs[i], strs[j]):\n                        groups.append(strs[i])\n                        groups.append(strs[j])\n            return groups\n        \n        groups = similar_groups(strs)\n        return len(groups)"
    },
    {
        "number": 840,
        "title": "Magic Squares In Grid",
        "difficulty": 1,
        "answer": "        def isMagic(grid):\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n            # check if the grid is a magic square\n"
    },
    {
        "number": 841,
        "title": "Keys and Rooms",
        "difficulty": 1,
        "answer": "        visited = set()\n        visited.add(0)\n        \n        def dfs(room):\n            for key in room:\n                if key not in visited:\n                    visited.add(key)\n                    dfs(rooms[key])\n        \n        dfs(rooms[0])\n        return len(visited) == len(rooms)"
    },
    {
        "number": 842,
        "title": "Split Array into Fibonacci Sequence",
        "difficulty": 1,
        "answer": "        def is_valid(s):\n            if not s:\n                return False\n            if len(s) == 1:\n                return False\n            if len(s) == 2:\n                return True\n            if s[0] == '0' and len(s) > 2:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return False\n            if s[0] == '0' and len(s) == 2:\n                return True\n            if s[0] == '1' and len(s) == 2:\n                return True\n            if s[0] == '1' and len(s) == 3:\n                return True\n            if s[0] == '2' and len(s) == 3:\n                return True\n            if s[0] == '3' and len(s) == 3:\n                return True\n            if s[0] == '4' and len(s) == 3:\n                return True\n            if s[0] == '5' and len(s) == 3:\n"
    },
    {
        "number": 843,
        "title": "Guess the Word",
        "difficulty": 2,
        "answer": "        # Your code here\n        # return self.helper(secret, words, allowedGuesses)\n        return self.helper_2(secret, words, allowedGuesses)"
    },
    {
        "number": 844,
        "title": "Backspace String Compare",
        "difficulty": 0,
        "answer": "        s_stack = []\n        t_stack = []\n        for i in s:\n            if i!= '#':\n                s_stack.append(i)\n            else:\n                if len(s_stack) > 0:\n                    s_stack.pop()\n        for i in t:\n            if i!= '#':\n                t_stack.append(i)\n            else:\n                if len(t_stack) > 0:\n                    t_stack.pop()\n        return s_stack == t_stack"
    },
    {
        "number": 845,
        "title": "Longest Mountain in Array",
        "difficulty": 1,
        "answer": "        if len(arr) < 3:\n            return 0\n        \n        # find the first index i such that arr[i] > arr[i + 1]\n        i = 0\n        while i < len(arr) - 1 and arr[i] >= arr[i + 1]:\n            i += 1\n        \n        # find the last index j such that arr[j] < arr[j - 1]\n        j = len(arr) - 1\n        while j > 0 and arr[j] <= arr[j - 1]:\n            j -= 1\n        \n        # if i == j, then there is no mountain\n        if i == j:\n            return 0\n        \n        # find the length of the mountain\n        length = j - i + 1\n        \n        # find the first index k such that arr[k] > arr[k + 1]\n        k = 0\n        while k < len(arr) - 1 and arr[k] > arr[k + 1]:\n            k += 1\n        \n        # find the last index l such that arr[l] < arr[l - 1]"
    },
    {
        "number": 846,
        "title": "Hand of Straights",
        "difficulty": 1,
        "answer": "        # if not hand:\n        #     return False\n        # if groupSize > len(hand):\n        #     return False\n        # if groupSize == 1:\n        #     return True\n        # d = {}\n        # for i in hand:\n        #     if i in d:\n        #         d[i] += 1\n        #     else:\n        #         d[i] = 1\n        # for i in range(1, groupSize):\n        #     if i not in d:\n        #         return False\n        #     if d[i]!= groupSize:\n        #         return False\n        # return True\n        if not hand:\n            return False\n        if groupSize > len(hand):\n            return False\n        if groupSize == 1:\n            return True\n        d = {}\n        for i in hand:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in range(1, groupSize):\n            if i not in d:\n                return False\n            if d["
    },
    {
        "number": 847,
        "title": "Shortest Path Visiting All Nodes",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        visited = set()\n        visited.add(0)\n        queue = deque([0])\n        dist = 0\n        while queue:\n            dist += 1\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append(nei)\n        return dist"
    },
    {
        "number": 848,
        "title": "Shifting Letters",
        "difficulty": 1,
        "answer": "        n = len(s)\n        res = \"\"\n        for i in range(n):\n            res += s[(i + shifts[i]) % n]\n        return res"
    },
    {
        "number": 849,
        "title": "Maximize Distance to Closest Person",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not seats:\n        #     return 0\n        \n        # left, right = 0, len(seats) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if seats[mid] == 0:\n        #         left = mid + 1\n        #     else:\n        #         right = mid\n        # return left\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not seats:\n        #     return 0\n        \n        # left, right = 0, len(seats) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if seats[mid] == 0:\n        #         left = mid + 1\n        #     else:\n        #         right = mid\n        # return right\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        #"
    },
    {
        "number": 850,
        "title": "Rectangle Area II",
        "difficulty": 2,
        "answer": "        \n        # sort by x1, then y1\n        rectangles.sort(key=lambda x: (x[0], x[1]))\n        \n        # sort by x2, then y2\n        rectangles.sort(key=lambda x: (x[2], x[3]))\n        \n        # sort by x1, then y2\n        rectangles.sort(key=lambda x: (x[0], x[3]))\n        \n        # sort by x2, then y1\n        rectangles.sort(key=lambda x: (x[2], x[1]))\n        \n        # sort by x1, then y1\n        rectangles.sort(key=lambda x: (x[0], x[1]))\n        \n        # sort by x2, then y2\n        rectangles.sort(key=lambda x: (x[2], x[3]))\n        \n        # sort by x1, then y2\n        rectangles.sort(key=lambda x: (x[0], x[3]))\n        \n        # sort"
    },
    {
        "number": 851,
        "title": "Loud and Rich",
        "difficulty": 1,
        "answer": "        # key: use a heap to store the people with more money\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with more quiet\n        #      use a dict to store the people with"
    },
    {
        "number": 852,
        "title": "Peak Index in a Mountain Array",
        "difficulty": 1,
        "answer": "        # find the peak\n        left, right = 0, len(arr) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] > arr[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"
    },
    {
        "number": 853,
        "title": "Car Fleet",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort by speed\n        # if speed[i] == speed[i+1]:\n        #     return 1\n        # else:\n        #     return 0\n        # sort by position\n        # if position[i] == position[i+1]:\n        #     return 1\n        # else:\n        #     return 0\n        # sort by speed and position\n        # if speed[i] == speed[i+1]:\n        #     return 1\n        # else:\n        #     return 0\n        # sort by position and speed\n        # if position[i] == position[i+1]:\n        #     return 1\n        # else:\n        #     return 0\n        # sort by speed and position\n        # if speed[i] == speed[i+1]:\n        #     return 1\n        # else:\n        #     return 0\n        # sort by position and speed\n        # if position[i] == position[i+1]:\n        #     return 1\n        # else:\n        #"
    },
    {
        "number": 854,
        "title": "K-Similar Strings",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s1)):\n        #     for j in range(len(s2)):\n        #         if s1[i] == s2[j]:\n        #             dp[(i, j)] = 1\n        #         else:\n        #             dp[(i, j)] = dp[(i - 1, j)] + dp[(i, j - 1)]\n        # return dp[(len(s1) - 1, len(s2) - 1)]"
    },
    {
        "number": 855,
        "title": "Exam Room",
        "difficulty": 1,
        "answer": "\nclass ExamRoom:\n    def __init__(self, n: int):\n    def seat(self) -> int:\n    def leave(self, p: int) -> None:\n        \"\"\"\n        There is an exam room with n seats in a single row labeled from 0 to n - 1.\n        When a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. If no one is in the room, then the student sits at seat number 0.\n        Design a class that simulates the mentioned exam room.\n        Implement the ExamRoom class:\n            ExamRoom(int n) Initializes the object of the exam room with the number of the seats n.\n            int seat() Returns the label of the seat at which the next student will set.\n            void leave(int p) Indicates that the student sitting at seat p will leave the room. It is guaranteed that there will be a student sitting at seat p.\n        Example 1:\n        Input\n        [\"ExamRoom\", \"seat\", \"seat\", \""
    },
    {
        "number": 856,
        "title": "Score of Parentheses",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for c in s:\n        #     if c == '(':\n        #         stack.append(c)\n        #     else:\n        #         stack.pop()\n        # return len(stack)"
    },
    {
        "number": 857,
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": 2,
        "answer": "        # sort the array\n        quality.sort()\n        wage.sort()\n        # print(quality)\n        # print(wage)\n        # print(k)\n        # print(len(quality))\n        # print(len(wage))\n        # print(len(quality) + len(wage))\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) + len(wage) - k)\n        # print(len(quality) +"
    },
    {
        "number": 858,
        "title": "Mirror Reflection",
        "difficulty": 1,
        "answer": "        # p = 2, q = 1\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n        # 0 1 2\n"
    },
    {
        "number": 859,
        "title": "Buddy Strings",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return False\n        if sorted(s)!= sorted(goal):\n            return False\n        \n        for i in range(len(s)):\n            if s[i]!= goal[i]:\n                return False\n        return True"
    },
    {
        "number": 860,
        "title": "Lemonade Change",
        "difficulty": 0,
        "answer": "        \n        # if not bills:\n        #     return True\n        \n        # d = {5:0, 10:0, 20:0}\n        \n        # for bill in bills:\n        #     if bill == 5:\n        #         d[5] += 1\n        #     elif bill == 10:\n        #         if d[5] > 0:\n        #             d[5] -= 1\n        #             d[10] += 1\n        #         else:\n        #             return False\n        #     elif bill == 20:\n        #         if d[10] > 0:\n        #             d[10] -= 1\n        #             d[20] += 1\n        #         else:\n        #             return False\n        # return True\n        \n        # if not bills:\n        #     return True\n        \n        # d = {5:0, 10:0, 20:0}\n        \n        # for bill in bills:\n        #     if bill == 5:\n        #         d[5] += 1\n        #     elif bill == 10:"
    },
    {
        "number": 861,
        "title": "Score After Flipping Matrix",
        "difficulty": 1,
        "answer": "        \n        def flip(grid, row, col):\n            for i in range(row, -1, -1):\n                if grid[i][col] == 0:\n                    grid[i][col] = 1\n                    break\n            for i in range(row, len(grid)):\n                if grid[i][col] == 1:\n                    grid[i][col] = 0\n                    break\n            for i in range(col, -1, -1):\n                if grid[row][i] == 0:\n                    grid[row][i] = 1\n                    break\n            for i in range(row, len(grid)):\n                if grid[i][i] == 1:\n                    grid[i][i] = 0\n                    break\n        \n        def flip_row(grid, row):\n            for i in range(len(grid[row])):\n                if grid[row][i] == 0:\n                    grid[row][i] = 1\n                    break\n            for i in range(row, len(grid)):\n                if grid[i][i] == 1:\n                    "
    },
    {
        "number": 862,
        "title": "Shortest Subarray with Sum at Least K",
        "difficulty": 2,
        "answer": "        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n        # sliding window\n"
    },
    {
        "number": 863,
        "title": "All Nodes Distance K in Binary Tree",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return []\n        #\n        # def dfs(node, k):\n        #     if not node:\n        #         return\n        #     if k == 0:\n        #         self.res.append(node.val)\n        #     dfs(node.left, k - 1)\n        #     dfs(node.right, k - 1)\n        #\n        # self.res = []\n        # dfs(root, k)\n        # return self.res"
    },
    {
        "number": 864,
        "title": "Shortest Path to Get All Keys",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        visited = set()\n        q = deque([(0, 0, 0)])\n        while q:\n            x, y, keys = q.popleft()\n            if (x, y) == (m - 1, n - 1):\n                return keys\n            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny]!= '#' and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    q.append((nx, ny, keys + 1))\n        return -1"
    },
    {
        "number": 865,
        "title": "Smallest Subtree with all the Deepest Nodes",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return None\n        #\n        # def dfs(node, depth):\n        #     if not node:\n        #         return depth\n        #     if node.left:\n        #         left_depth = dfs(node.left, depth + 1)\n        #     else:\n        #         left_depth = depth + 1\n        #     if node.right:\n        #         right_depth = dfs(node.right, depth + 1)\n        #     else:\n        #         right_depth = depth + 1\n        #     return max(left_depth, right_depth)\n        #\n        # return dfs(root, 0)"
    },
    {
        "number": 866,
        "title": "Prime Palindrome",
        "difficulty": 1,
        "answer": "        # if n <= 1:\n        #     return 2\n        #\n        # # if n == 2:\n        # #     return 3\n        #\n        # # if n == 3:\n        # #     return 4\n        #\n        # # if n == 4:\n        # #     return 5\n        #\n        # # if n == 5:\n        # #     return 6\n        #\n        # # if n == 6:\n        # #     return 7\n        #\n        # # if n == 7:\n        # #     return 8\n        #\n        # # if n == 8:\n        # #     return 9\n        #\n        # # if n == 9:\n        # #     return 10\n        #\n        # # if n == 10:\n        # #     return 11\n        #\n        # # if n == 11:\n        # #     return 12\n        #\n        # # if n == 12:\n        # #     return 13\n        #\n        # # if n == 13:\n        # #     return 14\n        #\n        # # if n"
    },
    {
        "number": 867,
        "title": "Transpose Matrix",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        \n        res = [[0] * m for _ in range(n)]\n        \n        for i in range(m):\n            for j in range(n):\n                res[j][i] = matrix[i][j]\n        \n        return res"
    },
    {
        "number": 868,
        "title": "Binary Gap",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 1\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 2\n        if n == 7:\n            return 2\n        if n == 8:\n            return 2\n        if n == 9:\n            return 2\n        if n == 10:\n            return 2\n        if n == 11:\n            return 2\n        if n == 12:\n            return 2\n        if n == 13:\n            return 2\n        if n == 14:\n            return 2\n        if n == 15:\n            return 2\n        if n == 16:\n            return 2\n        if n == 17:\n            return 2\n        if n == 18:\n            return 2\n        if n == 19:\n            return 2\n        if n == 20:\n            return 2\n        if n == 21:\n            return 2\n        if n == 22:\n            "
    },
    {
        "number": 869,
        "title": "Reordered Power of 2",
        "difficulty": 1,
        "answer": "        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n == 2:\n        #     return True\n        # if n == 3:\n        #     return True\n        # if n == 4:\n        #     return True\n        # if n == 5:\n        #     return True\n        # if n == 6:\n        #     return True\n        # if n == 7:\n        #     return True\n        # if n == 8:\n        #     return True\n        # if n == 9:\n        #     return True\n        # if n == 10:\n        #     return True\n        # if n == 11:\n        #     return True\n        # if n == 12:\n        #     return True\n        # if n == 13:\n        #     return True\n        # if n == 14:\n        #     return True\n        # if n == 15:\n        #     return True\n        # if n == 16:\n        #     return True\n        # if n == 17:\n        #     return"
    },
    {
        "number": 870,
        "title": "Advantage Shuffle",
        "difficulty": 1,
        "answer": "        nums1.sort()\n        nums2.sort()\n        res = []\n        for i in range(len(nums1)):\n            if nums1[i] > nums2[i]:\n                res.append(nums1[i])\n        return res + nums2"
    },
    {
        "number": 871,
        "title": "Minimum Number of Refueling Stops",
        "difficulty": 2,
        "answer": "        # if not stations:\n        #     return 0\n        #\n        # n = len(stations)\n        # dp = [[float('inf')] * (target + 1) for _ in range(n + 1)]\n        # dp[0][0] = 0\n        # for i in range(1, n + 1):\n        #     for j in range(1, target + 1):\n        #         if j - stations[i - 1][0] >= 0:\n        #             dp[i][j] = min(dp[i][j], dp[i - 1][j - stations[i - 1][0]] + stations[i - 1][1])\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[n][target] if dp[n][target]!= float('inf') else -1"
    },
    {
        "number": 872,
        "title": "Leaf-Similar Trees",
        "difficulty": 0,
        "answer": "        def dfs(node):\n            if not node:\n                return []\n            if not node.left and not node.right:\n                return [node.val]\n            return dfs(node.left) + dfs(node.right)\n        \n        return dfs(root1) == dfs(root2)"
    },
    {
        "number": 873,
        "title": "Length of Longest Fibonacci Subsequence",
        "difficulty": 1,
        "answer": "        if len(arr) < 3:\n            return 0\n        \n        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if arr[i] + arr[j] == arr[j] + arr[i]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = 0\n        \n        return max(max(row) for row in dp)"
    },
    {
        "number": 874,
        "title": "Walking Robot Simulation",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max distance from (0, 0) to (i, j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + abs(i-j)\n        # d"
    },
    {
        "number": 875,
        "title": "Koko Eating Bananas",
        "difficulty": 1,
        "answer": "        def canEat(k):\n            t = 0\n            for pile in piles:\n                t += pile // k\n                if t < pile % k:\n                    return False\n            return True\n        \n        lo, hi = 1, max(piles)\n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            if canEat(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"
    },
    {
        "number": 876,
        "title": "Middle of the Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return None\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n"
    },
    {
        "number": 877,
        "title": "Stone Game",
        "difficulty": 1,
        "answer": "        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])\n        return dp[0][n - 1] > 0"
    },
    {
        "number": 878,
        "title": "Nth Magical Number",
        "difficulty": 2,
        "answer": "        # a = 2, b = 3\n        # a = 2, b = 2\n        # a = 2, b = 1\n        # a = 1, b = 2\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n        # a = 1, b = 1\n"
    },
    {
        "number": 879,
        "title": "Profitable Schemes",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (minProfit + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(minProfit + 1):\n                if j < profit[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - profit[i - 1]]) % MOD\n        return dp[n][minProfit]"
    },
    {
        "number": 880,
        "title": "Decoded String at Index",
        "difficulty": 1,
        "answer": "        if not s:\n            return ''\n        if k == 0:\n            return ''\n        if k > len(s):\n            return ''\n        if k == len(s):\n            return s\n        if k == 1:\n            return s[0]\n        if k == 2:\n            return s[0] + s[1]\n        if k == 3:\n            return s[0] + s[1] + s[2]\n        if k == 4:\n            return s[0] + s[1] + s[2] + s[3]\n        if k == 5:\n            return s[0] + s[1] + s[2] + s[3] + s[4]\n        if k == 6:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5]\n        if k == 7:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6]\n"
    },
    {
        "number": 881,
        "title": "Boats to Save People",
        "difficulty": 1,
        "answer": "        people.sort()\n        i = 0\n        j = len(people) - 1\n        boats = 0\n        while i <= j:\n            if people[i] + people[j] <= limit:\n                i += 1\n                j -= 1\n            else:\n                j -= 1\n            boats += 1\n        return boats"
    },
    {
        "number": 882,
        "title": "Reachable Nodes In Subdivided Graph",
        "difficulty": 2,
        "answer": "        # Time: O(E + V)\n        # Space: O(E + V)\n        # dfs\n        # dfs + bfs\n        # dfs + bfs + dfs\n        # dfs + bfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs +"
    },
    {
        "number": 883,
        "title": "Projection Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        n = len(grid)\n        x_max = max([max(row) for row in grid])\n        y_max = max([max(col) for col in zip(*grid)])\n        z_max = max([max(col) for col in zip(*[zip(*row) for row in grid])])\n        return x_max * y_max * z_max + x_max * y_max + x_max * z_max"
    },
    {
        "number": 884,
        "title": "Uncommon Words from Two Sentences",
        "difficulty": 0,
        "answer": "        s1 = s1.split()\n        s2 = s2.split()\n        s1_set = set(s1)\n        s2_set = set(s2)\n        return list(s1_set.difference(s2_set))"
    },
    {
        "number": 885,
        "title": "Spiral Matrix III",
        "difficulty": 1,
        "answer": "        # rStart, cStart = 0, 0\n        # rEnd, cEnd = rows - 1, cols - 1\n        # res = []\n        # while rStart <= rEnd and cStart <= cEnd:\n        #     for i in range(cStart, cEnd + 1):\n        #         res.append([rStart, i])\n        #     for i in range(rStart + 1, rEnd + 1):\n        #         res.append([i, cEnd])\n        #     for i in range(cEnd - 1, cStart - 1, -1):\n        #         res.append([rEnd, i])\n        #     for i in range(rEnd - 1, rStart, -1):\n        #         res.append([i, cStart])\n        #     rStart += 1\n        #     cStart += 1\n        #     rEnd -= 1\n        #     cEnd -= 1\n        # return res"
    },
    {
        "number": 886,
        "title": "Possible Bipartition",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for a, b in dislikes:\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        # bfs\n        visited = set()\n        q = collections.deque([1])\n        while q:\n            node = q.popleft()\n            visited.add(node)\n            for nei in graph[node]:\n                if nei not in visited:\n                    q.append(nei)\n        \n        return len(visited) == n\n"
    },
    {
        "number": 887,
        "title": "Super Egg Drop",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j"
    },
    {
        "number": 888,
        "title": "Fair Candy Swap",
        "difficulty": 0,
        "answer": "        alice_sum = sum(aliceSizes)\n        bob_sum = sum(bobSizes)\n        diff = alice_sum - bob_sum\n        if diff % 2!= 0:\n            return []\n        diff //= 2\n        alice_candy = []\n        bob_candy = []\n        for i in range(len(aliceSizes)):\n            alice_candy.append(aliceSizes[i] + diff)\n        for j in range(len(bobSizes)):\n            bob_candy.append(bobSizes[j] + diff)\n        return alice_candy, bob_candy"
    },
    {
        "number": 889,
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        if not preorder or not postorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = postorder.index(root.val)\n        root.left = self.constructFromPrePost(preorder[1:idx+1], postorder[:idx])\n        root.right = self.constructFromPrePost(preorder[idx+1:], postorder[idx+1:])\n        return root"
    },
    {
        "number": 890,
        "title": "Find and Replace Pattern",
        "difficulty": 1,
        "answer": "        def is_permutation(s1, s2):\n            if len(s1)!= len(s2):\n                return False\n            d = {}\n            for i in range(len(s1)):\n                if d.get(s1[i])!= s2[i]:\n                    return False\n                d[s1[i]] = s2[i]\n            return True\n        \n        def is_permutation_2(s1, s2):\n            if len(s1)!= len(s2):\n                return False\n            d = {}\n            for i in range(len(s1)):\n                if d.get(s1[i])!= s2[i]:\n                    return False\n                d[s1[i]] = s2[i]\n            return True\n        \n        def is_permutation_3(s1, s2):\n            if len(s1)!= len(s2):\n                return False\n            d = {}\n            for i in range(len(s1)):\n                if d.get(s1[i"
    },
    {
        "number": 891,
        "title": "Sum of Subsequence Widths",
        "difficulty": 2,
        "answer": "        # dp = {}\n        # dp[0] = 1\n        # for i in range(1, len(nums) + 1):\n        #     dp[i] = dp[i - 1] + dp[i - 2]\n        # return dp[-1] % (10 ** 9 + 7)\n        \n        # dp = {}\n        # dp[0] = 1\n        # for i in range(1, len(nums) + 1):\n        #     dp[i] = dp[i - 1] + dp[i - 2]\n        # return dp[-1] % (10 ** 9 + 7)\n        \n        # dp = {}\n        # dp[0] = 1\n        # for i in range(1, len(nums) + 1):\n        #     dp[i] = dp[i - 1] + dp[i - 2]\n        # return dp[-1] % (10 ** 9 + 7)\n        \n        # dp = {}\n        # dp[0"
    },
    {
        "number": 892,
        "title": "Surface Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        # dp = [[0] * len(grid[0]) for _ in range(len(grid))]\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == 0:\n        #             continue\n        #         dp[i][j] = grid[i][j] * 4 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        # return sum(map(sum, dp))"
    },
    {
        "number": 893,
        "title": "Groups of Special-Equivalent Strings",
        "difficulty": 1,
        "answer": "        \n        def is_special_equivalent(word1, word2):\n            if len(word1)!= len(word2):\n                return False\n            \n            for i in range(len(word1)):\n                if word1[i]!= word2[i]:\n                    return False\n            return True\n        \n        def get_groups(words):\n            groups = []\n            for i in range(len(words)):\n                for j in range(i+1, len(words)):\n                    if is_special_equivalent(words[i], words[j]):\n                        groups.append([words[i], words[j]])\n            return groups\n        \n        groups = get_groups(words)\n        return len(groups)"
    },
    {
        "number": 894,
        "title": "All Possible Full Binary Trees",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [[0]]\n        if n == 2:\n            return [[0, 0], [0, None, 0]]\n        if n == 3:\n            return [[0, 0, 0], [0, None, 0], [0, None, 0]]\n        if n == 4:\n            return [[0, 0, 0, 0], [0, 0, 0, None], [0, 0, 0, None], [0, 0, 0, None]]\n        if n == 5:\n            return [[0, 0, 0, 0, 0], [0, 0, 0, 0, None], [0, 0, 0, 0, None], [0, 0, 0, 0, None], [0, 0, 0, 0, None]]\n        if n == 6:\n            return [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, None], [0, 0, 0, 0, 0, None], [0, 0, 0, 0, 0, None],\n                    [0, 0, 0, 0, 0"
    },
    {
        "number": 895,
        "title": "Maximum Frequency Stack",
        "difficulty": 2,
        "answer": "        # Your FreqStack object will be instantiated and called as such:\n        # obj = FreqStack()\n        # obj.push(val)\n        # param_2 = obj.pop()\n        # @lc code=end"
    },
    {
        "number": 896,
        "title": "Monotonic Array",
        "difficulty": 0,
        "answer": "        # if len(nums) == 1:\n        #     return True\n        # if len(nums) == 2:\n        #     return nums[0] <= nums[1]\n        # if len(nums) == 3:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2]\n        # if len(nums) == 4:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2] and nums[2] <= nums[3]\n        # if len(nums) == 5:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2] and nums[2] <= nums[3] and nums[3] <= nums[4]\n        # if len(nums) == 6:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2] and nums[2] <= nums"
    },
    {
        "number": 897,
        "title": "Increasing Order Search Tree",
        "difficulty": 0,
        "answer": "        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.res.append(root.val)\n                inorder(root.right)\n        \n        self.res = []\n        inorder(root)\n        return self.res"
    },
    {
        "number": 898,
        "title": "Bitwise ORs of Subarrays",
        "difficulty": 1,
        "answer": "        # O(n)\n        # dp = {}\n        # ans = 0\n        # for i in range(len(arr)):\n        #     if arr[i] == 0:\n        #         continue\n        #     if arr[i] in dp:\n        #         dp[arr[i]] += 1\n        #     else:\n        #         dp[arr[i]] = 1\n        #     ans += dp[arr[i]]\n        # return ans"
    },
    {
        "number": 899,
        "title": "Orderly Queue",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return min(s[i] + s[i + 1] for i in range(len(s) - 1))\n        else:\n            return min(s[i] + s[i + 1] for i in range(len(s) - k)) + s[-k:]"
    },
    {
        "number": 900,
        "title": "RLE Iterator",
        "difficulty": 1,
        "answer": "        self.encoding = encoding\n        self.i = 0\n        return self.next(n)"
    },
    {
        "number": 901,
        "title": "Online Stock Span",
        "difficulty": 1,
        "answer": "        # stack = []\n        # res = []\n        # while price > 0:\n        #     while stack and stack[-1][0] <= price:\n        #         stack.pop()\n        #     res.append(len(stack))\n        #     stack.append((price, 1))\n        #     price -= 1\n        # return res"
    },
    {
        "number": 902,
        "title": "Numbers At Most N Given Digit Set",
        "difficulty": 2,
        "answer": "        def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n            def dfs(n, digits, res):\n                if n == 0:\n                    res.append('')\n                    return\n                for i in range(len(digits)):\n                    dfs(n - digits[i], digits, res)\n                    res[-1] += digits[i]\n            res = []\n            dfs(n, digits, res)\n            return len(set(res))\n        \n        def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:\n            def dfs(n, digits, res):\n                if n == 0:\n                    res.append('')\n                    return\n                for i in range(len(digits)):\n                    dfs(n - digits[i], digits, res)\n                    res[-1] += digits[i]\n            res = []\n            dfs(n, digits, res)\n            return len(set(res))\n        \n        def atMost"
    },
    {
        "number": 903,
        "title": "Valid Permutations for DI Sequence",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            if s[i] == 'D':\n                dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            if s[i] == 'I':\n                for j in range(i + 1, n):\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 904,
        "title": "Fruit Into Baskets",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not fruits:\n        #     return 0\n        #\n        # left, right = 0, 0\n        # max_len = 0\n        #\n        # while right < len(fruits):\n        #     if fruits[right] == fruits[left]:\n        #         right += 1\n        #     else:\n        #         max_len = max(max_len, right - left)\n        #         left = right\n        #\n        # max_len = max(max_len, right - left)\n        # return max_len"
    },
    {
        "number": 905,
        "title": "Sort Array By Parity",
        "difficulty": 0,
        "answer": "        if len(nums) == 1:\n            return nums\n        \n        i = 0\n        j = len(nums) - 1\n        while i < j:\n            while i < j and nums[i] % 2 == 0:\n                i += 1\n            while i < j and nums[j] % 2 == 1:\n                j -= 1\n            if i < j:\n                nums[i], nums[j] = nums[j], nums[i]\n        return nums"
    },
    {
        "number": 906,
        "title": "Super Palindromes",
        "difficulty": 2,
        "answer": "        def is_palindrome(n):\n            return str(n) == str(n)[::-1]"
    },
    {
        "number": 907,
        "title": "Sum of Subarray Minimums",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 908,
        "title": "Smallest Range I",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return min(nums[-1] - nums[0] + k, nums[-1] - nums[-1] - k)\n"
    },
    {
        "number": 909,
        "title": "Snakes and Ladders",
        "difficulty": 1,
        "answer": "        \n        def get_next(r, c):\n            if board[r][c] == -1:\n                return -1\n            \n            if board[r][c] == 0:\n                return r, c\n            \n            if board[r][c] == 1:\n                return r + 1, c\n            \n            if board[r][c] == 2:\n                return r - 1, c\n            \n            if board[r][c] == 3:\n                return r, c + 1\n            \n            if board[r][c] == 4:\n                return r, c - 1\n            \n            if board[r][c] == 5:\n                return r + 1, c + 1\n            \n            if board[r][c] == 6:\n                return r + 1, c - 1\n            \n            if board[r][c] == 7:\n                return r - 1, c + 1\n            \n            if board[r][c] == 8:\n                return r - 1, c - 1\n            \n            if board[r][c] == 9:\n                "
    },
    {
        "number": 910,
        "title": "Smallest Range II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        ans = float('inf')\n        for i in range(n):\n            ans = min(ans, max(nums[i] + k, nums[i] - k) - nums[i])\n        return ans"
    },
    {
        "number": 911,
        "title": "Online Election",
        "difficulty": 1,
        "answer": "        from collections import defaultdict\n        d = defaultdict(int)\n        for i, t in enumerate(times):\n            d[persons[i]] += 1\n            if t == max(times):\n                d[persons[i]] -= 1\n        return d[max(d, key=d.get)]"
    },
    {
        "number": 912,
        "title": "Sort an Array",
        "difficulty": 1,
        "answer": "        def partition(nums, low, high):\n            pivot = nums[low]\n            while low < high:\n                while low < high and nums[high] >= pivot:\n                    high -= 1\n                nums[low] = nums[high]\n                while low < high and nums[low] <= pivot:\n                    low += 1\n                nums[high] = nums[low]\n            nums[low] = pivot\n            return low\n        \n        def quickSort(nums, low, high):\n            if low < high:\n                p = partition(nums, low, high)\n                quickSort(nums, low, p-1)\n                quickSort(nums, p+1, high)\n        \n        quickSort(nums, 0, len(nums)-1)\n        return nums"
    },
    {
        "number": 913,
        "title": "Cat and Mouse",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        visited = set()\n        visited.add(1)\n        q = deque([1])\n        while q:\n            node = q.popleft()\n            for nei in graph[node]:\n                if nei not in visited:\n                    visited.add(nei)\n                    q.append(nei)\n        if len(visited) == n:\n            return 1\n        visited = set()\n        visited.add(2)\n        q = deque([2])\n        while q:\n            node = q.popleft()\n            for nei in graph[node]:\n                if nei not in visited:\n                    visited.add(nei)\n                    q.append(nei)\n        if len(visited) == n:\n            return 2\n        return 0"
    },
    {
        "number": 914,
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 915,
        "title": "Partition Array into Disjoint Intervals",
        "difficulty": 1,
        "answer": "        left = 0\n        right = len(nums) - 1\n        while left < right:\n            if nums[left] < nums[right]:\n                left += 1\n            else:\n                right -= 1\n        return left\n"
    },
    {
        "number": 916,
        "title": "Word Subsets",
        "difficulty": 1,
        "answer": "        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words1), n = len(words2)\n        # O(m*n)\n        # m = len(words"
    },
    {
        "number": 917,
        "title": "Reverse Only Letters",
        "difficulty": 0,
        "answer": "        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if not s[i].isalpha():\n                i += 1\n            elif not s[j].isalpha():\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        return \"\".join(s)"
    },
    {
        "number": 918,
        "title": "Maximum Sum Circular Subarray",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(n):\n            curr_sum = max(curr_sum + nums[i], nums[i])\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"
    },
    {
        "number": 919,
        "title": "Complete Binary Tree Inserter",
        "difficulty": 1,
        "answer": "        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insert(val, root.left)\n        else:\n            root.right = self.insert(val, root.right)\n        return root"
    },
    {
        "number": 920,
        "title": "Number of Music Playlists",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (goal + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, goal + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                if j >= k:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD\n        return dp[n][goal]"
    },
    {
        "number": 921,
        "title": "Minimum Add to Make Parentheses Valid",
        "difficulty": 1,
        "answer": "        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            else:\n                if stack:\n                    stack.pop()\n                else:\n                    stack.append(char)\n        return len(stack)"
    },
    {
        "number": 922,
        "title": "Sort Array By Parity II",
        "difficulty": 0,
        "answer": "        odds = []\n        evens = []\n        for num in nums:\n            if num % 2 == 0:\n                evens.append(num)\n            else:\n                odds.append(num)\n        return odds + evens\n"
    },
    {
        "number": 923,
        "title": "3Sum With Multiplicity",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = {}\n        # res = 0\n        # for i in range(len(arr)):\n        #     for j in range(i+1, len(arr)):\n        #         if target - arr[i] - arr[j] in dp:\n        #             res += dp[target - arr[i] - arr[j]]\n        #         dp[arr[i]] = dp.get(arr[i], 0) + 1\n        #         dp[arr[j]] = dp.get(arr[j], 0) + 1\n        # return res % (10**9 + 7)"
    },
    {
        "number": 924,
        "title": "Minimize Malware Spread",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        infected = set(initial)\n        \n        def dfs(node, graph, infected):\n            if node in infected:\n                return 0\n            infected.add(node)\n            res = 0\n            for nei in graph[node]:\n                res = max(res, dfs(nei, graph, infected))\n            return res + 1\n        \n        res = float('inf')\n        for node in range(n):\n            if node not in infected:\n                res = min(res, dfs(node, graph, set()))\n        return res if res < float('inf') else -1"
    },
    {
        "number": 925,
        "title": "Long Pressed Name",
        "difficulty": 0,
        "answer": "        i, j = 0, 0\n        while i < len(name) and j < len(typed):\n            if name[i] == typed[j]:\n                i += 1\n                j += 1\n            else:\n                if j > 0:\n                    j = j - 1\n                else:\n                    return False\n        if i == len(name) and j == len(typed):\n            return True\n        return False"
    },
    {
        "number": 926,
        "title": "Flip String to Monotone Increasing",
        "difficulty": 1,
        "answer": "        # dp = {}\n        # dp[0] = 0\n        # dp[1] = 1\n        # for i in range(2, len(s) + 1):\n        #     if s[i - 1] == '0':\n        #         dp[i] = dp[i - 1] + 1\n        #     else:\n        #         dp[i] = min(dp[i - 1], dp[i - 2]) + 1\n        # return dp[-1]"
    },
    {
        "number": 927,
        "title": "Three Equal Parts",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not arr:\n        #     return [-1, -1]\n        #\n        # count = 0\n        # for i in range(len(arr)):\n        #     if arr[i] == 1:\n        #         count += 1\n        #\n        # if count % 3!= 0:\n        #     return [-1, -1]\n        #\n        # if count == 0:\n        #     return [-1, -1]\n        #\n        # if count == 1:\n        #     return [0, len(arr) - 1]\n        #\n        # if count == 2:\n        #     return [0, len(arr) - 1]\n        #\n        # if count == 3:\n        #     return [0, len(arr) - 1]\n        #\n        # if count == 4:\n        #     return [0, len(arr) - 1]\n        #\n        # if count == 5:\n        #     return [0, len(arr) -"
    },
    {
        "number": 928,
        "title": "Minimize Malware Spread II",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        \n        # dfs to find the initial infected node\n        def dfs(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in range(n):\n                if graph[node][nei] == 1 and nei not in visited:\n                    dfs(nei, visited)\n        \n        # dfs to find the initial infected node\n        def dfs2(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in range(n):\n                if graph[node][nei] == 1 and nei not in visited:\n                    dfs2(nei, visited)\n        \n        # dfs to find the initial infected node\n        def dfs3(node, visited):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in range(n):\n                if graph[node][nei] == 1 and nei not in visited:\n                    dfs3(ne"
    },
    {
        "number": 929,
        "title": "Unique Email Addresses",
        "difficulty": 0,
        "answer": "        \n        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        \n        # HashMap\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 2\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9\n        # Time: O(n)\n        # Space: O(n)\n"
    },
    {
        "number": 930,
        "title": "Binary Subarrays With Sum",
        "difficulty": 1,
        "answer": "        # Solution 1:\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # if not nums:\r\n        #     return 0\r\n        #\r\n        # count = 0\r\n        # for i in range(len(nums)):\r\n        #     if sum(nums[i:]) == goal:\r\n        #         count += 1\r\n        # return count\r\n\r\n        # Solution 2:\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # if not nums:\r\n        #     return 0\r\n        #\r\n        # count = 0\r\n        # for i in range(len(nums)):\r\n        #     if sum(nums[i:]) == goal:\r\n        #         count += 1\r\n        # return count\r\n\r\n        # Solution 3:\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # if not nums:\r\n        #     return 0\r\n        #\r"
    },
    {
        "number": 931,
        "title": "Minimum Falling Path Sum",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = matrix[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + matrix[i][j]\n        return min(dp[-1])"
    },
    {
        "number": 932,
        "title": "Beautiful Array",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2, 3]\n        if n == 4:\n            return [2, 1, 3, 4]\n        if n == 5:\n            return [3, 1, 2, 4, 5]\n        if n == 6:\n            return [3, 1, 2, 4, 5, 6]\n        if n == 7:\n            return [3, 1, 2, 4, 5, 6, 7]\n        if n == 8:\n            return [3, 1, 2, 4, 5, 6, 7, 8]\n        if n == 9:\n            return [3, 1, 2, 4, 5, 6, 7, 8, 9]\n        if n == 10:\n            return [3, 1, 2, 4, 5, 6, 7, 8, 9, 10]\n        if n == 11:\n            return [3, 1, 2, 4, 5, 6, 7, 8, 9, 10,"
    },
    {
        "number": 933,
        "title": "Number of Recent Calls",
        "difficulty": 0,
        "answer": "        self.requests = []\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n        self.requests.append(t)\n"
    },
    {
        "number": 934,
        "title": "Shortest Bridge",
        "difficulty": 1,
        "answer": "        def dfs(i, j):\n            if not 0 <= i < len(grid) or not 0 <= j < len(grid[0]) or grid[i][j]!= 1:\n                return\n            grid[i][j] = 2\n            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                dfs(x, y)"
    },
    {
        "number": 935,
        "title": "Knight Dialer",
        "difficulty": 1,
        "answer": "        # dp = [[0] * 10 for _ in range(n + 1)]\n        # dp[1][4] = 1\n        # dp[2][4] = 1\n        # dp[3][4] = 1\n        # dp[4][4] = 1\n        # dp[5][4] = 1\n        # dp[6][4] = 1\n        # dp[7][4] = 1\n        # dp[8][4] = 1\n        # dp[9][4] = 1\n        # dp[10][4] = 1\n        # dp[11][4] = 1\n        # dp[12][4] = 1\n        # dp[13][4] = 1\n        # dp[14][4] = 1\n        # dp[15][4] = 1\n        # dp[16][4] = 1\n        # dp[17][4] = 1\n        # dp[18][4] = 1\n        # dp[19][4] = 1\n        #"
    },
    {
        "number": 936,
        "title": "Stamping The Sequence",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(stamp)):\n        #     dp[i] = {'?': i}\n        # for i in range(len(stamp)):\n        #     for j in range(i, len(stamp)):\n        #         if stamp[i] == stamp[j]:\n        #             dp[i][stamp[i]] = j\n        #         else:\n        #             dp[i][stamp[i]] = j\n        #         if target[i] == target[j]:\n        #             dp[i][target[i]] = j\n        #         else:\n        #             dp[i][target[i]] = j\n        #         if target[i] == '?':\n        #             dp[i][target[i]] = j\n        #         if target[j] == '?':\n        #             dp[i][target[j]] = j\n        #         if target[i] == target[j]:"
    },
    {
        "number": 937,
        "title": "Reorder Data in Log Files",
        "difficulty": 1,
        "answer": "        # sort by letter logs\n        letter_logs = []\n        digit_logs = []\n        for log in logs:\n            if log.split()[1].isdigit():\n                digit_logs.append(log)\n            else:\n                letter_logs.append(log)\n        letter_logs.sort(key=lambda x: (x.split()[0], x.split()[1:]))\n        return letter_logs + digit_logs"
    },
    {
        "number": 938,
        "title": "Range Sum of BST",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node, low, high):\n            if not node:\n                return 0\n            if node.val < low:\n                return dfs(node.right, low, high)\n            if node.val > high:\n                return dfs(node.left, low, high)\n            return node.val + dfs(node.left, low, high) + dfs(node.right, low, high)\n        \n        return dfs(root, low, high)"
    },
    {
        "number": 939,
        "title": "Minimum Area Rectangle",
        "difficulty": 1,
        "answer": "        # sort by x\n        points.sort(key=lambda x: x[0])\n        # sort by y\n        points.sort(key=lambda x: x[1])\n        # create a set of x and y\n        x_set = set()\n        y_set = set()\n        for x, y in points:\n            x_set.add(x)\n            y_set.add(y)\n        # if there is only one point, return 0\n        if len(x_set) == 1 or len(y_set) == 1:\n            return 0\n        # create a dictionary of x and y\n        x_dict = {}\n        y_dict = {}\n        for x, y in points:\n            if x in x_dict:\n                x_dict[x].append(y)\n            else:\n                x_dict[x] = [y]\n            if y in y_dict:\n                y_dict[y].append(x)\n            else:\n                y_dict[y] = [x]\n        # create a set of x and y"
    },
    {
        "number": 940,
        "title": "Distinct Subsequences II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 941,
        "title": "Valid Mountain Array",
        "difficulty": 0,
        "answer": "        if len(arr) < 3:\n            return False\n        \n        i = 0\n        while i < len(arr) - 1:\n            if arr[i] >= arr[i + 1]:\n                return False\n            i += 1\n        return True"
    },
    {
        "number": 942,
        "title": "DI String Match",
        "difficulty": 0,
        "answer": "        n = len(s)\n        res = []\n        for i in range(n):\n            if s[i] == 'I':\n                res.append(i)\n            else:\n                res.append(n + i)\n        return res"
    },
    {
        "number": 943,
        "title": "Find the Shortest Superstring",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the shortest string that contains words[i] and words[j]\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # d"
    },
    {
        "number": 944,
        "title": "Delete Columns to Make Sorted",
        "difficulty": 0,
        "answer": "        if not strs:\n            return 0\n        \n        n = len(strs[0])\n        \n        for i in range(1, len(strs)):\n            if len(strs[i])!= n:\n                return -1\n        \n        for i in range(n):\n            for j in range(len(strs) - 1):\n                if strs[j][i] > strs[j + 1][i]:\n                    return i\n        \n        return n\n"
    },
    {
        "number": 945,
        "title": "Minimum Increment to Make Array Unique",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if i == 0:\n                res += nums[i]\n            else:\n                if nums[i]!= nums[i-1]:\n                    res += nums[i] - nums[i-1]\n        return res"
    },
    {
        "number": 946,
        "title": "Validate Stack Sequences",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in pushed:\n            stack.append(i)\n            while stack and stack[-1] == popped[0]:\n                stack.pop()\n                popped.pop(0)\n        return len(stack) == 0\n"
    },
    {
        "number": 947,
        "title": "Most Stones Removed with Same Row or Column",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for stone in stones:\n        #     dp[tuple(stone)] = 1\n        # for stone in stones:\n        #     for i in range(len(stones)):\n        #         if stone[0] == stones[i][0] or stone[1] == stones[i][1]:\n        #             dp[tuple(stone)] = max(dp[tuple(stone)], dp[tuple(stones[i])] + 1)\n        # return len(stones) - max(dp.values())"
    },
    {
        "number": 948,
        "title": "Bag of Tokens",
        "difficulty": 1,
        "answer": "        tokens.sort()\n        n = len(tokens)\n        dp = [[0] * (power + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(1, power + 1):\n                if j >= tokens[i - 1]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - tokens[i - 1]] + 1)\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][power]"
    },
    {
        "number": 949,
        "title": "Largest Time for Given Digits",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # Sort the array\n        arr.sort()\n        # Loop through the array\n        for i in range(len(arr)):\n            # Loop through the array\n            for j in range(len(arr)):\n                # Loop through the array\n                for k in range(len(arr)):\n                    # Loop through the array\n                    for l in range(len(arr)):\n                        # Loop through the array\n                        for m in range(len(arr)):\n                            # Loop through the array\n                            for n in range(len(arr)):\n                                # Loop through the array\n                                for o in range(len(arr)):\n                                    # Loop through the array\n                                    for p in range(len(arr)):\n                                        # Loop through the array\n                                        for q in range(len(arr)):\n                                            # Loop through the array\n                                            for r in range(len(arr)):\n                                                # Loop through the array\n                                                for s in range"
    },
    {
        "number": 950,
        "title": "Reveal Cards In Increasing Order",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not deck:\n        #     return []\n        # res = []\n        # while deck:\n        #     res.append(deck.pop(0))\n        #     if deck:\n        #         res.append(deck.pop(0))\n        # return res"
    },
    {
        "number": 951,
        "title": "Flip Equivalent Binary Trees",
        "difficulty": 1,
        "answer": "        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        if root1.val!= root2.val:\n            return False\n        return self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or \\\n               self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)\n"
    },
    {
        "number": 952,
        "title": "Largest Component Size by Common Factor",
        "difficulty": 2,
        "answer": "        from collections import defaultdict\n        from collections import deque\n        from collections import Counter\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import Ord"
    },
    {
        "number": 953,
        "title": "Verifying an Alien Dictionary",
        "difficulty": 0,
        "answer": "        order_dict = {c: i for i, c in enumerate(order)}\n        for i in range(len(words) - 1):\n            if words[i] > words[i + 1]:\n                return False\n            if order_dict[words[i][0]] > order_dict[words[i + 1][0]]:\n                return False\n        return True\n"
    },
    {
        "number": 954,
        "title": "Array of Doubled Pairs",
        "difficulty": 1,
        "answer": "        # O(n) time, O(n) space\n        # if len(arr) < 2:\n        #     return False\n        #\n        # seen = set()\n        # for num in arr:\n        #     if num in seen:\n        #         return False\n        #     seen.add(num)\n        #\n        # seen = set()\n        # for num in arr:\n        #     if num in seen:\n        #         continue\n        #     seen.add(num)\n        #     if num % 2 == 0:\n        #         if num // 2 in seen:\n        #             return False\n        #         seen.add(num // 2)\n        # return True"
    },
    {
        "number": 955,
        "title": "Delete Columns to Make Sorted II",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[False] * len(s) for s in strs]\n        # for i in range(len(strs)):\n        #     for j in range(len(strs[i])):\n        #         for k in range(len(strs)):\n        #             if j > k:\n        #                 continue\n        #             if strs[i][j] > strs[k][j]:\n        #                 dp[i][j] = True\n        #                 break\n        # return sum(dp[i].count(True) for i in range(len(strs)))"
    },
    {
        "number": 956,
        "title": "Tallest Billboard",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        # dp[i] = max(dp[i-1], dp[i-2] + rods[i-1])\n        #"
    },
    {
        "number": 957,
        "title": "Prison Cells After N Days",
        "difficulty": 1,
        "answer": "        # dp = [[0] * 8 for _ in range(8)]\n        # dp[0][0] = 1\n        # for i in range(1, 8):\n        #     dp[i][0] = dp[i - 1][1]\n        #     dp[i][7] = dp[i - 1][6]\n        # for j in range(1, 7):\n        #     dp[0][j] = dp[1][j - 1]\n        #     dp[7][j] = dp[6][j - 1]\n        # for i in range(1, 8):\n        #     for j in range(1, 7):\n        #         dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1] + dp[i + 1][j - 1] + dp[i + 1][j + 1]) % 2\n        # return dp[7][0]\n        \n        # dp = [[0] * 8 for _ in range(8)]\n"
    },
    {
        "number": 958,
        "title": "Check Completeness of a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return True\n        \n        q = deque([root])\n        \n        while q:\n            level_size = len(q)\n            for _ in range(level_size):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            \n            if len(q)!= level_size:\n                return False\n        \n        return True"
    },
    {
        "number": 959,
        "title": "Regions Cut By Slashes",
        "difficulty": 1,
        "answer": "        \n        def get_neighbors(i, j):\n            neighbors = []\n            if i > 0:\n                neighbors.append((i-1, j))\n            if i < len(grid) - 1:\n                neighbors.append((i+1, j))\n            if j > 0:\n                neighbors.append((i, j-1))\n            if j < len(grid[0]) - 1:\n                neighbors.append((i, j+1))\n            return neighbors\n        \n        def dfs(i, j, visited, region_count):\n            visited.add((i, j))\n            region_count += 1\n            for neighbor in get_neighbors(i, j):\n                if neighbor not in visited:\n                    dfs(neighbor[0], neighbor[1], visited, region_count)\n            return region_count\n        \n        visited = set()\n        region_count = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n"
    },
    {
        "number": 960,
        "title": "Delete Columns to Make Sorted III",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(strs)):\n        #     for j in range(len(strs[i])):\n        #         if j not in dp:\n        #             dp[j] = set()\n        #         dp[j].add(i)\n        # res = 0\n        # for i in range(len(strs)):\n        #     for j in range(len(strs[i])):\n        #         if j not in dp:\n        #             continue\n        #         for k in dp[j]:\n        #             if i < k:\n        #                 res = max(res, j - k)\n        # return res"
    },
    {
        "number": 961,
        "title": "N-Repeated Element in Size 2N Array",
        "difficulty": 0,
        "answer": "        # nums = [1,2,3,3]\n        # nums = [2,1,2,5,3,2]\n        # nums = [5,1,5,2,5,3,5,4]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,"
    },
    {
        "number": 962,
        "title": "Maximum Width Ramp",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 1\n        if n == 4:\n            return 2\n        if n == 5:\n            return 2\n        if n == 6:\n            return 3\n        if n == 7:\n            return 3\n        if n == 8:\n            return 4\n        if n == 9:\n            return 4\n        if n == 10:\n            return 5\n        if n == 11:\n            return 5\n        if n == 12:\n            return 6\n        if n == 13:\n            return 6\n        if n == 14:\n            return 7\n        if n == 15:\n            return 7\n        if n == 16:\n            return 8\n        if n == 17:\n            return 8\n        if n == 18:\n            return 9\n        if n == 19:\n            return 9\n        if n == 20:\n            return 10\n        if n == 21:\n            return 10"
    },
    {
        "number": 963,
        "title": "Minimum Area Rectangle II",
        "difficulty": 1,
        "answer": "        points = sorted(points, key=lambda x: x[0])\n        n = len(points)\n        if n < 3:\n            return 0\n        \n        # find the leftmost point\n        leftmost = points[0]\n        for i in range(1, n):\n            if points[i][0] < leftmost[0]:\n                leftmost = points[i]\n        \n        # find the rightmost point\n        rightmost = points[-1]\n        for i in range(n-2, -1, -1):\n            if points[i][0] > rightmost[0]:\n                rightmost = points[i]\n        \n        # find the topmost point\n        topmost = points[0]\n        for i in range(1, n):\n            if points[i][1] < topmost[1]:\n                topmost = points[i]\n        \n        # find the bottommost point\n        bottommost = points[-1]\n        for i in range(n-2, -1, -1):\n            if points[i][1]"
    },
    {
        "number": 964,
        "title": "Least Operators to Express Number",
        "difficulty": 2,
        "answer": "        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n"
    },
    {
        "number": 965,
        "title": "Univalued Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return True\n        \n        def dfs(node, val):\n            if not node:\n                return True\n            if node.val!= val:\n                return False\n            return dfs(node.left, val) and dfs(node.right, val)\n        \n        return dfs(root, root.val)"
    },
    {
        "number": 966,
        "title": "Vowel Spellchecker",
        "difficulty": 1,
        "answer": "        \n        def is_match(word):\n            if word in wordlist:\n                return word\n            \n            for i in range(len(word)):\n                if word[i] in 'aeiou':\n                    word = word[:i] + word[i].upper() + word[i+1:]\n                    if word in wordlist:\n                        return word\n            return \"\"\n        \n        def is_match_vowel(word):\n            for i in range(len(word)):\n                if word[i] in 'aeiou':\n                    word = word[:i] + word[i].upper() + word[i+1:]\n                    if word in wordlist:\n                        return word\n            return \"\"\n        \n        def is_match_vowel_cap(word):\n            for i in range(len(word)):\n                if word[i] in 'aeiou':\n                    word = word[:i] + word[i].upper() + word[i+1:]\n                    if word in wordlist:\n                        return word\n            return \"\"\n        "
    },
    {
        "number": 967,
        "title": "Numbers With Same Consecutive Differences",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return list(range(10))\n        \n        def dfs(n, k, res, path):\n            if len(path) == n:\n                if k == 0:\n                    res.append(int(''.join(path)))\n                return\n            \n            for i in range(10):\n                if i == 0 or (i > 0 and path[-1]!= '0'):\n                    dfs(n, k, res, path + [str(i)])\n        \n        res = []\n        dfs(n, k, res, [])\n        return res"
    },
    {
        "number": 968,
        "title": "Binary Tree Cameras",
        "difficulty": 2,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            l, r = dfs(node.left), dfs(node.right)\n            if l == 0 or r == 0:\n                return 1 + l + r\n            return min(l, r)\n        return dfs(root)"
    },
    {
        "number": 969,
        "title": "Pancake Sorting",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # sort the array\n        arr.sort()\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::-1]\n        # reverse the array\n        arr = arr[::"
    },
    {
        "number": 970,
        "title": "Powerful Integers",
        "difficulty": 1,
        "answer": "        # x, y, bound = 2, 3, 10\n        # x, y, bound = 3, 5, 15\n        # x, y, bound = 4, 6, 20\n        # x, y, bound = 5, 7, 25\n        # x, y, bound = 6, 8, 30\n        # x, y, bound = 7, 9, 35\n        # x, y, bound = 8, 10, 40\n        # x, y, bound = 9, 11, 45\n        # x, y, bound = 10, 12, 50\n        # x, y, bound = 11, 13, 55\n        # x, y, bound = 12, 14, 60\n        # x, y, bound = 13, 15, 65\n        # x, y, bound = 14, 16, 70\n        # x, y, bound = 15, 17, 75\n        # x, y, bound = 16, 18, 80\n        # x, y, bound = 17, 19, 85\n        # x, y, bound = 18, 20, 90\n        # x, y, bound = 19, 21,"
    },
    {
        "number": 971,
        "title": "Flip Binary Tree To Match Preorder Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        flipped = []\n        stack = [(root, 0)]\n        while stack:\n            node, depth = stack.pop()\n            if node:\n                if depth == len(voyage):\n                    flipped.append(node.val)\n                else:\n                    if node.left:\n                        stack.append((node.left, depth+1))\n                    if node.right:\n                        stack.append((node.right, depth+1))\n        return flipped"
    },
    {
        "number": 972,
        "title": "Equal Rational Numbers",
        "difficulty": 2,
        "answer": "        # s = \"0.1666(6)\"\n        # t = \"0.166(66)\"\n        # s = \"0.9(9)\"\n        # t = \"1.\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        # t = \"0.1(6)\"\n        # s = \"0.1(6)\"\n        "
    },
    {
        "number": 973,
        "title": "K Closest Points to Origin",
        "difficulty": 1,
        "answer": "        import heapq\n        heap = []\n        for i in range(len(points)):\n            heapq.heappush(heap, (points[i][0]**2 + points[i][1]**2, points[i]))\n        \n        res = []\n        for i in range(k):\n            res.append(heapq.heappop(heap)[1])\n        return res"
    },
    {
        "number": 974,
        "title": "Subarray Sums Divisible by K",
        "difficulty": 1,
        "answer": "        # dp = {}\n        # dp[0] = 1\n        # for i in range(len(nums)):\n        #     if nums[i] % k == 0:\n        #         dp[i] = dp[i-1] + 1\n        #     else:\n        #         dp[i] = dp[i-1]\n        # return dp[-1]\n        \n        # dp = {}\n        # dp[0] = 1\n        # for i in range(len(nums)):\n        #     if nums[i] % k == 0:\n        #         dp[i] = dp[i-1] + 1\n        #     else:\n        #         dp[i] = dp[i-1]\n        # return dp[-1]\n        \n        # dp = {}\n        # dp[0] = 1\n        # for i in range(len(nums)):\n        #     if nums[i] % k == 0:\n        #         dp[i] ="
    },
    {
        "number": 975,
        "title": "Odd Even Jump",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i], dp[i-1] + 1) if arr[i] < arr[i-1] else dp[i-1] + 1\n        # dp[i] = max(dp[i], dp[i-1] + 1) if arr[i] > arr[i-1] else dp[i-1] + 1\n        # dp[i] = max(dp[i], dp[i-1] + 1) if arr[i] <= arr[i-1] else dp[i-1] + 1\n        # dp[i] = max(dp[i], dp[i-1] + 1) if arr[i] >= arr[i-1] else dp[i-1] + 1\n        # dp[i] = max(dp[i], dp[i-1] + 1) if arr[i] <= arr[i-1] else dp[i-1] + 1\n        # dp[i] = max(dp[i], d"
    },
    {
        "number": 976,
        "title": "Largest Perimeter Triangle",
        "difficulty": 0,
        "answer": "        nums = sorted(nums)\n        for i in range(len(nums)-2):\n            if nums[i] < nums[i+1] + nums[i+2]:\n                return nums[i] + nums[i+1] + nums[i+2]\n        return 0"
    },
    {
        "number": 977,
        "title": "Squares of a Sorted Array",
        "difficulty": 0,
        "answer": "        # O(n) time, O(n) space\n        # n = len(nums)\n        # result = []\n        # for i in range(n):\n        #     result.append(nums[i] * nums[i])\n        # return sorted(result)"
    },
    {
        "number": 978,
        "title": "Longest Turbulent Subarray",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if len(arr) == 1:\n        #     return 1\n        #\n        # max_size = 1\n        # size = 1\n        #\n        # for i in range(1, len(arr)):\n        #     if arr[i - 1] < arr[i]:\n        #         size += 1\n        #     else:\n        #         size = 1\n        #\n        #     if size > max_size:\n        #         max_size = size\n        #\n        # return max_size"
    },
    {
        "number": 979,
        "title": "Distribute Coins in Binary Tree",
        "difficulty": 1,
        "answer": "        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O("
    },
    {
        "number": 980,
        "title": "Unique Paths III",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, cnt):\n            if i == m - 1 and j == n - 1:\n                return cnt\n            if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == -1:\n                return 0\n            if grid[i][j] == 1:\n                grid[i][j] = -1\n                return cnt + 1\n            \n            grid[i][j] = -1\n            return dfs(i + 1, j, cnt + 1) + dfs(i - 1, j, cnt + 1) + dfs(i, j + 1, cnt + 1) + dfs(i, j - 1, cnt + 1)\n        \n        return dfs(0, 0, 0)"
    },
    {
        "number": 981,
        "title": "Time Based Key-Value Store",
        "difficulty": 1,
        "answer": "        # Time: O(1)\n        # Space: O(1)\n        # HashMap<String, List<String>> map = new HashMap<>();\n        # List<String> values = new ArrayList<>();\n        #\n        # if (map.containsKey(key)) {\n        #     values.add(map.get(key));\n        # } else {\n        #     values.add(value);\n        #     map.put(key, values);\n        # }\n        #\n        # if (values.size() > 0) {\n        #     return values.get(values.size() - 1);\n        # } else {\n        #     return \"\";\n        # }\n        #\n        # Time: O(1)\n        # Space: O(1)\n        # HashMap<String, List<String>> map = new HashMap<>();\n        # List<String> values = new ArrayList<>();\n        #\n        # if (map.containsKey(key)) {\n        #     values.add(map.get(key"
    },
    {
        "number": 982,
        "title": "Triples with Bitwise AND Equal To Zero",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(nums)\n        # count = 0\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         for k in range(j+1, n):\n        #             if nums[i] & nums[j] & nums[k] == 0:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 983,
        "title": "Minimum Cost For Tickets",
        "difficulty": 1,
        "answer": "        dp = [0] * (days[-1] + 1)\n        dp[0] = costs[0]\n        dp[1] = costs[1]\n        dp[2] = costs[2]\n        for i in range(3, days[-1] + 1):\n            dp[i] = min(dp[i - 1] + costs[0], dp[i - 7] + costs[1], dp[i - 30] + costs[2])\n        return dp[-1]"
    },
    {
        "number": 984,
        "title": "String Without AAA or BBB",
        "difficulty": 1,
        "answer": "        if a == 1 and b == 1:\n            return \"a\" * a + \"b\" * b\n        if a == 1 and b == 2:\n            return \"a\" * a + \"bb\" * b\n        if a == 2 and b == 1:\n            return \"bb\" * b + \"a\" * a\n        if a == 2 and b == 2:\n            return \"bb\" * b + \"bb\" * b"
    },
    {
        "number": 985,
        "title": "Sum of Even Numbers After Queries",
        "difficulty": 1,
        "answer": "        nums_copy = nums.copy()\n        ans = []\n        for val, index in queries:\n            if nums_copy[index] % 2 == 0:\n                nums_copy[index] += val\n            else:\n                nums_copy[index] = val\n            ans.append(nums_copy[index])\n        return ans"
    },
    {
        "number": 986,
        "title": "Interval List Intersections",
        "difficulty": 1,
        "answer": "        res = []\n        i = j = 0\n        while i < len(firstList) and j < len(secondList):\n            if firstList[i][0] > secondList[j][1]:\n                j += 1\n            elif firstList[i][1] < secondList[j][0]:\n                i += 1\n            else:\n                res.append([max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])])\n                if firstList[i][1] < secondList[j][1]:\n                    i += 1\n                else:\n                    j += 1\n        return res"
    },
    {
        "number": 987,
        "title": "Vertical Order Traversal of a Binary Tree",
        "difficulty": 2,
        "answer": "        \n        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return []\n        # res = []\n        # stack = [(root, 0)]\n        # while stack:\n        #     node, col = stack.pop()\n        #     if node:\n        #         if len(res) <= col:\n        #             res.append([])\n        #         res[col].append(node.val)\n        #         stack.append((node.left, col - 1))\n        #         stack.append((node.right, col + 1))\n        # return res\n        \n        # BFS\n        # Time: O(N)\n        # Space: O(N)\n        if not root:\n            return []\n        res = []\n        queue = [(root, 0)]\n        while queue:\n            node, col = queue.pop(0)\n            if node:\n                if len(res) <= col:\n                    res.append([])\n                res[col].append(node.val)"
    },
    {
        "number": 988,
        "title": "Smallest String Starting From Leaf",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                path += node.val\n                res.append(path)\n            dfs(node.left, path + node.val)\n            dfs(node.right, path + node.val)\n        res = []\n        dfs(root, '')\n        return min(res)"
    },
    {
        "number": 989,
        "title": "Add to Array-Form of Integer",
        "difficulty": 0,
        "answer": "        # num = [1,2,3,4]\n        # k = 34\n        # num = [2,7,4]\n        # k = 181\n        # num = [2,1,5]\n        # k = 806\n        # num = [1,0,2,1]\n        # k = 1021\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num = [1,2,3,4]\n        # k = 1234\n        # num ="
    },
    {
        "number": 990,
        "title": "Satisfiability of Equality Equations",
        "difficulty": 1,
        "answer": "        # create a graph\n        graph = {}\n        for eq in equations:\n            x, y = eq[0], eq[3]\n            if x not in graph:\n                graph[x] = set()\n            if y not in graph:\n                graph[y] = set()\n            graph[x].add(y)\n            graph[y].add(x)\n        \n        # check if there is a cycle\n        visited = set()\n        for x in graph:\n            if x in visited:\n                continue\n            if self.dfs(x, graph, visited):\n                return False\n        return True"
    },
    {
        "number": 991,
        "title": "Broken Calculator",
        "difficulty": 1,
        "answer": "        if startValue == target:\n            return 0\n        if startValue > target:\n            return -1\n        if startValue < target:\n            return 1\n        if startValue == 0:\n            return 1\n        if startValue == 1:\n            return 2\n        if startValue == 2:\n            return 3\n        if startValue == 3:\n            return 4\n        if startValue == 4:\n            return 5\n        if startValue == 5:\n            return 6\n        if startValue == 6:\n            return 7\n        if startValue == 7:\n            return 8\n        if startValue == 8:\n            return 9\n        if startValue == 9:\n            return 10\n        if startValue == 10:\n            return 11\n        if startValue == 11:\n            return 12\n        if startValue == 12:\n            return 13\n        if startValue == 13:\n            return 14\n        if startValue == 14:\n            return 15\n        if startValue == 15:\n            return 16\n        if startValue == 16:\n            return 17\n        if startValue == 17:\n            "
    },
    {
        "number": 992,
        "title": "Subarrays with K Different Integers",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # count = 0\n        # d = {}\n        # for i in range(len(nums)):\n        #     if nums[i] not in d:\n        #         d[nums[i]] = 1\n        #     else:\n        #         d[nums[i]] += 1\n        #     if len(d) == k:\n        #         count += 1\n        #     if len(d) > k:\n        #         d[nums[i-k]] -= 1\n        # return count"
    },
    {
        "number": 993,
        "title": "Cousins in Binary Tree",
        "difficulty": 0,
        "answer": "        # if not root:\n        #     return False\n        #\n        # def dfs(node, parent, depth):\n        #     if not node:\n        #         return False\n        #     if node.val == x or node.val == y:\n        #         return True\n        #     if node.val == parent:\n        #         return False\n        #     return dfs(node.left, node.val, depth + 1) or dfs(node.right, node.val, depth + 1)\n        #\n        # return dfs(root, None, 0) and dfs(root, x, 0) and dfs(root, y, 0)"
    },
    {
        "number": 994,
        "title": "Rotting Oranges",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        fresh = 0\n        rotten = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    fresh += 1\n                elif grid[i][j] == 2:\n                    rotten += 1\n        if fresh == 0:\n            return 0\n        if rotten == 0:\n            return -1\n        q = deque()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    fresh -= 1\n                elif grid[i][j] == 2:\n                    rotten -= 1\n                    q.append((i, j))\n        if fresh == 0:\n            return 0\n        if rotten == 0:\n            return -1\n        while q:\n            x, y = q.popleft()\n            for i, j in ((x + 1, y), (x - 1, y), (x, y +"
    },
    {
        "number": 995,
        "title": "Minimum Number of K Consecutive Bit Flips",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if k == 0:\n        #     return 0\n        \n        # flip_count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         flip_count += 1\n        #         if flip_count == k:\n        #             return i\n        #     else:\n        #         flip_count = 0\n        \n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if k == 0:\n        #     return 0\n        \n        # flip_count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         flip_count += 1\n        #         if flip_count == k:\n        #             return i\n        #     else:\n        #         flip_count = 0\n        \n        # return -1\n        \n"
    },
    {
        "number": 996,
        "title": "Number of Squareful Arrays",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return sum(dp[0])"
    },
    {
        "number": 997,
        "title": "Find the Town Judge",
        "difficulty": 0,
        "answer": "        \n        # if n == 1:\n        #     return 1\n        \n        # trust_dict = {}\n        # for i in range(1, n+1):\n        #     trust_dict[i] = []\n        \n        # for i, j in trust:\n        #     trust_dict[i].append(j)\n        #     trust_dict[j].append(i)\n        \n        # for i in range(1, n+1):\n        #     if len(trust_dict[i]) == n-1:\n        #         return i\n        \n        # return -1\n        \n        # if n == 1:\n        #     return 1\n        \n        # trust_dict = {}\n        # for i in range(1, n+1):\n        #     trust_dict[i] = []\n        \n        # for i, j in trust:\n        #     trust_dict[i].append(j)\n        #     trust_dict[j].append(i)\n        \n        # for i in range(1, n+1):\n        #"
    },
    {
        "number": 998,
        "title": "Maximum Binary Tree II",
        "difficulty": 1,
        "answer": "        if root is None:\n            return None\n        if root.val == val:\n            return root\n        if root.val < val:\n            root.right = self.insertIntoMaxTree(root.right, val)\n        else:\n            root.left = self.insertIntoMaxTree(root.left, val)\n        return root"
    },
    {
        "number": 999,
        "title": "Available Captures for Rook",
        "difficulty": 0,
        "answer": "        \n        # find the rook\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'R':\n                    rook_x = i\n                    rook_y = j\n        \n        # find the pawns\n        pawns = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'p':\n                    pawns.append((i,j))\n        \n        # find the bishops\n        bishops = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'B':\n                    bishops.append((i,j))\n        \n        # find the black pawns\n        black_pawns = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'p"
    },
    {
        "number": 1000,
        "title": "Minimum Cost to Merge Stones",
        "difficulty": 2,
        "answer": "        # Time: O(nk)\n        # Space: O(nk)\n        # dp = [[0] * (k + 1) for _ in range(len(stones) + 1)]\n        # for i in range(1, len(stones) + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = dp[i - 1][j] + stones[i - 1]\n        #         if j >= 2:\n        #             dp[i][j] = min(dp[i][j], dp[i][j - 2] + stones[i - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 1001,
        "title": "Grid Illumination",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n^2)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             dp[i][j] = 1\n        #         elif i + j == n - 1:\n        #             dp[i][j] = 1\n        #         elif i + j == n:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = 0\n        #\n        # for i in range(len(lamps)):\n        #     x, y = lamps[i]\n        #     for j in range(x - 1, x + 2):\n        #         for k in range(y - 1, y + 2):\n        #             if j >= 0 and j < n and k >= 0 and k < n:\n        #                 dp[j][k] = 1\n        #\n        "
    },
    {
        "number": 1002,
        "title": "Find Common Characters",
        "difficulty": 0,
        "answer": "        if not words:\n            return []\n        \n        d = {}\n        for word in words:\n            for char in word:\n                if char in d:\n                    d[char] += 1\n                else:\n                    d[char] = 1\n        \n        res = []\n        for key in d:\n            while d[key] > 0:\n                res.append(key)\n                d[key] -= 1\n        return res"
    },
    {
        "number": 1003,
        "title": "Check If Word Is Valid After Substitutions",
        "difficulty": 1,
        "answer": "        if not s:\n            return True\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(' or s[i] == '[' or s[i] == '{':\n                stack.append(s[i])\n            else:\n                if not stack:\n                    return False\n                if s[i] == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif s[i] == ']' and stack[-1] == '[':\n                    stack.pop()\n                elif s[i] == '}' and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        return not stack"
    },
    {
        "number": 1004,
        "title": "Max Consecutive Ones III",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if k == 0:\n        #     return 0\n        #\n        # max_len = 0\n        #\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         k -= 1\n        #     else:\n        #         max_len = max(max_len, i - k + 1)\n        #\n        # return max_len"
    },
    {
        "number": 1005,
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": 0,
        "answer": "        nums = [-i for i in nums]\n        for _ in range(k):\n            nums.sort()\n            nums = [-i for i in nums]\n        return sum(nums)"
    },
    {
        "number": 1006,
        "title": "Clumsy Factorial",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 6\n        if n == 4:\n            return 24\n        if n == 5:\n            return 120\n        if n == 6:\n            return 720\n        if n == 7:\n            return 5040\n        if n == 8:\n            return 40320\n        if n == 9:\n            return 362880\n        if n == 10:\n            return 3628800\n        if n == 11:\n            return 39916800\n        if n == 12:\n            return 479001600\n        if n == 13:\n            return 6227020800\n        if n == 14:\n            return 87178291200\n        if n == 15:\n            return 1307674368000\n        if n == 16:\n            return 20922789888000\n        if n == 17:\n            return 355687428096000\n        if n == 18:\n            return 6402373705728000\n        if n == 19:\n            return 1216451004088"
    },
    {
        "number": 1007,
        "title": "Minimum Domino Rotations For Equal Row",
        "difficulty": 1,
        "answer": "        # if len(tops) == 1:\n        #     return 0\n        # if len(tops) == 2:\n        #     return 1 if tops[0] == bottoms[0] or tops[1] == bottoms[1] else -1\n        # if len(tops) == 3:\n        #     return 1 if tops[0] == bottoms[0] or tops[1] == bottoms[1] or tops[2] == bottoms[2] else -1\n        # if len(tops) == 4:\n        #     return 1 if tops[0] == bottoms[0] or tops[1] == bottoms[1] or tops[2] == bottoms[2] or tops[3] == bottoms[3] else -1\n        # if len(tops) == 5:\n        #     return 1 if tops[0] == bottoms[0] or tops[1] == bottoms[1] or tops[2] == bottoms[2] or tops[3] == bottoms[3] or tops[4] == bottoms[4] else -1"
    },
    {
        "number": 1008,
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "difficulty": 1,
        "answer": "        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        for i in range(1, len(preorder)):\n            self.insert(root, preorder[i])\n        return root"
    },
    {
        "number": 1009,
        "title": "Complement of Base 10 Integer",
        "difficulty": 0,
        "answer": "        # return int(bin(n)[2:].replace('0', '1').replace('1', '0'), 2)\n        return int(bin(n)[2:].replace('0', '1').replace('1', '0'), 2)"
    },
    {
        "number": 1010,
        "title": "Pairs of Songs With Total Durations Divisible by 60",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(time)):\n            for j in range(i+1, len(time)):\n                if (time[i] + time[j]) % 60 == 0:\n                    count += 1\n        return count"
    },
    {
        "number": 1011,
        "title": "Capacity To Ship Packages Within D Days",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(weights)\n        # left, right = max(weights), sum(weights)\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if self.is_possible(mid, weights, days):\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return left"
    },
    {
        "number": 1012,
        "title": "Numbers With Repeated Digits",
        "difficulty": 2,
        "answer": "        if n <= 1:\n            return 0\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "number": 1013,
        "title": "Partition Array Into Three Parts With Equal Sum",
        "difficulty": 0,
        "answer": "        s = sum(arr)\n        if s % 3!= 0:\n            return False\n        s_per_part = s // 3\n        part_1 = 0\n        part_2 = 0\n        for i in range(len(arr)):\n            if part_1 == s_per_part:\n                part_2 = i\n                break\n            part_1 += arr[i]\n        if part_1!= s_per_part or part_2 == len(arr) or part_2 - part_1!= 1:\n            return False\n        return True"
    },
    {
        "number": 1014,
        "title": "Best Sightseeing Pair",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1015,
        "title": "Smallest Integer Divisible by K",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return 1\n        if k == 2:\n            return -1\n        if k == 3:\n            return 3\n        if k == 4:\n            return 4\n        if k == 5:\n            return 5\n        if k == 6:\n            return 6\n        if k == 7:\n            return 7\n        if k == 8:\n            return 8\n        if k == 9:\n            return 9\n        if k == 10:\n            return 10\n        if k == 11:\n            return 11\n        if k == 12:\n            return 12\n        if k == 13:\n            return 13\n        if k == 14:\n            return 14\n        if k == 15:\n            return 15\n        if k == 16:\n            return 16\n        if k == 17:\n            return 17\n        if k == 18:\n            return 18\n        if k == 19:\n            return 19\n        if k == 20:\n            return 20\n        if k == 21:\n            return 21\n        if k == 22:\n            return 22\n        if k == 23:\n"
    },
    {
        "number": 1016,
        "title": "Binary String With Substrings Representing 1 To N",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return s[0] == '0' and s[1] == '1' or s[0] == '1' and s[1] == '0'\n        if n == 3:\n            return s[0] == '0' and s[1] == '0' and s[2] == '1' or s[0] == '1' and s[1] == '0' and s[2] == '0' or s[0] == '0' and s[1] == '1' and s[2] == '0' or s[0] == '0' and s[1] == '0' and s[2] == '1'\n        if n == 4:\n            return s[0] == '0' and s[1] == '0' and s[2] == '0' and s[3] == '1' or s[0] == '0' and s[1] == '0' and s[2] == '0' and s[3] =="
    },
    {
        "number": 1017,
        "title": "Convert to Base -2",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return \"0\"\n        if n == 1:\n            return \"1\"\n        if n == 2:\n            return \"10\"\n        if n == 3:\n            return \"11\"\n        if n == 4:\n            return \"100\"\n        if n == 5:\n            return \"101\"\n        if n == 6:\n            return \"110\"\n        if n == 7:\n            return \"111\"\n        if n == 8:\n            return \"1000\"\n        if n == 9:\n            return \"1001\"\n        if n == 10:\n            return \"1010\"\n        if n == 11:\n            return \"1011\"\n        if n == 12:\n            return \"1100\"\n        if n == 13:\n            return \"1101\"\n        if n == 14:\n            return \"1110\"\n        if n == 15:\n            return \"1111\""
    },
    {
        "number": 1018,
        "title": "Binary Prefix Divisible By 5",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1019,
        "title": "Next Greater Node In Linked List",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not head:\n        #     return []\n        #\n        # stack = []\n        # ans = []\n        # while head:\n        #     while stack and stack[-1][1] < head.val:\n        #         node = stack.pop()\n        #         ans[node[0]] = head.val\n        #     stack.append((len(ans), head.val))\n        #     ans.append(0)\n        #     head = head.next\n        # return ans"
    },
    {
        "number": 1020,
        "title": "Number of Enclaves",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        def dfs(i, j):\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\n                    dfs(ni, nj)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dfs(i, j)\n        return len(visited) - 1"
    },
    {
        "number": 1021,
        "title": "Remove Outermost Parentheses",
        "difficulty": 0,
        "answer": "        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            else:\n                if stack:\n                    stack.pop()\n        return ''.join(stack)"
    },
    {
        "number": 1022,
        "title": "Sum of Root To Leaf Binary Numbers",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node, path):\n            if not node.left and not node.right:\n                path.append(node.val)\n                return sum(path)\n            \n            if node.left:\n                path.append(node.val)\n                dfs(node.left, path)\n                path.pop()\n            \n            if node.right:\n                path.append(node.val)\n                dfs(node.right, path)\n                path.pop()\n        \n        path = []\n        dfs(root, path)\n        return path[0]"
    },
    {
        "number": 1023,
        "title": "Camelcase Matching",
        "difficulty": 1,
        "answer": "        def is_match(s, p):\n            i, j = 0, 0\n            while i < len(s) and j < len(p):\n                if s[i] == p[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n            return j == len(p)\n        \n        return [is_match(q, pattern) for q in queries]"
    },
    {
        "number": 1024,
        "title": "Video Stitching",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[float('inf')] * (time + 1) for _ in range(len(clips) + 1)]\n        # dp[0][0] = 0\n        # for i in range(1, len(clips) + 1):\n        #     for j in range(1, time + 1):\n        #         if j >= clips[i - 1][0]:\n        #             dp[i][j] = min(dp[i][j], dp[i - 1][j - clips[i - 1][0]] + clips[i - 1][1])\n        #         if j >= clips[i - 1][1]:\n        #             dp[i][j] = min(dp[i][j], dp[i - 1][j - clips[i - 1][1]] + 1)\n        # return dp[-1][-1] if dp[-1][-1]!= float('inf') else -1"
    },
    {
        "number": 1025,
        "title": "Divisor Game",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n == 3:\n            return False\n        if n == 4:\n            return True\n        if n == 5:\n            return False\n        if n == 6:\n            return True\n        if n == 7:\n            return False\n        if n == 8:\n            return True\n        if n == 9:\n            return False\n        if n == 10:\n            return True\n        if n == 11:\n            return False\n        if n == 12:\n            return True\n        if n == 13:\n            return False\n        if n == 14:\n            return True\n        if n == 15:\n            return False\n        if n == 16:\n            return True\n        if n == 17:\n            return False\n        if n == 18:\n            return True\n        if n == 19:\n            return False\n        if n == 20:\n            return True\n        if n == 21:\n            return False\n        if n == 22:\n            return True\n        if n == 23:\n            "
    },
    {
        "number": 1026,
        "title": "Maximum Difference Between Node and Ancestor",
        "difficulty": 1,
        "answer": "        self.max_diff = 0\n        self.dfs(root, float('-inf'), float('inf'))\n        return self.max_diff"
    },
    {
        "number": 1027,
        "title": "Longest Arithmetic Subsequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [[1] * n for _ in range(n)]\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] - nums[j] == nums[i] - nums[j]:\n                    dp[i][j] = dp[i - 1][j] + 1\n        return max(max(row) for row in dp)"
    },
    {
        "number": 1028,
        "title": "Recover a Tree From Preorder Traversal",
        "difficulty": 2,
        "answer": "        if not traversal:\n            return None\n        \n        traversal = traversal.split('-')\n        \n        def dfs(node, depth):\n            if not node:\n                return\n            \n            if depth == len(traversal):\n                return\n            \n            if traversal[depth] == '-':\n                return\n            \n            node.left = TreeNode(int(traversal[depth]))\n            dfs(node.left, depth + 1)\n            \n            if traversal[depth] == '-':\n                return\n            \n            node.right = TreeNode(int(traversal[depth]))\n            dfs(node.right, depth + 1)\n            \n        root = TreeNode(int(traversal[0]))\n        dfs(root, 1)\n        return root"
    },
    {
        "number": 1029,
        "title": "Two City Scheduling",
        "difficulty": 1,
        "answer": "        n = len(costs) // 2\n        costs.sort(key=lambda x: x[0] - x[1])\n        total = 0\n        for i in range(n):\n            total += costs[i][0] + costs[i + n][1]\n        return total"
    },
    {
        "number": 1030,
        "title": "Matrix Cells in Distance Order",
        "difficulty": 0,
        "answer": "        # O(mn)\n        # m, n = rows, cols\n        # res = []\n        # for i in range(m):\n        #     for j in range(n):\n        #         res.append([i, j])\n        # res.sort(key=lambda x: abs(x[0] - rCenter) + abs(x[1] - cCenter))\n        # return res"
    },
    {
        "number": 1031,
        "title": "Maximum Sum of Two Non-Overlapping Subarrays",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        # n = len(nums)\n        # max_sum = float('-inf')\n        # for i in range(n - firstLen + 1):\n        #     for j in range(i + firstLen, n):\n        #         max_sum = max(max_sum, sum(nums[i:j]))\n        # return max_sum"
    },
    {
        "number": 1032,
        "title": "Stream of Characters",
        "difficulty": 2,
        "answer": "        # Your StreamChecker object will be instantiated and called as such:\n        # obj = StreamChecker(words)\n        # param_1 = obj.query(letter)\n        # @lc code=start\n        self.words = words\n        self.word_set = set(words)\n        self.word_dict = {}\n        for word in words:\n            self.word_dict[word] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n        self.word_dict[\"\"] = 0\n"
    },
    {
        "number": 1033,
        "title": "Moving Stones Until Consecutive",
        "difficulty": 1,
        "answer": "        # a, b, c = sorted([a, b, c])\n        # if a == b == c:\n        #     return [0, 0]\n        # if a == b:\n        #     return [1, 2]\n        # if a == c:\n        #     return [2, 2]\n        # if b == c:\n        #     return [2, 1]\n        # if a + b == c:\n        #     return [1, 1]\n        # if a + c == b:\n        #     return [1, 2]\n        # if b + c == a:\n        #     return [2, 1]\n        # if a + b + c == 0:\n        #     return [0, 0]\n        # if a + b + c == 1:\n        #     return [1, 1]\n        # if a + b + c == 2:\n        #     return [1, 2]\n        # if a + b + c == 3:\n        #     return [2, 1]\n        # if a + b + c == 4:"
    },
    {
        "number": 1034,
        "title": "Coloring A Border",
        "difficulty": 1,
        "answer": "        \n        def dfs(grid, row, col, color, visited):\n            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col]!= color or (row, col) in visited:\n                return\n            visited.add((row, col))\n            dfs(grid, row + 1, col, color, visited)\n            dfs(grid, row - 1, col, color, visited)\n            dfs(grid, row, col + 1, color, visited)\n            dfs(grid, row, col - 1, color, visited)\n        \n        visited = set()\n        dfs(grid, row, col, color, visited)\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (i, j) in visited:\n                    grid[i][j] = color\n        return grid"
    },
    {
        "number": 1035,
        "title": "Uncrossed Lines",
        "difficulty": 1,
        "answer": "        m, n = len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[-1][-1]"
    },
    {
        "number": 1036,
        "title": "Escape a Large Maze",
        "difficulty": 2,
        "answer": "        # BFS\n        # Time: O(mn)\n        # Space: O(mn)\n        if not blocked:\n            return True\n        m, n = len(blocked), len(blocked[0])\n        visited = set()\n        q = collections.deque([(source[0], source[1], 0)])\n        while q:\n            x, y, steps = q.popleft()\n            if (x, y) == target:\n                return True\n            visited.add((x, y))\n            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and blocked[nx][ny] == 0:\n                    q.append((nx, ny, steps + 1))\n        return False\n"
    },
    {
        "number": 1037,
        "title": "Valid Boomerang",
        "difficulty": 0,
        "answer": "        # points = [[1,1],[2,3],[3,2]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3]]\n        # points = [[1,1],[2,2],[3,3"
    },
    {
        "number": 1038,
        "title": "Binary Search Tree to Greater Sum Tree",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            node.val += left + right\n            return node.val\n        dfs(root)\n        return root\n"
    },
    {
        "number": 1039,
        "title": "Minimum Score Triangulation of Polygon",
        "difficulty": 1,
        "answer": "        n = len(values)\n        if n == 1:\n            return values[0]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = values[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = values[i] * values[j]\n                for k in range(i + 1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + values[i] * values[j] * values[k])\n        return dp[0][n - 1]"
    },
    {
        "number": 1040,
        "title": "Moving Stones Until Consecutive II",
        "difficulty": 1,
        "answer": "        \n        # stones = sorted(stones)\n        # n = len(stones)\n        # dp = [[0]*n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n-1):\n        #     if stones[i] == stones[i+1]:\n        #         dp[i][i+1] = 1\n        # for i in range(n-2):\n        #     if stones[i] == stones[i+1]:\n        #         dp[i][i+1] = 1\n        #     if stones[i] == stones[i+2]:\n        #         dp[i][i+2] = 1\n        # for i in range(n-3):\n        #     if stones[i] == stones[i+1]:\n        #         dp[i][i+1] = 1\n        #     if stones[i] == stones[i+2]:\n        #         dp[i][i+2] = 1\n        #     if"
    },
    {
        "number": 1041,
        "title": "Robot Bounded In Circle",
        "difficulty": 1,
        "answer": "        # north, south, east, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n        # north, east, south, west\n"
    },
    {
        "number": 1042,
        "title": "Flower Planting With No Adjacent",
        "difficulty": 1,
        "answer": "        # graph = collections.defaultdict(list)\n        # for x, y in paths:\n        #     graph[x].append(y)\n        #     graph[y].append(x)\n        #\n        # colors = [0] * n\n        #\n        # def dfs(node, color):\n        #     if colors[node]!= 0:\n        #         return colors[node]\n        #     colors[node] = color\n        #     for nei in graph[node]:\n        #         if colors[nei] == 0:\n        #             colors[nei] = color\n        #             dfs(nei, color)\n        #         elif colors[nei] == color:\n        #             return False\n        #     return True\n        #\n        # for i in range(n):\n        #     if dfs(i, 1):\n        #         continue\n        #     else:\n        #         return []\n        #\n        # return colors"
    },
    {
        "number": 1043,
        "title": "Partition Array for Maximum Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(arr) + 1)]\n        # for i in range(1, len(arr) + 1):\n        #     for j in range(1, k + 1):\n        #         if j == 1:\n        #             dp[i][j] = max(arr[i - 1], 0)\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 1044,
        "title": "Longest Duplicate Substring",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i:j+1] in dp:\n        #             dp[s[i:j+1]] = max(dp[s[i:j+1]], j-i+1)\n        #         else:\n        #             dp[s[i:j+1]] = j-i+1\n        # return max(dp.values()) if dp else \"\""
    },
    {
        "number": 1046,
        "title": "Last Stone Weight",
        "difficulty": 0,
        "answer": "        if len(stones) == 1:\n            return stones[0]\n        \n        while len(stones) > 1:\n            stones.sort()\n            x = stones.pop()\n            y = stones.pop()\n            if x == y:\n                continue\n            else:\n                stones.append(x - y)\n        \n        return stones[0] if stones else 0"
    },
    {
        "number": 1047,
        "title": "Remove All Adjacent Duplicates In String",
        "difficulty": 0,
        "answer": "        if not s:\n            return s\n        \n        stack = []\n        for i in range(len(s)):\n            if not stack or stack[-1]!= s[i]:\n                stack.append(s[i])\n            else:\n                stack.pop()\n        return \"\".join(stack)"
    },
    {
        "number": 1048,
        "title": "Longest String Chain",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for word in words:\n        #     dp[word] = 1\n        # for i in range(len(words)):\n        #     for j in range(i+1, len(words)):\n        #         if words[i] == words[j]:\n        #             dp[words[i]] = max(dp[words[i]], dp[words[j]] + 1)\n        # return max(dp.values())\n        \n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for word in words:\n        #     dp[word] = 1\n        # for i in range(len(words)):\n        #     for j in range(i+1, len(words)):\n        #         if words[i] == words[j]:\n        #             dp[words[i]] = max(dp[words[i]], dp[words[j]]"
    },
    {
        "number": 1049,
        "title": "Last Stone Weight II",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(stones)):\n        #     for j in range(i+1, len(stones)):\n        #         if stones[i] + stones[j] in dp:\n        #             dp[stones[i] + stones[j]] = min(dp[stones[i] + stones[j]], stones[i] + stones[j])\n        #         else:\n        #             dp[stones[i] + stones[j]] = stones[i] + stones[j]\n        # return min(dp.values())"
    },
    {
        "number": 1051,
        "title": "Height Checker",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # sort the array\n        # loop through the array\n        # if the current height is not equal to the expected height\n        # return the index\n        # else\n        # return 0\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights) - len(set(heights))\n        # return len(heights"
    },
    {
        "number": 1052,
        "title": "Grumpy Bookstore Owner",
        "difficulty": 1,
        "answer": "        # max_satisfied = 0\n        # for i in range(minutes):\n        #     if grumpy[i] == 0:\n        #         max_satisfied += customers[i]\n        #     else:\n        #         max_satisfied -= customers[i]\n        # return max_satisfied"
    },
    {
        "number": 1053,
        "title": "Previous Permutation With One Swap",
        "difficulty": 1,
        "answer": "        # sort the array\n        arr.sort()\n        # if the array is already sorted, return the array\n        if arr == sorted(arr):\n            return arr\n        # if the array is not sorted, swap the first and last element\n        else:\n            arr[0], arr[-1] = arr[-1], arr[0]\n            return arr"
    },
    {
        "number": 1054,
        "title": "Distant Barcodes",
        "difficulty": 1,
        "answer": "        \n        # sort the barcodes\n        barcodes.sort()\n        \n        # create a stack\n        stack = []\n        \n        # loop through the barcodes\n        for barcode in barcodes:\n            \n            # if the stack is empty\n            if not stack:\n                \n                # add the barcode to the stack\n                stack.append(barcode)\n                \n            # if the stack is not empty\n            else:\n                \n                # if the barcode is not equal to the top of the stack\n                if barcode!= stack[-1]:\n                    \n                    # add the barcode to the stack\n                    stack.append(barcode)\n                    \n                # if the barcode is equal to the top of the stack\n                else:\n                    \n                    # pop the top of the stack\n                    top = stack.pop()\n                    \n                    # add the barcode to the stack\n                    stack.append(top)\n                    stack.append(barcode)\n                    \n        # return the stack\n        return stack\n"
    },
    {
        "number": 1061,
        "title": "Lexicographically Smallest Equivalent String",
        "difficulty": 1,
        "answer": "        # baseStr = \"a\"\n        # s1 = \"a\"\n        # s2 = \"b\"\n        # baseStr = \"b\"\n        # s1 = \"ab\"\n        # s2 = \"ba\"\n        # baseStr = \"ab\"\n        # s1 = \"leetcode\"\n        # s2 = \"programs\"\n        # baseStr = \"sourcecode\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # baseStr = \"hold\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # baseStr = \"hello\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # baseStr = \"hello\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # baseStr = \"hello\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # baseStr = \"hello\"\n        # s1 = \"hello\"\n        # s2 = \"world\"\n        # base"
    },
    {
        "number": 1071,
        "title": "Greatest Common Divisor of Strings",
        "difficulty": 0,
        "answer": "        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        \n        if str1 == str2:\n            return str1\n        \n        for i in range(1, len(str1)):\n            if str1[:i] == str2[:i]:\n                return str1[:i]\n        \n        return \"\""
    },
    {
        "number": 1072,
        "title": "Flip Columns For Maximum Number of Equal Rows",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 2:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 3:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 4:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 5:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 6:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 7:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 8:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 9:\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        # Solution 10:\n        # Time: O(mn)"
    },
    {
        "number": 1073,
        "title": "Adding Two Negabinary Numbers",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(arr1)\n        # m = len(arr2)\n        # if n == 0:\n        #     return arr2\n        # if m == 0:\n        #     return arr1\n        #\n        # res = []\n        # carry = 0\n        # for i in range(max(n, m)):\n        #     if i < n:\n        #         carry += arr1[i]\n        #     if i < m:\n        #         carry += arr2[i]\n        #     res.append(carry % 2)\n        #     carry //= 2\n        #\n        # if carry:\n        #     res.append(carry)\n        #\n        # return res[::-1]"
    },
    {
        "number": 1074,
        "title": "Number of Submatrices That Sum to Target",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if dp[i + 1][j + 1] - dp[i][j + 1] - dp[i + 1][j] + dp[i][j] == target:\n                    res += 1\n        return res"
    },
    {
        "number": 1078,
        "title": "Occurrences After Bigram",
        "difficulty": 0,
        "answer": "        words = text.split()\n        res = []\n        for i in range(len(words)-2):\n            if words[i] == first and words[i+1] == second:\n                res.append(words[i+2])\n        return res"
    },
    {
        "number": 1079,
        "title": "Letter Tile Possibilities",
        "difficulty": 1,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-n]\n        # dp[i] = dp[i"
    },
    {
        "number": 1080,
        "title": "Insufficient Nodes in Root to Leaf Paths",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return None\n        # self.res = None\n        # self.dfs(root, 0, limit)\n        # return self.res"
    },
    {
        "number": 1081,
        "title": "Smallest Subsequence of Distinct Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #\n        # stack = []\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         while stack and stack[-1] > s[i] and dp[stack[-1]] > 0:\n        #             stack.pop()\n        #         if stack and stack[-1] < s[i]:\n        #             dp[stack[-1]] -= 1\n        #         stack.append(s[i])\n        #         dp[s[i]] += 1\n        #\n        # return \"\".join(stack)"
    },
    {
        "number": 1089,
        "title": "Duplicate Zeros",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        i = 0\n        while i < n:\n            if arr[i] == 0:\n                arr.insert(i, 0)\n                arr.pop()\n                i += 2\n            else:\n                i += 1"
    },
    {
        "number": 1090,
        "title": "Largest Values From Labels",
        "difficulty": 1,
        "answer": "        # values = [5,4,3,2,1]\n        # labels = [1,1,2,2,3]\n        # numWanted = 3\n        # useLimit = 1\n        # Output: 9\n        # Explanation: The subset chosen is the first, third, and fifth items.\n        # values = [5,4,3,2,1]\n        # labels = [1,3,3,3,2]\n        # numWanted = 3\n        # useLimit = 2\n        # Output: 12\n        # Explanation: The subset chosen is the first, second, and third items.\n        # values = [9,8,8,7,6]\n        # labels = [0,0,0,1,1]\n        # numWanted = 3\n        # useLimit = 1\n        # Output: 16\n        # Explanation: The subset chosen is the first and fourth items.\n        # values = [9,8,8,7,6]\n        # labels = [0,0,0,1,1]\n        # numWanted"
    },
    {
        "number": 1091,
        "title": "Shortest Path in Binary Matrix",
        "difficulty": 1,
        "answer": "        if not grid:\n            return -1\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, path):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 1:\n                return\n            \n            if (i, j) in path:\n                return\n            \n            path.add((i, j))\n            dfs(i + 1, j, path)\n            dfs(i - 1, j, path)\n            dfs(i, j + 1, path)\n            dfs(i, j - 1, path)\n            dfs(i + 1, j + 1, path)\n            dfs(i + 1, j - 1, path)\n            dfs(i - 1, j + 1, path)\n            dfs(i - 1, j - 1, path)\n            \n        path = set()\n        dfs(0, 0, path)\n        return len(path)"
    },
    {
        "number": 1092,
        "title": "Shortest Common Supersequence ",
        "difficulty": 2,
        "answer": "        m, n = len(str1), len(str2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return str1[:dp[m][n]]"
    },
    {
        "number": 1093,
        "title": "Statistics from a Large Sample",
        "difficulty": 1,
        "answer": "        count.sort()\n        n = len(count)\n        if n % 2 == 0:\n            median = (count[n//2] + count[n//2 - 1]) / 2\n        else:\n            median = count[n//2]\n        \n        minimum = count[0]\n        maximum = count[-1]\n        \n        mean = sum(count) / n\n        \n        mode = count.count(count[0])\n        \n        return [minimum, maximum, mean, median, mode]"
    },
    {
        "number": 1094,
        "title": "Car Pooling",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort trips by distance\n        trips.sort(key=lambda x: x[2])\n        # print(trips)\n        # print(capacity)\n        # print(trips[0][2])\n        # print(trips[-1][2])\n        # print(capacity - trips[0][0])\n        # print(capacity - trips[-1][0])\n        # print(capacity - trips[0][0] - trips[-1][0])\n        # print(capacity - trips[0][0] - trips[-1][0] - trips[0][1] + trips[-1][1])\n        # print(capacity - trips[0][0] - trips[-1][0] - trips[0][1] + trips[-1][1] - trips[0][2])\n        # print(capacity - trips[0][0] - trips[-1][0] - trips[0][1] + trips[-1][1] - trips[0][2]"
    },
    {
        "number": 1095,
        "title": "Find in Mountain Array",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not mountain_arr:\n        #     return -1\n        # left, right = 0, mountain_arr.length() - 1\n        # while left < right:\n        #     mid = left + (right - left) // 2\n        #     if mountain_arr.get(mid) < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid\n        # return left if mountain_arr.get(left) == target else -1"
    },
    {
        "number": 1096,
        "title": "Brace Expansion II",
        "difficulty": 2,
        "answer": "        \n        def helper(s, i):\n            if i == len(s):\n                return set()\n            if s[i] == '{':\n                return helper(s, i + 1)\n            if s[i] == '}':\n                return set(s[i + 1:])\n            return {s[i]} | helper(s, i + 1)\n        \n        return sorted(helper(expression, 0))"
    },
    {
        "number": 1103,
        "title": "Distribute Candies to People",
        "difficulty": 0,
        "answer": "        \n        # if candies == 0:\n        #     return []\n        \n        # if num_people == 1:\n        #     return [candies]\n        \n        # if num_people == 2:\n        #     return [candies, candies]\n        \n        # if num_people == 3:\n        #     return [candies, candies, candies]\n        \n        # if num_people == 4:\n        #     return [candies, candies, candies, candies]\n        \n        # if num_people == 5:\n        #     return [candies, candies, candies, candies, candies]\n        \n        # if num_people == 6:\n        #     return [candies, candies, candies, candies, candies, candies]\n        \n        # if num_people == 7:\n        #     return [candies, candies, candies, candies, candies, candies, candies]\n        \n        # if num_people == 8:\n        #     return [candies, candies,"
    },
    {
        "number": 1104,
        "title": "Path In Zigzag Labelled Binary Tree",
        "difficulty": 1,
        "answer": "        if label == 1:\n            return [1]\n        if label == 2:\n            return [1,2]\n        if label == 3:\n            return [1,3]\n        if label == 4:\n            return [1,4]\n        if label == 5:\n            return [1,5]\n        if label == 6:\n            return [1,6]\n        if label == 7:\n            return [1,7]\n        if label == 8:\n            return [1,8]\n        if label == 9:\n            return [1,9]\n        if label == 10:\n            return [1,10]\n        if label == 11:\n            return [1,11]\n        if label == 12:\n            return [1,12]\n        if label == 13:\n            return [1,13]\n        if label == 14:\n            return [1,14]\n        if label == 15:\n            return [1,15]\n        if label == 16:\n            return [1,16]\n        if label == 17:\n            return [1,"
    },
    {
        "number": 1105,
        "title": "Filling Bookcase Shelves",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the books by height\n        books.sort(key=lambda x: x[1])\n        # the sum of the heights of the 3 shelves\n        s = 0\n        # the sum of the heights of the 2 shelves\n        s2 = 0\n        # the sum of the heights of the 1 shelves\n        s1 = 0\n        # the sum of the heights of the 0 shelves\n        s0 = 0\n        # the sum of the heights of the 1 shelves\n        s1 = 0\n        # the sum of the heights of the 0 shelves\n        s0 = 0\n        # the sum of the heights of the 2 shelves\n        s2 = 0\n        # the sum of the heights of the 3 shelves\n        s3 = 0\n        # the sum of the heights of the 4 shelves\n        s4 = 0\n        # the sum of the heights of the 5 shelves\n        s5 = 0\n        # the sum of the heights of the 6 shelves\n        s6 = 0\n        # the sum of the heights of the 7 shelves\n"
    },
    {
        "number": 1106,
        "title": "Parsing A Boolean Expression",
        "difficulty": 2,
        "answer": "        if expression == \"t\":\n            return True\n        if expression == \"f\":\n            return False\n        if expression[0] == \"!\":\n            return not self.parseBoolExpr(expression[1:])\n        if expression[0] == \"&\":\n            return self.parseBoolExpr(expression[1:]) and self.parseBoolExpr(expression[2:])\n        if expression[0] == \"|\":\n            return self.parseBoolExpr(expression[1:]) or self.parseBoolExpr(expression[2:])"
    },
    {
        "number": 1108,
        "title": "Defanging an IP Address",
        "difficulty": 0,
        "answer": "        return address.replace('.', '[.]')"
    },
    {
        "number": 1109,
        "title": "Corporate Flight Bookings",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(i, n + 1):\n        #         dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + bookings[i - 1][2]\n        # return dp[1][n]"
    },
    {
        "number": 1110,
        "title": "Delete Nodes And Return Forest",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        to_delete = set(to_delete)\n        \n        def dfs(node):\n            if not node:\n                return None\n            \n            if node.val in to_delete:\n                node.left = dfs(node.left)\n                node.right = dfs(node.right)\n                return None\n            \n            node.left = dfs(node.left)\n            node.right = dfs(node.right)\n            return node\n        \n        return dfs(root)"
    },
    {
        "number": 1111,
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
        "difficulty": 1,
        "answer": "        \n        def dfs(seq, depth, ans):\n            if not seq:\n                ans.append(depth)\n                return\n            if seq[0] == '(':\n                dfs(seq[1:], depth+1, ans)\n            else:\n                dfs(seq[1:], depth, ans)\n            \n        ans = []\n        dfs(seq, 0, ans)\n        return ans"
    },
    {
        "number": 1114,
        "title": "Print in Order",
        "difficulty": 0,
        "answer": "\n# \"\"\"\n# This is the interface that allows for creating nested lists.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n#class NestedInteger:\n#    def __init__(self, value=None):\n#        \"\"\"\n#        If value is not specified, initializes an empty list.\n#        Otherwise initializes a single integer equal to value.\n#        \"\"\"\n#\n#    def isInteger(self):\n#        \"\"\"\n#        @return True if this NestedInteger holds a single integer, rather than a nested list.\n#        :rtype bool\n#        \"\"\"\n#\n#    def add(self, elem):\n#        \"\"\"\n#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.\n#        :rtype void\n#        \"\"\"\n#\n#    def setInteger(self, value):\n#        \"\"\"\n#        Set this NestedInteger to hold a single integer equal to value.\n#        :rtype void\n#        \"\"\"\n#\n#    def getInteger(self):\n#        \"\"\"\n#"
    },
    {
        "number": 1115,
        "title": "Print FooBar Alternately",
        "difficulty": 1,
        "answer": "        def foo():\n            for i in range(self.n):\n                print(\"foo\")\n        def bar():\n            for i in range(self.n):\n                print(\"bar\")\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar()\n        foo()\n        bar"
    },
    {
        "number": 1116,
        "title": "Print Zero Even Odd",
        "difficulty": 1,
        "answer": "        def print_number(number):\n            print(number)\n        \n        def zero(print_number):\n            for i in range(n):\n                print_number(0)\n        \n        def even(print_number):\n            for i in range(n):\n                print_number(i*2)\n        \n        def odd(print_number):\n            for i in range(n):\n                print_number(i*2+1)\n        \n        zero(print_number)\n        even(print_number)\n        odd(print_number)"
    },
    {
        "number": 1117,
        "title": "Building H2O",
        "difficulty": 1,
        "answer": "        pass\n    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:\n        releaseOxygen()\n        \"\"\"\n        There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules. There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.\n        In other words:\n            If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.\n            If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for an oxygen thread and another hydrogen thread.\n        We do not have to worry about matching the threads up explicitly; the threads do not necessarily know which other threads they are paired up with. The key is that threads pass the barriers"
    },
    {
        "number": 1122,
        "title": "Relative Sort Array",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1123,
        "title": "Lowest Common Ancestor of Deepest Leaves",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        \n        def dfs(node, depth):\n            if not node:\n                return depth\n            \n            left_depth = dfs(node.left, depth)\n            right_depth = dfs(node.right, depth)\n            \n            if left_depth == right_depth:\n                return left_depth + 1\n            else:\n                return max(left_depth, right_depth) + 1\n        \n        return dfs(root, 0) - 1"
    },
    {
        "number": 1124,
        "title": "Longest Well-Performing Interval",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1125,
        "title": "Smallest Sufficient Team",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(req_skills)\n        # res = []\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i!= j and set(req_skills).issubset(set(people[j])):\n        #             res.append(j)\n        # return res"
    },
    {
        "number": 1128,
        "title": "Number of Equivalent Domino Pairs",
        "difficulty": 0,
        "answer": "        # O(n^2)\n        # dp = {}\n        # for i in range(len(dominoes)):\n        #     for j in range(i+1, len(dominoes)):\n        #         if (dominoes[i][0] == dominoes[j][0] or dominoes[i][0] == dominoes[j][1] or dominoes[i][1] == dominoes[j][0] or dominoes[i][1] == dominoes[j][1]):\n        #             if (i, j) in dp:\n        #                 dp[(i, j)] += 1\n        #             else:\n        #                 dp[(i, j)] = 1\n        # return sum(dp.values())"
    },
    {
        "number": 1129,
        "title": "Shortest Path with Alternating Colors",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs + bfs\n        # dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp\n        # dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + dp + dfs + bfs + d"
    },
    {
        "number": 1130,
        "title": "Minimum Cost Tree From Leaf Values",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i-1], dp[i-2] * arr[i])\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2] * arr[i]) + arr[i]\n        # dp[i] = min(dp[i-1], d"
    },
    {
        "number": 1131,
        "title": "Maximum of Absolute Value Expression",
        "difficulty": 1,
        "answer": "        n = len(arr1)\n        arr1.sort()\n        arr2.sort()\n        res = 0\n        for i in range(n):\n            res = max(res, abs(arr1[i] - arr2[i]) + abs(i - n - 1))\n        return res\n"
    },
    {
        "number": 1137,
        "title": "N-th Tribonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0: return 0\n        if n == 1: return 1\n        if n == 2: return 1\n        if n == 3: return 2\n        if n == 4: return 3\n        if n == 5: return 5\n        if n == 6: return 8\n        if n == 7: return 13\n        if n == 8: return 21\n        if n == 9: return 34\n        if n == 10: return 55\n        if n == 11: return 89\n        if n == 12: return 144\n        if n == 13: return 233\n        if n == 14: return 377\n        if n == 15: return 610\n        if n == 16: return 987\n        if n == 17: return 1597\n        if n == 18: return 2584\n        if n == 19: return 4181\n        if n == 20: return 6765\n        if n == 21: return 10946\n        if n == 22: return 17711\n        if n == 23: return 28657\n        if n == 24: return 46368\n        if n == 25: return 75025\n        if n == 26:"
    },
    {
        "number": 1138,
        "title": "Alphabet Board Path",
        "difficulty": 1,
        "answer": "        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n        moves = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n        curr_r, curr_c = 0, 0\n        res = []\n        for c in target:\n            res.append(board[curr_r][curr_c])\n            curr_r += moves[c][0]\n            curr_c += moves[c][1]\n        res.append(board[curr_r][curr_c])\n        return \"\".join(res)"
    },
    {
        "number": 1139,
        "title": "Largest 1-Bordered Square",
        "difficulty": 1,
        "answer": "        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] == 1:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return max([max(row) for row in dp]) ** 2\n"
    },
    {
        "number": 1140,
        "title": "Stone Game II",
        "difficulty": 1,
        "answer": "        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], piles[i] + dp[i + 2][j])\n        return dp[0][-1]"
    },
    {
        "number": 1143,
        "title": "Longest Common Subsequence",
        "difficulty": 1,
        "answer": "        m = len(text1)\n        n = len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]"
    },
    {
        "number": 1144,
        "title": "Decrease Elements To Make Array Zigzag",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21"
    },
    {
        "number": 1145,
        "title": "Binary Tree Coloring Game",
        "difficulty": 1,
        "answer": "        def dfs(node, color):\n            if not node:\n                return 0\n            if node.val == color:\n                return 1 + dfs(node.left, 1 - color) + dfs(node.right, 1 - color)\n            else:\n                return max(dfs(node.left, 1 - color), dfs(node.right, 1 - color))"
    },
    {
        "number": 1146,
        "title": "Snapshot Array",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1147,
        "title": "Longest Chunked Palindrome Decomposition",
        "difficulty": 2,
        "answer": "        if not text:\n            return 0\n        \n        n = len(text)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i):\n                if text[i] == text[j] and (i - j <= 2 or dp[j + 1][i - 1]):\n                    dp[j][i] = 1 + dp[j + 1][i - 1]\n        \n        return max(max(row) for row in dp)"
    },
    {
        "number": 1154,
        "title": "Day of the Year",
        "difficulty": 0,
        "answer": "        year, month, day = map(int, date.split('-'))\n        days_in_month = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\n        if month == 2:\n            if year % 4 == 0:\n                days_in_month[2] = 29\n            else:\n                days_in_month[2] = 28\n        return sum(days_in_month.values()) - day + 1"
    },
    {
        "number": 1155,
        "title": "Number of Dice Rolls With Target Sum",
        "difficulty": 1,
        "answer": "        dp = [[0] * (target + 1) for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, target + 1):\n                if j - i >= 0:\n                    dp[i][j] = dp[i][j] + dp[i - 1][j - i]\n        return dp[k][target] % (10 ** 9 + 7)"
    },
    {
        "number": 1156,
        "title": "Swap For Longest Repeated Character Substring",
        "difficulty": 1,
        "answer": "        if not text:\n            return 0\n        \n        n = len(text)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if text[i] == text[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        return dp[0][n - 1]"
    },
    {
        "number": 1157,
        "title": "Online Majority Element In Subarray",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = {}\n        # for i in range(left, right+1):\n        #     count[arr[i]] = count.get(arr[i], 0) + 1\n        # for i in range(left, right+1):\n        #     if count[arr[i]] > threshold:\n        #         return arr[i]\n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        # count = {}\n        # for i in range(left, right+1):\n        #     count[arr[i]] = count.get(arr[i], 0) + 1\n        # for i in range(left, right+1):\n        #     if count[arr[i]] > threshold:\n        #         return arr[i]\n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        # count = {}\n        # for i in range(left, right+1):\n"
    },
    {
        "number": 1160,
        "title": "Find Words That Can Be Formed by Characters",
        "difficulty": 0,
        "answer": "        # Time: O(n * m)\n        # Space: O(n * m)\n        # dp = {}\n        # for word in words:\n        #     for char in word:\n        #         if char not in dp:\n        #             dp[char] = 1\n        #         else:\n        #             dp[char] += 1\n        #\n        # ans = 0\n        # for word in words:\n        #     for char in word:\n        #         if char not in dp:\n        #             break\n        #         else:\n        #             dp[char] -= 1\n        #             if dp[char] == 0:\n        #                 del dp[char]\n        #     if len(word) == len(set(word)):\n        #         ans += len(word)\n        # return ans"
    },
    {
        "number": 1161,
        "title": "Maximum Level Sum of a Binary Tree",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return 0\n        # self.max_sum = float('-inf')\n        # self.max_level = 1\n        # self.dfs(root, 1)\n        # return self.max_level"
    },
    {
        "number": 1162,
        "title": "As Far from Land as Possible",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def bfs(i, j):\n            q = deque([(i, j)])\n            visited = set()\n            visited.add((i, j))\n            dist = 0\n            while q:\n                size = len(q)\n                for _ in range(size):\n                    x, y = q.popleft()\n                    for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                dist += 1\n            return dist\n        \n        res = -1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] =="
    },
    {
        "number": 1163,
        "title": "Last Substring in Lexicographical Order",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return \"\"\n        #\n        # stack = []\n        # for i in range(len(s)):\n        #     if not stack or s[i] > stack[-1]:\n        #         stack.append(s[i])\n        #     else:\n        #         while stack and s[i] < stack[-1]:\n        #             stack.pop()\n        #         stack.append(s[i])\n        #\n        # return \"\".join(stack)"
    },
    {
        "number": 1169,
        "title": "Invalid Transactions",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1170,
        "title": "Compare Strings by Frequency of the Smallest Character",
        "difficulty": 1,
        "answer": "        # O(n*m)\n        # n = len(queries)\n        # m = len(words)\n        # res = []\n        # for i in range(n):\n        #     count = 0\n        #     for j in range(m):\n        #         if queries[i] < words[j]:\n        #             count += 1\n        #     res.append(count)\n        # return res"
    },
    {
        "number": 1171,
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        curr = head\n        while curr:\n            curr.next = self.removeZeroSumSublists(curr.next)\n            if curr.val == 0 and curr.next:\n                curr = curr.next\n            else:\n                curr = curr.next\n                \n        return head\n"
    },
    {
        "number": 1172,
        "title": "Dinner Plate Stacks",
        "difficulty": 2,
        "answer": "    def __init__(self, capacity: int):\n    def push(self, val: int) -> None:\n    def pop(self) -> int:\n    def popAtStack(self, index: int) -> int:\n        \"\"\"\n        You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\n        Implement the DinnerPlates class:\n            DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks capacity.\n            void push(int val) Pushes the given integer val into the leftmost stack with a size less than capacity.\n            int pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all the stacks are empty.\n            int popAtStack(int index) Returns the value at the top of the stack with the given index index and removes it from that stack or returns -1 if the stack with that given index is empty.\n        Example 1:\n        Input\n        [\"DinnerPlates\", \"push\", \"push\","
    },
    {
        "number": 1175,
        "title": "Prime Arrangements",
        "difficulty": 0,
        "answer": "        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 6\n        # if n == 4:\n        #     return 24\n        # if n == 5:\n        #     return 60\n        # if n == 6:\n        #     return 240\n        # if n == 7:\n        #     return 728\n        # if n == 8:\n        #     return 5040\n        # if n == 9:\n        #     return 40320\n        # if n == 10:\n        #     return 362880\n        # if n == 11:\n        #     return 39916800\n        # if n == 12:\n        #     return 479001600\n        # if n == 13:\n        #     return 5040320\n        # if n == 14:\n        #     return 40320320\n        # if n == 15:\n        #     return 362880320\n        # if n == 16:\n        #     return 39916800320\n        # if n == 17"
    },
    {
        "number": 1177,
        "title": "Can Make Palindrome from Substring",
        "difficulty": 1,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = [[False] * 26 for _ in range(len(s))]\n        # for i in range(len(s)):\n        #     dp[i][ord(s[i]) - ord('a')] = True\n        #\n        # for left, right, k in queries:\n        #     if k == 0:\n        #         for i in range(left, right + 1):\n        #             dp[i][ord(s[i]) - ord('a')] = not dp[i][ord(s[i]) - ord('a')]\n        #     else:\n        #         for i in range(left, right + 1):\n        #             if dp[i][ord(s[i]) - ord('a')]:\n        #                 dp[i][ord(s[i]) - ord('a')] = not dp[i][ord(s[i]) - ord('a')]\n        #                 k -= 1\n        #                 if k == 0:\n"
    },
    {
        "number": 1178,
        "title": "Number of Valid Words for Each Puzzle",
        "difficulty": 2,
        "answer": "        def is_valid(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_2(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_3(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_4(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_5(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_6(word, puzzle):\n            for c in word:\n                if c not in puzzle:\n                    return False\n            return True\n        \n        def is_valid_7(word, puzzle):\n            for c in word:\n                if c not"
    },
    {
        "number": 1184,
        "title": "Distance Between Bus Stops",
        "difficulty": 0,
        "answer": "        # Time: O(n)\r\n        # Space: O(n)\r\n        # dp = [0] * len(distance)\r\n        # dp[start] = distance[start]\r\n        # for i in range(start + 1, len(distance)):\r\n        #     dp[i] = dp[i - 1] + distance[i]\r\n        # return min(dp[destination], dp[destination - 1])\r\n\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # dp = 0\r\n        # for i in range(len(distance)):\r\n        #     dp += distance[i]\r\n        # return dp - distance[start] - distance[destination]\r\n\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # dp = 0\r\n        # for i in range(len(distance)):\r\n        #     dp += distance[i]\r\n        # return min(dp - distance[start], dp"
    },
    {
        "number": 1185,
        "title": "Day of the Week",
        "difficulty": 0,
        "answer": "        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        # day_of_week = [\"Sunday"
    },
    {
        "number": 1186,
        "title": "Maximum Subarray Sum with One Deletion",
        "difficulty": 1,
        "answer": "        # Solution 1: DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(arr)\n        # dp[0] = arr[0]\n        # for i in range(1, len(arr)):\n        #     dp[i] = max(dp[i-1] + arr[i], arr[i])\n        # return max(dp)"
    },
    {
        "number": 1187,
        "title": "Make Array Strictly Increasing",
        "difficulty": 2,
        "answer": "        # O(n) time, O(n) space\n        # if not arr1 or not arr2: return -1\n        # n = len(arr1)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1):\n        #     if arr1[i] < arr1[i + 1]:\n        #         dp[i][i + 1] = 1\n        # for i in range(n - 2, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if arr1[i] < arr1[j]:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1] + 1)\n        # return dp[0][n - 1]"
    },
    {
        "number": 1189,
        "title": "Maximum Number of Balloons",
        "difficulty": 0,
        "answer": "        from collections import Counter\n        cnt = Counter(text)\n        return min(cnt[\"b\"], cnt[\"a\"], cnt[\"l\"], cnt[\"o\"], cnt[\"n\"])"
    },
    {
        "number": 1190,
        "title": "Reverse Substrings Between Each Pair of Parentheses",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                start = stack.pop()\n                s = s[:start] + s[start+1:i][::-1] + s[i+1:]\n        return s"
    },
    {
        "number": 1191,
        "title": "K-Concatenation Maximum Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(arr) + 1)]\n        # for i in range(1, len(arr) + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i - 1])\n        # return max(dp[-1]) % (10 ** 9 + 7)"
    },
    {
        "number": 1192,
        "title": "Critical Connections in a Network",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # BFS\n"
    },
    {
        "number": 1195,
        "title": "Fizz Buzz Multithreaded",
        "difficulty": 1,
        "answer": "        def fizz(printFizz: 'Callable[[], None]') -> None:\n            for i in range(1, self.n + 1):\n                if i % 3 == 0 and i % 5 == 0:\n                    printFizz()\n                elif i % 3 == 0:\n                    printFizz()\n                elif i % 5 == 0:\n                    printBuzz()\n                else:\n                    printNumber()\n        def buzz(printBuzz: 'Callable[[], None]') -> None:\n            for i in range(1, self.n + 1):\n                if i % 3 == 0 and i % 5 == 0:\n                    printBuzz()\n                elif i % 3 == 0:\n                    printFizz()\n                elif i % 5 == 0:\n                    printBuzz()\n                else:\n                    printNumber()\n        def fizzbuzz(printFizzBuzz: 'Callable[[], None]') -> None:\n            for i in range(1, self.n + 1):\n                if i % 3 == 0 and i % 5 == 0:\n                    printFizzBuzz"
    },
    {
        "number": 1200,
        "title": "Minimum Absolute Difference",
        "difficulty": 0,
        "answer": "        arr.sort()\n        min_diff = float('inf')\n        res = []\n        for i in range(len(arr)-1):\n            if arr[i+1] - arr[i] < min_diff:\n                min_diff = arr[i+1] - arr[i]\n                res = [[arr[i], arr[i+1]]]\n            elif arr[i+1] - arr[i] == min_diff:\n                res.append([arr[i], arr[i+1]])\n        return res\n"
    },
    {
        "number": 1201,
        "title": "Ugly Number III",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return a\n        if n == 2:\n            return min(a, b, c)\n        if n == 3:\n            return min(a, min(b, c))\n        if n == 4:\n            return min(a, min(b, min(c, a)))\n        if n == 5:\n            return min(a, min(b, min(c, min(a, b))))\n        if n == 6:\n            return min(a, min(b, min(c, min(a, min(b, c)))))\n        if n == 7:\n            return min(a, min(b, min(c, min(a, min(b, min(c, a)))))\n        if n == 8:\n            return min(a, min(b, min(c, min(a, min(b, min(c, min(a, b)))))\n        if n == 9:\n            return min(a, min(b, min(c, min(a, min(b, min(c, min(a, min"
    },
    {
        "number": 1202,
        "title": "Smallest String With Swaps",
        "difficulty": 1,
        "answer": "        \n        # sort the pairs by their first index\n        pairs.sort(key=lambda x: x[0])\n        \n        # create a dict to keep track of the index of each character\n        char_to_index = {}\n        for i, c in enumerate(s):\n            char_to_index[c] = i\n        \n        # create a dict to keep track of the index of each character\n        index_to_char = {}\n        for i, c in enumerate(s):\n            index_to_char[i] = c\n        \n        # create a dict to keep track of the number of times each character appears\n        char_count = {}\n        for c in s:\n            if c not in char_count:\n                char_count[c] = 0\n            char_count[c] += 1\n        \n        # create a dict to keep track of the number of times each character appears\n        index_count = {}\n        for i in range(len(s)):\n            if i not in index_count:\n                index_count[i] = 0\n            "
    },
    {
        "number": 1203,
        "title": "Sort Items by Groups Respecting Dependencies",
        "difficulty": 2,
        "answer": "        \n        # create a map from group to index\n        group_map = {}\n        for i, g in enumerate(group):\n            if g not in group_map:\n                group_map[g] = i\n        \n        # create a map from item to group\n        item_map = {}\n        for i, item in enumerate(group):\n            if item not in item_map:\n                item_map[item] = []\n            item_map[item].append(i)\n        \n        # create a map from group to items\n        group_items = {}\n        for i, item in enumerate(group):\n            if item not in group_items:\n                group_items[item] = []\n            group_items[item].append(i)\n        \n        # create a map from item to group\n        item_group = {}\n        for i, item in enumerate(group):\n            if item not in item_group:\n                item_group[item] = []\n            item_group[item].append(i)\n        \n        # create a map from item to"
    },
    {
        "number": 1206,
        "title": "Design Skiplist",
        "difficulty": 2,
        "answer": "        # Your code here\n        class Node:\n            def __init__(self, val):\n                self.val = val\n                self.next = None\n                self.prev = None\n        class SkipList:\n            def __init__(self):\n                self.head = None\n                self.tail = None\n                self.size = 0\n            def add(self, val):\n                if self.head is None:\n                    self.head = Node(val)\n                    self.tail = self.head\n                else:\n                    self.tail.next = Node(val)\n                    self.tail.next.prev = self.tail\n                    self.tail = self.tail.next\n                self.size += 1\n            def search(self, val):\n                curr = self.head\n                while curr:\n                    if curr.val == val:\n                        return True\n                    curr = curr.next\n                return False\n            def erase(self, val):\n                curr = self.head\n                while curr:\n                    if curr.val == val:\n                        if curr"
    },
    {
        "number": 1207,
        "title": "Unique Number of Occurrences",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # count = {}\n        # for i in arr:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        # return len(count.values()) == len(set(count.values()))\n        \n        # O(n) time | O(n) space\n        # count = {}\n        # for i in arr:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        # return len(count.values()) == len(set(count.values()))\n        \n        # O(n) time | O(n) space\n        # count = {}\n        # for i in arr:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        # return len(count.values()) == len(set(count.values"
    },
    {
        "number": 1208,
        "title": "Get Equal Substrings Within Budget",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        # for i in range(1, len(s) + 1):\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1]\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        # return dp[-1][-1]"
    },
    {
        "number": 1209,
        "title": "Remove All Adjacent Duplicates in String II",
        "difficulty": 1,
        "answer": "        if not s:\n            return s\n        \n        stack = []\n        for i in range(len(s)):\n            if len(stack) == 0:\n                stack.append(s[i])\n            elif stack[-1] == s[i]:\n                stack.pop()\n            else:\n                stack.append(s[i])\n            if len(stack) == k:\n                stack.pop()\n        return \"\".join(stack)"
    },
    {
        "number": 1210,
        "title": "Minimum Moves to Reach Target with Rotations",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(r, c, d):\n            if r == m-1 and c == n-1:\n                return 0\n            if d == 0:\n                if r == m-1:\n                    return dfs(r, c+1, 1) + 1\n                if c == n-1:\n                    return dfs(r+1, c, 2) + 1\n                if grid[r][c] == 0:\n                    return dfs(r, c+1, 1) + 1\n                if grid[r][c] == 1:\n                    return dfs(r+1, c, 2) + 1\n            if d == 1:\n                if r == 0:\n                    return dfs(r, c+1, 2) + 1\n                if c == n-1:\n                    return dfs(r-1, c, 3) + 1\n                if grid[r][c] == 0:\n                    return dfs(r, c+1, 1) + 1\n                if grid[r"
    },
    {
        "number": 1217,
        "title": "Minimum Cost to Move Chips to The Same Position",
        "difficulty": 0,
        "answer": "        # count = 0\n        # for i in range(len(position)):\n        #     if position[i] % 2 == 0:\n        #         count += 1\n        #     else:\n        #         count -= 1\n        # return count\n        \n        # count = 0\n        # for i in range(len(position)):\n        #     if position[i] % 2 == 0:\n        #         count += 1\n        # return count\n        \n        # count = 0\n        # for i in range(len(position)):\n        #     if position[i] % 2 == 0:\n        #         count += 1\n        # return count\n        \n        # count = 0\n        # for i in range(len(position)):\n        #     if position[i] % 2 == 0:\n        #         count += 1\n        # return count\n        \n        # count = 0\n        # for i in range(len(position)):\n        #     if position[i] % 2 == 0:\n        #         count += 1\n        # return count\n        \n        #"
    },
    {
        "number": 1218,
        "title": "Longest Arithmetic Subsequence of Given Difference",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1], dp[i-2]+1)\n        # dp[i] = max(dp[i-1],"
    },
    {
        "number": 1219,
        "title": "Path with Maximum Gold",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return max(dp[-1])"
    },
    {
        "number": 1220,
        "title": "Count Vowels Permutation",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * 5 for _ in range(n + 1)]\n        dp[1][0] = 1\n        dp[2][0] = 1\n        dp[2][1] = 1\n        dp[2][2] = 1\n        dp[2][3] = 1\n        dp[2][4] = 1\n        dp[3][0] = 1\n        dp[3][1] = 1\n        dp[3][2] = 1\n        dp[3][3] = 1\n        dp[3][4] = 1\n        dp[4][0] = 1\n        dp[4][1] = 1\n        dp[4][2] = 1\n        dp[4][3] = 1\n        dp[4][4] = 1\n        for i in range(5, n + 1):\n            for j in range(5):\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j + 1]) % MOD\n        return dp[n][0]"
    },
    {
        "number": 1221,
        "title": "Split a String in Balanced Strings",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] == 'R':\n                count += 1\n            else:\n                count -= 1\n            if count == 0:\n                return i + 1\n        return count"
    },
    {
        "number": 1222,
        "title": "Queens That Can Attack the King",
        "difficulty": 1,
        "answer": "        def is_attack(x1, y1, x2, y2):\n            if abs(x1 - x2) == abs(y1 - y2):\n                return True\n            return False\n        \n        def is_attack_diag(x1, y1, x2, y2):\n            if abs(x1 - x2) == abs(y1 - y2):\n                return True\n            return False\n        \n        def is_attack_diag_2(x1, y1, x2, y2):\n            if abs(x1 - x2) == abs(y1 - y2):\n                return True\n            return False\n        \n        def is_attack_diag_3(x1, y1, x2, y2):\n            if abs(x1 - x2) == abs(y1 - y2):\n                return True\n            return False\n        \n        def is_attack_diag_4(x1, y1, x2, y2):\n            if abs(x1 - x2) == abs(y1 - y"
    },
    {
        "number": 1223,
        "title": "Dice Roll Simulation",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(len(rollMax) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(dp)):\n            for j in range(1, n + 1):\n                for k in range(1, rollMax[i - 1] + 1):\n                    dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n        return dp[-1][-1]"
    },
    {
        "number": 1224,
        "title": "Maximum Equal Frequency",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1226,
        "title": "The Dining Philosophers",
        "difficulty": 1,
        "answer": "        # print(f\"{philosopher} wants to eat\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeftFork} {putRightFork}\")\n        # print(f\"{pickLeftFork} {pickRightFork} {eat} {putLeft"
    },
    {
        "number": 1227,
        "title": "Airplane Seat Assignment Probability",
        "difficulty": 1,
        "answer": "        # n = 1\n        # return 1\n        # n = 2\n        # return 0.5\n        # n = 3\n        # return 0.3333333333333333\n        # n = 4\n        # return 0.25\n        # n = 5\n        # return 0.2\n        # n = 6\n        # return 0.16666666666666666\n        # n = 7\n        # return 0.1428571428571429\n        # n = 8\n        # return 0.125\n        # n = 9\n        # return 0.1\n        # n = 10\n        # return 0.09523809523809523\n        # n = 11\n        # return 0.08333333333333333\n        # n = 12\n        # return 0.0769230769230769\n        # n = 13\n        # return 0.06666666666666667\n        # n = 14\n        # return 0.05555555555555556\n        # n = 15\n        # return 0.04347826086956522\n        # n = 16\n        #"
    },
    {
        "number": 1232,
        "title": "Check If It Is a Straight Line",
        "difficulty": 0,
        "answer": "        if len(coordinates) < 3:\r\n            return False\r\n        x1, y1 = coordinates[0]\r\n        x2, y2 = coordinates[1]\r\n        for i in range(2, len(coordinates)):\r\n            x3, y3 = coordinates[i]\r\n            if (x2 - x1) * (y3 - y2)!= (x3 - x2) * (y1 - y2):\r\n                return False\r\n        return True\r\n\r\n\r\nclass Solution:\r\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\r\n        \"\"\"\r\n        You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.\r\n        Example 1:\r\n        Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\r\n        Output: true\r\n        Example 2:\r\n        "
    },
    {
        "number": 1233,
        "title": "Remove Sub-Folders from the Filesystem",
        "difficulty": 1,
        "answer": "        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        # folder = [\"/a\",\"/a/b\",\"/c/d\",\"/c/d/e\",\"/c/f\"]\n        #"
    },
    {
        "number": 1234,
        "title": "Replace the Substring for Balanced String",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] == 'Q':\n                count += 1\n            elif s[i] == 'W':\n                count -= 1\n            elif s[i] == 'E':\n                count += 1\n            elif s[i] == 'R':\n                count -= 1\n            if count == 0:\n                return i + 1\n        return 0"
    },
    {
        "number": 1235,
        "title": "Maximum Profit in Job Scheduling",
        "difficulty": 2,
        "answer": "        n = len(startTime)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = profit[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j] + profit[i] * (endTime[j] - startTime[i]))\n        return dp[0][n - 1]"
    },
    {
        "number": 1237,
        "title": "Find Positive Integer Solution for a Given Equation",
        "difficulty": 1,
        "answer": "        def f(x, y):\n            return x + y\n        \n        def g(x, y):\n            return x * y\n        \n        def h(x, y):\n            return x * y + 1\n        \n        def i(x, y):\n            return x * y + 2\n        \n        def j(x, y):\n            return x * y + 3\n        \n        def k(x, y):\n            return x * y + 4\n        \n        def l(x, y):\n            return x * y + 5\n        \n        def m(x, y):\n            return x * y + 6\n        \n        def n(x, y):\n            return x * y + 7\n        \n        def o(x, y):\n            return x * y + 8\n        \n        def p(x, y):\n            return x * y + 9\n        \n        def q(x, y):\n            return x * y + 10\n        \n        def r(x, y):\n            return x * y + 11\n        \n        def s(x, y"
    },
    {
        "number": 1238,
        "title": "Circular Permutation in Binary Representation",
        "difficulty": 1,
        "answer": "        def gen(n):\r\n            if n == 1:\r\n                return [0]\r\n            if n == 2:\r\n                return [0,1]\r\n            if n == 3:\r\n                return [0,1,2]\r\n            if n == 4:\r\n                return [0,1,2,3]\r\n            if n == 5:\r\n                return [0,1,2,3,4]\r\n            if n == 6:\r\n                return [0,1,2,3,4,5]\r\n            if n == 7:\r\n                return [0,1,2,3,4,5,6]\r\n            if n == 8:\r\n                return [0,1,2,3,4,5,6,7]\r\n            if n == 9:\r\n                return [0,1,2,3,4,5,6,7,8]\r\n            if n == 10:\r\n                return [0,1,2,3,4,5,6,7,8,9]\r\n            if"
    },
    {
        "number": 1239,
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # def helper(arr, s):\n        #     if s in dp:\n        #         return dp[s]\n        #     if len(s) == 0:\n        #         return 0\n        #     if len(s) == 1:\n        #         return 1\n        #     if len(s) == 2:\n        #         if s[0] == s[1]:\n        #             return 2\n        #         else:\n        #             return 1\n        #     if len(s) == 3:\n        #         if s[0] == s[1] and s[1] == s[2]:\n        #             return 3\n        #         else:\n        #             return 2\n        #     if len(s) == 4:\n        #         if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n        #             return 4\n        #         else:\n        "
    },
    {
        "number": 1240,
        "title": "Tiling a Rectangle with the Fewest Squares",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j"
    },
    {
        "number": 1247,
        "title": "Minimum Swaps to Make Strings Equal",
        "difficulty": 1,
        "answer": "        # s1 = \"xx\"\n        # s2 = \"yy\"\n        # s1 = \"xy\"\n        # s2 = \"yx\"\n        # s1 = \"xxy\"\n        # s2 = \"xyy\"\n        # s1 = \"xxxy\"\n        # s2 = \"xyxy\"\n        # s1 = \"xxxyy\"\n        # s2 = \"xyxyyy\"\n        # s1 = \"xxxyyyy\"\n        # s2 = \"xyxyyyyy\"\n        # s1 = \"xxxyyyyyy\"\n        # s2 = \"xyxyyyyyyy\"\n        # s1 = \"xxxyyyyyyyy\"\n        # s2 = \"xyxyyyyyyyyy\"\n        # s1 = \"xxxyyyyyyyyyy\"\n        # s2 = \"xyxyyyyyyyyyyy\"\n        # s1 = \"xxxyyyyyyyyyyyy\"\n        # s2 = \"xyxyyyyyyyyyyyyy\"\n        # s1 = \"xxxyyyyyyyyy"
    },
    {
        "number": 1248,
        "title": "Count Number of Nice Subarrays",
        "difficulty": 1,
        "answer": "        count = 0\r\n        for i in range(len(nums)):\r\n            if nums[i] % 2 == 1:\r\n                count += 1\r\n            if count == k:\r\n                count = 0\r\n                continue\r\n            if count < k:\r\n                count += 1\r\n        return count\r\n\r\n\r\nclass Solution:\r\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\r\n        \"\"\"\r\n        Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\r\n        Return the number of nice sub-arrays.\r\n        Example 1:\r\n        Input: nums = [1,1,2,1,1], k = 3\r\n        Output: 2\r\n        Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\r\n        Example 2:\r\n        Input: nums = [2,4,6],"
    },
    {
        "number": 1249,
        "title": "Minimum Remove to Make Valid Parentheses",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    stack.append(i)\n        \n        res = []\n        for i in range(len(s)):\n            if i not in stack:\n                res.append(s[i])\n        \n        return ''.join(res)"
    },
    {
        "number": 1250,
        "title": "Check If It Is a Good Array",
        "difficulty": 2,
        "answer": "        if len(nums) == 0:\n            return False\n        if len(nums) == 1:\n            return True\n        if len(nums) == 2:\n            return nums[0] == 1 and nums[1] == 1\n        if len(nums) == 3:\n            return nums[0] == 1 and nums[1] == 1 and nums[2] == 1\n        if len(nums) == 4:\n            return nums[0] == 1 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1\n        if len(nums) == 5:\n            return nums[0] == 1 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1\n        if len(nums) == 6:\n            return nums[0] == 1 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1 and nums["
    },
    {
        "number": 1252,
        "title": "Cells with Odd Values in a Matrix",
        "difficulty": 0,
        "answer": "        # m = 2, n = 3, indices = [[0,1],[1,1]]\n        # m = 2, n = 2, indices = [[1,1],[0,0]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0],[0,2]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0],[0,2],[1,2]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0],[0,2],[1,2],[2,1]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0],[0,2],[1,2],[2,1],[0,3],[1,3],[2,2]]\n        # m = 3, n = 3, indices = [[0,1],[1,1],[2,0],[0,2"
    },
    {
        "number": 1253,
        "title": "Reconstruct a 2-Row Binary Matrix",
        "difficulty": 1,
        "answer": "        if upper == 0 or lower == 0:\n            return []\n        if upper == lower:\n            return [[1] * upper]\n        if upper == 1:\n            return [[1]]\n        if lower == 1:\n            return [[0]]\n        if upper == 2:\n            return [[1, 0], [0, 1]]\n        if lower == 2:\n            return [[0, 1], [1, 0]]\n        if upper == 3:\n            return [[1, 1, 0], [0, 0, 1]]\n        if lower == 3:\n            return [[0, 1, 1], [1, 0, 0]]\n        if upper == 4:\n            return [[1, 1, 1, 0], [0, 0, 0, 1]]\n        if lower == 4:\n            return [[0, 1, 1, 1], [1, 0, 0, 0]]\n        if upper == 5:\n            return [[1, 1, 1, 1, 0], [0, 0, 0, 0, 1]]\n        if lower == 5:\n            return [[1, 0, 1, 1"
    },
    {
        "number": 1254,
        "title": "Number of Closed Islands",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if not (0 <= i < m and 0 <= j < n) or grid[i][j]!= 1:\n                return\n            grid[i][j] = 2\n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                dfs(x, y)\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dfs(i, j)\n                    res += 1\n        return res"
    },
    {
        "number": 1255,
        "title": "Maximum Score Words Formed by Letters",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + score[i]\n        # dp["
    },
    {
        "number": 1260,
        "title": "Shift 2D Grid",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        for _ in range(k):\n            for i in range(m):\n                for j in range(n):\n                    if i == m - 1:\n                        grid[i][j], grid[0][j] = grid[0][j], grid[i][j]\n                    elif j == 0:\n                        grid[i][j], grid[i + 1][0] = grid[i + 1][0], grid[i][j]\n                    else:\n                        grid[i][j], grid[i][j - 1] = grid[i][j - 1], grid[i][j]\n        return grid"
    },
    {
        "number": 1261,
        "title": "Find Elements in a Contaminated Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, target):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n            return dfs(node.left, target * 2 + 1) or dfs(node.right, target * 2 + 2)\n        return dfs(root, target)"
    },
    {
        "number": 1262,
        "title": "Greatest Sum Divisible by Three",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [[0] * 3 for _ in range(n)]\n        dp[0][0] = nums[0]\n        dp[0][1] = nums[0]\n        dp[0][2] = nums[0]\n        dp[1][0] = nums[1]\n        dp[1][1] = nums[1]\n        dp[1][2] = nums[1]\n        for i in range(2, n):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) + nums[i]\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]) + nums[i]\n            dp[i][2]"
    },
    {
        "number": 1263,
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        visited = set()\n        q = deque([(0, 0, 0)])\n        while q:\n            i, j, cnt = q.popleft()\n            if (i, j) == (m - 1, n - 1):\n                return cnt\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            if grid[i][j] == 'S':\n                q.append((i + 1, j, cnt + 1))\n                q.append((i - 1, j, cnt + 1))\n                q.append((i, j + 1, cnt + 1))\n                q.append((i, j - 1, cnt + 1))\n            elif grid[i][j] == '#':\n                continue\n            else:\n                q.append((i + 1, j, cnt))\n                q.append((i - 1, j, cnt))\n                q.append((i, j + 1, c"
    },
    {
        "number": 1266,
        "title": "Minimum Time Visiting All Points",
        "difficulty": 0,
        "answer": "        if len(points) == 1:\n            return 0\n        \n        # sort by x\n        points.sort(key=lambda x: x[0])\n        \n        # sort by y\n        points.sort(key=lambda x: x[1])\n        \n        # init\n        x_min = points[0][0]\n        y_min = points[0][1]\n        x_max = points[-1][0]\n        y_max = points[-1][1]\n        \n        # init time\n        time = 0\n        \n        # loop\n        for i in range(1, len(points)):\n            # update x\n            if points[i][0] < x_min:\n                x_min = points[i][0]\n            elif points[i][0] > x_max:\n                x_max = points[i][0]\n            \n            # update y\n            if points[i][1] < y_min:\n                y_min = points[i][1]\n            elif points[i][1] > y"
    },
    {
        "number": 1267,
        "title": "Count Servers that Communicate",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return 0\n            if grid[i][j] == 0:\n                return 0\n            if grid[i][j] == 1:\n                grid[i][j] = 0\n                return 1 + dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1)\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    res += dfs(i, j)\n        return res"
    },
    {
        "number": 1268,
        "title": "Search Suggestions System",
        "difficulty": 1,
        "answer": "        products.sort()\n        res = []\n        for i in range(len(searchWord)):\n            curr = []\n            for j in range(len(products)):\n                if products[j][i] == searchWord[i]:\n                    curr.append(products[j])\n            res.append(curr)\n        return res"
    },
    {
        "number": 1269,
        "title": "Number of Ways to Stay in the Same Place After Some Steps",
        "difficulty": 2,
        "answer": "        if steps == 0:\n            return 1\n        if steps == 1:\n            return arrLen\n        if steps == 2:\n            return arrLen * (arrLen - 1)\n        if steps == 3:\n            return arrLen * (arrLen - 1) * (arrLen - 2)\n        if steps == 4:\n            return arrLen * (arrLen - 1) * (arrLen - 2) * (arrLen - 3)\n        if steps == 5:\n            return arrLen * (arrLen - 1) * (arrLen - 2) * (arrLen - 3) * (arrLen - 4)\n        if steps == 6:\n            return arrLen * (arrLen - 1) * (arrLen - 2) * (arrLen - 3) * (arrLen - 4) * (arrLen - 5)\n        if steps == 7:\n            return arrLen * (arrLen - 1) * (arrLen - 2) * (arrLen - 3) * (arrLen - 4) * (arrLen - 5) * (arrLen - 6)\n        if steps == 8:\n            "
    },
    {
        "number": 1275,
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": 0,
        "answer": "        \n        def check_winner(grid):\n            for i in range(3):\n                if grid[i][0] == grid[i][1] == grid[i][2]!= 0:\n                    return grid[i][0]\n                if grid[0][i] == grid[1][i] == grid[2][i]!= 0:\n                    return grid[0][i]\n            if grid[0][0] == grid[1][1] == grid[2][2]!= 0:\n                return grid[0][0]\n            if grid[0][2] == grid[1][1] == grid[2][0]!= 0:\n                return grid[0][2]\n            return None\n        \n        def check_draw(grid):\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] == 0:\n                        return False\n            return True\n        \n        def check_pending(grid):\n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j"
    },
    {
        "number": 1276,
        "title": "Number of Burgers with No Waste of Ingredients",
        "difficulty": 1,
        "answer": "        if tomatoSlices < cheeseSlices:\n            return []\n        if tomatoSlices == cheeseSlices:\n            return [1, 0]\n        if tomatoSlices == cheeseSlices + 1:\n            return [0, 1]\n        if tomatoSlices == cheeseSlices + 2:\n            return [0, 2]\n        if tomatoSlices == cheeseSlices + 3:\n            return [0, 3]\n        if tomatoSlices == cheeseSlices + 4:\n            return [0, 4]\n        if tomatoSlices == cheeseSlices + 5:\n            return [0, 5]\n        if tomatoSlices == cheeseSlices + 6:\n            return [0, 6]\n        if tomatoSlices == cheeseSlices + 7:\n            return [0, 7]\n        if tomatoSlices == cheeseSlices + 8:\n            return [0, 8]\n        if tomatoSlices == cheeseSlices + 9:\n            return [0, 9]\n        if tomatoSlic"
    },
    {
        "number": 1277,
        "title": "Count Square Submatrices with All Ones",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    count += dp[i][j]\n        return count"
    },
    {
        "number": 1278,
        "title": "Palindrome Partitioning III",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return self.palindromePartition2(s)\n        dp = [[0] * n for _ in range(k)]\n        for i in range(n):\n            dp[0][i] = 1\n        for i in range(1, k):\n            for j in range(n):\n                if j == 0:\n                    dp[i][j] = 1\n                elif s[j] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[k - 1][n - 1]"
    },
    {
        "number": 1281,
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "difficulty": 0,
        "answer": "        if n < 10:\n            return n\n        \n        product = 1\n        sum = 0\n        while n:\n            product *= n % 10\n            sum += n % 10\n            n //= 10\n        return product - sum"
    },
    {
        "number": 1282,
        "title": "Group the People Given the Group Size They Belong To",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # groupSizes.sort()\n        # groups = []\n        # for size in groupSizes:\n        #     if not groups or size!= groups[-1][-1] + 1:\n        #         groups.append([i for i in range(len(groupSizes)) if groupSizes[i] == size])\n        # return groups"
    },
    {
        "number": 1283,
        "title": "Find the Smallest Divisor Given a Threshold",
        "difficulty": 1,
        "answer": "        # Binary search\n        # Time: O(nlog(n))\n        # Space: O(1)\n        # nums.sort()\n        # left, right = 1, nums[-1]\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if sum(map(lambda x: x // mid, nums)) < threshold:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left"
    },
    {
        "number": 1284,
        "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j] = min flips needed to convert mat[i][j] to 0\n        # dp[i][j"
    },
    {
        "number": 1286,
        "title": "Iterator for Combination",
        "difficulty": 1,
        "answer": "        def backtrack(start, end, path, res):\n            if start == end:\n                res.append(path)\n                return\n            for i in range(start, end):\n                backtrack(start, i, path + chr(start + 97), res)\n        res = []\n        backtrack(97, 123, \"\", res)\n        return res[0]"
    },
    {
        "number": 1287,
        "title": "Element Appearing More Than 25% In Sorted Array",
        "difficulty": 0,
        "answer": "        \n        # O(n) time | O(1) space\n        # count = 0\n        # for i in range(len(arr)):\n        #     if arr[i] == 1:\n        #         count += 1\n        #     else:\n        #         count -= 1\n        #     if count > len(arr) // 4:\n        #         return arr[i]\n        \n        # O(n) time | O(1) space\n        # count = 0\n        # for i in range(len(arr)):\n        #     if arr[i] == 1:\n        #         count += 1\n        #     else:\n        #         count -= 1\n        #     if count > len(arr) // 4:\n        #         return arr[i]\n        \n        # O(n) time | O(1) space\n        # count = 0\n        # for i in range(len(arr)):\n        #     if arr[i] == 1:\n        #         count += 1\n        #     else:\n        #         count -= 1\n        #     "
    },
    {
        "number": 1288,
        "title": "Remove Covered Intervals",
        "difficulty": 1,
        "answer": "        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[0])\n        \n        i = 0\n        while i < len(intervals) - 1:\n            if intervals[i][1] >= intervals[i+1][0]:\n                intervals.pop(i)\n            else:\n                i += 1\n        return len(intervals)\n"
    },
    {
        "number": 1289,
        "title": "Minimum Falling Path Sum II",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return min(dp[-1])"
    },
    {
        "number": 1290,
        "title": "Convert Binary Number in a Linked List to Integer",
        "difficulty": 0,
        "answer": "        if not head:\n            return 0\n        \n        curr = head\n        decimal = 0\n        while curr:\n            decimal = decimal * 2 + curr.val\n            curr = curr.next\n        return decimal"
    },
    {
        "number": 1291,
        "title": "Sequential Digits",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(low, high + 1):\n            if self.is_sequential(i):\n                res.append(i)\n        return res"
    },
    {
        "number": 1292,
        "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        if not mat or not mat[0]: return 0\n        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = mat[i][j]\n                else:\n                    dp[i][j] = mat[i][j] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if dp[i][j] <= threshold:\n                    res = max(res, j - i + 1)\n        return res"
    },
    {
        "number": 1293,
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def neighbors(i, j):\n            for di, dj in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n:\n                    yield ni, nj\n        \n        def bfs(i, j):\n            q = deque([(i, j)])\n            visited = set([(i, j)])\n            steps = 0\n            while q:\n                steps += 1\n                for _ in range(len(q)):\n                    i, j = q.popleft()\n                    for ni, nj in neighbors(i, j):\n                        if grid[ni][nj] == 0 and (ni, nj) not in visited:\n                            q.append((ni, nj))\n                            visited.add((ni, nj))\n            return steps\n        \n        def dfs(i, j):\n            if i"
    },
    {
        "number": 1295,
        "title": "Find Numbers with Even Number of Digits",
        "difficulty": 0,
        "answer": "        count = 0\n        for num in nums:\n            if len(str(num)) % 2 == 0:\n                count += 1\n        return count"
    },
    {
        "number": 1296,
        "title": "Divide Array in Sets of K Consecutive Numbers",
        "difficulty": 1,
        "answer": "        if len(nums) % k!= 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums) // k):\n            if nums[i]!= i + 1:\n                return False\n        \n        return True\n"
    },
    {
        "number": 1297,
        "title": "Maximum Number of Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (maxSize + 1) for _ in range(maxLetters + 1)]\n        # for i in range(1, maxLetters + 1):\n        #     for j in range(minSize, maxSize + 1):\n        #         for k in range(j, len(s)):\n        #             if s[k] == s[k - j]:\n        #                 dp[i][j] = dp[i][j] + 1\n        # return max(max(row) for row in dp)"
    },
    {
        "number": 1298,
        "title": "Maximum Candies You Can Get from Boxes",
        "difficulty": 2,
        "answer": "        \n        # dp = [[0] * (len(initialBoxes) + 1) for _ in range(len(status))]\n        # for i in range(len(status)):\n        #     dp[i][0] = status[i]\n        # for i in range(len(status)):\n        #     for j in range(len(initialBoxes)):\n        #         if status[i] == 1:\n        #             dp[i][j + 1] = max(dp[i][j + 1], dp[i - 1][j] + candies[i])\n        #         else:\n        #             dp[i][j + 1] = max(dp[i][j + 1], dp[i - 1][j])\n        # return dp[-1][-1]\n        \n        # dp = [[0] * (len(initialBoxes) + 1) for _ in range(len(status))]\n        # for i in range(len(status)):\n        #     dp[i][0] = status[i]\n"
    },
    {
        "number": 1299,
        "title": "Replace Elements with Greatest Element on Right Side",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n == 0:\n            return []\n        \n        max_val = -1\n        for i in range(n-1, -1, -1):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            arr[i] = max_val\n        \n        return arr"
    },
    {
        "number": 1300,
        "title": "Sum of Mutated Array Closest to Target",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1301,
        "title": "Number of Paths with Max Score",
        "difficulty": 2,
        "answer": "        m, n = len(board), len(board[0])\n        dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = int(board[0][0])\n        for i in range(1, n):\n            dp[0][i][0] = dp[0][i - 1][0] + int(board[0][i])\n        for i in range(1, m):\n            dp[i][0][0] = dp[i - 1][0][0] + int(board[i][0])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) + int(board[i][j])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j][1] = max(dp[i - 1][j]["
    },
    {
        "number": 1302,
        "title": "Deepest Leaves Sum",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        q = deque([root])\n        res = 0\n        while q:\n            size = len(q)\n            for i in range(size):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                if not node.left and not node.right:\n                    res += node.val\n        return res"
    },
    {
        "number": 1304,
        "title": "Find N Unique Integers Sum up to Zero",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [-1]\n        if n == 2:\n            return [-1, 0, 1]\n        if n == 3:\n            return [-1, 0, 1, 3]\n        if n == 4:\n            return [-1, 0, 1, 3, 4]\n        if n == 5:\n            return [-1, 0, 1, 3, 4, -7]\n        if n == 6:\n            return [-1, 0, 1, 3, 4, -7, -5]\n        if n == 7:\n            return [-1, 0, 1, 3, 4, -7, -5, -3]\n        if n == 8:\n            return [-1, 0, 1, 3, 4, -7, -5, -3, -1]\n        if n == 9:\n            return [-1, 0, 1, 3, 4, -7, -5, -3, -1, -1]\n        if n == 10:\n            return [-1, 0, 1, 3, 4"
    },
    {
        "number": 1305,
        "title": "All Elements in Two Binary Search Trees",
        "difficulty": 1,
        "answer": "        def inorder(root):\n            if root:\n                inorder(root.left)\n                res.append(root.val)\n                inorder(root.right)\n        res = []\n        inorder(root1)\n        inorder(root2)\n        return sorted(res)"
    },
    {
        "number": 1306,
        "title": "Jump Game III",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        visited = set()\n        visited.add(start)\n        \n        def dfs(i):\n            if i < 0 or i >= n:\n                return False\n            if arr[i] == 0:\n                return True\n            if i in visited:\n                return False\n            visited.add(i)\n            return dfs(i + arr[i]) or dfs(i - arr[i])\n        \n        return dfs(start)"
    },
    {
        "number": 1307,
        "title": "Verbal Arithmetic Puzzle",
        "difficulty": 2,
        "answer": "        # if len(words)!= len(result):\n        #     return False\n        #\n        # d = {}\n        # for i in range(len(words)):\n        #     d[words[i]] = int(result[i])\n        #\n        # for i in range(len(words)):\n        #     for j in range(len(words)):\n        #         if i!= j and words[i] in d and words[j] in d:\n        #             if d[words[i]] + d[words[j]]!= int(result[i + j]):\n        #                 return False\n        # return True"
    },
    {
        "number": 1309,
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "difficulty": 0,
        "answer": "        # s = \"10#11#12\"\n        # s = \"1326#\"\n        # s = \"10#11#12#13\"\n        # s = \"10#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\"\n        # s = \"10#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#27#28#29#30#31#32#33#34#35#36#37#38#39#40#41#42#43#44#45#46#47#48#49#50#51#52#53#54#55#56#57#58#59#60#61#62#63#64#65#66#67#68#69#70#71#72#73#74#75#76#77#78#79#80#81#82#83#84#85#86#87#88#89#90#91#92#93#"
    },
    {
        "number": 1310,
        "title": "XOR Queries of a Subarray",
        "difficulty": 1,
        "answer": "        # O(n)\n        # ans = []\n        # for i in range(len(queries)):\n        #     left, right = queries[i]\n        #     xor = 0\n        #     for j in range(left):\n        #         xor ^= arr[j]\n        #     for j in range(left, right):\n        #         xor ^= arr[j]\n        #     for j in range(right, len(arr)):\n        #         xor ^= arr[j]\n        #     ans.append(xor)\n        # return ans"
    },
    {
        "number": 1311,
        "title": "Get Watched Videos by Your Friends",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # if not watchedVideos or not friends:\n        #     return []\n        # visited = set()\n        # q = collections.deque([(id, 0)])\n        # seen = set()\n        # seen.add(id)\n        # while q:\n        #     node, level = q.popleft()\n        #     if level == level:\n        #         return sorted(watchedVideos[node])\n        #     for nei in friends[node]:\n        #         if nei not in seen:\n        #             q.append((nei, level+1))\n        #             seen.add(nei)\n        # return []\n        \n        # DFS\n        # Time: O(V+E)\n        # Space: O(V+E)\n        if not watchedVideos or not friends:\n            return []\n        \n        # visited = set()\n        # q = collections.deque([(id, 0)])\n"
    },
    {
        "number": 1312,
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if s[0] == s[1] else 2\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n        return dp[0][n - 1]"
    },
    {
        "number": 1313,
        "title": "Decompress Run-Length Encoded List",
        "difficulty": 0,
        "answer": "        res = []\n        for i in range(0, len(nums), 2):\n            res += nums[i+1] * [nums[i]]\n        return res"
    },
    {
        "number": 1314,
        "title": "Matrix Block Sum",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                ans[i][j] = sum(mat[max(i - k, 0):min(i + k + 1, m), max(j - k, 0):min(j + k + 1, n)])\n        return ans"
    },
    {
        "number": 1315,
        "title": "Sum of Nodes with Even-Valued Grandparent",
        "difficulty": 1,
        "answer": "        def dfs(node, parent, grandparent):\n            if not node:\n                return 0\n            if node.val % 2 == 0:\n                return grandparent + dfs(node.left, node, parent) + dfs(node.right, node, parent)\n            else:\n                return dfs(node.left, node, parent) + dfs(node.right, node, parent)\n        return dfs(root, 0, 0)"
    },
    {
        "number": 1316,
        "title": "Distinct Echo Substrings",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for i in range(len(text)):\n        #     if text[i] not in dp:\n        #         dp[text[i]] = set()\n        #     dp[text[i]].add(i)\n        \n        # ans = 0\n        # for i in range(len(text)):\n        #     for j in range(i+1, len(text)+1):\n        #         if text[i:j] in dp:\n        #             ans += 1\n        \n        # return ans\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for i in range(len(text)):\n        #     if text[i] not in dp:\n        #         dp[text[i]] = set()\n        #     dp[text[i]].add(i)\n        \n        # ans = 0\n        # for i in"
    },
    {
        "number": 1317,
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 1]\n        if n == 3:\n            return [1, 2]\n        if n == 4:\n            return [1, 3]\n        if n == 5:\n            return [1, 4]\n        if n == 6:\n            return [1, 5]\n        if n == 7:\n            return [1, 6]\n        if n == 8:\n            return [1, 7]\n        if n == 9:\n            return [1, 8]\n        if n == 10:\n            return [1, 9]\n        if n == 11:\n            return [2, 9]\n        if n == 12:\n            return [2, 10]\n        if n == 13:\n            return [2, 11]\n        if n == 14:\n            return [2, 12]\n        if n == 15:\n            return [2, 13]\n        if n == 16:\n            return [2, 14]\n        "
    },
    {
        "number": 1318,
        "title": "Minimum Flips to Make a OR b Equal to c",
        "difficulty": 1,
        "answer": "        # a = 2, b = 6, c = 5\r\n        # a = 1, b = 2, c = 3\r\n        # a = 0, b = 2, c = 7\r\n        # a = 0, b = 1, c = 3\r\n        # a = 0, b = 0, c = 3\r\n        # a = 0, b = 1, c = 2\r\n        # a = 0, b = 0, c = 2\r\n        # a = 0, b = 1, c = 1\r\n        # a = 0, b = 0, c = 1\r\n        # a = 1, b = 1, c = 1\r\n        # a = 1, b = 0, c = 1\r\n        # a = 1, b = 1, c = 0\r\n        # a = 1, b = 0, c = 0\r\n        # a = 1, b = 0, c = 0\r\n        # a = 1, b = 0, c = 0\r\n        # a = 1, b = 0, c = 0\r\n        # a = 1, b = 0,"
    },
    {
        "number": 1319,
        "title": "Number of Operations to Make Network Connected",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # if not connections:\n        #     return 0\n        #\n        # def dfs(node, visited):\n        #     visited.add(node)\n        #     for nei in graph[node]:\n        #         if nei not in visited:\n        #             dfs(nei, visited)\n        #\n        # graph = defaultdict(list)\n        # for u, v in connections:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # visited = set()\n        # count = 0\n        # for node in range(n):\n        #     if node not in visited:\n        #         dfs(node, visited)\n        #         count += 1\n        # return count"
    },
    {
        "number": 1320,
        "title": "Minimum Distance to Type a Word Using Two Fingers",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min("
    },
    {
        "number": 1323,
        "title": "Maximum 69 Number",
        "difficulty": 0,
        "answer": "        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '"
    },
    {
        "number": 1324,
        "title": "Print Words Vertically",
        "difficulty": 1,
        "answer": "        if not s: return []\n        s = s.split()\n        res = []\n        for i in range(len(s)):\n            res.append(s[i])\n            if i < len(s) - 1:\n                res.append(\" \")\n        return res"
    },
    {
        "number": 1325,
        "title": "Delete Leaves With a Given Value",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        \n        def dfs(node):\n            if not node:\n                return None\n            \n            if not node.left and not node.right and node.val == target:\n                return None\n            \n            node.left = dfs(node.left)\n            node.right = dfs(node.right)\n            \n            return node\n        \n        return dfs(root)\n"
    },
    {
        "number": 1326,
        "title": "Minimum Number of Taps to Open to Water a Garden",
        "difficulty": 2,
        "answer": "        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n"
    },
    {
        "number": 1328,
        "title": "Break a Palindrome",
        "difficulty": 1,
        "answer": "        if len(palindrome) == 1:\n            return \"\"\n        if palindrome == palindrome[::-1]:\n            return palindrome\n        for i in range(len(palindrome)):\n            if palindrome[i]!= 'a':\n                continue\n            for j in range(i+1, len(palindrome)):\n                if palindrome[j]!= 'a':\n                    continue\n                if palindrome[i] > palindrome[j]:\n                    return palindrome[:i] + 'a' + palindrome[i+1:j] + 'b' + palindrome[j+1:]\n        return \"\""
    },
    {
        "number": 1329,
        "title": "Sort the Matrix Diagonally",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        diag_sorted = []\n        for i in range(m):\n            diag_sorted.append([])\n            for j in range(n):\n                diag_sorted[i].append(mat[i][j])\n        diag_sorted.sort()\n        for i in range(m):\n            for j in range(n):\n                mat[i][j] = diag_sorted[i][j]\n        return mat"
    },
    {
        "number": 1330,
        "title": "Reverse Subarray To Maximize Array Value",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        for i in range(n - 1):\n            nums[i] = abs(nums[i] - nums[i + 1])\n        return max(nums)"
    },
    {
        "number": 1331,
        "title": "Rank Transform of an Array",
        "difficulty": 0,
        "answer": "        # O(n)\n        # rank = {}\n        # for i, num in enumerate(arr):\n        #     if num not in rank:\n        #         rank[num] = i + 1\n        # return [rank[num] for num in arr]"
    },
    {
        "number": 1332,
        "title": "Remove Palindromic Subsequences",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1333,
        "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
        "difficulty": 1,
        "answer": "        \n        def filter(restaurants, veganFriendly, maxPrice, maxDistance):\n            res = []\n            for r in restaurants:\n                if r[3] <= maxPrice and r[4] <= maxDistance and r[2] == veganFriendly:\n                    res.append(r)\n            return res\n        \n        res = filter(restaurants, veganFriendly, maxPrice, maxDistance)\n        res.sort(key=lambda x: (x[1], x[0]), reverse=True)\n        return [r[0] for r in res]"
    },
    {
        "number": 1334,
        "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dfs + bfs\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        # dfs: O(n)\n        # bfs: O(n)\n        #"
    },
    {
        "number": 1335,
        "title": "Minimum Difficulty of a Job Schedule",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + jobDifficulty[i]\n        # dp[i][j] = min(dp["
    },
    {
        "number": 1337,
        "title": "The K Weakest Rows in a Matrix",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m, n = len(mat), len(mat[0])\n        # res = []\n        # for i in range(m):\n        #     count = 0\n        #     for j in range(n):\n        #         if mat[i][j] == 1:\n        #             count += 1\n        #     res.append((count, i))\n        # res.sort(key=lambda x: (x[0], x[1]))\n        # return [i[1] for i in res[:k]]"
    },
    {
        "number": 1338,
        "title": "Reduce Array Size to The Half",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1339,
        "title": "Maximum Product of Splitted Binary Tree",
        "difficulty": 1,
        "answer": "        self.max_sum = float('-inf')\n        self.max_product = float('-inf')\n        self.dfs(root)\n        return self.max_product"
    },
    {
        "number": 1340,
        "title": "Jump Game V",
        "difficulty": 2,
        "answer": "        \n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        # dp[i] = max jumps from index i to index i+d\n        "
    },
    {
        "number": 1342,
        "title": "Number of Steps to Reduce a Number to Zero",
        "difficulty": 0,
        "answer": "        count = 0\n        while num!= 0:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = num - 1\n            count += 1\n        return count"
    },
    {
        "number": 1343,
        "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = 0\n        # for i in range(len(arr)):\n        #     if sum(arr[i:i+k]) >= threshold:\n        #         count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = 0\n        # for i in range(len(arr)):\n        #     if sum(arr[i:i+k]) >= threshold:\n        #         count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = 0\n        # for i in range(len(arr)):\n        #     if sum(arr[i:i+k]) >= threshold:\n        #         count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = 0\n        # for i in range(len("
    },
    {
        "number": 1344,
        "title": "Angle Between Hands of a Clock",
        "difficulty": 1,
        "answer": "        # hour = 12\n        # minutes = 30\n        # hour = 3\n        # minutes = 30\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes = 15\n        # hour = 3\n        # minutes ="
    },
    {
        "number": 1345,
        "title": "Jump Game IV",
        "difficulty": 2,
        "answer": "        # dp[i] = min jumps to reach arr[i]\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n        #"
    },
    {
        "number": 1346,
        "title": "Check If N and Its Double Exist",
        "difficulty": 0,
        "answer": "        if len(arr) < 2:\n            return False\n        \n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] == 2 * arr[j]:\n                    return True\n        return False"
    },
    {
        "number": 1347,
        "title": "Minimum Number of Steps to Make Two Strings Anagram",
        "difficulty": 1,
        "answer": "        # Time: O(s*t)\n        # Space: O(s*t)\n        # dp = [[0]*(len(t)+1) for _ in range(len(s)+1)]\n        # for i in range(len(s)+1):\n        #     dp[i][0] = i\n        # for j in range(len(t)+1):\n        #     dp[0][j] = j\n        # for i in range(1, len(s)+1):\n        #     for j in range(1, len(t)+1):\n        #         if s[i-1] == t[j-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        #         else:\n        #             dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # return dp[-1][-1]"
    },
    {
        "number": 1348,
        "title": "Tweet Counts Per Frequency",
        "difficulty": 1,
        "answer": "        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O(N)\n        # Space Complexity: O(N)\n        \n        # Time Complexity: O("
    },
    {
        "number": 1349,
        "title": "Maximum Students Taking Exam",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0] * len(seats[0]) for _ in range(len(seats))]\n        # for i in range(len(seats)):\n        #     for j in range(len(seats[0])):\n        #         if seats[i][j] == '.':\n        #             dp[i][j] = 0\n        #         else:\n        #             dp[i][j] = 1\n        # for i in range(len(seats)):\n        #     for j in range(len(seats[0])):\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j-1] + dp[i][j+1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i-1][j] + dp[i+1][j]\n        #         elif i == len(seats)-1:"
    },
    {
        "number": 1351,
        "title": "Count Negative Numbers in a Sorted Matrix",
        "difficulty": 0,
        "answer": "        n = len(grid)\n        m = len(grid[0])\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] < 0:\n                    count += 1\n        return count"
    },
    {
        "number": 1352,
        "title": "Product of the Last K Numbers",
        "difficulty": 1,
        "answer": "        # Your ProductOfNumbers object will be instantiated and called as such:\n        # obj = ProductOfNumbers()\n        # obj.add(num)\n        # param_2 = obj.getProduct(k)\n        # @lc code=start\n        self.nums = []\n        self.product = 1"
    },
    {
        "number": 1353,
        "title": "Maximum Number of Events That Can Be Attended",
        "difficulty": 1,
        "answer": "        events.sort(key=lambda x: x[0])\n        n = len(events)\n        res = 0\n        for i in range(n):\n            if events[i][1] >= events[i][0]:\n                res += 1\n            else:\n                events[i][1] = events[i][0]\n        return res"
    },
    {
        "number": 1354,
        "title": "Construct Target Array With Multiple Sums",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not target:\n        #     return True\n        # target_sum = sum(target)\n        # if target_sum % 2!= 0:\n        #     return False\n        # target_sum = target_sum // 2\n        # target_sum_list = []\n        # for i in range(len(target)):\n        #     target_sum_list.append(target[i] + target_sum)\n        # return target_sum_list == sorted(target_sum_list)"
    },
    {
        "number": 1356,
        "title": "Sort Integers by The Number of 1 Bits",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1357,
        "title": "Apply Discount Every n Orders",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        # n = len(products)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(n):\n        #     dp[i][i] = prices[i]\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         dp[i][j] = prices[i] + prices[j] + dp[i + 1][j] - dp[i + 1][j - 1]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j - 1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i -"
    },
    {
        "number": 1358,
        "title": "Number of Substrings Containing All Three Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         count += dp[s[i]]\n        #     dp[s[i]] = dp.get(s[i], 0) + 1\n        # return count"
    },
    {
        "number": 1359,
        "title": "Count All Valid Pickup and Delivery Options",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                dp[i][j] %= MOD\n        return dp[n][n]"
    },
    {
        "number": 1360,
        "title": "Number of Days Between Two Dates",
        "difficulty": 0,
        "answer": "        # date1 = \"2019-06-29\"\n        # date2 = \"2019-06-30\"\n        # date1 = \"2020-01-15\"\n        # date2 = \"2019-12-31\"\n        # date1 = \"2019-06-29\"\n        # date2 = \"2019-06-30\"\n        # date1 = \"2020-01-15\"\n        # date2 = \"2019-12-31\"\n        # date1 = \"2019-06-29\"\n        # date2 = \"2019-06-30\"\n        # date1 = \"2020-01-15\"\n        # date2 = \"2019-12-31\"\n        # date1 = \"2019-06-29\"\n        # date2 = \"2019-06-30\"\n        # date1 = \"2020-01-15\"\n        # date2 = \"2019-12-31\"\n        # date1 = \"2019-06-29\"\n        # date2 = \"2019-06-30\"\n        # date1 = \"2020-01-15\"\n        # date"
    },
    {
        "number": 1361,
        "title": "Validate Binary Tree Nodes",
        "difficulty": 1,
        "answer": "        def dfs(node, left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left[0]!= -1 and left[0]!= node:\n                return False\n            if right[0]!= -1 and right[0]!= node:\n                return False\n            return dfs(node, left[1:], right[1:])\n        return dfs(0, leftChild, rightChild)"
    },
    {
        "number": 1362,
        "title": "Closest Divisors",
        "difficulty": 1,
        "answer": "        # if num == 1:\n        #     return [1,1]\n        # if num == 2:\n        #     return [1,2]\n        # if num == 3:\n        #     return [1,3]\n        # if num == 4:\n        #     return [2,2]\n        # if num == 5:\n        #     return [2,5]\n        # if num == 6:\n        #     return [3,3]\n        # if num == 7:\n        #     return [3,7]\n        # if num == 8:\n        #     return [4,4]\n        # if num == 9:\n        #     return [4,9]\n        # if num == 10:\n        #     return [5,5]\n        # if num == 11:\n        #     return [5,11]\n        # if num == 12:\n        #     return [6,6]\n        # if num == 13:\n        #     return [6,13]\n        # if num == 14:\n        #     return [7,7"
    },
    {
        "number": 1363,
        "title": "Largest Multiple of Three",
        "difficulty": 2,
        "answer": "        \n        # if not digits:\n        #     return \"\"\n        \n        # digits.sort()\n        # for i in range(len(digits)-2):\n        #     if digits[i] == 0 or digits[i+1] == 0 or digits[i+2] == 0:\n        #         continue\n        #     if digits[i] + digits[i+1] + digits[i+2] == 0:\n        #         return str(digits[i]) + str(digits[i+1]) + str(digits[i+2])\n        \n        # return \"\"\n        \n        # if not digits:\n        #     return \"\"\n        \n        # digits.sort()\n        # for i in range(len(digits)-2):\n        #     if digits[i] == 0 or digits[i+1] == 0 or digits[i+2] == 0:\n        #         continue\n        #     if digits[i] + digits[i+1] + digits[i+2] == 0:\n        #         return str(digits[i])"
    },
    {
        "number": 1365,
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "difficulty": 0,
        "answer": "        count = {}\n        for i in range(len(nums)):\n            if nums[i] in count:\n                count[nums[i]] += 1\n            else:\n                count[nums[i]] = 1\n        \n        return [count[i] for i in nums]"
    },
    {
        "number": 1366,
        "title": "Rank Teams by Votes",
        "difficulty": 1,
        "answer": "        votes = sorted(votes, key=lambda x: (len(x), x))\n        res = []\n        for i in range(len(votes)):\n            res.append(votes[i][0])\n        return \"\".join(res)"
    },
    {
        "number": 1367,
        "title": "Linked List in Binary Tree",
        "difficulty": 1,
        "answer": "        if not head:\n            return True\n        \n        def dfs(node, path):\n            if not node:\n                return False\n            \n            if node.val == path[-1]:\n                path.pop()\n                if not path:\n                    return True\n                return dfs(node.left, path) or dfs(node.right, path)\n            return False\n        \n        def dfs_rec(node, path):\n            if not node:\n                return False\n            \n            if node.val == path[-1]:\n                path.pop()\n                if not path:\n                    return True\n                return dfs_rec(node.left, path) or dfs_rec(node.right, path)\n            return False\n        \n        def dfs_iter(node, path):\n            if not node:\n                return False\n            \n            if node.val == path[-1]:\n                path.pop()\n                if not path:\n                    return True\n                return dfs_iter(node.left, path) or dfs_iter(node.right, path"
    },
    {
        "number": 1368,
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, cost):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return cost\n            \n            if grid[i][j] == 1:\n                grid[i][j] = 2\n                return cost + 1 + dfs(i + 1, j, cost + 1) + dfs(i, j + 1, cost + 1)\n            elif grid[i][j] == 2:\n                grid[i][j] = 3\n                return cost + 1 + dfs(i - 1, j, cost + 1) + dfs(i, j + 1, cost + 1)\n            elif grid[i][j] == 3:\n                grid[i][j] = 4\n                return cost + 1 + dfs(i + 1, j, cost + 1) + dfs(i, j - 1, cost + 1)\n            elif grid[i][j] == 4:\n                grid["
    },
    {
        "number": 1370,
        "title": "Increasing Decreasing String",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return s\n        #\n        # result = []\n        # while s:\n        #     result.append(s[0])\n        #     s = s[1:]\n        #     result.append(s[0])\n        #     s = s[1:]\n        #\n        # return \"\".join(result)"
    },
    {
        "number": 1371,
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "difficulty": 1,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        count = 0\n        max_count = 0\n        start = 0\n        for i in range(len(s)):\n            if s[i] in vowels:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"
    },
    {
        "number": 1372,
        "title": "Longest ZigZag Path in a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node, direction):\n            if not node:\n                return 0\n            \n            if direction == 'right':\n                return max(dfs(node.right, 'left'), dfs(node.left, 'right')) + 1\n            else:\n                return max(dfs(node.left, 'right'), dfs(node.right, 'left')) + 1\n        \n        return dfs(root, 'right') - dfs(root, 'left')"
    },
    {
        "number": 1373,
        "title": "Maximum Sum BST in Binary Tree",
        "difficulty": 2,
        "answer": "        self.max_sum = float('-inf')\n        self.max_sum_node = None\n        self.dfs(root)\n        return self.max_sum"
    },
    {
        "number": 1374,
        "title": "Generate a String With Characters That Have Odd Counts",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 'a'\n        if n == 2:\n            return 'ab'\n        if n == 3:\n            return 'aba'\n        if n == 4:\n            return 'abab'\n        if n == 5:\n            return 'ababa'\n        if n == 6:\n            return 'ababab'\n        if n == 7:\n            return 'abababab'\n        if n == 8:\n            return 'ababababab'\n        if n == 9:\n            return 'abababababab'\n        if n == 10:\n            return 'ababababababab'\n        if n == 11:\n            return 'abababababababab'\n        if n == 12:\n            return 'ababababababababab'\n        if n == 13:\n            return 'abababababababababab'\n        if n == 14:\n            return 'ababababababababababab'\n        if n == 15:\n            return 'abab"
    },
    {
        "number": 1375,
        "title": "Number of Times Binary String Is Prefix-Aligned",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not flips:\n        #     return 0\n        # count = 0\n        # for i in range(len(flips)):\n        #     if flips[i] == 0:\n        #         flips[i] = 1\n        #         count += 1\n        #         if count == len(flips):\n        #             return count\n        #         flips[i] = 0\n        # return count"
    },
    {
        "number": 1376,
        "title": "Time Needed to Inform All Employees",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for i, m in enumerate(manager):\n            if m!= -1:\n                graph[m].append(i)\n        \n        def dfs(node, parent, time):\n            if node == -1:\n                return time\n            time += informTime[node]\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                time = dfs(child, node, time)\n            return time\n        \n        return dfs(headID, -1, 0)"
    },
    {
        "number": 1377,
        "title": "Frog Position After T Seconds",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i, j in edges:\n        #     dp[i][j] = 1\n        #     dp[j][i] = 1\n        # for k in range(n):\n        #     for i in range(n):\n        #         for j in range(n):\n        #             dp[i][j] += dp[i][k] * dp[k][j]\n        # return dp[1][target] / (n - 1)"
    },
    {
        "number": 1379,
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "difficulty": 0,
        "answer": "        if not original:\n            return None\n        if original.val == target.val:\n            return target\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)"
    },
    {
        "number": 1380,
        "title": "Lucky Numbers in a Matrix",
        "difficulty": 0,
        "answer": "        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn"
    },
    {
        "number": 1381,
        "title": "Design a Stack With Increment Operation",
        "difficulty": 1,
        "answer": "        # Your CustomStack object will be instantiated and called as such:\n        # obj = CustomStack(maxSize)\n        # obj.push(x)\n        # param_2 = obj.pop()\n        # obj.increment(k,val)\n        # @lc code=start\n        class CustomStack:\n            def __init__(self, maxSize: int):\n                self.stack = []\n                self.maxSize = maxSize"
    },
    {
        "number": 1382,
        "title": "Balance a Binary Search Tree",
        "difficulty": 1,
        "answer": "        def inorder(node):\n            if node:\n                inorder(node.left)\n                self.res.append(node.val)\n                inorder(node.right)\n        self.res = []\n        inorder(root)\n        return self.res"
    },
    {
        "number": 1383,
        "title": "Maximum Performance of a Team",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + speed[i] * min(efficiency[i], efficiency[j]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + speed[i] * min(efficiency[i], efficiency[j]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + speed[i] * min(efficiency[i], efficiency[j]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + speed[i] * min(efficiency[i], efficiency[j]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + speed[i] * min(efficiency[i], efficiency[j]))\n        # dp["
    },
    {
        "number": 1385,
        "title": "Find the Distance Value Between Two Arrays",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # n = len(arr1)\n        # m = len(arr2)\n        # d = abs(d)\n        # count = 0\n        # for i in range(n):\n        #     for j in range(m):\n        #         if abs(arr1[i] - arr2[j]) <= d:\n        #             count += 1\n        # return count"
    },
    {
        "number": 1386,
        "title": "Cinema Seat Allocation",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * 10 for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(10):\n        #         if j not in reservedSeats[i]:\n        #             dp[i][j] = dp[i-1][j] + 1\n        #         else:\n        #             dp[i][j] = dp[i-1][j]\n        # return max(dp[n-1])"
    },
    {
        "number": 1387,
        "title": "Sort Integers by The Power Value",
        "difficulty": 1,
        "answer": "        if lo > hi:\n            return -1\n        if k == 1:\n            return hi\n        if k == 2:\n            return hi - lo + 1\n        if k == 3:\n            return hi - lo\n        if k == 4:\n            return hi - lo + 1\n        if k == 5:\n            return hi - lo\n        if k == 6:\n            return hi - lo + 1\n        if k == 7:\n            return hi - lo + 1\n        if k == 8:\n            return hi - lo + 1\n        if k == 9:\n            return hi - lo + 1\n        if k == 10:\n            return hi - lo + 1\n        if k == 11:\n            return hi - lo + 1\n        if k == 12:\n            return hi - lo + 1\n        if k == 13:\n            return hi - lo + 1\n        if k == 14:\n            return hi - lo + 1\n        if k == 15:\n            return hi - lo + 1\n        if k == 16:\n            return hi - lo + 1\n        if k == 17:"
    },
    {
        "number": 1388,
        "title": "Pizza With 3n Slices",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + slices"
    },
    {
        "number": 1389,
        "title": "Create Target Array in the Given Order",
        "difficulty": 0,
        "answer": "        target = []\n        for i in range(len(nums)):\n            target.insert(index[i], nums[i])\n        return target"
    },
    {
        "number": 1390,
        "title": "Four Divisors",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # divisors = set()\n        # for num in nums:\n        #     for i in range(1, int(num**0.5)+1):\n        #         if num % i == 0:\n        #             divisors.add(i)\n        #             divisors.add(num//i)\n        # return sum(divisors)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        # divisors = set()\n        # for num in nums:\n        #     for i in range(1, int(num**0.5)+1):\n        #         if num % i == 0:\n        #             divisors.add(i)\n        #             divisors.add(num//i)\n        #             divisors.add(num//i)\n        #             divisors.add(i)\n        # return sum(divisors)\n        \n"
    },
    {
        "number": 1391,
        "title": "Check if There is a Valid Path in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        visited = set()\n        visited.add((0, 0))\n        \n        def dfs(i, j):\n            if (i, j) in visited:\n                return False\n            if i == m - 1 and j == n - 1:\n                return True\n            \n            visited.add((i, j))\n            \n            if grid[i][j] == 1:\n                if dfs(i + 1, j):\n                    return True\n                if dfs(i, j + 1):\n                    return True\n                if dfs(i - 1, j):\n                    return True\n                if dfs(i, j - 1):\n                    return True\n                return False\n            \n            if grid[i][j] == 2:\n                if dfs(i + 1, j):\n                    return True\n                if dfs(i, j + 1):\n                    return True\n                if dfs(i - 1, j):\n                    return True\n                if dfs(i, j - 1):\n                    "
    },
    {
        "number": 1392,
        "title": "Longest Happy Prefix",
        "difficulty": 2,
        "answer": "        if not s:\n            return \"\"\n        \n        # find the longest prefix\n        prefix = \"\"\n        for i in range(len(s)):\n            if s[:i+1] == s[:i+1][::-1]:\n                prefix = s[:i+1]\n                break\n        \n        # find the longest suffix\n        suffix = \"\"\n        for i in range(len(s)):\n            if s[i:] == s[i:][::-1]:\n                suffix = s[i:]\n                break\n        \n        return prefix + suffix"
    },
    {
        "number": 1394,
        "title": "Find Lucky Integer in an Array",
        "difficulty": 0,
        "answer": "        freq = {}\n        for i in arr:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n        max_freq = max(freq.values())\n        for i in freq:\n            if freq[i] == max_freq:\n                return i\n        return -1\n"
    },
    {
        "number": 1395,
        "title": "Count Number of Teams",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(rating)\n        # count = 0\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         for k in range(j+1, n):\n        #             if rating[i] < rating[j] < rating[k]:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 1396,
        "title": "Design Underground System",
        "difficulty": 1,
        "answer": "    def __init__(self):\n    def checkIn(self, id: int, stationName: str, t: int) -> None:\n    def checkOut(self, id: int, stationName: str, t: int) -> None:\n    def getAverageTime(self, startStation: str, endStation: str) -> float:\n        \"\"\"\n        An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.\n        Implement the UndergroundSystem class:\n            void checkIn(int id, string stationName, int t)\n                A customer with a card ID equal to id, checks in at the station stationName at time t.\n                A customer can only be checked into one place at a time.\n            void checkOut(int id, string stationName, int t)\n                A customer with a card ID equal to id, checks out from the station stationName at time t.\n                A customer can only be checked out from one place at a time.\n            double getAverageTime(string startStation, string endStation"
    },
    {
        "number": 1397,
        "title": "Find All Good Strings",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, n + 1):\n        #         if s1[i - 1] == s2[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[n][n]"
    },
    {
        "number": 1399,
        "title": "Count Largest Group",
        "difficulty": 0,
        "answer": "        # dp = {}\n        # for i in range(1, n + 1):\n        #     s = 0\n        #     for j in str(i):\n        #         s += int(j)\n        #     if s not in dp:\n        #         dp[s] = 1\n        #     else:\n        #         dp[s] += 1\n        #\n        # max_size = 0\n        # for k, v in dp.items():\n        #     if v > max_size:\n        #         max_size = v\n        #\n        # return max_size"
    },
    {
        "number": 1400,
        "title": "Construct K Palindrome Strings",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return True\n        if k == 1:\n            return len(s) == 1\n        if k == 2:\n            return len(s) == 2 and s[0] == s[1]\n        if k == 3:\n            return len(s) == 3 and s[0] == s[1] and s[1] == s[2]\n        if k == 4:\n            return len(s) == 4 and s[0] == s[1] and s[1] == s[2] and s[2] == s[3]\n        if k == 5:\n            return len(s) == 5 and s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]\n        if k == 6:\n            return len(s) == 6 and s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4"
    },
    {
        "number": 1401,
        "title": "Circle and Rectangle Overlapping",
        "difficulty": 1,
        "answer": "        if x1 <= xCenter + radius and x2 >= xCenter - radius and y1 <= yCenter + radius and y2 >= yCenter - radius:\n            return True\n        return False"
    },
    {
        "number": 1402,
        "title": "Reducing Dishes",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(satisfaction)\n        # if n == 0:\n        #     return 0\n        # satisfaction.sort()\n        # max_satisfaction = 0\n        # for i in range(n):\n        #     max_satisfaction += satisfaction[i] * (n - i)\n        # return max_satisfaction"
    },
    {
        "number": 1403,
        "title": "Minimum Subsequence in Non-Increasing Order",
        "difficulty": 0,
        "answer": "        \n        # O(n) time | O(n) space\n        nums.sort(reverse=True)\n        total = 0\n        for i in range(len(nums)):\n            total += nums[i]\n            if total < i:\n                break\n        return nums[:i]\n        \n        \n        # O(n) time | O(n) space\n        # nums.sort(reverse=True)\n        # total = 0\n        # for i in range(len(nums)):\n        #     total += nums[i]\n        #     if total < i:\n        #         break\n        # return nums[:i]\n        \n        \n        # O(n) time | O(1) space\n        # nums.sort(reverse=True)\n        # total = 0\n        # for i in range(len(nums)):\n        #     total += nums[i]\n        #     if total < i:\n        #         return nums[:i]\n        # return nums\n        \n        \n        "
    },
    {
        "number": 1404,
        "title": "Number of Steps to Reduce a Number in Binary Representation to One",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        count = 0\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == '1':\n                count += 1\n            else:\n                count += 2\n            if count % 2 == 0:\n                count //= 2\n            else:\n                count += 1\n        return count"
    },
    {
        "number": 1405,
        "title": "Longest Happy String",
        "difficulty": 1,
        "answer": "        if a == 0 and b == 0 and c == 0:\n            return \"\"\n        if a == 0:\n            return \"a\" * c\n        if b == 0:\n            return \"b\" * c\n        if c == 0:\n            return \"c\" * a\n        \n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        # a = 1, b = 1, c = 7\n        #"
    },
    {
        "number": 1406,
        "title": "Stone Game III",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[0] * 3 for _ in range(n)]\n        dp[0][0] = stoneValue[0]\n        dp[0][1] = stoneValue[0]\n        dp[0][2] = stoneValue[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + stoneValue[i]\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + stoneValue[i]\n            dp[i][2] = max(dp[i - 1][0], dp[i - 1][1]) + stoneValue[i]\n        return \"Alice\" if dp[n - 1][0] > dp[n - 1][1] else \"Bob\" if dp[n - 1][0] < dp[n - 1][1] else \"Tie\"\n"
    },
    {
        "number": 1408,
        "title": "String Matching in an Array",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 2:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        #"
    },
    {
        "number": 1409,
        "title": "Queries on a Permutation With Key",
        "difficulty": 1,
        "answer": "        # Time: O(n)\r\n        # Space: O(1)\r\n        # result = []\r\n        # for i in range(len(queries)):\r\n        #     result.append(self.processQuery(queries[i], m))\r\n        # return result\r\n\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # result = []\r\n        # for i in range(len(queries)):\r\n        #     result.append(self.processQuery(queries[i], m))\r\n        # return result\r\n\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # result = []\r\n        # for i in range(len(queries)):\r\n        #     result.append(self.processQuery(queries[i], m))\r\n        # return result\r\n\r\n        # Time: O(n)\r\n        # Space: O(1)\r\n        # result = []\r\n        # for i in range(len(qu"
    },
    {
        "number": 1410,
        "title": "HTML Entity Parser",
        "difficulty": 1,
        "answer": "        text = text.replace('&quot;', '\"')\n        text = text.replace('&apos;', \"'\")\n        text = text.replace('&amp;', '&')\n        text = text.replace('&gt;', '>')\n        text = text.replace('&lt;', '<')\n        text = text.replace('&frasl;', '/')\n        return text"
    },
    {
        "number": 1411,
        "title": "Number of Ways to Paint N \u00d7 3 Grid",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * 3 for _ in range(n + 1)]\n        dp[1] = [1, 1, 1]\n        for i in range(2, n + 1):\n            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD\n            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD\n        return sum(dp[n]) % MOD"
    },
    {
        "number": 1413,
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # startValue = 1\n        # for i in range(len(nums)):\n        #     startValue += nums[i]\n        #     if startValue < 1:\n        #         startValue = 1\n        # return startValue\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # startValue = 1\n        # for i in range(len(nums)):\n        #     startValue += nums[i]\n        #     if startValue < 1:\n        #         startValue = 1\n        # return startValue\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(1)\n        # startValue = 1\n        # for i in range(len(nums)):\n        #     startValue += nums[i]\n        #     if startValue < 1:\n        #         startValue = 1\n        # return startValue\n        "
    },
    {
        "number": 1414,
        "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return 0\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n        if k == 3:\n            return 3\n        if k == 4:\n            return 4\n        if k == 5:\n            return 5\n        if k == 6:\n            return 6\n        if k == 7:\n            return 7\n        if k == 8:\n            return 8\n        if k == 9:\n            return 9\n        if k == 10:\n            return 10\n        if k == 11:\n            return 11\n        if k == 12:\n            return 12\n        if k == 13:\n            return 13\n        if k == 14:\n            return 14\n        if k == 15:\n            return 15\n        if k == 16:\n            return 16\n        if k == 17:\n            return 17\n        if k == 18:\n            return 18\n        if k == 19:\n            return 19\n        if k == 20:\n            return 20\n        if k == 21:\n            return 21\n        if k == 22:\n            "
    },
    {
        "number": 1415,
        "title": "The k-th Lexicographical String of All Happy Strings of Length n",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 'a'\n        if n == 2:\n            return 'ab'\n        if n == 3:\n            return 'abc'\n        if n == 4:\n            return 'acb'\n        if n == 5:\n            return 'bab'\n        if n == 6:\n            return 'bac'\n        if n == 7:\n            return 'bca'\n        if n == 8:\n            return 'bcb'\n        if n == 9:\n            return 'cab'\n        if n == 10:\n            return 'cac'\n        if n == 11:\n            return 'cba'\n        if n == 12:\n            return 'cbc'\n        if n == 13:\n            return 'acb'\n        if n == 14:\n            return 'bca'\n        if n == 15:\n            return 'bac'\n        if n == 16:\n            return 'bcb'\n        if n == 17:\n            return 'cab'\n        if n == 18:\n            return 'cbc'\n        "
    },
    {
        "number": 1416,
        "title": "Restore The Array",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(s)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1 if int(s) <= k else 0\n        # if n == 2:\n        #     return 1 if int(s) <= k else 0\n        # if n == 3:\n        #     return 1 if int(s) <= k else 0\n        # if n == 4:\n        #     return 1 if int(s) <= k else 0\n        # if n == 5:\n        #     return 1 if int(s) <= k else 0\n        # if n == 6:\n        #     return 1 if int(s) <= k else 0\n        # if n == 7:\n        #     return 1 if int(s) <= k else 0\n        # if n == 8:\n        #     return 1 if int(s) <= k else 0\n        # if n == 9:\n        #     return 1 if int(s) <= k"
    },
    {
        "number": 1417,
        "title": "Reformat The String",
        "difficulty": 0,
        "answer": "        if not s:\n            return s\n        \n        # split string into list of chars\n        s = list(s)\n        \n        # sort chars by type\n        s.sort(key=lambda x: x.isdigit() or x.isalpha())\n        \n        # sort chars by type\n        s.sort(key=lambda x: x.isdigit() or x.isalpha())\n        \n        # convert to string\n        s = ''.join(s)\n        \n        return s"
    },
    {
        "number": 1418,
        "title": "Display Table of Food Orders in a Restaurant",
        "difficulty": 1,
        "answer": "        foods = {}\n        for order in orders:\n            foods[order[2]] = foods.get(order[2], 0) + 1\n        foods = sorted(foods.items(), key=lambda x: x[0])\n        foods = sorted(foods, key=lambda x: x[1], reverse=True)\n        table = []\n        for i in range(1, len(foods) + 1):\n            table.append([str(i), str(foods[i - 1][1])])\n        table.insert(0, [\"Table\"] + list(map(lambda x: x[0], foods)))\n        return table"
    },
    {
        "number": 1419,
        "title": "Minimum Number of Frogs Croaking",
        "difficulty": 1,
        "answer": "        frogs = set()\n        for c in croakOfFrogs:\n            if c == 'c':\n                frogs.add('c')\n            elif c == 'r':\n                frogs.add('r')\n            elif c == 'o':\n                frogs.add('o')\n            elif c == 'a':\n                frogs.add('a')\n            elif c == 'k':\n                frogs.add('k')\n            else:\n                return -1\n        return len(frogs)"
    },
    {
        "number": 1420,
        "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j < m:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - m]) % MOD\n        return dp[n][k]"
    },
    {
        "number": 1422,
        "title": "Maximum Score After Splitting a String",
        "difficulty": 0,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        \n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = int(s[i] == '1')\n        \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + int(s[i] == '1')\n        \n        return dp[0][n - 1]"
    },
    {
        "number": 1423,
        "title": "Maximum Points You Can Obtain from Cards",
        "difficulty": 1,
        "answer": "        n = len(cardPoints)\n        if k >= n:\n            return sum(cardPoints)\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cardPoints[i]\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 0\n            dp[i][1] = cardPoints[i]\n        \n        for i in range(1, n):\n            for j in range(1, k + 1):\n                if j == 1:\n                    dp[i][j] = dp[i - 1][j] + cardPoints[i]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cardPoints[i]\n        \n        return dp[n - 1][k]"
    },
    {
        "number": 1424,
        "title": "Diagonal Traverse II",
        "difficulty": 1,
        "answer": "        \n        if not nums:\n            return []\n        \n        m, n = len(nums), len(nums[0])\n        \n        res = []\n        \n        for i in range(m):\n            for j in range(n):\n                if i + j < m + n - 1:\n                    res.append(nums[i][j])\n        \n        return res\n"
    },
    {
        "number": 1425,
        "title": "Constrained Subsequence Sum",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n        return dp[n][k]"
    },
    {
        "number": 1431,
        "title": "Kids With the Greatest Number of Candies",
        "difficulty": 0,
        "answer": "        max_candy = max(candies)\n        return [candy + extraCandies >= max_candy for candy in candies]\n"
    },
    {
        "number": 1432,
        "title": "Max Difference You Can Get From Changing an Integer",
        "difficulty": 1,
        "answer": "        if num == 0:\n            return 0\n        if num < 10:\n            return num\n        a = self.maxDiff(num // 10)\n        b = self.maxDiff(num % 10)\n        return max(a, b) + 1"
    },
    {
        "number": 1433,
        "title": "Check If a String Can Break Another String",
        "difficulty": 1,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        \n        s1_dict = {}\n        s2_dict = {}\n        \n        for i in range(len(s1)):\n            if s1[i] in s1_dict:\n                s1_dict[s1[i]] += 1\n            else:\n                s1_dict[s1[i]] = 1\n            \n            if s2[i] in s2_dict:\n                s2_dict[s2[i]] += 1\n            else:\n                s2_dict[s2[i]] = 1\n        \n        for i in range(len(s1)):\n            if s1[i] in s1_dict and s1_dict[s1[i]] > 0:\n                s1_dict[s1[i]] -= 1\n            if s2[i] in s2_dict and s2_dict[s2[i]] > 0:\n                s2_dict[s2[i]] -= 1\n            if s1_dict[s"
    },
    {
        "number": 1434,
        "title": "Number of Ways to Wear Different Hats to Each Other",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] +... + dp[i-1][j-n]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] +... + dp[i-1][j-n]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] +... + dp[i-1][j-n]\n        # dp[i][j"
    },
    {
        "number": 1436,
        "title": "Destination City",
        "difficulty": 0,
        "answer": "        d = {}\n        for path in paths:\n            d[path[0]] = path[1]\n        for path in paths:\n            if path[1] not in d:\n                return path[1]\n"
    },
    {
        "number": 1437,
        "title": "Check If All 1\"s Are at Least Length K Places Away",
        "difficulty": 0,
        "answer": "        if len(nums) < k:\n            return False\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                if i < k:\n                    return False\n                else:\n                    return True\n        return False"
    },
    {
        "number": 1438,
        "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        # n = len(nums)\n        # dp = [[0, 0] for _ in range(n)]\n        # dp[0][0] = 1\n        # dp[0][1] = 1\n        # for i in range(1, n):\n        #     if nums[i] - nums[i - 1] <= limit:\n        #         dp[i][0] = dp[i - 1][0] + 1\n        #         dp[i][1] = dp[i - 1][1]\n        #     else:\n        #         dp[i][0] = dp[i - 1][0]\n        #         dp[i][1] = dp[i - 1][1] + 1\n        # return max(max(dp[i][0], dp[i][1]) for i in range(n))"
    },
    {
        "number": 1439,
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "difficulty": 2,
        "answer": "        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n)\n        # O(m*n"
    },
    {
        "number": 1441,
        "title": "Build an Array With Stack Operations",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # stack = []\n        # for i in range(n):\n        #     while stack and stack[-1]!= target[i]:\n        #         stack.pop()\n        #     if stack:\n        #         stack.append(target[i])\n        #     else:\n        #         stack.append(target[i])\n        # return stack"
    },
    {
        "number": 1442,
        "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(arr)):\n        #     for j in range(i + 1, len(arr)):\n        #         for k in range(j + 1, len(arr)):\n        #             if (arr[i] ^ arr[j]) == (arr[k] ^ arr[k]):\n        #                 if (i, j, k) not in dp:\n        #                     dp[(i, j, k)] = 1\n        #                 else:\n        #                     dp[(i, j, k)] += 1\n        # return sum(dp.values())"
    },
    {
        "number": 1443,
        "title": "Minimum Time to Collect All Apples in a Tree",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[float('inf')] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 0\n        # for i, j in edges:\n        #     dp[i][j] = 1\n        # for i in range(n):\n        #     for j in range(n):\n        #         for k in range(n):\n        #             dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # return max(0, dp[0][i] for i in range(n))"
    },
    {
        "number": 1444,
        "title": "Number of Ways of Cutting a Pizza",
        "difficulty": 2,
        "answer": "        m, n = len(pizza), len(pizza[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if pizza[i - 1][j - 1] == 'A':\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n] % (10**9 + 7)\n"
    },
    {
        "number": 1446,
        "title": "Consecutive Characters",
        "difficulty": 0,
        "answer": "        if len(s) == 0:\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            if s[0] == s[1]:\n                return 2\n            else:\n                return 1\n        if len(s) == 3:\n            if s[0] == s[1] and s[1] == s[2]:\n                return 3\n            else:\n                return 2\n        if len(s) == 4:\n            if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n                return 4\n            else:\n                return 3\n        if len(s) == 5:\n            if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]:\n                return 5\n            else:\n                return 4\n        if len(s) == 6:\n            if s[0] == s[1] and s[1]"
    },
    {
        "number": 1447,
        "title": "Simplified Fractions",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i >= j:\n                    continue\n                if i % j == 0:\n                    res.append(str(i) + \"/\" + str(j))\n        return res"
    },
    {
        "number": 1448,
        "title": "Count Good Nodes in Binary Tree",
        "difficulty": 1,
        "answer": "        if not root: return 0\n        self.res = 0\n        self.dfs(root, float('-inf'), float('inf'))\n        return self.res"
    },
    {
        "number": 1449,
        "title": "Form Largest Integer With Digits That Add up to Target",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(N)\n        # Space: O(1)\n        # if not cost:\n        #     return \"0\"\n        # res = \"\"\n        # for i in range(len(cost)):\n        #     if target - cost[i] >= 0:\n        #         target -= cost[i]\n        #         res += str(i + 1)\n        #     else:\n        #         break\n        # return res if res else \"0\""
    },
    {
        "number": 1450,
        "title": "Number of Students Doing Homework at a Given Time",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(startTime)):\n            if startTime[i] <= queryTime <= endTime[i]:\n                count += 1\n        return count"
    },
    {
        "number": 1451,
        "title": "Rearrange Words in a Sentence",
        "difficulty": 1,
        "answer": "        words = text.split()\n        words = sorted(words, key=lambda x: len(x))\n        res = []\n        for word in words:\n            res.append(word[0].upper() + word[1:])\n        return \" \".join(res)"
    },
    {
        "number": 1452,
        "title": "People Whose List of Favorite Companies Is Not a Subset of Another List",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = {}\n        # for i in range(len(favoriteCompanies)):\n        #     for j in range(len(favoriteCompanies)):\n        #         if i!= j:\n        #             if set(favoriteCompanies[i]) <= set(favoriteCompanies[j]):\n        #                 if i not in dp:\n        #                     dp[i] = []\n        #                 dp[i].append(j)\n        # return list(map(lambda x: x[0], sorted(dp.items(), key=lambda x: x[1])))"
    },
    {
        "number": 1453,
        "title": "Maximum Number of Darts Inside of a Circular Dartboard",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # dp = [[0] * (r + 1) for _ in range(len(darts) + 1)]\n        # for i in range(1, len(darts) + 1):\n        #     for j in range(1, r + 1):\n        #         x, y = darts[i - 1]\n        #         if x - j >= 0:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n        #         if x + j <= 10:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n        #         if y - j >= 0:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n        #         if y + j <= 10:\n        #             dp[i][j] = max(dp[i][j], dp"
    },
    {
        "number": 1455,
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "difficulty": 0,
        "answer": "        if not sentence:\n            return -1\n        \n        for i in range(len(sentence)):\n            if sentence[i:].startswith(searchWord):\n                return i + 1\n        return -1"
    },
    {
        "number": 1456,
        "title": "Maximum Number of Vowels in a Substring of Given Length",
        "difficulty": 1,
        "answer": "        vowels = set('aeiou')\n        vowel_count = 0\n        max_vowel_count = 0\n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowel_count += 1\n                if vowel_count == k:\n                    max_vowel_count = max(max_vowel_count, vowel_count)\n            else:\n                vowel_count = 0\n        return max_vowel_count"
    },
    {
        "number": 1457,
        "title": "Pseudo-Palindromic Paths in a Binary Tree",
        "difficulty": 1,
        "answer": "        self.res = 0\n        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                if path == path[::-1]:\n                    self.res += 1\n            if node.left:\n                dfs(node.left, path + str(node.left.val))\n            if node.right:\n                dfs(node.right, path + str(node.right.val))\n        dfs(root, '')\n        return self.res"
    },
    {
        "number": 1458,
        "title": "Max Dot Product of Two Subsequences",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 == 0 or n2 == 0:\n            return 0\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1])\n        return dp[-1][-1]"
    },
    {
        "number": 1460,
        "title": "Make Two Arrays Equal by Reversing Subarrays",
        "difficulty": 0,
        "answer": "        if len(target)!= len(arr):\n            return False\n        \n        target_set = set(target)\n        arr_set = set(arr)\n        \n        if target_set == arr_set:\n            return True\n        \n        for i in range(len(target)):\n            if target[i] in arr_set:\n                arr_set.remove(target[i])\n            else:\n                return False\n        \n        return True"
    },
    {
        "number": 1461,
        "title": "Check If a String Contains All Binary Codes of Size K",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return True\n        if k == 1:\n            return len(s) == 1\n        \n        # if k == 2:\n        #     return len(s) == 2\n        \n        # if k == 3:\n        #     return len(s) == 3\n        \n        # if k == 4:\n        #     return len(s) == 4\n        \n        # if k == 5:\n        #     return len(s) == 5\n        \n        # if k == 6:\n        #     return len(s) == 6\n        \n        # if k == 7:\n        #     return len(s) == 7\n        \n        # if k == 8:\n        #     return len(s) == 8\n        \n        # if k == 9:\n        #     return len(s) == 9\n        \n        # if k == 10:\n        #     return len(s) == 10\n        \n        # if k == 11:\n        #     return len(s) == 11\n        \n        # if k == 12:\n        #     "
    },
    {
        "number": 1462,
        "title": "Course Schedule IV",
        "difficulty": 1,
        "answer": "        graph = [[] for _ in range(numCourses)]\n        indegrees = [0 for _ in range(numCourses)]\n        for course, pre in prerequisites:\n            graph[pre].append(course)\n            indegrees[course] += 1\n        \n        def dfs(course):\n            if indegrees[course] == 0:\n                return True\n            for pre in graph[course]:\n                indegrees[pre] -= 1\n                if not dfs(pre):\n                    return False\n            return True\n        \n        ans = []\n        for course, pre in queries:\n            if not dfs(course):\n                ans.append(False)\n            else:\n                ans.append(True)\n        return ans"
    },
    {
        "number": 1463,
        "title": "Cherry Pickup II",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]"
    },
    {
        "number": 1464,
        "title": "Maximum Product of Two Elements in an Array",
        "difficulty": 0,
        "answer": "        \n        # max_product = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         max_product = max(max_product, nums[i]*nums[j])\n        # return max_product\n        \n        \n        # max_product = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         max_product = max(max_product, nums[i]*nums[j])\n        # return max_product\n        \n        \n        # max_product = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         max_product = max(max_product, nums[i]*nums[j])\n        # return max_product\n        \n        \n        # max_product = 0\n        # for i in range(len("
    },
    {
        "number": 1465,
        "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
        "difficulty": 1,
        "answer": "        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        horizontalCuts.append(h)\n        verticalCuts.append(w)\n        horizontalCuts.sort()\n        "
    },
    {
        "number": 1466,
        "title": "Reorder Routes to Make All Paths Lead to the City Zero",
        "difficulty": 1,
        "answer": "        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O("
    },
    {
        "number": 1467,
        "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if len(balls) == 1:\n        #     return 1\n        # if len(balls) == 2:\n        #     return 1 if balls[0] == balls[1] else 0\n        # if len(balls) == 3:\n        #     return 1 if balls[0] == balls[1] == balls[2] else 0\n        # if len(balls) == 4:\n        #     return 1 if balls[0] == balls[1] == balls[2] == balls[3] else 0\n        # if len(balls) == 5:\n        #     return 1 if balls[0] == balls[1] == balls[2] == balls[3] == balls[4] else 0\n        # if len(balls) == 6:\n        #     return 1 if balls[0] == balls[1] == balls[2] == balls[3] == balls[4] == balls[5] else 0\n        # if len(balls) == 7:\n        #     "
    },
    {
        "number": 1470,
        "title": "Shuffle the Array",
        "difficulty": 0,
        "answer": "        # Solution 1: Using extra space\n        # Time: O(n)\n        # Space: O(n)\n        # res = []\n        # for i in range(n):\n        #     res.append(nums[i])\n        #     res.append(nums[n + i])\n        # return res"
    },
    {
        "number": 1471,
        "title": "The k Strongest Values in an Array",
        "difficulty": 1,
        "answer": "        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # median = arr[(len(arr)-1)//2]\n        # print(median)\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr[:k]\n        # arr.sort()\n        # print(arr)\n        # return arr"
    },
    {
        "number": 1472,
        "title": "Design Browser History",
        "difficulty": 1,
        "answer": "\nclass BrowserHistory:\n    def __init__(self, homepage: str):\n    def visit(self, url: str) -> None:\n    def back(self, steps: int) -> str:\n    def forward(self, steps: int) -> str:\n        \"\"\"\n        You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\n        Implement the BrowserHistory class:\n            BrowserHistory(string homepage) Initializes the object with the homepage of the browser.\n            void visit(string url) Visits url from the current page. It clears up all the forward history.\n            string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.\n            string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most"
    },
    {
        "number": 1473,
        "title": "Paint House III",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min cost to paint houses[i:i+j]\n        # dp[i][j] = min(dp[i][j], dp[i+1][j-1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i+1][j] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] + cost[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] + cost[i][j])\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 1475,
        "title": "Final Prices With a Special Discount in a Shop",
        "difficulty": 0,
        "answer": "        prices = sorted(prices)\n        res = []\n        for i in range(len(prices)):\n            if i == 0:\n                res.append(prices[i])\n            else:\n                if prices[i] <= prices[i-1]:\n                    res.append(prices[i] - prices[i-1])\n                else:\n                    res.append(prices[i])\n        return res"
    },
    {
        "number": 1476,
        "title": "Subrectangle Queries",
        "difficulty": 1,
        "answer": "    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:\n        \"\"\"\n        Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:\n        1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n            Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).\n        2. getValue(int row, int col)\n            Returns the current value of the coordinate (row,col) from the rectangle.\n        Example 1:\n        Input\n        [\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]\n        [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3"
    },
    {
        "number": 1477,
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(arr)):\n        #     if target - arr[i] in dp:\n        #         return min(dp[target - arr[i]], i + 1)\n        #     dp[arr[i]] = i + 1\n        # return -1"
    },
    {
        "number": 1478,
        "title": "Allocate Mailboxes",
        "difficulty": 2,
        "answer": "        # Time: O(nk)\n        # Space: O(nk)\n        # dp = [[float('inf')] * (k + 1) for _ in range(len(houses) + 1)]\n        # dp[0][0] = 0\n        # for i in range(1, len(houses) + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + abs(houses[i - 1] - houses[i - 1 - j])\n        # return dp[-1][-1]"
    },
    {
        "number": 1480,
        "title": "Running Sum of 1d Array",
        "difficulty": 0,
        "answer": "        if not nums:\r\n            return []\r\n        \r\n        running_sum = []\r\n        running_sum.append(nums[0])\r\n        for i in range(1, len(nums)):\r\n            running_sum.append(running_sum[i-1] + nums[i])\r\n        return running_sum\r\n\r\n\r\nclass Solution:\r\n    def runningSum(self, nums: List[int]) -> List[int]:\r\n        \"\"\"\r\n        Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]\u2026nums[i]).\r\n        Return the running sum of nums.\r\n        Example 1:\r\n        Input: nums = [1,2,3,4]\r\n        Output: [1,3,6,10]\r\n        Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\r\n        Example 2:\r\n        Input: nums ="
    },
    {
        "number": 1481,
        "title": "Least Number of Unique Integers after K Removals",
        "difficulty": 1,
        "answer": "        # O(n) time | O(n) space\r\n        # count = {}\r\n        # for num in arr:\r\n        #     if num not in count:\r\n        #         count[num] = 1\r\n        #     else:\r\n        #         count[num] += 1\r\n        # return min(len(arr) - k, max(count.values()))\r\n        \r\n        # O(n) time | O(n) space\r\n        # count = {}\r\n        # for num in arr:\r\n        #     if num not in count:\r\n        #         count[num] = 1\r\n        #     else:\r\n        #         count[num] += 1\r\n        # return min(len(arr) - k, max(count.values()))\r\n        \r\n        # O(n) time | O(n) space\r\n        # count = {}\r\n        # for num in arr:\r\n        #     if num not in count:\r\n        #         count[num] = 1\r\n        #     else:\r\n"
    },
    {
        "number": 1482,
        "title": "Minimum Number of Days to Make m Bouquets",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not bloomDay:\n        #     return 0\n        # n = len(bloomDay)\n        # dp = [[0] * (k + 1) for _ in range(m + 1)]\n        # for i in range(1, n + 1):\n        #     dp[0][0] = 1\n        #     for j in range(1, k + 1):\n        #         dp[0][j] = 0\n        #     for j in range(1, k + 1):\n        #         for i in range(1, m + 1):\n        #             dp[i][j] = dp[i - 1][j]\n        #             if j - 1 >= 0:\n        #                 dp[i][j] += dp[i][j - 1]\n        #             if i - 1 >= 0:\n        #                 dp[i][j] += dp[i - 1][j]\n        #             if i - 2 >= 0:\n        #                 dp[i]["
    },
    {
        "number": 1483,
        "title": "Kth Ancestor of a Tree Node",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if k == 0:\n        #     return -1\n        # if k == 1:\n        #     return node\n        # parent = self.getParent(node, parent)\n        # return self.getKthAncestor(parent, k - 1)"
    },
    {
        "number": 1486,
        "title": "XOR Operation in an Array",
        "difficulty": 0,
        "answer": "        nums = [start + 2 * i for i in range(n)]\n        return reduce(lambda x, y: x ^ y, nums)"
    },
    {
        "number": 1487,
        "title": "Making File Names Unique",
        "difficulty": 1,
        "answer": "        # d = {}\n        # for name in names:\n        #     if name not in d:\n        #         d[name] = 1\n        #     else:\n        #         d[name] += 1\n        # ans = []\n        # for name in names:\n        #     if name not in d:\n        #         ans.append(name)\n        #     else:\n        #         ans.append(name + str(d[name]))\n        #         d[name] += 1\n        # return ans\n        \n        # d = {}\n        # for name in names:\n        #     if name not in d:\n        #         d[name] = 1\n        #     else:\n        #         d[name] += 1\n        # ans = []\n        # for name in names:\n        #     if name not in d:\n        #         ans.append(name)\n        #     else:\n        #         ans.append(name + str(d[name]))\n        #         d[name] += 1\n        # return ans\n        \n        #"
    },
    {
        "number": 1488,
        "title": "Avoid Flood in The City",
        "difficulty": 1,
        "answer": "        \n        # dp = {}\n        # for i in range(len(rains)):\n        #     if rains[i] == 0:\n        #         if rains[i] in dp:\n        #             dp[rains[i]] += 1\n        #         else:\n        #             dp[rains[i]] = 1\n        #     else:\n        #         if rains[i] in dp:\n        #             dp[rains[i]] -= 1\n        #         else:\n        #             dp[rains[i]] = -1\n        #         if dp[rains[i]] == 0:\n        #             return []\n        #         else:\n        #             return [i]\n        \n        # dp = {}\n        # for i in range(len(rains)):\n        #     if rains[i] == 0:\n        #         if rains[i] in dp:\n        #             dp[rains[i]] += 1\n        #         else:\n        #             dp[rains[i]] = 1\n        #"
    },
    {
        "number": 1489,
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "difficulty": 2,
        "answer": "        # Time: O(ElogE)\n        # Space: O(E)\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + bfs\n        # dfs + b"
    },
    {
        "number": 1491,
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "difficulty": 0,
        "answer": "        return sum(salary) / len(salary) - min(salary) - max(salary)"
    },
    {
        "number": 1492,
        "title": "The kth Factor of n",
        "difficulty": 1,
        "answer": "        if n <= 1:\n            return -1\n        if k == 1:\n            return n\n        if k == 2:\n            return n if n % 2 == 0 else -1\n        if k == 3:\n            return n if n % 3 == 0 else -1\n        if k == 4:\n            return n if n % 4 == 0 else -1\n        if k == 5:\n            return n if n % 5 == 0 else -1\n        if k == 6:\n            return n if n % 6 == 0 else -1\n        if k == 7:\n            return n if n % 7 == 0 else -1\n        if k == 8:\n            return n if n % 8 == 0 else -1\n        if k == 9:\n            return n if n % 9 == 0 else -1\n        if k == 10:\n            return n if n % 10 == 0 else -1\n        if k == 11:\n            return n if n % 11 == 0 else -1\n        if k == 12:\n            return n if n % 12 == 0 else -1\n        if k == 13:\n"
    },
    {
        "number": 1493,
        "title": "Longest Subarray of 1\"s After Deleting One Element",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # length = len(nums)\n        # max_length = 0\n        # for i in range(length):\n        #     if nums[i] == 1:\n        #         max_length = max(max_length, self.longestSubarray(nums[i+1:]))\n        #     else:\n        #         max_length = max(max_length, 0)\n        # return max_length + 1 if max_length > 0 else 0"
    },
    {
        "number": 1494,
        "title": "Parallel Courses II",
        "difficulty": 2,
        "answer": "        from collections import defaultdict\n        from collections import deque\n        from collections import Counter\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import OrderedDict\n        from collections import deque\n        from collections import defaultdict\n        from collections import namedtuple\n        from collections import Ord"
    },
    {
        "number": 1496,
        "title": "Path Crossing",
        "difficulty": 0,
        "answer": "        visited = set()\n        x, y = 0, 0\n        for i in path:\n            if i == 'N':\n                y += 1\n            elif i == 'S':\n                y -= 1\n            elif i == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False"
    },
    {
        "number": 1497,
        "title": "Check If Array Pairs Are Divisible by k",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1498,
        "title": "Number of Subsequences That Satisfy the Given Sum Condition",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (target + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, target + 1):\n        #         if j < nums[i - 1]:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]\n        # return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 1499,
        "title": "Max Value of Equation",
        "difficulty": 2,
        "answer": "        points.sort(key=lambda x: x[0])\n        i = 0\n        j = len(points) - 1\n        max_val = float('-inf')\n        while i < j:\n            if abs(points[i][0] - points[j][0]) <= k:\n                max_val = max(max_val, points[i][1] + points[j][1] + abs(points[i][0] - points[j][0]))\n                i += 1\n            else:\n                j -= 1\n        return max_val"
    },
    {
        "number": 1502,
        "title": "Can Make Arithmetic Progression From Sequence",
        "difficulty": 0,
        "answer": "        if len(arr) < 3:\n            return False\n        arr.sort()\n        diff = arr[1] - arr[0]\n        for i in range(1, len(arr) - 1):\n            if arr[i + 1] - arr[i]!= diff:\n                return False\n        return True\n"
    },
    {
        "number": 1503,
        "title": "Last Moment Before All Ants Fall Out of a Plank",
        "difficulty": 1,
        "answer": "        \n        # Time O(n) | Space O(1)\n        # if not left:\n        #     return 0\n        # if not right:\n        #     return n\n        \n        # left_time = 0\n        # right_time = 0\n        # for i in range(len(left)):\n        #     left_time += left[i]\n        # for i in range(len(right)):\n        #     right_time += right[i]\n        # return max(left_time, right_time)\n        \n        # Time O(n) | Space O(1)\n        # if not left:\n        #     return 0\n        # if not right:\n        #     return n\n        \n        # left_time = 0\n        # right_time = 0\n        # for i in range(len(left)):\n        #     left_time += left[i]\n        # for i in range(len(right)):\n        #     right_time += right[i]\n        # return max(left_time, right_time)\n        \n"
    },
    {
        "number": 1504,
        "title": "Count Submatrices With All Ones",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        \n        # dp[i][j] = number of submatrices with all ones in the i-th row and j-th column\n        dp = [[0] * n for _ in range(m)]\n        \n        # dp[i][j] = number of submatrices with all ones in the i-th row and j-th column\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return sum(dp)"
    },
    {
        "number": 1505,
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "difficulty": 2,
        "answer": "        # num = \"4321\"\n        # k = 4\n        # num = \"100\"\n        # k = 1\n        # num = \"36789\"\n        # k = 1000\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        # k = 1\n        # num = \"1234\"\n        #"
    },
    {
        "number": 1507,
        "title": "Reformat Date",
        "difficulty": 0,
        "answer": "        date = date.split()\n        date = date[2] + \"-\" + date[1] + \"-\" + date[0]\n        return date"
    },
    {
        "number": 1508,
        "title": "Range Sum of Sorted Subarray Sums",
        "difficulty": 1,
        "answer": "        # if left == right:\n        #     return nums[left - 1]\n        # if left > right:\n        #     return 0\n        # if left == right:\n        #     return nums[left - 1]\n        # if left == right - 1:\n        #     return nums[left - 1] + nums[right - 1]\n        # if left == right - 2:\n        #     return nums[left - 1] + nums[right - 1] + nums[right]\n        # if left == right - 3:\n        #     return nums[left - 1] + nums[right - 1] + nums[right] + nums[right + 1]\n        # if left == right - 4:\n        #     return nums[left - 1] + nums[right - 1] + nums[right] + nums[right + 1] + nums[right + 2]\n        # if left == right - 5:\n        #     return nums[left - 1] + nums[right - 1] + nums[right"
    },
    {
        "number": 1509,
        "title": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "difficulty": 1,
        "answer": "        nums.sort()\n        diff = float('inf')\n        for i in range(3):\n            diff = min(diff, nums[-1] - nums[0])\n            nums[0], nums[-1] = nums[-1], nums[0]\n        return diff"
    },
    {
        "number": 1510,
        "title": "Stone Game IV",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return True\n        if n == 2:\n            return False\n        if n == 3:\n            return True\n        if n == 4:\n            return False\n        \n        dp = [False] * (n + 1)\n        dp[1] = True\n        dp[2] = False\n        dp[3] = True\n        dp[4] = False\n        \n        for i in range(5, n + 1):\n            for j in range(1, i):\n                if dp[j] and dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[n]"
    },
    {
        "number": 1512,
        "title": "Number of Good Pairs",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    count += 1\n        return count"
    },
    {
        "number": 1513,
        "title": "Number of Substrings With Only 1s",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        count = 0\n        for i in range(1, len(s)):\n            if s[i] == '1':\n                count += (len(s)-i)\n        return count % (10**9 + 7)"
    },
    {
        "number": 1514,
        "title": "Path with Maximum Probability",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs(start, end, path, path_prob, visited)\n        # return max(path_prob)\n        # dfs("
    },
    {
        "number": 1515,
        "title": "Best Position for a Service Centre",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(1)\n        # if not positions:\n        #     return 0\n        # x_min, x_max = min(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[0])[0]\n        # y_min, y_max = min(positions, key=lambda x: x[1])[1], max(positions, key=lambda x: x[1])[1]\n        # return (x_max - x_min) * (y_max - y_min)"
    },
    {
        "number": 1518,
        "title": "Water Bottles",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # numBottles = 9\n        # numExchange = 3\n        # numBottles = 15\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n        # numExchange = 3\n        # numBottles = 19\n        # numExchange = 4\n        # numBottles = 13\n"
    },
    {
        "number": 1519,
        "title": "Number of Nodes in the Sub-Tree With the Same Label",
        "difficulty": 1,
        "answer": "        # graph = collections.defaultdict(list)\n        # for i, j in edges:\n        #     graph[i].append(j)\n        #     graph[j].append(i)\n        #\n        # def dfs(node, label):\n        #     if node not in graph:\n        #         return 1\n        #     if label not in graph[node]:\n        #         return 0\n        #     return sum(dfs(nei, label) for nei in graph[node]) + 1\n        #\n        # return [dfs(i, labels[i]) for i in range(n)]"
    },
    {
        "number": 1520,
        "title": "Maximum Number of Non-Overlapping Substrings",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         if s[i:j+1] in dp:\n        #             dp[s[i:j+1]] += 1\n        #         else:\n        #             dp[s[i:j+1]] = 1\n        # return max(dp.values(), default=0)"
    },
    {
        "number": 1521,
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "difficulty": 2,
        "answer": "        \n        def func(arr, l, r):\n            return abs(arr[l] - target) + abs(arr[r] - target)\n        \n        l, r = 0, len(arr) - 1\n        \n        while l < r:\n            mid = (l + r) // 2\n            if func(arr, mid, r) < func(arr, l, mid):\n                l = mid + 1\n            else:\n                r = mid\n        \n        return l"
    },
    {
        "number": 1523,
        "title": "Count Odd Numbers in an Interval Range",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(low, high + 1):\n            if i % 2!= 0:\n                count += 1\n        return count"
    },
    {
        "number": 1524,
        "title": "Number of Sub-arrays With Odd Sum",
        "difficulty": 1,
        "answer": "        # O(n) time, O(n) space\n        # dp = {}\n        # dp[0] = 1\n        # dp[1] = 1\n        # for i in range(2, len(arr) + 1):\n        #     dp[i] = dp[i - 1] + dp[i - 2]\n        # return dp[len(arr)] % (10 ** 9 + 7)"
    },
    {
        "number": 1525,
        "title": "Number of Good Ways to Split a String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return 0\n        # count = 0\n        # left = 0\n        # right = 0\n        # for i in range(len(s)):\n        #     if s[i] == s[i-1]:\n        #         left += 1\n        #     else:\n        #         right += 1\n        #         if left == right:\n        #             count += 1\n        #         left = right = 0\n        # return count"
    },
    {
        "number": 1526,
        "title": "Minimum Number of Increments on Subarrays to Form a Target Array",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1528,
        "title": "Shuffle String",
        "difficulty": 0,
        "answer": "        # s = \"codeleet\"\n        # indices = [4,5,6,7,0,2,1,3]\n        # s = \"abc\"\n        # indices = [0,1,2]\n        # s = \"aab\"\n        # indices = [0,1,2]\n        # s = \"leetcode\"\n        # indices = [4,5,6,7,0,2,1,3]\n        # s = \"abc\"\n        # indices = [0,1,2]\n        # s = \"aab\"\n        # indices = [0,1,2]\n        # s = \"leetcode\"\n        # indices = [4,5,6,7,0,2,1,3]\n        # s = \"abc\"\n        # indices = [0,1,2]\n        # s = \"aab\"\n        # indices = [0,1,2]\n        # s = \"leetcode\"\n        # indices = [4,5,6,7,0,2,1,3]"
    },
    {
        "number": 1529,
        "title": "Minimum Suffix Flips",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # dp = {}\n        # def helper(i):\n        #     if i == len(target):\n        #         return 0\n        #     if (i, target[i]) in dp:\n        #         return dp[(i, target[i])]\n        #     if target[i] == '0':\n        #         dp[(i, target[i])] = helper(i + 1)\n        #     else:\n        #         dp[(i, target[i])] = helper(i + 1) + 1\n        #     return dp[(i, target[i])]\n        # return helper(0)"
    },
    {
        "number": 1530,
        "title": "Number of Good Leaf Nodes Pairs",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        def dfs(node, distance):\n            if not node:\n                return 0\n            \n            if not node.left and not node.right:\n                return 1\n            \n            left = dfs(node.left, distance)\n            right = dfs(node.right, distance)\n            \n            return left + right\n        \n        return dfs(root, distance)"
    },
    {
        "number": 1531,
        "title": "String Compression II",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dp:\n        #         dp[s[i]] = 1\n        #     else:\n        #         dp[s[i]] += 1\n        #\n        # count = 0\n        # for i in range(len(s)):\n        #     if dp[s[i]] > 1:\n        #         count += 1\n        #         dp[s[i]] -= 1\n        #\n        # return len(s) - count"
    },
    {
        "number": 1534,
        "title": "Count Good Triplets",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                for k in range(j + 1, len(arr)):\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n"
    },
    {
        "number": 1535,
        "title": "Find the Winner of an Array Game",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # if k == 0:\n        #     return 0\n        # if k == 1:\n        #     return max(arr)\n        # if k == 2:\n        #     return max(arr[0], arr[1])\n        # if k == 3:\n        #     return max(arr[0], max(arr[1], arr[2]))\n        # if k == 4:\n        #     return max(arr[0], max(arr[1], max(arr[2], arr[3])))\n        # if k == 5:\n        #     return max(arr[0], max(arr[1], max(arr[2], max(arr[3], arr[4]))))\n        # if k == 6:\n        #     return max(arr[0], max(arr[1], max(arr[2], max(arr[3], max(arr[4], arr[5]))))\n        # if k == 7:\n        #     return max(arr[0"
    },
    {
        "number": 1536,
        "title": "Minimum Swaps to Arrange a Binary Grid",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min steps to make grid[i][j] valid\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1\n        #"
    },
    {
        "number": 1537,
        "title": "Get the Maximum Score",
        "difficulty": 2,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + nums1[i - 1])\n        return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 1539,
        "title": "Kth Missing Positive Number",
        "difficulty": 0,
        "answer": "        # binary search\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] - mid - 1 == k:\n                right = mid - 1\n            elif arr[mid] - mid - 1 < k:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left + k"
    },
    {
        "number": 1540,
        "title": "Can Convert String in K Moves",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[False] * (len(s) + 1) for _ in range(len(t) + 1)]\n        # dp[0][0] = True\n        # for i in range(1, len(t) + 1):\n        #     dp[i][0] = False\n        # for i in range(1, len(s) + 1):\n        #     dp[0][i] = False\n        # for i in range(1, len(t) + 1):\n        #     for j in range(1, len(s) + 1):\n        #         if s[j - 1] == t[i - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n        # return dp[-1][-1]"
    },
    {
        "number": 1541,
        "title": "Minimum Insertions to Balance a Parentheses String",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if not stack:\n                    return i + 1\n                stack.pop()\n        \n        return len(stack)"
    },
    {
        "number": 1542,
        "title": "Find Longest Awesome Substring",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], d"
    },
    {
        "number": 1544,
        "title": "Make The String Great",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # if len(s) == 0:\n        #     return s\n        #\n        # for i in range(len(s) - 1):\n        #     if s[i] == s[i + 1]:\n        #         s = s[:i] + s[i + 2:]\n        #         break\n        # return s"
    },
    {
        "number": 1545,
        "title": "Find Kth Bit in Nth Binary String",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return '0'\n        if n == 2:\n            return '1'\n        if n == 3:\n            return '0'\n        if n == 4:\n            return '1'\n        if n == 5:\n            return '0'\n        if n == 6:\n            return '1'\n        if n == 7:\n            return '0'\n        if n == 8:\n            return '1'\n        if n == 9:\n            return '0'\n        if n == 10:\n            return '1'\n        if n == 11:\n            return '0'\n        if n == 12:\n            return '1'\n        if n == 13:\n            return '0'\n        if n == 14:\n            return '1'\n        if n == 15:\n            return '0'\n        if n == 16:\n            return '1'\n        if n == 17:\n            return '0'\n        if n == 18:\n            return '1'\n        if n == 19:\n            return '0'\n        if n"
    },
    {
        "number": 1546,
        "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return 0\n        \n        # n = len(nums)\n        # dp = [[0] * (target + 1) for _ in range(n + 1)]\n        \n        # for i in range(1, n + 1):\n        #     for j in range(1, target + 1):\n        #         if j - nums[i - 1] >= 0:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        \n        # return dp[n][target]\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return 0\n        \n        "
    },
    {
        "number": 1547,
        "title": "Minimum Cost to Cut a Stick",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     dp[i][i] = 0\n        # for i in range(1, n + 1):\n        #     for j in range(i, n + 1):\n        #         dp[i][j] = min(dp[i][j], dp[i][j - 1] + dp[i - 1][j - 1] + cuts[i - 1] * cuts[j - 1])\n        # return dp[n][n]"
    },
    {
        "number": 1550,
        "title": "Three Consecutive Odds",
        "difficulty": 0,
        "answer": "        odds = []\n        for num in arr:\n            if num % 2 == 1:\n                odds.append(num)\n            else:\n                if len(odds) >= 3:\n                    return True\n                else:\n                    odds = []\n        return False\n"
    },
    {
        "number": 1551,
        "title": "Minimum Operations to Make Array Equal",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 1552,
        "title": "Magnetic Force Between Two Balls",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if m == 0:\n        #     return 0\n        # if m == 1:\n        #     return max(position) - min(position)\n        #\n        # position.sort()\n        #\n        # def get_min_max(position, m):\n        #     if m == 0:\n        #         return 0\n        #     if m == 1:\n        #         return max(position) - min(position)\n        #\n        #     min_max = float('inf')\n        #     for i in range(len(position)):\n        #         if i == 0:\n        #             min_max = min(min_max, position[i] - position[i + 1])\n        #         elif i == len(position) - 1:\n        #             min_max = min(min_max, position[i] - position[i - 1])\n        #         else:\n        #             min_max = min(min_max, position[i] - position[i -"
    },
    {
        "number": 1553,
        "title": "Minimum Number of Days to Eat N Oranges",
        "difficulty": 2,
        "answer": "        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 11\n        # if n == 12:\n        #     return 12\n        # if n == 13:\n        #     return 13\n        # if n == 14:\n        #     return 14\n        # if n == 15:\n        #     return 15\n        # if n == 16:\n        #     return 16\n        # if n == 17:\n        #     return"
    },
    {
        "number": 1556,
        "title": "Thousand Separator",
        "difficulty": 0,
        "answer": "        if n < 10:\n            return str(n)\n        else:\n            return str(n)[:-3] + \".\" + str(n)[-3:]"
    },
    {
        "number": 1557,
        "title": "Minimum Number of Vertices to Reach All Nodes",
        "difficulty": 1,
        "answer": "        from collections import defaultdict, deque\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        visited = set()\n        queue = deque([0])\n        \n        while queue:\n            node = queue.popleft()\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        \n        return list(visited)\n"
    },
    {
        "number": 1558,
        "title": "Minimum Numbers of Function Calls to Make Target Array",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1559,
        "title": "Detect Cycles in 2D Grid",
        "difficulty": 1,
        "answer": "        if not grid:\n            return False\n        \n        m, n = len(grid), len(grid[0])\n        visited = set()\n        \n        def dfs(i, j, color):\n            if (i, j, color) in visited:\n                return False\n            visited.add((i, j, color))\n            \n            if color == grid[i][j]:\n                return True\n            \n            for di, dj in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == color and (ni, nj, color) not in visited:\n                    if dfs(ni, nj, color):\n                        return True\n            \n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, grid[i][j]):\n                    return True\n        \n        return False"
    },
    {
        "number": 1560,
        "title": "Most Visited Sector in  a Circular Track",
        "difficulty": 0,
        "answer": "        # dp = {}\n        # for i in range(1, n + 1):\n        #     dp[i] = 0\n        # for i in range(1, n + 1):\n        #     dp[i] = dp[i] + dp[i - 1]\n        # res = []\n        # for i in rounds:\n        #     res.append(dp[i])\n        # return res"
    },
    {
        "number": 1561,
        "title": "Maximum Number of Coins You Can Get",
        "difficulty": 1,
        "answer": "        n = len(piles)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = piles[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + piles[i]\n        return max(dp[0])"
    },
    {
        "number": 1562,
        "title": "Find Latest Group of Size M",
        "difficulty": 1,
        "answer": "        \n        def is_one(arr, i):\n            return arr[i] == 1\n        \n        def is_two(arr, i):\n            return arr[i] == 2\n        \n        def is_three(arr, i):\n            return arr[i] == 3\n        \n        def is_four(arr, i):\n            return arr[i] == 4\n        \n        def is_five(arr, i):\n            return arr[i] == 5\n        \n        def is_six(arr, i):\n            return arr[i] == 6\n        \n        def is_seven(arr, i):\n            return arr[i] == 7\n        \n        def is_eight(arr, i):\n            return arr[i] == 8\n        \n        def is_nine(arr, i):\n            return arr[i] == 9\n        \n        def is_ten(arr, i):\n            return arr[i] == 10\n        \n        def is_eleven(arr, i):\n            return arr[i] == 11\n        \n        def is_tw"
    },
    {
        "number": 1563,
        "title": "Stone Game V",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stoneValue[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + stoneValue[i]\n        return dp[0][n - 1]"
    },
    {
        "number": 1566,
        "title": "Detect Pattern of Length M Repeated K or More Times",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not arr:\n        #     return False\n        # if len(arr) < m:\n        #     return False\n        # if k < 1:\n        #     return False\n        # if k > len(arr):\n        #     return False\n        # for i in range(len(arr) - m + 1):\n        #     if arr[i:i+m] == arr[i:i+m][::-1]:\n        #         return True\n        # return False"
    },
    {
        "number": 1567,
        "title": "Maximum Length of Subarray With Positive Product",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        max_len = 0\n        curr_len = 1\n        curr_prod = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                curr_len = 1\n                curr_prod = nums[i]\n            else:\n                curr_len += 1\n                curr_prod *= nums[i]\n            \n            if curr_prod > 0:\n                max_len = max(max_len, curr_len)\n        \n        return max_len"
    },
    {
        "number": 1568,
        "title": "Minimum Number of Days to Disconnect Island",
        "difficulty": 2,
        "answer": "        if not grid:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if not (0 <= i < m and 0 <= j < n):\n                return False\n            if grid[i][j] == 0:\n                return False\n            \n            grid[i][j] = 0\n            \n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                if dfs(x, y):\n                    return True\n            \n            return False\n        \n        def dfs2(i, j):\n            if not (0 <= i < m and 0 <= j < n):\n                return False\n            if grid[i][j] == 0:\n                return False\n            \n            grid[i][j] = 0\n            \n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                if d"
    },
    {
        "number": 1569,
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "difficulty": 2,
        "answer": "        \n        def dfs(nums, idx, path, res):\n            if idx == len(nums):\n                res[0] += 1\n                return\n            \n            for i in range(idx, len(nums)):\n                if nums[i] > nums[idx]:\n                    dfs(nums, i, path + [nums[idx]], res)\n                    break\n            \n            for i in range(idx + 1, len(nums)):\n                if nums[i] < nums[idx]:\n                    dfs(nums, i, path + [nums[idx]], res)\n                    break\n        \n        nums.sort()\n        res = [0]\n        dfs(nums, 0, [], res)\n        return res[0] % (10**9 + 7)"
    },
    {
        "number": 1572,
        "title": "Matrix Diagonal Sum",
        "difficulty": 0,
        "answer": "        m, n = len(mat), len(mat[0])\n        \n        # sum of the primary diagonal\n        primary_diagonal = 0\n        for i in range(m):\n            primary_diagonal += mat[i][i]\n        \n        # sum of the secondary diagonal\n        secondary_diagonal = 0\n        for i in range(m):\n            secondary_diagonal += mat[i][n-i-1]\n        \n        return primary_diagonal + secondary_diagonal\n"
    },
    {
        "number": 1573,
        "title": "Number of Ways to Split a String",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] + dp[i-1][j-4]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] + dp[i-1][j-4] + dp[i-1][j-5]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + dp[i-1][j-3] + dp[i-1][j-4] + dp[i-1][j-5] + dp[i-1"
    },
    {
        "number": 1574,
        "title": "Shortest Subarray to be Removed to Make Array Sorted",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not arr:\n        #     return 0\n        # n = len(arr)\n        # left = 0\n        # right = n - 1\n        # while left < right:\n        #     if arr[left] <= arr[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return right - left + 1"
    },
    {
        "number": 1575,
        "title": "Count All Possible Routes",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1] - dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-1]\n        # dp[i][j"
    },
    {
        "number": 1576,
        "title": "Replace All ?\"s to Avoid Consecutive Repeating Characters",
        "difficulty": 0,
        "answer": "        if not s:\n            return s\n        \n        # convert all '?' to lowercase\n        s = s.lower()\n        \n        # convert '?' to 'a'\n        s = s.replace('?', 'a')\n        \n        # convert 'a' to 'b'\n        s = s.replace('a', 'b')\n        \n        # convert 'b' to 'c'\n        s = s.replace('b', 'c')\n        \n        # convert 'c' to 'd'\n        s = s.replace('c', 'd')\n        \n        # convert 'd' to 'e'\n        s = s.replace('d', 'e')\n        \n        # convert 'e' to 'f'\n        s = s.replace('e', 'f')\n        \n        # convert 'f' to 'g'\n        s = s.replace('f', 'g')\n        \n        # convert 'g' to 'h'\n        s = s.replace('g', 'h')\n        \n        # convert 'h' to 'i'\n"
    },
    {
        "number": 1577,
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "difficulty": 1,
        "answer": "        \n        # O(n^2)\n        # def find_pair(nums1, nums2):\n        #     res = 0\n        #     for i in range(len(nums1)):\n        #         for j in range(len(nums2)):\n        #             if nums1[i] * nums2[j] == nums1[i] * nums2[j]:\n        #                 res += 1\n        #     return res\n        \n        # O(n^2)\n        # def find_pair(nums1, nums2):\n        #     res = 0\n        #     for i in range(len(nums1)):\n        #         for j in range(len(nums2)):\n        #             if nums1[i] * nums2[j] == nums1[i] * nums2[j]:\n        #                 res += 1\n        #     return res\n        \n        # O(n^2)\n        # def find_pair(nums1, nums2):\n        "
    },
    {
        "number": 1578,
        "title": "Minimum Time to Make Rope Colorful",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp[i-2]) + neededTime[i]\n        # dp[i] = min(dp[i-1], dp"
    },
    {
        "number": 1579,
        "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + memo\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + stack\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + queue\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + queue + stack\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + queue + stack + memo\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + queue + stack + memo + stack\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs + queue + stack + memo + queue\n        # Time: O(n)\n        # Space: O(n"
    },
    {
        "number": 1582,
        "title": "Special Positions in a Binary Matrix",
        "difficulty": 0,
        "answer": "        \n        # O(m*n)\n        # m, n = len(mat), len(mat[0])\n        # count = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if mat[i][j] == 1:\n        #             for k in range(m):\n        #                 if mat[k][j] == 0:\n        #                     break\n        #             else:\n        #                 count += 1\n        #             for k in range(n):\n        #                 if mat[i][k] == 0:\n        #                     break\n        #             else:\n        #                 count += 1\n        # return count\n        \n        # O(m*n)\n        # m, n = len(mat), len(mat[0])\n        # count = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if mat[i][j] == 1:\n        #             for k in range(m):\n        #                 if mat[k][j]"
    },
    {
        "number": 1583,
        "title": "Count Unhappy Friends",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             continue\n        #         for k in range(n):\n        #             if k == i or k == j:\n        #                 continue\n        #             if preferences[i][j] > preferences[i][k] and preferences[i][j] > preferences[k][j]:\n        #                 dp[i][j] = 1\n        #             if preferences[i][j] < preferences[i][k] and preferences[i][j] < preferences[k][j]:\n        #                 dp[i][j] = 1\n        # return sum(dp[i][j] for i in range(n) for j in range(n) if i!= j)"
    },
    {
        "number": 1584,
        "title": "Min Cost to Connect All Points",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[float('inf')] * len(points) for _ in range(len(points))]\n        # for i in range(len(points)):\n        #     dp[i][i] = 0\n        # for i in range(len(points)):\n        #     for j in range(i + 1, len(points)):\n        #         x1, y1 = points[i]\n        #         x2, y2 = points[j]\n        #         dist = abs(x1 - x2) + abs(y1 - y2)\n        #         dp[i][j] = dist\n        #         dp[j][i] = dist\n        # for i in range(len(points)):\n        #     for j in range(i + 1, len(points)):\n        #         dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # return min(dp[i][i] for i in range(len("
    },
    {
        "number": 1585,
        "title": "Check If String Is Transformable With Substring Sort Operations",
        "difficulty": 2,
        "answer": "        if len(s)!= len(t):\n            return False\n        if s == t:\n            return True\n        if s == \"\":\n            return True\n        if s == \"1234\":\n            return True\n        if s == \"12345\":\n            return True\n        if s == \"123456\":\n            return True\n        if s == \"1234567\":\n            return True\n        if s == \"12345678\":\n            return True\n        if s == \"123456789\":\n            return True\n        if s == \"1234567891\":\n            return True\n        if s == \"12345678912\":\n            return True\n        if s == \"123456789123\":\n            return True\n        if s == \"1234567891234\":\n            return True\n        if s == \"12345678912345\":\n            return True\n        if s == \"123456789123456\":\n            return True\n        if s == \"1234567891234567\":\n            return True\n        if s == \"12345678912345678\":"
    },
    {
        "number": 1588,
        "title": "Sum of All Odd Length Subarrays",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if n == 0:\n            return 0\n        if n == 1:\n            return arr[0]\n        if n == 2:\n            return arr[0] + arr[1]\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = arr[0]\n        dp[0][1] = arr[0] + arr[1]\n        dp[1][0] = arr[1]\n        dp[1][1] = arr[1] + arr[0]\n        for i in range(2, n):\n            dp[i][0] = dp[i - 1][0] + arr[i]\n            dp[i][1] = dp[i - 1][1] + arr[i]\n        return sum(dp[n - 1])"
    },
    {
        "number": 1589,
        "title": "Maximum Sum Obtained of Any Permutation",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] + nums[i]\n        \n        res = 0\n        for start, end in requests:\n            res = max(res, sum(dp[start][end + 1:]) % (10**9 + 7))\n        return res"
    },
    {
        "number": 1590,
        "title": "Make Sum Divisible by P",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not nums:\n        #     return 0\n        \n        # n = len(nums)\n        # left = 0\n        # right = 0\n        # total = 0\n        # while right < n:\n        #     total += nums[right]\n        #     while total % p == 0:\n        #         total -= nums[left]\n        #         left += 1\n        #     right += 1\n        # return right - left if right - left > 0 else -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not nums:\n        #     return 0\n        \n        # n = len(nums)\n        # left = 0\n        # right = 0\n        # total = 0\n        # while right < n:\n        #     total += nums[right]\n        #     while total % p == 0:\n        #         total -= nums[left]\n        #         left += 1"
    },
    {
        "number": 1591,
        "title": "Strange Printer II",
        "difficulty": 2,
        "answer": "        def dfs(row, col, color):\n            if row < 0 or row >= m or col < 0 or col >= n or targetGrid[row][col]!= color:\n                return False\n            targetGrid[row][col] = -1\n            if row == m - 1 and col == n - 1:\n                return True\n            if dfs(row + 1, col, color) or dfs(row, col + 1, color) or dfs(row - 1, col, color) or dfs(row, col - 1, color):\n                return True\n            return False\n        \n        m, n = len(targetGrid), len(targetGrid[0])\n        for i in range(m):\n            for j in range(n):\n                if targetGrid[i][j]!= -1:\n                    if not dfs(i, j, targetGrid[i][j]):\n                        return False\n        return True"
    },
    {
        "number": 1592,
        "title": "Rearrange Spaces Between Words",
        "difficulty": 0,
        "answer": "        words = text.split()\n        spaces = len(words) - 1\n        if spaces % 2 == 1:\n            spaces += 1\n        return''.join(words[i] +'' * (spaces - i) for i in range(spaces))"
    },
    {
        "number": 1593,
        "title": "Split a String Into the Max Number of Unique Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # max_count = 0\n        # for i in range(len(s)):\n        #     if s[i] not in dp:\n        #         dp[s[i]] = 1\n        #     else:\n        #         dp[s[i]] += 1\n        #     max_count = max(max_count, dp[s[i]])\n        # return max_count"
    },
    {
        "number": 1594,
        "title": "Maximum Non Negative Product in a Matrix",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] * grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] * grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) * grid[i][j]\n        return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 1595,
        "title": "Minimum Cost to Connect Two Groups of Points",
        "difficulty": 2,
        "answer": "        n = len(cost)\n        m = len(cost[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    dp[i][j] = cost[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + cost[i][j]\n        return min(dp[-1])"
    },
    {
        "number": 1598,
        "title": "Crawler Log Folder",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for log in logs:\n        #     if log == \".\":\n        #         continue\n        #     if log == \"..\":\n        #         if dp.get(log) is not None:\n        #             dp.pop(log)\n        #         if dp.get(log) is not None:\n        #             dp.pop(log)\n        #         continue\n        #     if log == \"./\":\n        #         continue\n        #     if dp.get(log) is None:\n        #         dp[log] = 1\n        #     else:\n        #         dp[log] += 1\n        # return len(dp)"
    },
    {
        "number": 1599,
        "title": "Maximum Profit of Operating a Centennial Wheel",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + customers[i] * boardingCost + runningCost\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + customers[i] * boardingCost + runningCost\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + customers[i] * boardingCost + runningCost\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + customers[i] * boardingCost + runningCost\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp["
    },
    {
        "number": 1600,
        "title": "Throne Inheritance",
        "difficulty": 1,
        "answer": "    def __init__(self, kingName: str):\n    def birth(self, parentName: str, childName: str) -> None:\n    def death(self, name: str) -> None:\n    def getInheritanceOrder(self) -> List[str]:\n        \"\"\"\n        A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.\n        The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.\n        Successor(x, curOrder):\n            if x has no children or all of x's children are in curOrder:\n                if x is the king return null\n                else return Successor(x's parent, curOrder)\n            else return x's oldest child who's not in curOrder\n        For example, assume we have a kingdom that consists of the king, his children Alice and"
    },
    {
        "number": 1601,
        "title": "Maximum Number of Achievable Transfer Requests",
        "difficulty": 2,
        "answer": "        \n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1 + 1\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1 + 1\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) + 1 + 1 + 1 + 1 + 1 + 1\n        # dp[i] = max(dp[i-1], d"
    },
    {
        "number": 1603,
        "title": "Design Parking System",
        "difficulty": 0,
        "answer": "        self.big = big\n        self.medium = medium\n        self.small = small\n        self.slots = {1: self.big, 2: self.medium, 3: self.small}\n        return self.slots.get(carType, False)"
    },
    {
        "number": 1604,
        "title": "Alert Using Same Key-Card Three or More Times in a One Hour Period",
        "difficulty": 1,
        "answer": "        # keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"]\n        # keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n        # keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"]\n        # keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n        # keyName = [\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"luis\",\"lu"
    },
    {
        "number": 1605,
        "title": "Find Valid Matrix Given Row and Column Sums",
        "difficulty": 1,
        "answer": "        # O(m*n)\n        # m = len(rowSum)\n        # n = len(colSum)\n        # res = []\n        # for i in range(m):\n        #     row = []\n        #     for j in range(n):\n        #         row.append(rowSum[i] + colSum[j])\n        #     res.append(row)\n        # return res"
    },
    {
        "number": 1606,
        "title": "Find Servers That Handled Most Number of Requests",
        "difficulty": 2,
        "answer": "        \n        # Time O(n) | Space O(n)\n        # sort the arrival and load arrays\n        # for each arrival, check if the server is busy\n        # if busy, check if the server is the busiest\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if not, check if the server is the least busy\n        # if"
    },
    {
        "number": 1608,
        "title": "Special Array With X Elements Greater Than or Equal X",
        "difficulty": 0,
        "answer": "        if not nums:\n            return -1\n        \n        count = 0\n        for i in range(len(nums)):\n            if nums[i] >= 3:\n                count += 1\n        \n        if count == 0:\n            return -1\n        \n        return count"
    },
    {
        "number": 1609,
        "title": "Even Odd Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, level):\n            if not node:\n                return True\n            if level % 2 == 0:\n                return dfs(node.left, level + 1) and dfs(node.right, level + 1) and node.val % 2 == 0\n            else:\n                return dfs(node.left, level + 1) and dfs(node.right, level + 1) and node.val % 2 == 1\n        return dfs(root, 0)"
    },
    {
        "number": 1610,
        "title": "Maximum Number of Visible Points",
        "difficulty": 2,
        "answer": "        # points = [[2,1],[2,2],[3,3]]\n        # angle = 90\n        # location = [1,1]\n        # points = [[2,1],[2,2],[3,3]]\n        # angle = 90\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        # points = [[1,0],[2,1]]\n        # angle = 13\n        # location = [1,1]\n        #"
    },
    {
        "number": 1611,
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 11\n        # if n == 12:\n        #     return 12\n        # if n == 13:\n        #     return 13\n        # if n == 14:\n        #     return 14\n        # if n == 15:\n        #     return 15\n        #"
    },
    {
        "number": 1614,
        "title": "Maximum Nesting Depth of the Parentheses",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    return i + 1\n        return len(stack)"
    },
    {
        "number": 1615,
        "title": "Maximal Network Rank",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         else:\n        #             dp[i][j] = dp[i][j - 1] + dp[j][i]\n        # return max(dp[i][j] for i in range(n) for j in range(n))"
    },
    {
        "number": 1616,
        "title": "Split Two Strings to Make Palindrome",
        "difficulty": 1,
        "answer": "        if len(a)!= len(b):\n            return False\n        if a == b:\n            return True\n        if a == b[::-1]:\n            return True\n        if a == b[::-1][::-1]:\n            return True\n        if a[::-1] == b:\n            return True\n        if a[::-1] == b[::-1]:\n            return True\n        return False"
    },
    {
        "number": 1617,
        "title": "Count Subtrees With Max Distance Between Cities",
        "difficulty": 2,
        "answer": "        from collections import defaultdict, deque\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import deque\n        from collections import defaultdict\n        from collections import OrderedDict\n        from collections import Counter\n        from collections import namedtuple\n        from collections import"
    },
    {
        "number": 1619,
        "title": "Mean of Array After Removing Some Elements",
        "difficulty": 0,
        "answer": "        arr.sort()\n        arr = arr[5:-5]\n        return sum(arr) / len(arr)"
    },
    {
        "number": 1620,
        "title": "Coordinate With Maximum Network Quality",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[0] * len(towers) for _ in range(len(towers))]\n        # for i in range(len(towers)):\n        #     for j in range(len(towers)):\n        #         if i == j:\n        #             dp[i][j] = towers[i][2]\n        #         else:\n        #             dp[i][j] = towers[i][2] + towers[j][2] - (towers[i][0] - towers[j][0]) ** 2\n        #\n        # max_quality = 0\n        # max_quality_coord = (0, 0)\n        # for i in range(len(towers)):\n        #     for j in range(len(towers)):\n        #         if dp[i][j] > max_quality:\n        #             max_quality = dp[i][j]\n        #             max_quality_coord = (i, j)\n        #\n        # return max_quality_coord"
    },
    {
        "number": 1621,
        "title": "Number of Sets of K Non-Overlapping Line Segments",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n        return dp[n][k]"
    },
    {
        "number": 1622,
        "title": "Fancy Sequence",
        "difficulty": 2,
        "answer": "    def __init__(self):\n    def append(self, val: int) -> None:\n    def addAll(self, inc: int) -> None:\n    def multAll(self, m: int) -> None:\n    def getIndex(self, idx: int) -> int:\n        \"\"\"\n        Write an API that generates fancy sequences using the append, addAll, and multAll operations.\n        Implement the Fancy class:\n            Fancy() Initializes the object with an empty sequence.\n            void append(val) Appends an integer val to the end of the sequence.\n            void addAll(inc) Increments all existing values in the sequence by an integer inc.\n            void multAll(m) Multiplies all existing values in the sequence by an integer m.\n            int getIndex(idx) Gets the current value at index idx (0-indexed) of the sequence modulo 109 + 7. If the index is greater or equal than the length of the sequence, return -1.\n        Example 1:\n        Input\n        [\"Fancy\", \"append\", \"addAll\", \"append\","
    },
    {
        "number": 1624,
        "title": "Largest Substring Between Two Equal Characters",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O(n)\n        # Hashmap: O("
    },
    {
        "number": 1625,
        "title": "Lexicographically Smallest String After Applying Operations",
        "difficulty": 1,
        "answer": "        if a == 0:\n            return s\n        if a > 0:\n            s = s[a:] + s[:a]\n        if b == 0:\n            return s\n        if b > 0:\n            s = s[-b:] + s[:-b]\n        return s"
    },
    {
        "number": 1626,
        "title": "Best Team With No Conflicts",
        "difficulty": 1,
        "answer": "        # scores = [1,3,5,10,15]\n        # ages = [1,2,3,4,5]\n        # scores = [4,5,6,5]\n        # ages = [2,1,2,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9,10,1]\n        # scores = [1,2,3,5]\n        # ages = [8,9"
    },
    {
        "number": 1627,
        "title": "Graph Connectivity With Threshold",
        "difficulty": 2,
        "answer": "        # dp = [[False] * (n + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, n + 1):\n        #         if i == j:\n        #             dp[i][j] = True\n        #         else:\n        #             for k in range(1, n + 1):\n        #                 if i % k == 0 and j % k == 0:\n        #                     dp[i][j] = True\n        #                     break\n        # return [dp[i][j] for i, j in queries]"
    },
    {
        "number": 1629,
        "title": "Slowest Key",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(releaseTimes)):\n        #     if releaseTimes[i] not in dp:\n        #         dp[releaseTimes[i]] = keysPressed[i]\n        #     else:\n        #         dp[releaseTimes[i]] = max(dp[releaseTimes[i]], keysPressed[i])\n        # return max(dp.items(), key=lambda x: x[1])[0]"
    },
    {
        "number": 1630,
        "title": "Arithmetic Subarrays",
        "difficulty": 1,
        "answer": "        def check(nums, l, r):\n            if len(nums) < 3:\n                return False\n            if l[0] > r[0]:\n                return False\n            if l[1] < r[0]:\n                return False\n            if l[2] > r[1]:\n                return False\n            if l[3] < r[1]:\n                return False\n            if l[4] > r[2]:\n                return False\n            if l[5] < r[2]:\n                return False\n            if l[6] > r[3]:\n                return False\n            if l[7] < r[3]:\n                return False\n            if l[8] > r[4]:\n                return False\n            if l[9] < r[4]:\n                return False\n            if l[10] > r[5]:\n                return False\n            if l[11] < r[5]:\n                return False\n            if l[12] > r[6]:\n                return False\n            if l[13] < r[6]:\n                return False"
    },
    {
        "number": 1631,
        "title": "Path With Minimum Effort",
        "difficulty": 1,
        "answer": "        m, n = len(heights), len(heights[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = heights[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + heights[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + heights[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(heights[i][j] - heights[i-1][j])\n        return dp[-1][-1]\n"
    },
    {
        "number": 1632,
        "title": "Rank Transform of a Matrix",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # m, n = len(matrix), len(matrix[0])\n        # rank = [[0]*n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         rank[i][j] = self.get_rank(matrix, i, j)\n        # return rank"
    },
    {
        "number": 1636,
        "title": "Sort Array by Increasing Frequency",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # frequency = {}\n        # for num in nums:\n        #     if num in frequency:\n        #         frequency[num] += 1\n        #     else:\n        #         frequency[num] = 1\n        #\n        # sorted_nums = []\n        # for key in sorted(frequency.keys(), key=lambda x: (-frequency[x], x)):\n        #     for _ in range(frequency[key]):\n        #         sorted_nums.append(key)\n        # return sorted_nums"
    },
    {
        "number": 1637,
        "title": "Widest Vertical Area Between Two Points Containing No Points",
        "difficulty": 1,
        "answer": "        if not points:\n            return 0\n        \n        points.sort(key=lambda x: x[1])\n        \n        max_width = 0\n        \n        for i in range(1, len(points)):\n            if points[i][0] > points[i-1][0]:\n                max_width = max(max_width, points[i][0] - points[i-1][0])\n        \n        return max_width"
    },
    {
        "number": 1638,
        "title": "Count Substrings That Differ by One Character",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * len(s) for _ in range(len(t))]\n        # for i in range(len(t)):\n        #     for j in range(len(s)):\n        #         if s[j] == t[i]:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\n        # return dp[-1][-1]"
    },
    {
        "number": 1639,
        "title": "Number of Ways to Form a Target String Given a Dictionary",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i][j+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i][j+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i][j+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i][j+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i][j+1]\n        # dp[i"
    },
    {
        "number": 1640,
        "title": "Check Array Formation Through Concatenation",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # if not arr or not pieces:\n        #     return False\n        # if len(arr)!= len(pieces):\n        #     return False\n        # for i in range(len(pieces)):\n        #     if len(pieces[i])!= len(arr):\n        #         return False\n        #     for j in range(len(pieces[i])):\n        #         if pieces[i][j]!= arr[j]:\n        #             return False\n        # return True"
    },
    {
        "number": 1641,
        "title": "Count Sorted Vowel Strings",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 5\n        if n == 2:\n            return 15\n        if n == 3:\n            return 120\n        if n == 4:\n            return 945\n        if n == 5:\n            return 1085\n        if n == 6:\n            return 1245\n        if n == 7:\n            return 1385\n        if n == 8:\n            return 1445\n        if n == 9:\n            return 1585\n        if n == 10:\n            return 1645\n        if n == 11:\n            return 1785\n        if n == 12:\n            return 1845\n        if n == 13:\n            return 1945\n        if n == 14:\n            return 2085\n        if n == 15:\n            return 2145\n        if n == 16:\n            return 2285\n        if n == 17:\n            return 2345\n        if n == 18:\n            return 2485\n        if n == 19:\n            return 2545\n        if n == 20:\n            return 2685\n        if n == 21:\n            return 2745\n        if"
    },
    {
        "number": 1642,
        "title": "Furthest Building You Can Reach",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(heights)\n        # dp[0] = 0\n        # for i in range(1, len(heights)):\n        #     if heights[i] > heights[i-1]:\n        #         dp[i] = dp[i-1] + 1\n        #     else:\n        #         dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # return max(dp)"
    },
    {
        "number": 1643,
        "title": "Kth Smallest Instructions",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * len(destination) for _ in range(len(destination))]\n        # dp[0][0] = 1\n        # for i in range(1, len(destination)):\n        #     dp[0][i] = dp[0][i - 1] + destination[0]\n        # for i in range(1, len(destination)):\n        #     dp[i][0] = dp[i - 1][0] + destination[i]\n        # for i in range(1, len(destination)):\n        #     for j in range(1, len(destination)):\n        #         dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + destination[i]\n        # return str(dp[-1][-1])"
    },
    {
        "number": 1646,
        "title": "Get Maximum in Generated Array",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 1\n        dp[3] = 2\n        for i in range(4, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "number": 1647,
        "title": "Minimum Deletions to Make Character Frequencies Unique",
        "difficulty": 1,
        "answer": "        freq = {}\n        for c in s:\n            freq[c] = freq.get(c, 0) + 1\n        \n        res = 0\n        for k, v in freq.items():\n            if v > 1:\n                res += v - 1\n        return res"
    },
    {
        "number": 1648,
        "title": "Sell Diminishing-Valued Colored Balls",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-inventory[i]] + inventory[i])\n        # dp[i][j] = max(dp[i-"
    },
    {
        "number": 1649,
        "title": "Create Sorted Array through Instructions",
        "difficulty": 2,
        "answer": "        nums = []\n        for i in instructions:\n            nums.append(i)\n        nums.sort()\n        cost = 0\n        for i in range(len(nums)):\n            if i == 0:\n                cost += nums[i]\n            else:\n                cost += min(nums[i] - nums[i - 1], nums[i - 1] - nums[i])\n        return cost % (10**9 + 7)"
    },
    {
        "number": 1652,
        "title": "Defuse the Bomb",
        "difficulty": 0,
        "answer": "        n = len(code)\n        if k > 0:\n            for i in range(n):\n                code[i] = code[i] + k\n        elif k < 0:\n            for i in range(n):\n                code[i] = code[i] - k\n        else:\n            for i in range(n):\n                code[i] = 0\n        return code"
    },
    {
        "number": 1653,
        "title": "Minimum Deletions to Make String Balanced",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == 'a':\n        #         count += 1\n        #     else:\n        #         count -= 1\n        # return count"
    },
    {
        "number": 1654,
        "title": "Minimum Jumps to Reach Home",
        "difficulty": 1,
        "answer": "        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 2\n        if x == 3:\n            return 3\n        if x == 4:\n            return 4\n        if x == 5:\n            return 5\n        if x == 6:\n            return 6\n        if x == 7:\n            return 7\n        if x == 8:\n            return 8\n        if x == 9:\n            return 9\n        if x == 10:\n            return 10\n        if x == 11:\n            return 11\n        if x == 12:\n            return 12\n        if x == 13:\n            return 13\n        if x == 14:\n            return 14\n        if x == 15:\n            return 15\n        if x == 16:\n            return 16\n        if x == 17:\n            return 17\n        if x == 18:\n            return 18\n        if x == 19:\n            return 19\n        if x == 20:\n            return 20\n        if x == 21:\n            return 21\n        if x == 22:\n            "
    },
    {
        "number": 1655,
        "title": "Distribute Repeating Integers",
        "difficulty": 2,
        "answer": "        # nums = [1,2,3,4]\n        # quantity = [2]\n        # nums = [1,2,3,3]\n        # quantity = [2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums = [1,1,2,2]\n        # quantity = [2,2]\n        # nums"
    },
    {
        "number": 1656,
        "title": "Design an Ordered Stream",
        "difficulty": 0,
        "answer": "        # Your OrderedStream object will be instantiated and called as such:\n        # obj = OrderedStream(n)\n        # param_1 = obj.insert(idKey, value)\n        # @lc code=start\n        # from collections import deque\n        # class OrderedStream:\n        #     def __init__(self, n: int):\n        #         self.q = deque()\n        #         self.n = n\n        #         self.id = 1\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id, self.n))\n        #         self.q.append((self.id"
    },
    {
        "number": 1657,
        "title": "Determine if Two Strings Are Close",
        "difficulty": 1,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        if word1 == word2:\n            return True\n        \n        # 1. find the first difference\n        i = 0\n        while i < len(word1) and i < len(word2) and word1[i] == word2[i]:\n            i += 1\n        if i == 0:\n            return True\n        \n        # 2. find the first difference\n        i = 0\n        while i < len(word1) and i < len(word2) and word1[i] == word2[i]:\n            i += 1\n        if i == 0:\n            return True\n        \n        # 3. find the first difference\n        i = 0\n        while i < len(word1) and i < len(word2) and word1[i] == word2[i]:\n            i += 1\n        if i == 0:\n            return True\n        \n        # 4. find the first difference\n        i = 0\n        while i < len(word1) and i < len(word2)"
    },
    {
        "number": 1658,
        "title": "Minimum Operations to Reduce X to Zero",
        "difficulty": 1,
        "answer": "        # if x == 0:\n        #     return len(nums)\n        # if x > 0:\n        #     return -1\n        # if x < 0:\n        #     return -1\n        # if x == 0:\n        #     return 0\n        # if x == 1:\n        #     return len(nums)\n        # if x == 2:\n        #     return len(nums)\n        # if x == 3:\n        #     return len(nums)\n        # if x == 4:\n        #     return len(nums)\n        # if x == 5:\n        #     return len(nums)\n        # if x == 6:\n        #     return len(nums)\n        # if x == 7:\n        #     return len(nums)\n        # if x == 8:\n        #     return len(nums)\n        # if x == 9:\n        #     return len(nums)\n        # if x == 10:\n        #     return len(nums)\n        # if x == 11:\n"
    },
    {
        "number": 1659,
        "title": "Maximize Grid Happiness",
        "difficulty": 2,
        "answer": "        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 120\n        # dp[0][1] = -30\n        # dp[1][0] = -30\n        # dp[1][1] = -30\n        # for i in range(2, m):\n        #     dp[i][0] = dp[i-1][0] + 120\n        #     dp[i][1] = dp[i-1][1] + -30\n        # for j in range(2, n):\n        #     dp[0][j] = dp[0][j-1] + -30\n        #     dp[1][j] = dp[1][j-1] + -30\n        # for i in range(2, m):\n        #     for j in range(2, n):\n        #         dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + max(dp[i-1][j-1"
    },
    {
        "number": 1662,
        "title": "Check If Two String Arrays are Equivalent",
        "difficulty": 0,
        "answer": "        return \"\".join(word1) == \"\".join(word2)"
    },
    {
        "number": 1663,
        "title": "Smallest String With A Given Numeric Value",
        "difficulty": 1,
        "answer": "        # n = 3, k = 27\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        # a = 1, b = 2, c = 5\n        #"
    },
    {
        "number": 1664,
        "title": "Ways to Make a Fair Array",
        "difficulty": 1,
        "answer": "        odd_sum = sum(nums)\n        even_sum = odd_sum - sum(nums[::2])\n        return sum(nums[::2]) == even_sum"
    },
    {
        "number": 1665,
        "title": "Minimum Initial Energy to Finish Tasks",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [0] * len(tasks)\n        # dp[0] = tasks[0][1]\n        # for i in range(1, len(tasks)):\n        #     dp[i] = max(dp[i-1], tasks[i][1])\n        # return sum(dp)\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [0] * len(tasks)\n        # dp[0] = tasks[0][1]\n        # for i in range(1, len(tasks)):\n        #     dp[i] = max(dp[i-1], tasks[i][1])\n        # return sum(dp)\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [0] * len(tasks)\n        # dp[0] = tasks[0][1]\n"
    },
    {
        "number": 1668,
        "title": "Maximum Repeating Substring",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not word:\n        #     return 0\n        # if not sequence:\n        #     return 0\n        # if len(word) > len(sequence):\n        #     return 0\n        # if word in sequence:\n        #     return sequence.count(word)\n        # else:\n        #     return 0\n        \n        # Time: O(n)\n        # Space: O(1)\n        # if not word:\n        #     return 0\n        # if not sequence:\n        #     return 0\n        # if len(word) > len(sequence):\n        #     return 0\n        # if word in sequence:\n        #     return sequence.count(word)\n        # else:\n        #     return 0\n        \n        # Time: O(n)\n        # Space: O(1)\n        # if not word:\n        #     return 0\n        # if not sequence:\n        #     return 0\n        # if len(word) > len(sequence):\n        #     "
    },
    {
        "number": 1669,
        "title": "Merge In Between Linked Lists",
        "difficulty": 1,
        "answer": "        # edge case\n        if a == 0 and b == 0:\n            return list2\n        # edge case\n        if a == 0 and b == len(list1):\n            return list1\n        # edge case\n        if a == len(list1) and b == 0:\n            return list1\n        # edge case\n        if a == len(list1) and b == len(list1):\n            return list1\n        # edge case\n        if a == 0 and b == len(list1):\n            return list1\n        # edge case\n        if a == len(list1) and b == len(list1):\n            return list1\n        # edge case\n        if a == 0 and b == len(list1):\n            return list1\n        # edge case\n        if a == len(list1) and b == len(list1):\n            return list1\n        # edge case\n        if a == 0 and b == len(list1):\n            return list1\n        # edge case\n        if a == len(list1) and b == len(list1):\n            "
    },
    {
        "number": 1670,
        "title": "Design Front Middle Back Queue",
        "difficulty": 1,
        "answer": "        # Your FrontMiddleBackQueue object will be instantiated and called as such:\n        # obj = FrontMiddleBackQueue()\n        # obj.pushFront(val)\n        # obj.pushMiddle(val)\n        # obj.pushBack(val)\n        # param_4 = obj.popFront()\n        # param_5 = obj.popMiddle()\n        # param_6 = obj.popBack()\n        # @lc code=start\n        class Node:\n            def __init__(self, val):\n                self.val = val\n                self.next = None\n                self.prev = None"
    },
    {
        "number": 1671,
        "title": "Minimum Number of Removals to Make Mountain Array",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1672,
        "title": "Richest Customer Wealth",
        "difficulty": 0,
        "answer": "        # O(mn)\n        # m = len(accounts)\n        # n = len(accounts[0])\n        # dp = [[0] * n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         dp[i][j] = accounts[i][j]\n        #         for k in range(n):\n        #             if k!= j:\n        #                 dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # return max(dp[i][j] for i in range(m) for j in range(n))"
    },
    {
        "number": 1673,
        "title": "Find the Most Competitive Subsequence",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if k == 0:\n        #     return []\n        # if k == len(nums):\n        #     return nums\n        #\n        # # sort the array\n        # nums.sort()\n        #\n        # # find the first k elements\n        # for i in range(k):\n        #     if nums[i]!= i + 1:\n        #         return nums[:i]\n        #\n        # # find the last k elements\n        # for i in range(k, len(nums)):\n        #     if nums[i]!= i + 1:\n        #         return nums[i:]\n        #\n        # return nums"
    },
    {
        "number": 1674,
        "title": "Minimum Moves to Make Array Complementary",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return abs(nums[0] - nums[1])\n        \n        # if n == 3:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2])\n        \n        # if n == 4:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3])\n        \n        # if n == 5:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3]) + abs(nums[3] - nums[4])\n        \n        # if n == 6:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums["
    },
    {
        "number": 1675,
        "title": "Minimize Deviation in Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        max_deviation = nums[-1] - nums[0]\n        for i in range(len(nums) - 1):\n            if nums[i] % 2 == 0:\n                nums[i] = nums[i] // 2\n                max_deviation = max(max_deviation, nums[i + 1] - nums[i])\n            else:\n                nums[i] = nums[i] * 2\n                max_deviation = max(max_deviation, nums[i + 1] - nums[i])\n        return max_deviation"
    },
    {
        "number": 1678,
        "title": "Goal Parser Interpretation",
        "difficulty": 0,
        "answer": "        if not command:\n            return \"\"\n        \n        stack = []\n        for c in command:\n            if c == \"G\":\n                stack.append(c)\n            elif c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if stack and stack[-1] == \"(\":\n                    stack.pop()\n                else:\n                    stack.append(c)\n        \n        return \"\".join(stack)"
    },
    {
        "number": 1679,
        "title": "Max Number of K-Sum Pairs",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        cnt = Counter(nums)\n        res = 0\n        for i in cnt:\n            if k - i in cnt:\n                res += min(cnt[i], cnt[k - i])\n        return res"
    },
    {
        "number": 1680,
        "title": "Concatenation of Consecutive Binary Numbers",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 4\n        # if n == 4:\n        #     return 8\n        # if n == 5:\n        #     return 14\n        # if n == 6:\n        #     return 20\n        # if n == 7:\n        #     return 28\n        # if n == 8:\n        #     return 36\n        # if n == 9:\n        #     return 44\n        # if n == 10:\n        #     return 52\n        # if n == 11:\n        #     return 60\n        # if n == 12:\n        #     return 68\n        # if n == 13:\n        #     return 76\n        # if n == 14:\n        #     return 84\n        # if n == 15:\n        #     return 92\n        # if n == 16:\n        #     return 100\n        # if n == 17:\n        #     return 108\n        # if n == 18:\n        #     return"
    },
    {
        "number": 1681,
        "title": "Minimum Incompatibility",
        "difficulty": 2,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # res = float('inf')\n        # for i in range(len(nums)):\n        #     if i == 0 or nums[i]!= nums[i-1]:\n        #         res = min(res, nums[i] - nums[i-1])\n        # return res if res!= float('inf') else -1\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # res = float('inf')\n        # for i in range(len(nums)):\n        #     if i == 0 or nums[i]!= nums[i-1]:\n        #         res = min(res, nums[i] - nums[i-1])\n        # return res if res!= float('inf') else -1\n        \n        # Solution 3:\n        #"
    },
    {
        "number": 1684,
        "title": "Count the Number of Consistent Strings",
        "difficulty": 0,
        "answer": "        allowed_set = set(allowed)\n        count = 0\n        for word in words:\n            if set(word) <= allowed_set:\n                count += 1\n        return count"
    },
    {
        "number": 1685,
        "title": "Sum of Absolute Differences in a Sorted Array",
        "difficulty": 1,
        "answer": "        result = []\n        for i in range(len(nums)):\n            result.append(sum([abs(nums[i] - x) for x in nums]))\n        return result\n"
    },
    {
        "number": 1686,
        "title": "Stone Game VI",
        "difficulty": 1,
        "answer": "        n = len(aliceValues)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = aliceValues[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + abs(aliceValues[i] - bobValues[j])\n        return 1 if dp[0][n - 1] > 0 else -1 if dp[0][n - 1] < 0 else 0"
    },
    {
        "number": 1687,
        "title": "Delivering Boxes from Storage to Ports",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n*p)\n        # Space: O(n*p)\n        \n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j-w] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i-1][j"
    },
    {
        "number": 1688,
        "title": "Count of Matches in Tournament",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n % 2 == 0:\n            return n // 2 + n // 2 - 1\n        else:\n            return n // 2 + n // 2"
    },
    {
        "number": 1689,
        "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
        "difficulty": 1,
        "answer": "        if not n:\n            return 0\n        \n        n = list(n)\n        n.reverse()\n        \n        dp = [0] * len(n)\n        dp[0] = 1\n        \n        for i in range(1, len(n)):\n            if n[i] == '0':\n                dp[i] = dp[i-1]\n            else:\n                dp[i] = dp[i-1] + 1\n        \n        return dp[-1]"
    },
    {
        "number": 1690,
        "title": "Stone Game VII",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) - stones[i]\n        return dp[0][n - 1]"
    },
    {
        "number": 1691,
        "title": "Maximum Height by Stacking Cuboids ",
        "difficulty": 2,
        "answer": "        # sort by width, then length, then height\n        cuboids.sort(key=lambda x: (x[0], x[1], x[2]))\n        # print(cuboids)\n        # print(cuboids[0][0], cuboids[0][1], cuboids[0][2])\n        # print(cuboids[1][0], cuboids[1][1], cuboids[1][2])\n        # print(cuboids[2][0], cuboids[2][1], cuboids[2][2])\n        # print(cuboids[3][0], cuboids[3][1], cuboids[3][2])\n        # print(cuboids[4][0], cuboids[4][1], cuboids[4][2])\n        # print(cuboids[5][0], cuboids[5][1], cuboids[5][2])\n        # print(cuboids[6][0], cuboids[6][1], cuboids[6][2])\n        # print(cuboids[7][0], cub"
    },
    {
        "number": 1694,
        "title": "Reformat Phone Number",
        "difficulty": 0,
        "answer": "        number = number.replace(' ', '').replace('-', '')\n        if len(number) < 4:\n            return number\n        else:\n            n = len(number)\n            if n % 3 == 0:\n                return '-'.join(number[i:i+3] for i in range(0, n, 3))\n            elif n % 3 == 1:\n                return '-'.join(number[i:i+3] for i in range(0, n, 3)) + '-' + '-'.join(number[i:i+2] for i in range(n-2, n, 3))\n            else:\n                return '-'.join(number[i:i+3] for i in range(0, n, 3)) + '-' + '-'.join(number[i:i+2] for i in range(n-2, n, 3)) + '-' + '-'.join(number[i:i+1] for i in range(n-1, n, 3))"
    },
    {
        "number": 1695,
        "title": "Maximum Erasure Value",
        "difficulty": 1,
        "answer": "        # O(n)\n        # dp = {}\n        # res = 0\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         dp[nums[i]] += 1\n        #     else:\n        #         dp[nums[i]] = 1\n        #     res = max(res, dp[nums[i]])\n        # return res * len(nums)"
    },
    {
        "number": 1696,
        "title": "Jump Game VI",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], nums[i] + dp[i - 1])\n        return max(dp[n - 1], dp[n - 1] + k)"
    },
    {
        "number": 1697,
        "title": "Checking Existence of Edge Length Limited Paths",
        "difficulty": 2,
        "answer": "        # edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]]\n        # queries = [[0,1,2],[0,2,5]]\n        # edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]]\n        # queries = [[0,1,2],[0,2,5]]\n        # edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]]\n        # queries = [[0,1,2],[0,2,5]]\n        # edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]]\n        # queries = [[0,1,2],[0,2,5]]\n        # edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]]\n        # queries = [[0,1,2],[0,2,5]]\n        # edgeList ="
    },
    {
        "number": 1700,
        "title": "Number of Students Unable to Eat Lunch",
        "difficulty": 0,
        "answer": "        \n        # Time: O(N)\n        # Space: O(N)\n        \n        # count = 0\n        # while sandwiches:\n        #     if students[0] == sandwiches[0]:\n        #         students.pop(0)\n        #         sandwiches.pop(0)\n        #     else:\n        #         students.append(students.pop(0))\n        #         sandwiches.append(sandwiches.pop(0))\n        #         count += 1\n        # return count\n        \n        # Time: O(N)\n        # Space: O(1)\n        \n        # count = 0\n        # while sandwiches and students:\n        #     if students[0] == sandwiches[0]:\n        #         students.pop(0)\n        #         sandwiches.pop(0)\n        #     else:\n        #         students.append(students.pop(0))\n        #         sandwiches.append(sandwiches.pop(0))\n        #         count += 1\n        # return count\n        \n"
    },
    {
        "number": 1701,
        "title": "Average Waiting Time",
        "difficulty": 1,
        "answer": "        # sort the customers by arrival time\n        customers.sort(key=lambda x: x[0])\n        # initialize the total waiting time\n        total_waiting_time = 0\n        # initialize the current time\n        current_time = 0\n        # loop through the customers\n        for customer in customers:\n            # update the total waiting time\n            total_waiting_time += customer[1] - current_time\n            # update the current time\n            current_time = customer[1]\n        # return the average waiting time\n        return total_waiting_time / len(customers)\n"
    },
    {
        "number": 1702,
        "title": "Maximum Binary String After Change",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(binary)\n        # if n == 1:\n        #     return binary\n        #\n        # for i in range(n):\n        #     if binary[i] == '0':\n        #         binary = binary[:i] + '1' + binary[i + 1:]\n        #         break\n        #\n        # for i in range(n):\n        #     if binary[i] == '1':\n        #         binary = binary[:i] + '0' + binary[i + 1:]\n        #         break\n        #\n        # return binary"
    },
    {
        "number": 1703,
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "difficulty": 2,
        "answer": "        # nums = [1,0,0,1,0,1]\n        # k = 2\n        # nums = [1,0,0,0,0,0,1,1]\n        # k = 3\n        # nums = [1,1,0,1]\n        # k = 2\n        # nums = [1,1,0,1]\n        # k = 3\n        # nums = [1,1,0,1]\n        # k = 2\n        # nums = [1,1,0,1]\n        # k = 3\n        # nums = [1,1,0,1]\n        # k = 2\n        # nums = [1,1,0,1]\n        # k = 3\n        # nums = [1,1,0,1]\n        # k = 2\n        # nums = [1,1,0,1]\n        # k = 3\n        # nums = [1,1,0,1]\n        # k = 2\n        # nums = [1"
    },
    {
        "number": 1704,
        "title": "Determine if String Halves Are Alike",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n        a = s[:len(s)//2]\n        b = s[len(s)//2:]\n        count_a = 0\n        count_b = 0\n        for i in a:\n            if i in vowels:\n                count_a += 1\n        for i in b:\n            if i in vowels:\n                count_b += 1\n        return count_a == count_b"
    },
    {
        "number": 1705,
        "title": "Maximum Number of Eaten Apples",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(days)\n        # for i in range(len(days)):\n        #     if days[i] == 0:\n        #         dp[i] = 0\n        #     else:\n        #         dp[i] = dp[i-1] + apples[i]\n        # return max(dp)"
    },
    {
        "number": 1706,
        "title": "Where Will the Ball Fall",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, d):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j]!= d:\n                return False\n            \n            grid[i][j] = -1\n            \n            if i == m - 1 and j == n - 1:\n                return True\n            \n            if d == 1:\n                if dfs(i + 1, j, d):\n                    return True\n                if dfs(i, j + 1, d):\n                    return True\n            else:\n                if dfs(i - 1, j, d):\n                    return True\n                if dfs(i, j - 1, d):\n                    return True\n            \n            grid[i][j] = d\n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 1):\n                    return [i, j]\n        \n        return [-1]\n        \n        \n        "
    },
    {
        "number": 1707,
        "title": "Maximum XOR With an Element From Array",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1710,
        "title": "Maximum Units on a Truck",
        "difficulty": 0,
        "answer": "        box_types = sorted(boxTypes, key=lambda x: x[1], reverse=True)\n        total_units = 0\n        for box_type in box_types:\n            if truckSize - box_type[0] >= 0:\n                truckSize -= box_type[0]\n                total_units += box_type[1]\n            else:\n                total_units += truckSize * box_type[1]\n                break\n        return total_units"
    },
    {
        "number": 1711,
        "title": "Count Good Meals",
        "difficulty": 1,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp"
    },
    {
        "number": 1712,
        "title": "Ways to Split Array Into Three Subarrays",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        n = len(nums)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1]) % MOD\n        return dp[0][n]"
    },
    {
        "number": 1713,
        "title": "Minimum Operations to Make a Subsequence",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1716,
        "title": "Calculate Money in Leetcode Bank",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 1717,
        "title": "Maximum Score From Removing Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        # for i in range(1, len(s) + 1):\n        #     for j in range(1, len(s) + 1):\n        #         if s[i - 1] == s[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[-1][-1] + max(x, y)"
    },
    {
        "number": 1718,
        "title": "Construct the Lexicographically Largest Valid Sequence",
        "difficulty": 1,
        "answer": "        \n        def construct(n):\n            if n == 1:\n                return [1]\n            \n            if n == 2:\n                return [1,2]\n            \n            if n == 3:\n                return [1,2,3]\n            \n            if n == 4:\n                return [1,2,3,4]\n            \n            if n == 5:\n                return [1,2,3,4,5]\n            \n            if n == 6:\n                return [1,2,3,4,5,6]\n            \n            if n == 7:\n                return [1,2,3,4,5,6,7]\n            \n            if n == 8:\n                return [1,2,3,4,5,6,7,8]\n            \n            if n == 9:\n                return [1,2,3,4,5,6,7,8,9]\n            \n            if n == 10:\n                return [1,2,3,4,5,6,7,8,9,10]\n            \n            "
    },
    {
        "number": 1719,
        "title": "Number Of Ways To Reconstruct A Tree",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(pairs)):\n        #     for j in range(i+1, len(pairs)):\n        #         if pairs[i][0] in dp and pairs[j][1] in dp[pairs[i][0]]:\n        #             return 0\n        #         if pairs[i][1] in dp and pairs[j][0] in dp[pairs[i][1]]:\n        #             return 0\n        #         dp[pairs[i][0]] = dp.get(pairs[i][0], set()) | {pairs[j][1]}\n        #         dp[pairs[i][1]] = dp.get(pairs[i][1], set()) | {pairs[j][0]}\n        # return 1"
    },
    {
        "number": 1720,
        "title": "Decode XORed Array",
        "difficulty": 0,
        "answer": "        n = len(encoded)\n        res = [first]\n        for i in range(1, n):\n            res.append(encoded[i] ^ res[i - 1])\n        return res"
    },
    {
        "number": 1721,
        "title": "Swapping Nodes in a Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the kth node from the beginning and the kth node from the end\n        kth_node_from_beginning = length - k\n        kth_node_from_end = k - 1\n        \n        # swap the kth node from the beginning and the kth node from the end\n        curr = head\n        for _ in range(kth_node_from_beginning):\n            curr = curr.next\n        \n        # swap the kth node from the end and the kth node from the beginning\n        prev = None\n        while curr and kth_node_from_end >= 0:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            kth_node_from_end -= 1\n        \n        # connect the new"
    },
    {
        "number": 1722,
        "title": "Minimize Hamming Distance After Swap Operations",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * len(source) for _ in range(len(target))]\n        # for i in range(len(source)):\n        #     for j in range(len(target)):\n        #         if source[i] == target[j]:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 1723,
        "title": "Find Minimum Time to Finish All Jobs",
        "difficulty": 2,
        "answer": "        jobs.sort()\n        n = len(jobs)\n        if k >= n:\n            return sum(jobs)\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + jobs[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + jobs[i - 1]\n        return dp[n][k]"
    },
    {
        "number": 1725,
        "title": "Number Of Rectangles That Can Form The Largest Square",
        "difficulty": 0,
        "answer": "        # sort by area\r\n        rectangles.sort(key=lambda x: x[0] * x[1], reverse=True)\r\n        # print(rectangles)\r\n        maxLen = 0\r\n        count = 0\r\n        for i in range(len(rectangles)):\r\n            if rectangles[i][0] * rectangles[i][1] > maxLen:\r\n                maxLen = rectangles[i][0] * rectangles[i][1]\r\n                count = 1\r\n            elif rectangles[i][0] * rectangles[i][1] == maxLen:\r\n                count += 1\r\n        return count\r\n\r\n\r\nclass Solution:\r\n    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:\r\n        \"\"\"\r\n        You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.\r\n        You can cut the ith rectangle to form a square with a side length of k if both k <= li and k"
    },
    {
        "number": 1726,
        "title": "Tuple with Same Product",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                dp[i][i + 1] = 1\n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i, j):\n                    dp[i][j] += dp[i][k] * dp[k + 1][j]\n        return sum(dp[0])"
    },
    {
        "number": 1727,
        "title": "Largest Submatrix With Rearrangements",
        "difficulty": 1,
        "answer": "        # Time: O(mn)\n        # Space: O(mn)\n        # dp = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         if matrix[i][j] == 1:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = 0\n        #\n        # for i in range(len(matrix)):\n        #     for j in range(len(matrix[0])):\n        #         for k in range(i, len(matrix)):\n        #             if matrix[k][j] == 1:\n        #                 dp[i][j] = max(dp[i][j], dp[k][j] + 1)\n        #\n        # return max([max(row) for row in dp])"
    },
    {
        "number": 1728,
        "title": "Cat and Mouse II",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[False] * len(grid[0]) for _ in range(len(grid))]\n        # dp[0][0] = True\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == 'C':\n        #             if i == 0:\n        #                 dp[i][j] = True\n        #             else:\n        #                 dp[i][j] = dp[i-1][j] and (grid[i][j] == '.' or dp[i-1][j-1])\n        #         elif grid[i][j] == 'M':\n        #             if j == 0:\n        #                 dp[i][j] = True\n        #             else:\n        #                 dp[i][j] = dp[i][j-1] and (grid[i][j] == '.' or dp"
    },
    {
        "number": 1732,
        "title": "Find the Highest Altitude",
        "difficulty": 0,
        "answer": "        # max_alt = 0\n        # for i in range(len(gain)):\n        #     if gain[i] > max_alt:\n        #         max_alt = gain[i]\n        # return max_alt\n        \n        # max_alt = 0\n        # for i in range(len(gain)):\n        #     if gain[i] > max_alt:\n        #         max_alt = gain[i]\n        # return max_alt\n        \n        # max_alt = 0\n        # for i in range(len(gain)):\n        #     if gain[i] > max_alt:\n        #         max_alt = gain[i]\n        # return max_alt\n        \n        # max_alt = 0\n        # for i in range(len(gain)):\n        #     if gain[i] > max_alt:\n        #         max_alt = gain[i]\n        # return max_alt\n        \n        # max_alt = 0\n        # for i in range(len(gain)):\n        #     if gain"
    },
    {
        "number": 1733,
        "title": "Minimum Number of People to Teach",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min("
    },
    {
        "number": 1734,
        "title": "Decode XORed Permutation",
        "difficulty": 1,
        "answer": "        n = len(encoded)\n        perm = [0] * n\n        for i in range(n):\n            perm[i] = encoded[i] ^ encoded[i + 1]\n        return perm\n"
    },
    {
        "number": 1735,
        "title": "Count Ways to Make Array With Product",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (len(queries) + 1) for _ in range(len(queries) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(queries) + 1):\n            for j in range(1, len(queries) + 1):\n                for k in range(1, len(queries) + 1):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k - 1]) % MOD\n        ans = []\n        for ni, ki in queries:\n            ans.append(dp[ni][ki])\n        return ans"
    },
    {
        "number": 1736,
        "title": "Latest Time by Replacing Hidden Digits",
        "difficulty": 0,
        "answer": "        time = time.replace('?', '2')\n        time = time.replace('?', '3')\n        time = time.replace('?', '9')\n        time = time.replace('?', '1')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time = time.replace('?', '9')\n        time ="
    },
    {
        "number": 1737,
        "title": "Change Minimum Characters to Satisfy One of Three Conditions",
        "difficulty": 1,
        "answer": "        # a = \"aba\"\n        # b = \"caa\"\n        # a = \"dabadd\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda\"\n        # a = \"aab\"\n        # b = \"cda"
    },
    {
        "number": 1738,
        "title": "Find Kth Largest XOR Coordinate Value",
        "difficulty": 1,
        "answer": "        # O(m*n)\n        # m, n = len(matrix), len(matrix[0])\n        # heap = []\n        # for i in range(m):\n        #     for j in range(n):\n        #         heapq.heappush(heap, (matrix[i][j], i, j))\n        #\n        # for _ in range(k):\n        #     _, i, j = heapq.heappop(heap)\n        #     matrix[i][j] = 0\n        # return matrix[0][0]"
    },
    {
        "number": 1739,
        "title": "Building Boxes",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 1742,
        "title": "Maximum Number of Balls in a Box",
        "difficulty": 0,
        "answer": "        if lowLimit > highLimit:\n            return 0\n        if lowLimit == highLimit:\n            return 1\n        if lowLimit == 1:\n            return 1\n        if lowLimit == 2:\n            return 2\n        if lowLimit == 3:\n            return 3\n        if lowLimit == 4:\n            return 4\n        if lowLimit == 5:\n            return 5\n        if lowLimit == 6:\n            return 6\n        if lowLimit == 7:\n            return 7\n        if lowLimit == 8:\n            return 8\n        if lowLimit == 9:\n            return 9\n        if lowLimit == 10:\n            return 10\n        if lowLimit == 11:\n            return 11\n        if lowLimit == 12:\n            return 12\n        if lowLimit == 13:\n            return 13\n        if lowLimit == 14:\n            return 14\n        if lowLimit == 15:\n            return 15\n        if lowLimit == 16:\n            return 16\n        if lowLimit == 17:\n            return 17\n        if lowLimit == 18:\n            return 18\n        if lowLimit == 19:\n"
    },
    {
        "number": 1743,
        "title": "Restore the Array From Adjacent Pairs",
        "difficulty": 1,
        "answer": "        n = len(adjacentPairs)\n        adjacentPairs.sort(key=lambda x: x[0])\n        nums = []\n        for i in range(n):\n            nums.append(adjacentPairs[i][0])\n            nums.append(adjacentPairs[i][1])\n        return nums"
    },
    {
        "number": 1744,
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[False] * (len(candiesCount) + 1) for _ in range(len(queries) + 1)]\n        # for i in range(len(candiesCount) + 1):\n        #     dp[0][i] = True\n        # for i in range(len(queries) + 1):\n        #     dp[i][0] = True\n        # for i in range(1, len(queries) + 1):\n        #     for j in range(1, len(candiesCount) + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if j >= queries[i - 1][0]:\n        #             dp[i][j] = dp[i][j] or dp[i - 1][j - queries[i - 1][0]]\n        #         if j >= queries[i - 1][1]:\n        #             dp[i][j] = dp[i][j] or"
    },
    {
        "number": 1745,
        "title": "Palindrome Partitioning IV",
        "difficulty": 2,
        "answer": "        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def isPalindrome2(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome3(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome4(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome5(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome6(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome7(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome8(s):\n            return s == ''.join(reversed(s))\n        \n        def isPalindrome9(s):\n            return s == ''.join(reversed(s))\n        \n        def is"
    },
    {
        "number": 1748,
        "title": "Sum of Unique Elements",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # nums = set(nums)\n        # return sum(nums)"
    },
    {
        "number": 1749,
        "title": "Maximum Absolute Sum of Any Subarray",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # max_sum = 0\n        # for i in range(len(nums)):\n        #     max_sum = max(max_sum, nums[i])\n        #     nums[i] = max_sum\n        # return max_sum"
    },
    {
        "number": 1750,
        "title": "Minimum Length of String After Deleting Similar Ends",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dp:\n        #         dp[s[i]] = i\n        #     else:\n        #         dp[s[i]] = min(dp[s[i]], i)\n        #\n        # for i in range(len(s)):\n        #     if s[i] not in dp:\n        #         continue\n        #     else:\n        #         if i - dp[s[i]] > 1:\n        #             return i - dp[s[i]]\n        # return len(s)"
    },
    {
        "number": 1751,
        "title": "Maximum Number of Events That Can Be Attended II",
        "difficulty": 2,
        "answer": "        events.sort(key=lambda x: x[0])\n        n = len(events)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = events[i][2]\n            for j in range(i):\n                if events[i][0] < events[j][1]:\n                    dp[i] = max(dp[i], dp[j] + events[i][2])\n        return max(dp)"
    },
    {
        "number": 1752,
        "title": "Check if Array Is Sorted and Rotated",
        "difficulty": 0,
        "answer": "        # if len(nums) == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # if len(nums) == 2:\n        #     return nums[0] <= nums[1]\n        # if len(nums) == 3:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2]\n        # if len(nums) == 4:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2] and nums[2] <= nums[3]\n        # if len(nums) == 5:\n        #     return nums[0] <= nums[1] and nums[1] <= nums[2] and nums[2] <= nums[3] and nums[3] <= nums[4]\n        # if len(nums) == 6:\n        #     return nums[0] <= nums[1] and nums"
    },
    {
        "number": 1753,
        "title": "Maximum Score From Removing Stones",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + b[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + c[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i] + b[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i] + c[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + b[i] + c[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i]["
    },
    {
        "number": 1754,
        "title": "Largest Merge Of Two Strings",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m = len(word1)\n        # n = len(word2)\n        # res = []\n        # for i in range(m+n):\n        #     if i < m:\n        #         res.append(word1[i])\n        #     else:\n        #         res.append(word2[i-m])\n        # return \"\".join(res)"
    },
    {
        "number": 1755,
        "title": "Closest Subsequence Sum",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1758,
        "title": "Minimum Changes To Make Alternating Binary String",
        "difficulty": 0,
        "answer": "        # if len(s) == 1:\n        #     return 0\n        # if len(s) == 2:\n        #     if s[0] == s[1]:\n        #         return 0\n        #     else:\n        #         return 1\n        # if len(s) == 3:\n        #     if s[0] == s[1] and s[1] == s[2]:\n        #         return 0\n        #     elif s[0] == s[1] or s[1] == s[2]:\n        #         return 1\n        #     else:\n        #         return 2\n        # if len(s) == 4:\n        #     if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n        #         return 0\n        #     elif s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:\n        #         return 1\n        #     else:\n        #         return 2\n        #"
    },
    {
        "number": 1759,
        "title": "Count Number of Homogenous Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n)\r\n        # Space: O(n)\r\n        # dp = {}\r\n        # count = 0\r\n        # for i in range(len(s)):\r\n        #     if s[i] not in dp:\r\n        #         dp[s[i]] = 1\r\n        #     else:\r\n        #         dp[s[i]] += 1\r\n        #     count += dp[s[i]]\r\n        # return count % (10**9 + 7)\r\n\r\n        # Time: O(n)\r\n        # Space: O(n)\r\n        # dp = {}\r\n        # count = 0\r\n        # for i in range(len(s)):\r\n        #     if s[i] not in dp:\r\n        #         dp[s[i]] = 1\r\n        #     else:\r\n        #         dp[s[i]] += 1\r\n        #     count += dp[s[i]]\r\n        # return count\r\n\r\n        # Time:"
    },
    {
        "number": 1760,
        "title": "Minimum Limit of Balls in a Bag",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * (maxOperations + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, maxOperations + 1):\n        #         if j == 1:\n        #             dp[i][j] = nums[i - 1]\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + nums[i - 1])\n        \n        # return dp[-1][-1]\n        \n        # dp = [[0] * (maxOperations + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, maxOperations + 1):\n        #         if j == 1:"
    },
    {
        "number": 1761,
        "title": "Minimum Degree of a Connected Trio in a Graph",
        "difficulty": 2,
        "answer": "        # graph = defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, visited, graph, degree):\n        #     visited.add(node)\n        #     for nei in graph[node]:\n        #         if nei not in visited:\n        #             dfs(nei, visited, graph, degree)\n        #     degree[node] += 1\n        #\n        # def dfs_count(node, graph, degree):\n        #     visited = set()\n        #     dfs(node, visited, graph, degree)\n        #     return degree[node]\n        #\n        # def dfs_count_2(node, graph, degree):\n        #     visited = set()\n        #     visited.add(node)\n        #     for nei in graph[node]:\n        #         if nei not in visited:\n        #             dfs_count_2(nei, graph"
    },
    {
        "number": 1763,
        "title": "Longest Nice Substring",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] = i\n        #     else:\n        #         dp[s[i]] = i\n        #\n        # max_len = 0\n        # max_start = 0\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         if i - dp[s[i]] > max_len:\n        #             max_len = i - dp[s[i]]\n        #             max_start = dp[s[i]]\n        # return s[max_start:max_start + max_len]"
    },
    {
        "number": 1764,
        "title": "Form Array by Concatenating Subarrays of Another Array",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not groups:\n        #     return False\n        # if not nums:\n        #     return False\n        #\n        # groups_set = set(groups)\n        # nums_set = set(nums)\n        #\n        # for group in groups:\n        #     if group in groups_set:\n        #         continue\n        #     if group[0] in nums_set:\n        #         return False\n        #\n        # for num in nums:\n        #     if num in nums_set:\n        #         continue\n        #     if num in groups_set:\n        #         return False\n        #\n        # return True"
    },
    {
        "number": 1765,
        "title": "Map of Highest Peak",
        "difficulty": 1,
        "answer": "        m, n = len(isWater), len(isWater[0])\n        \n        def dfs(i, j, height):\n            if i < 0 or i >= m or j < 0 or j >= n or isWater[i][j] == 1:\n                return\n            \n            isWater[i][j] = height\n            dfs(i-1, j, height+1)\n            dfs(i+1, j, height+1)\n            dfs(i, j-1, height+1)\n            dfs(i, j+1, height+1)\n        \n        dfs(0, 0, 0)\n        \n        return isWater"
    },
    {
        "number": 1766,
        "title": "Tree of Coprimes",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            if node == parent:\n                return -1\n            \n            for child in graph[node]:\n                if child == parent:\n                    continue\n                \n                if nums[node] % nums[child] == 0:\n                    return dfs(child, node)\n            \n            return node\n        \n        ans = [-1] * n\n        for i in range(n):\n            ans[i] = dfs(i, -1)\n        return ans"
    },
    {
        "number": 1768,
        "title": "Merge Strings Alternately",
        "difficulty": 0,
        "answer": "        if len(word1) < len(word2):\n            return word1 + word2 + word1\n        else:\n            return word2 + word1 + word2"
    },
    {
        "number": 1769,
        "title": "Minimum Number of Operations to Move All Balls to Each Box",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1],"
    },
    {
        "number": 1770,
        "title": "Maximum Score from Performing Multiplication Operations",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1771,
        "title": "Maximize Palindrome Length From Subsequences",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        # for i in range(len(word1) + 1):\n        #     for j in range(len(word2) + 1):\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 0\n        #         elif word1[i - 1] == word2[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 2\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 1773,
        "title": "Count Items Matching a Rule",
        "difficulty": 0,
        "answer": "        count = 0\n        for item in items:\n            if ruleKey == \"type\" and ruleValue == item[0]:\n                count += 1\n            elif ruleKey == \"color\" and ruleValue == item[1]:\n                count += 1\n            elif ruleKey == \"name\" and ruleValue == item[2]:\n                count += 1\n        return count"
    },
    {
        "number": 1774,
        "title": "Closest Dessert Cost",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n * m * log(n * m))\n        # Space: O(n * m)\n        # n = len(baseCosts)\n        # m = len(toppingCosts)\n        # dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n        # dp[0][0] = 0\n        # for i in range(1, n + 1):\n        #     dp[i][0] = dp[i - 1][0] + baseCosts[i - 1]\n        # for i in range(1, m + 1):\n        #     dp[0][i] = dp[0][i - 1] + toppingCosts[i - 1]\n        # for i in range(1, n + 1):\n        #     for j in range(1, m + 1):\n        #         dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + baseCosts[i - 1] +"
    },
    {
        "number": 1775,
        "title": "Equal Sum Arrays With Minimum Number of Operations",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        # dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]\n        # for i in range(len(nums1) - 1, -1, -1):\n        #     for j in range(len(nums2) - 1, -1, -1):\n        #         if nums1[i] == nums2[j]:\n        #             dp[i][j] = dp[i + 1][j + 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\n        # return dp[0][0]\n        \n        # O(n)\n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 ="
    },
    {
        "number": 1776,
        "title": "Car Fleet II",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort by speed\n        cars.sort(key=lambda x: x[1])\n        # print(cars)\n        # print(cars[0][1])\n        # print(cars[-1][1])\n        # print(cars[0][0])\n        # print(cars[-1][0])\n        # print(cars[0][1] - cars[-1][1])\n        # print(cars[0][0] - cars[-1][0])\n        # print(cars[0][1] - cars[-1][1])\n        # print(cars[0][0] - cars[-1][0])\n        # print(cars[0][1] - cars[-1][1])\n        # print(cars[0][0] - cars[-1][0])\n        # print(cars[0][1] - cars[-1][1])\n        # print(cars[0][0] - cars[-1][0])\n        # print(cars["
    },
    {
        "number": 1779,
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "difficulty": 0,
        "answer": "        \n        def dist(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        def valid(x, y, points):\n            for i in range(len(points)):\n                if dist(x, y, points[i][0], points[i][1]) == 1:\n                    return True\n            return False\n        \n        min_dist = float('inf')\n        min_idx = -1\n        for i in range(len(points)):\n            if valid(x, y, points[i]):\n                cur_dist = dist(x, y, points[i][0], points[i][1])\n                if cur_dist < min_dist:\n                    min_dist = cur_dist\n                    min_idx = i\n        return min_idx\n"
    },
    {
        "number": 1780,
        "title": "Check if Number is a Sum of Powers of Three",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return True\n        if n == 22:\n            "
    },
    {
        "number": 1781,
        "title": "Sum of Beauty of All Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(i, len(s)):\n        #         dp[i][s[j]] = dp[i].get(s[j], 0) + 1\n        #\n        # res = 0\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         res += min(dp[i].get(s[j], 0), dp[j].get(s[i], 0))\n        # return res"
    },
    {
        "number": 1782,
        "title": "Count Pairs Of Nodes",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1784,
        "title": "Check if Binary String Has at Most One Segment of Ones",
        "difficulty": 0,
        "answer": "        ones = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                ones += 1\n            else:\n                ones = 0\n            if ones > 1:\n                return False\n        return True"
    },
    {
        "number": 1785,
        "title": "Minimum Elements to Add to Form a Given Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # left = 0\n        # right = len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] <= limit:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left"
    },
    {
        "number": 1786,
        "title": "Number of Restricted Paths From First to Last Node",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs + bfs\n        # dfs + bfs + dfs\n        # dfs + bfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + d"
    },
    {
        "number": 1787,
        "title": "Make the XOR of All Segments Equal to Zero",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR of a segment\n        # Time: O(n)\n        # Space: O(n)\n        \n        # XOR"
    },
    {
        "number": 1790,
        "title": "Check if One String Swap Can Make Strings Equal",
        "difficulty": 0,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if s1 == s2[::-1]:\n            return True\n        if s1 == s2[::-1][::-1]:\n            return True\n        if s1 == s2[::-1][::-1][::-1]:\n            return True\n        if s1 == s2[::-1][::-1][::-1][::-1]:\n            return True\n        return False"
    },
    {
        "number": 1791,
        "title": "Find Center of Star Graph",
        "difficulty": 0,
        "answer": "        n = len(edges)\n        visited = set()\n        for i in range(n):\n            visited.add(edges[i][0])\n            visited.add(edges[i][1])\n        for i in range(n):\n            if edges[i][0] not in visited:\n                return edges[i][0]\n            if edges[i][1] not in visited:\n                return edges[i][1]\n        return -1"
    },
    {
        "number": 1792,
        "title": "Maximum Average Pass Ratio",
        "difficulty": 1,
        "answer": "        # sort by class size\n        classes.sort(key=lambda x: x[1], reverse=True)\n        # sort by class pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1], reverse=True)\n        # sort by class average pass ratio\n        classes.sort(key=lambda x: x[0] / x[1"
    },
    {
        "number": 1793,
        "title": "Maximum Score of a Good Subarray",
        "difficulty": 2,
        "answer": "        # O(n)\n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     dp[i] = min(dp[i-1], nums[i])\n        # return max(dp) * (len(nums) - k)\n        \n        # O(n)\n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     dp[i] = min(dp[i-1], nums[i])\n        # return max(dp) * (len(nums) - k)\n        \n        # O(n)\n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     dp[i] = min("
    },
    {
        "number": 1796,
        "title": "Second Largest Digit in a String",
        "difficulty": 0,
        "answer": "        # s = \"dfa12321afd\"\n        # s = \"abc1111\"\n        # s = \"a1b2c3d4e5f6g7h8i9j0\"\n        # s = \"a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8i9j0a1b2c3d4e5f6g7h8"
    },
    {
        "number": 1797,
        "title": "Design Authentication Manager",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1798,
        "title": "Maximum Number of Consecutive Values You Can Make",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max("
    },
    {
        "number": 1799,
        "title": "Maximize Score After N Operations",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + nums[i] * gcd(nums[i], nums[j])\n        return dp[0][n - 1]"
    },
    {
        "number": 1800,
        "title": "Maximum Ascending Subarray Sum",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # max_sum = 0\n        # for i in range(len(nums)):\n        #     max_sum = max(max_sum, nums[i] + max(nums[i+1:]) )\n        # return max_sum"
    },
    {
        "number": 1801,
        "title": "Number of Orders in the Backlog",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[0] * (len(orders) + 1) for _ in range(len(orders) + 1)]\n        # for i in range(1, len(orders) + 1):\n        #     for j in range(1, len(orders) + 1):\n        #         if orders[i - 1][2] == 0:\n        #             dp[i][j] = dp[i][j - 1]\n        #         else:\n        #             dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + orders[i - 1][0]\n        # return dp[-1][-1] % (10**9 + 7)"
    },
    {
        "number": 1802,
        "title": "Maximum Value at a Given Index in a Bounded Array",
        "difficulty": 1,
        "answer": "        # dp = [[0] * (maxSum + 1) for _ in range(n + 1)]\n        # dp[0][0] = 1\n        # for i in range(1, n + 1):\n        #     for j in range(maxSum + 1):\n        #         if j - nums[i - 1] >= 0:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + 1)\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[n][maxSum]"
    },
    {
        "number": 1803,
        "title": "Count Pairs With XOR in a Range",
        "difficulty": 2,
        "answer": "        def count(nums, low, high):\n            count = 0\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if low <= (nums[i] ^ nums[j]) <= high:\n                        count += 1\n            return count\n        \n        return count(nums, low, high) + count(nums, high, low)"
    },
    {
        "number": 1805,
        "title": "Number of Different Integers in a String",
        "difficulty": 0,
        "answer": "        if not word:\n            return 0\n        \n        word = word.replace(' ', '')\n        word = word.replace('0', '')\n        word = word.replace('1', '')\n        word = word.replace('2', '')\n        word = word.replace('3', '')\n        word = word.replace('4', '')\n        word = word.replace('5', '')\n        word = word.replace('6', '')\n        word = word.replace('7', '')\n        word = word.replace('8', '')\n        word = word.replace('9', '')\n        \n        return len(set(word))"
    },
    {
        "number": 1806,
        "title": "Minimum Number of Operations to Reinitialize a Permutation",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 1807,
        "title": "Evaluate the Bracket Pairs of a String",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for i in range(len(s)):\n        #     if s[i] == \"(\":\n        #         stack.append(i)\n        #     elif s[i] == \")\":\n        #         start = stack.pop()\n        #         s = s[:start] + s[i+1:]\n        #         s = s[:start] + \"?\" + s[start+1:]\n        # return s"
    },
    {
        "number": 1808,
        "title": "Maximize Number of Nice Divisors",
        "difficulty": 2,
        "answer": "        def is_prime(n):\r\n            if n == 1:\r\n                return False\r\n            for i in range(2, int(n**0.5)+1):\r\n                if n % i == 0:\r\n                    return False\r\n            return True\r\n        \r\n        def get_prime_factors(n):\r\n            prime_factors = []\r\n            while n % 2 == 0:\r\n                prime_factors.append(2)\r\n                n = n // 2\r\n            for i in range(3, int(n**0.5)+1, 2):\r\n                while n % i == 0:\r\n                    prime_factors.append(i)\r\n                    n = n // i\r\n            if n > 2:\r\n                prime_factors.append(n)\r\n            return prime_factors\r\n        \r\n        def get_divisors(n):\r\n            divisors = []\r\n            for i in range(1, n+1):\r\n                if n % i == 0:\r\n                    divisors."
    },
    {
        "number": 1812,
        "title": "Determine Color of a Chessboard Square",
        "difficulty": 0,
        "answer": "        return coordinates[0] in ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] and coordinates[1] in ['1', '2', '3', '4', '5', '6', '7', '8']"
    },
    {
        "number": 1813,
        "title": "Sentence Similarity III",
        "difficulty": 1,
        "answer": "        if len(sentence1)!= len(sentence2):\n            return False\n        if sentence1 == sentence2:\n            return True\n        if sentence1 == \"\":\n            return sentence2 == \"\"\n        if sentence2 == \"\":\n            return sentence1 == \"\"\n        if sentence1[0] == sentence2[0]:\n            return self.areSentencesSimilar(sentence1[1:], sentence2[1:])\n        else:\n            return False"
    },
    {
        "number": 1814,
        "title": "Count Nice Pairs in an Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == nums[j] + nums[i]:\n                    res += 1\n        return res % (10 ** 9 + 7)\n"
    },
    {
        "number": 1815,
        "title": "Maximum Number of Groups Getting Fresh Donuts",
        "difficulty": 2,
        "answer": "        # dp[i] = max happy groups ending with group i\n        # dp[i] = max happy groups ending with group i + dp[i-1]\n        # dp[i] = max happy groups ending with group i + dp[i-1] + dp[i-2]\n        # dp[i] = max happy groups ending with group i + dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = max happy groups ending with group i + dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = max happy groups ending with group i + dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = max happy groups ending with group i + dp[i-1] + dp[i-2] + dp"
    },
    {
        "number": 1816,
        "title": "Truncate Sentence",
        "difficulty": 0,
        "answer": "        return''.join(s.split()[:k])"
    },
    {
        "number": 1817,
        "title": "Finding the Users Active Minutes",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        #"
    },
    {
        "number": 1818,
        "title": "Minimum Absolute Sum Difference",
        "difficulty": 1,
        "answer": "        nums1_len = len(nums1)\n        nums2_len = len(nums2)\n        if nums1_len == 0 or nums2_len == 0:\n            return 0\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(nums1[i] - nums2[j])\n        dp = [[0] * (nums2_len + 1) for _ in range(nums1_len + 1)]\n        \n        for i in range(1, nums1_len + 1):\n            dp[i][0] = dp[i - 1][0] + abs(nums1[i - 1] - nums2[0])\n        \n        for j in range(1, nums2_len + 1):\n            dp[0][j] = dp[0][j - 1] + abs(nums1[0] - nums2[j - 1])\n        \n        for i in range(1, num"
    },
    {
        "number": 1819,
        "title": "Number of Different Subsequences GCDs",
        "difficulty": 2,
        "answer": "        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)"
    },
    {
        "number": 1822,
        "title": "Sign of the Product of an Array",
        "difficulty": 0,
        "answer": "        # return 1 if all(x > 0 for x in nums) else -1 if all(x < 0 for x in nums) else 0\n        return 1 if all(x > 0 for x in nums) else -1 if all(x < 0 for x in nums) else 0\n"
    },
    {
        "number": 1823,
        "title": "Find the Winner of the Circular Game",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if k == 1:\n            return 1\n        if k == n:\n            return n\n        if k > n:\n            return -1\n        if k == 2:\n            return n\n        if k == 3:\n            return 1\n        if k == 4:\n            return 1\n        if k == 5:\n            return 1\n        if k == 6:\n            return 1\n        if k == 7:\n            return 1\n        if k == 8:\n            return 1\n        if k == 9:\n            return 1\n        if k == 10:\n            return 1\n        if k == 11:\n            return 1\n        if k == 12:\n            return 1\n        if k == 13:\n            return 1\n        if k == 14:\n            return 1\n        if k == 15:\n            return 1\n        if k == 16:\n            return 1\n        if k == 17:\n            return 1\n        if k == 18:\n            return 1\n        if k == 19:\n            return 1\n        if k == 20:\n"
    },
    {
        "number": 1824,
        "title": "Minimum Sideway Jumps",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(n + 1):\n        #     dp[i][i] = 1\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n + 1):\n        #         if obstacles[i] == 0:\n        #             dp[i][j] = dp[i + 1][j]\n        #         else:\n        #             dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n        # return dp[0][n]"
    },
    {
        "number": 1825,
        "title": "Finding MK Average",
        "difficulty": 2,
        "answer": "    def addElement(self, num: int) -> None:\n    def calculateMKAverage(self) -> int:\n        \"\"\"\n        You are given two integers, m and k, and a stream of integers. You are tasked to implement a data structure that calculates the MKAverage for the stream.\n        The MKAverage can be calculated using these steps:\n            If the number of the elements in the stream is less than m you should consider the MKAverage to be -1. Otherwise, copy the last m elements of the stream to a separate container.\n            Remove the smallest k elements and the largest k elements from the container.\n            Calculate the average value for the rest of the elements rounded down to the nearest integer.\n        Implement the MKAverage class:\n            MKAverage(int m, int k) Initializes the MKAverage object with an empty stream and the two integers m and k.\n            void addElement(int num) Inserts a new element num into the stream.\n            int calculateMKAverage() Calculates and returns the MKAverage for the current stream rounded down to the nearest integer.\n        Example 1:\n        Input\n        [\""
    },
    {
        "number": 1827,
        "title": "Minimum Operations to Make the Array Increasing",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1: return 0\n        if n == 2: return 1 if nums[1] > nums[0] else 2\n        if n == 3: return 1 if nums[2] > nums[1] else 2\n        if n == 4: return 1 if nums[3] > nums[2] else 2\n        if n == 5: return 1 if nums[4] > nums[3] else 2\n        if n == 6: return 1 if nums[5] > nums[4] else 2\n        if n == 7: return 1 if nums[6] > nums[5] else 2\n        if n == 8: return 1 if nums[7] > nums[6] else 2\n        if n == 9: return 1 if nums[8] > nums[7] else 2\n        if n == 10: return 1 if nums[9] > nums[8] else 2\n        if n == 11: return 1 if nums[10] > nums[9] else 2\n        if"
    },
    {
        "number": 1828,
        "title": "Queries on Number of Points Inside a Circle",
        "difficulty": 1,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 1829,
        "title": "Maximum XOR for Each Query",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return []\n        # n = len(nums)\n        # if n == 1:\n        #     return [0]\n        # if n == 2:\n        #     return [nums[0] ^ nums[1]]\n        # if n == 3:\n        #     return [nums[0] ^ nums[1] ^ nums[2]]\n        # if n == 4:\n        #     return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3]]\n        # if n == 5:\n        #     return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3] ^ nums[4]]\n        # if n == 6:\n        #     return [nums[0] ^ nums[1] ^ nums[2] ^ nums[3] ^ nums[4] ^ nums[5]]\n        "
    },
    {
        "number": 1830,
        "title": "Minimum Number of Operations to Make String Sorted",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if s[0] < s[1] else 2\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] < s[j]:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 1832,
        "title": "Check if the Sentence Is Pangram",
        "difficulty": 0,
        "answer": "        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        return set(alphabet) <= set(sentence.lower())"
    },
    {
        "number": 1833,
        "title": "Maximum Ice Cream Bars",
        "difficulty": 1,
        "answer": "        # costs.sort()\n        # print(costs)\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n        # print(costs[::-1])\n        # print(coins)\n"
    },
    {
        "number": 1834,
        "title": "Single-Threaded CPU",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort by enqueue time\n        tasks.sort(key=lambda x: x[0])\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n        # print(tasks)\n"
    },
    {
        "number": 1835,
        "title": "Find XOR Sum of All Pairs Bitwise AND",
        "difficulty": 2,
        "answer": "        xor_sum = 0\n        for i in range(len(arr1)):\n            xor_sum ^= arr1[i] & arr2[i]\n        return xor_sum"
    },
    {
        "number": 1837,
        "title": "Sum of Digits in Base K",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n < 0:\n            return -self.sumBase(-n, k)\n        if k == 1:\n            return n\n        if k == 2:\n            return n + n\n        if k == 3:\n            return n + n + n\n        if k == 4:\n            return n + n + n + n\n        if k == 5:\n            return n + n + n + n + n\n        if k == 6:\n            return n + n + n + n + n + n\n        if k == 7:\n            return n + n + n + n + n + n + n\n        if k == 8:\n            return n + n + n + n + n + n + n + n\n        if k == 9:\n            return n + n + n + n + n + n + n + n + n\n        if k == 10:\n            return n + n + n + n + n + n + n + n + n + n\n        if k == 11:\n            return n + n + n + n + n +"
    },
    {
        "number": 1838,
        "title": "Frequency of the Most Frequent Element",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1839,
        "title": "Longest Substring Of All Vowels in Order",
        "difficulty": 1,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        n = len(word)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            for j in range(i):\n                if word[j] in vowels and word[i] in vowels:\n                    dp[j][i] = max(dp[j][i], dp[j + 1][i - 1] + 1)\n        return max(max(row) for row in dp)"
    },
    {
        "number": 1840,
        "title": "Maximum Building Height",
        "difficulty": 2,
        "answer": "        \n        # dp[i] = max height of building i\n        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3, dp[i-5] + 4)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3, dp[i-5] + 4, dp[i-6] + 5)"
    },
    {
        "number": 1844,
        "title": "Replace All Digits with Characters",
        "difficulty": 0,
        "answer": "        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c3d4e\"\n        # s = \"a1b2c"
    },
    {
        "number": 1845,
        "title": "Seat Reservation Manager",
        "difficulty": 1,
        "answer": "        # Your SeatManager object will be instantiated and called as such:\n        # obj = SeatManager(n)\n        # param_1 = obj.reserve()\n        # obj.unreserve(seatNumber)\n        # @lc code=end"
    },
    {
        "number": 1846,
        "title": "Maximum Element After Decreasing and Rearranging",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not arr:\n        #     return 0\n        # arr.sort()\n        # for i in range(1, len(arr)):\n        #     if arr[i] - arr[i - 1] > 1:\n        #         arr[i] = arr[i - 1] + 1\n        # return max(arr)"
    },
    {
        "number": 1847,
        "title": "Closest Room",
        "difficulty": 2,
        "answer": "        \n        def dist(room, query):\n            return abs(room[0] - query[0]) + abs(room[1] - query[1])\n        \n        rooms = sorted(rooms, key=lambda x: x[1])\n        \n        ans = []\n        for query in queries:\n            i = bisect.bisect_left(rooms, query)\n            if i == len(rooms):\n                ans.append(-1)\n            else:\n                ans.append(rooms[i][0])\n        return ans"
    },
    {
        "number": 1848,
        "title": "Minimum Distance to the Target Element",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        #\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] == target:\n        #         return abs(mid - start)\n        #     elif nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return abs(left - start)"
    },
    {
        "number": 1849,
        "title": "Splitting a String Into Descending Consecutive Values",
        "difficulty": 1,
        "answer": "        # if len(s) == 1:\n        #     return False\n        # if len(s) == 2:\n        #     return True\n        # if len(s) == 3:\n        #     return True\n        # if len(s) == 4:\n        #     return True\n        # if len(s) == 5:\n        #     return True\n        # if len(s) == 6:\n        #     return True\n        # if len(s) == 7:\n        #     return True\n        # if len(s) == 8:\n        #     return True\n        # if len(s) == 9:\n        #     return True\n        # if len(s) == 10:\n        #     return True\n        # if len(s) == 11:\n        #     return True\n        # if len(s) == 12:\n        #     return True\n        # if len(s) == 13:\n        #     return True\n        # if len(s) == 14:\n        #     return True\n        # if len(s) == 15:\n        "
    },
    {
        "number": 1850,
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "difficulty": 1,
        "answer": "        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k ="
    },
    {
        "number": 1851,
        "title": "Minimum Interval to Include Each Query",
        "difficulty": 2,
        "answer": "        # sort intervals by endpoints\n        intervals.sort(key=lambda x: x[1])\n        # sort queries by endpoints\n        queries.sort()\n        # create a list of intervals\n        intervals_list = []\n        for i in range(len(intervals)):\n            intervals_list.append([intervals[i][0], intervals[i][1]])\n        # create a list of queries\n        queries_list = []\n        for i in range(len(queries)):\n            queries_list.append(queries[i])\n        # create a list of intervals\n        intervals_list.sort(key=lambda x: x[0])\n        # create a list of queries\n        queries_list.sort()\n        # create a list of intervals\n        intervals_list_sorted = []\n        for i in range(len(intervals_list)):\n            intervals_list_sorted.append([intervals_list[i][0], intervals_list[i][1]])\n        # create a list of queries\n        "
    },
    {
        "number": 1854,
        "title": "Maximum Population Year",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(logs)\n        # logs.sort(key=lambda x: (x[0], x[1]))\n        # max_pop = 0\n        # for i in range(n):\n        #     if logs[i][0] <= logs[i][1]:\n        #         max_pop = max(max_pop, logs[i][1] - logs[i][0] + 1)\n        # return logs[0][0] if max_pop > 0 else -1\n        \n        # Time: O(nlog(n))\n        # Space: O(n)\n        # n = len(logs)\n        # logs.sort(key=lambda x: (x[0], x[1]))\n        # max_pop = 0\n        # for i in range(n):\n        #     if logs[i][0] <= logs[i][1]:\n        #         max_pop = max(max_pop, logs[i][1] - logs[i]["
    },
    {
        "number": 1855,
        "title": "Maximum Distance Between a Pair of Values",
        "difficulty": 1,
        "answer": "        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        max_dist = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                max_dist = max(max_dist, j - i)\n                i += 1\n            else:\n                j += 1\n        return max_dist"
    },
    {
        "number": 1856,
        "title": "Maximum Subarray Min-Product",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # min_product = float('inf')\n        # max_product = float('-inf')\n        # for i in range(len(nums)):\n        #     min_product = min(min_product, nums[i])\n        #     max_product = max(max_product, nums[i] * (i + 1))\n        # return max_product - min_product"
    },
    {
        "number": 1857,
        "title": "Largest Color Value in a Directed Graph",
        "difficulty": 2,
        "answer": "        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs\r\n        # dfs + bfs"
    },
    {
        "number": 1859,
        "title": "Sorting the Sentence",
        "difficulty": 0,
        "answer": "        s = s.split()\n        s = sorted(s, key=lambda x: (x[0].lower(), int(x[1:])))\n        return \" \".join(s)"
    },
    {
        "number": 1860,
        "title": "Incremental Memory Leak",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0, 0], [0, 0]]\n        # dp[0][0] = memory1\n        # dp[0][1] = memory2\n        # dp[1][0] = memory2\n        # dp[1][1] = memory1\n        # for i in range(2, n + 1):\n        #     dp[0][0] = max(dp[0][0], dp[1][0] + 1)\n        #     dp[0][1] = max(dp[0][1], dp[1][1] + 1)\n        #     dp[1][0] = max(dp[1][0], dp[0][0] + 1)\n        #     dp[1][1] = max(dp[1][1], dp[0][1] + 1)\n        # return [max(dp[0][0], dp[1][0]), dp[0][0], dp[1][1]]"
    },
    {
        "number": 1861,
        "title": "Rotating the Box",
        "difficulty": 1,
        "answer": "        m, n = len(box), len(box[0])\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '*':\n                    box[i][j] = '.'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '#':\n                    box[i][j] = '*'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '.':\n                    box[i][j] = '#'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '*':\n                    box[i][j] = '#'\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '#':\n                    box[i][j] = '*'\n        for i in range(m):\n            for j in range(n):\n                if"
    },
    {
        "number": 1862,
        "title": "Sum of Floored Pairs",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                res += (nums[i] // nums[j])\n        return res % (10 ** 9 + 7)"
    },
    {
        "number": 1863,
        "title": "Sum of All Subset XOR Totals",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        nums.sort()\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] ^ dp[i][j - 1]\n        return sum(map(sum, dp))"
    },
    {
        "number": 1864,
        "title": "Minimum Number of Swaps to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        # if len(s) == 1:\n        #     return 0\n        #\n        # count = 0\n        # for i in range(len(s) - 1):\n        #     if s[i]!= s[i + 1]:\n        #         count += 1\n        #         if count > 1:\n        #             return -1\n        # return count"
    },
    {
        "number": 1865,
        "title": "Finding Pairs With a Certain Sum",
        "difficulty": 1,
        "answer": "    def add(self, index: int, val: int) -> None:\n    def count(self, tot: int) -> int:\n        \"\"\"\n        You are given two integer arrays nums1 and nums2. You are tasked to implement a data structure that supports queries of two types:\n            Add a positive integer to an element of a given index in the array nums2.\n            Count the number of pairs (i, j) such that nums1[i] + nums2[j] equals a given value (0 <= i < nums1.length and 0 <= j < nums2.length).\n        Implement the FindSumPairs class:\n            FindSumPairs(int[] nums1, int[] nums2) Initializes the FindSumPairs object with two integer arrays nums1 and nums2.\n            void add(int index, int val) Adds val to nums2[index], i.e., apply nums2[index] += val.\n            int count(int tot) Returns the number of pairs (i, j) such that nums1[i] + nums"
    },
    {
        "number": 1866,
        "title": "Number of Ways to Rearrange Sticks With K Sticks Visible",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        if k == n:\n            return 1\n        if k > n:\n            return 0\n        if k == 0:\n            return 1\n        if k == 2:\n            return n - 1\n        if k == 3:\n            return n - 2\n        if k == 4:\n            return n - 3\n        if k == 5:\n            return n - 4\n        if k == 6:\n            return n - 5\n        if k == 7:\n            return n - 6\n        if k == 8:\n            return n - 7\n        if k == 9:\n            return n - 8\n        if k == 10:\n            return n - 9\n        if k == 11:\n            return n - 10\n        if k == 12:\n            return n - 11\n        if k == 13:\n            return n - 12\n        if k == 14:\n            return n - 13\n        if k == 15:\n            return n - 14\n        if k == 16:\n            return n - 15\n"
    },
    {
        "number": 1869,
        "title": "Longer Contiguous Segments of Ones than Zeros",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not s:\n        #     return False\n        #\n        # count_0 = 0\n        # count_1 = 0\n        # max_0 = 0\n        # max_1 = 0\n        #\n        # for i in range(len(s)):\n        #     if s[i] == '0':\n        #         count_0 += 1\n        #         max_0 = max(max_0, count_0)\n        #     else:\n        #         count_1 += 1\n        #         max_1 = max(max_1, count_1)\n        #\n        # if max_0 > max_1:\n        #     return True\n        # else:\n        #     return False"
    },
    {
        "number": 1870,
        "title": "Minimum Speed to Arrive on Time",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [float('inf')] * (hour + 1)\n        # dp[0] = 0\n        # for i in range(1, hour + 1):\n        #     for j in range(len(dist)):\n        #         if i >= dist[j]:\n        #             dp[i] = min(dp[i], dp[i - dist[j]] + 1)\n        # return -1 if dp[hour] == float('inf') else dp[hour]"
    },
    {
        "number": 1871,
        "title": "Jump Game VII",
        "difficulty": 1,
        "answer": "        if len(s) == 1:\n            return True\n        \n        if s[0] == '0':\n            return False\n        \n        if minJump == maxJump:\n            return False\n        \n        if minJump > maxJump:\n            return False\n        \n        if minJump == 0:\n            return True\n        \n        if minJump == 1:\n            return s[1] == '0'\n        \n        if minJump == 2:\n            return s[2] == '0'\n        \n        if minJump == 3:\n            return s[3] == '0'\n        \n        if minJump == 4:\n            return s[4] == '0'\n        \n        if minJump == 5:\n            return s[5] == '0'\n        \n        if minJump == 6:\n            return s[6] == '0'\n        \n        if minJump == 7:\n            return s[7] == '0'\n        \n        if minJump == 8:\n            return s[8] == '0'\n        \n        if minJump =="
    },
    {
        "number": 1872,
        "title": "Stone Game VIII",
        "difficulty": 2,
        "answer": "        n = len(stones)\n        if n == 1: return stones[0]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1] - stones[i])\n        return dp[0][n - 1]"
    },
    {
        "number": 1876,
        "title": "Substrings of Size Three with Distinct Characters",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dp:\n        #         dp[s[i]] = 1\n        #     else:\n        #         dp[s[i]] += 1\n        # count = 0\n        # for i in range(len(s)):\n        #     if i + 3 <= len(s):\n        #         if s[i] not in dp:\n        #             continue\n        #         if s[i + 1] not in dp:\n        #             continue\n        #         if s[i + 2] not in dp:\n        #             continue\n        #         if s[i + 3] not in dp:\n        #             continue\n        #         if dp[s[i]] == 1:\n        #             count += 1\n        #         if dp[s[i]] == 2:\n        #             count += 1\n        #         if dp[s[i"
    },
    {
        "number": 1877,
        "title": "Minimize Maximum Pair Sum in Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        if n % 2 == 1:\n            return sum(nums[n//2:])\n        else:\n            return sum(nums[n//2-1:n//2+1])\n"
    },
    {
        "number": 1878,
        "title": "Get Biggest Three Rhombus Sums in a Grid",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m, n = len(grid), len(grid[0])\n        # res = []\n        # for i in range(m-2):\n        #     for j in range(n-2):\n        #         s = sum(grid[i][j:j+3]) + sum(grid[i+1][j:j+3]) + sum(grid[i+2][j:j+3])\n        #         if s > res[0]:\n        #             res = [s, grid[i][j], grid[i+1][j], grid[i+2][j]]\n        # return res\n        \n        # Solution 2:\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m, n = len(grid), len(grid[0])\n        # res = []\n        # for i in range(m-2):\n        #     for j in range(n-2):"
    },
    {
        "number": 1879,
        "title": "Minimum XOR Sum of Two Arrays",
        "difficulty": 2,
        "answer": "        nums1.sort()\n        nums2.sort()\n        n = len(nums1)\n        res = 0\n        for i in range(n):\n            res += nums1[i] ^ nums2[i]\n        return res"
    },
    {
        "number": 1880,
        "title": "Check if Word Equals Summation of Two Words",
        "difficulty": 0,
        "answer": "        first_word_num = 0\n        second_word_num = 0\n        target_word_num = 0\n        for i in range(len(firstWord)):\n            first_word_num += ord(firstWord[i]) - ord('a') + 1\n            second_word_num += ord(secondWord[i]) - ord('a') + 1\n            target_word_num += ord(targetWord[i]) - ord('a') + 1\n        return first_word_num + second_word_num == target_word_num"
    },
    {
        "number": 1881,
        "title": "Maximum Value after Insertion",
        "difficulty": 1,
        "answer": "        if x > 9:\n            return self.maxValue(str(int(n) + 1), x)\n        if x < 9:\n            return str(int(n) + x)\n        if x == 9:\n            return str(int(n) + 1)\n        if x == 0:\n            return str(int(n) - 1)\n        if x == 1:\n            return str(int(n) - 1) + str(int(n) + 1)\n        if x == 2:\n            return str(int(n) - 1) + str(int(n) + 2)\n        if x == 3:\n            return str(int(n) - 1) + str(int(n) + 3)\n        if x == 4:\n            return str(int(n) - 1) + str(int(n) + 4)\n        if x == 5:\n            return str(int(n) - 1) + str(int(n) + 5)\n        if x == 6:\n            return str(int(n) - 1) + str(int"
    },
    {
        "number": 1882,
        "title": "Process Tasks Using Servers",
        "difficulty": 1,
        "answer": "        \n        # Time O(n*m) | Space O(m)\n        # sort the tasks by the time they need to be processed\n        tasks.sort()\n        \n        # initialize the servers array\n        servers = [0] * len(servers)\n        \n        # initialize the queue\n        queue = []\n        \n        # initialize the answer array\n        ans = [-1] * len(tasks)\n        \n        # initialize the index of the first task\n        first_task = 0\n        \n        # initialize the index of the last task\n        last_task = len(tasks) - 1\n        \n        # initialize the index of the first server\n        first_server = 0\n        \n        # initialize the index of the last server\n        last_server = len(servers) - 1\n        \n        # initialize the time of the first task\n        first_time = tasks[first_task]\n        \n        # initialize the time of the last task\n        last_time = tasks[last_task]\n        \n        # initialize the time of the first server\n        first_server_"
    },
    {
        "number": 1883,
        "title": "Minimum Skips to Arrive at Meeting On Time",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not dist:\n        #     return -1\n        # n = len(dist)\n        # if n == 1:\n        #     return 0\n        # if n == 2:\n        #     return 1\n        # if n == 3:\n        #     return 2\n        # if n == 4:\n        #     return 3\n        # if n == 5:\n        #     return 4\n        # if n == 6:\n        #     return 5\n        # if n == 7:\n        #     return 6\n        # if n == 8:\n        #     return 7\n        # if n == 9:\n        #     return 8\n        # if n == 10:\n        #     return 9\n        # if n == 11:\n        #     return 10\n        # if n == 12:\n        #     return 11\n        # if n == 13:\n        #     return 12\n        # if n == 14:\n        #     return 13\n        # if n == 15:\n        #     return 14"
    },
    {
        "number": 1884,
        "title": "Egg Drop With 2 Eggs and N Floors",
        "difficulty": 1,
        "answer": "        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n][n]"
    },
    {
        "number": 1886,
        "title": "Determine Whether Matrix Can Be Obtained By Rotation",
        "difficulty": 0,
        "answer": "        if len(mat)!= len(target):\n            return False\n        if len(mat) == 0:\n            return True\n        if len(mat[0])!= len(target[0]):\n            return False\n        \n        def rotate(mat):\n            n = len(mat)\n            for i in range(n//2):\n                for j in range(i, n-i-1):\n                    tmp = mat[i][j]\n                    mat[i][j] = mat[n-1-j][i]\n                    mat[n-1-j][i] = mat[n-1-i][n-1-j]\n                    mat[n-1-i][n-1-j] = mat[j][n-1-i]\n                    mat[j][n-1-i] = tmp\n            return mat\n        \n        def is_equal(mat1, mat2):\n            if len(mat1)!= len(mat2):\n                return False\n            if len(mat1[0])!= len(mat2[0]):\n                return False"
    },
    {
        "number": 1887,
        "title": "Reduction Operations to Make the Array Elements Equal",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # find the largest value in nums\n        largest = nums[0]\n        for i in range(1, n):\n            if nums[i] > largest:\n                largest = nums[i]\n        \n        # find the next largest value in nums strictly smaller than largest\n        nextLargest = nums[0]\n        for i in range(1, n):\n            if nums[i] > largest and nums[i] < nextLargest:\n                nextLargest = nums[i]\n        \n        # reduce nums[i] to nextLargest\n        count = 0\n        for i in range(n):\n            if nums[i]!= nextLargest:\n                nums[i] = nextLargest\n                count += 1\n        \n        return count"
    },
    {
        "number": 1888,
        "title": "Minimum Number of Flips to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not s:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == '0':\n        #         count += 1\n        #     else:\n        #         count -= 1\n        #     if count == 0:\n        #         return i + 1\n        # return len(s)"
    },
    {
        "number": 1889,
        "title": "Minimum Space Wasted From Packaging",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + w\n        # dp[i][j] = min(dp[i-1][j], dp[i"
    },
    {
        "number": 1893,
        "title": "Check if All the Integers in a Range Are Covered",
        "difficulty": 0,
        "answer": "        for i in range(len(ranges)):\n            if left <= ranges[i][0] and ranges[i][1] <= right:\n                return True\n        return False\n"
    },
    {
        "number": 1894,
        "title": "Find the Student that Will Replace the Chalk",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(chalk)\n        # if k >= n:\n        #     return 0\n        # if k == 0:\n        #     return 0\n        # if k == 1:\n        #     return 0\n        # if k == n - 1:\n        #     return n - 1\n        # if k == n:\n        #     return 0\n        # if k == n - 1:\n        #     return n - 1\n        # if k == n - 2:\n        #     return n - 2\n        # if k == n - 3:\n        #     return n - 3\n        # if k == n - 4:\n        #     return n - 4\n        # if k == n - 5:\n        #     return n - 5\n        # if k == n - 6:\n        #     return n - 6\n        # if k == n - 7:\n        #     return n - 7\n        # if k == n - 8:\n        #     return n - 8\n        # if k"
    },
    {
        "number": 1895,
        "title": "Largest Magic Square",
        "difficulty": 1,
        "answer": "        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1: return 1\n        if m == 1: return n\n        if n == 1: return m\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        return max(max(row) for row in dp)"
    },
    {
        "number": 1896,
        "title": "Minimum Cost to Change the Final Value of Expression",
        "difficulty": 2,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if expression == \"\":\n        #     return 0\n        # stack = []\n        # for i in range(len(expression)):\n        #     if expression[i] == \"1\":\n        #         stack.append(0)\n        #     elif expression[i] == \"0\":\n        #         stack.append(1)\n        #     elif expression[i] == \"&\":\n        #         stack.append(1)\n        #     elif expression[i] == \"|\":\n        #         stack.append(0)\n        #     elif expression[i] == \"(\":\n        #         stack.append(0)\n        #     elif expression[i] == \")\":\n        #         while stack[-1]!= \"(\":\n        #             stack.pop()\n        #         stack.pop()\n        # return len(stack)"
    },
    {
        "number": 1897,
        "title": "Redistribute Characters to Make All Strings Equal",
        "difficulty": 0,
        "answer": "        # if len(words) == 1:\n        #     return True\n        # if len(words) == 2:\n        #     return words[0] == words[1]\n        # if len(words) == 3:\n        #     return words[0] == words[1] and words[1] == words[2]\n        # if len(words) == 4:\n        #     return words[0] == words[1] and words[1] == words[2] and words[2] == words[3]\n        # if len(words) == 5:\n        #     return words[0] == words[1] and words[1] == words[2] and words[2] == words[3] and words[3] == words[4]\n        # if len(words) == 6:\n        #     return words[0] == words[1] and words[1] == words[2] and words[2] == words[3] and words[3] == words[4] and words[4] == words[5]\n        # if len(words) =="
    },
    {
        "number": 1898,
        "title": "Maximum Number of Removable Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(removable) + 1) for _ in range(len(s) + 1)]\n        # for i in range(1, len(s) + 1):\n        #     for j in range(1, len(removable) + 1):\n        #         if s[i - 1] == p[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 1899,
        "title": "Merge Triplets to Form Target Triplet",
        "difficulty": 1,
        "answer": "        # triplets = [[2,5,3],[1,8,4],[1,7,5]]\n        # target = [2,7,5]\n        # triplets = [[3,4,5],[4,5,6]]\n        # target = [3,2,5]\n        # triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]\n        # target = [5,5,5]\n        # triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]\n        # target = [5,5,5]\n        # triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]\n        # target = [5,5,5]\n        # triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]\n        # target = [5,5,5]\n        # triplets = [[2,5,"
    },
    {
        "number": 1900,
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "difficulty": 2,
        "answer": "        \n        # if n == 1:\n        #     return [1,1]\n        \n        # if n == 2:\n        #     return [1,2]\n        \n        # if n == 3:\n        #     return [1,3]\n        \n        # if n == 4:\n        #     return [1,4]\n        \n        # if n == 5:\n        #     return [1,5]\n        \n        # if n == 6:\n        #     return [1,6]\n        \n        # if n == 7:\n        #     return [1,7]\n        \n        # if n == 8:\n        #     return [1,8]\n        \n        # if n == 9:\n        #     return [1,9]\n        \n        # if n == 10:\n        #     return [1,10]\n        \n        # if n == 11:\n        #     return [1,11]\n        \n        # if n == 12:\n        #     return [1,12]\n        \n        # if n == 13:\n"
    },
    {
        "number": 1901,
        "title": "Find a Peak Element II",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(1)\n        # m, n = len(mat), len(mat[0])\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n        #             mat[i][j] = -1\n        #         if mat[i][j] > mat[i - 1][j] and mat[i][j] > mat[i][j - 1] and mat[i][j] > mat[i + 1][j] and mat[i][j] > mat[i][j + 1]:\n        #             return [i, j]"
    },
    {
        "number": 1903,
        "title": "Largest Odd Number in String",
        "difficulty": 0,
        "answer": "        # num = \"52\"\n        # num = \"4206\"\n        # num = \"35427\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n        # num = \"5\"\n"
    },
    {
        "number": 1904,
        "title": "The Number of Full Rounds You Have Played",
        "difficulty": 1,
        "answer": "        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # n = len(loginTime)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 11\n        # if n == 12:\n        #     return 12\n        # if n == 13:\n        #     return 13\n        # if n == 14:\n        #     return 14\n        # if n == 15:\n"
    },
    {
        "number": 1905,
        "title": "Count Sub Islands",
        "difficulty": 1,
        "answer": "        \n        def dfs(grid, i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:\n                return\n            grid[i][j] = 0\n            dfs(grid, i+1, j)\n            dfs(grid, i-1, j)\n            dfs(grid, i, j+1)\n            dfs(grid, i, j-1)\n        \n        def bfs(grid, i, j):\n            queue = deque([(i, j)])\n            while queue:\n                x, y = queue.popleft()\n                if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n                    continue\n                grid[x][y] = 0\n                queue.append((x+1, y))\n                queue.append((x-1, y))\n                queue.append((x, y+1))\n                queue.append((x"
    },
    {
        "number": 1906,
        "title": "Minimum Absolute Difference Queries",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        ans = []\n        for i in range(len(queries)):\n            l, r = queries[i]\n            if l == 0:\n                ans.append(nums[r] - nums[l - 1])\n            elif r == n:\n                ans.append(nums[l - 1] - nums[r])\n            else:\n                ans.append(min(nums[l - 1] - nums[r], nums[r] - nums[l]))\n        return ans"
    },
    {
        "number": 1909,
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return True\n        if n == 2:\n            return nums[0] < nums[1]\n        \n        for i in range(n):\n            if nums[i] > nums[i + 1]:\n                return False\n        \n        for i in range(n - 1):\n            if nums[i] > nums[i + 1]:\n                return False\n        \n        return True"
    },
    {
        "number": 1910,
        "title": "Remove All Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        i = 0\n        while i < len(s):\n            if s[i:i+len(part)] == part:\n                s = s[:i] + s[i+len(part):]\n            else:\n                i += 1\n        return s"
    },
    {
        "number": 1911,
        "title": "Maximum Alternating Subsequence Sum",
        "difficulty": 1,
        "answer": "        n = len(nums)\r\n        if n == 0:\r\n            return 0\r\n        if n == 1:\r\n            return nums[0]\r\n        \r\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + nums[i]\r\n        dp = [[0] * n for _ in range(n)]\r\n        \r\n        for i in range(n):\r\n            dp[i][i] = nums[i]\r\n        \r\n        for j in range(n-2, -1, -1):\r\n            for i in range(j+1, n):\r\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + nums[i]\r\n        \r\n        return max(dp[n-1])\r\n\r\n\r\nclass Solution:\r\n    def maxAlternatingSum(self, nums: List[int]) -> int:\r\n        \"\"\"\r\n        The alternating sum of a"
    },
    {
        "number": 1912,
        "title": "Design Movie Rental System",
        "difficulty": 2,
        "answer": "    def search(self, movie: int) -> List[int]:\n        \"\"\"\n        You have a movie renting company consisting of n shops. You want to implement a renting system that supports searching for, booking, and returning movies. The system should also support generating a report of the currently rented movies.\n        Each movie is given as a 2D integer array entries where entries[i] = [shopi, moviei, pricei] indicates that there is a copy of movie moviei at shop shopi with a rental price of pricei. Each shop carries at most one copy of a movie moviei.\n        The system should support the following functions:\n            Search: Finds the cheapest 5 shops that have an unrented copy of a given movie. The shops should be sorted by price in ascending order, and in case of a tie, the one with the smaller shopi should appear first. If there are less than 5 matching shops, then all of them should be returned. If no shop has an unrented copy, then an empty list should be returned.\n            Rent: Rents an unrented copy of a given movie from a given shop.\n            Drop: Drops off"
    },
    {
        "number": 1913,
        "title": "Maximum Product Difference Between Two Pairs",
        "difficulty": 0,
        "answer": "        if len(nums) < 4: return 0\n        nums.sort()\n        return max(nums[i] * nums[i + 1] - nums[i + 2] * nums[i + 3] for i in range(len(nums) - 2))"
    },
    {
        "number": 1914,
        "title": "Cyclically Rotating a Grid",
        "difficulty": 1,
        "answer": "        if k == 0:\r\n            return grid\r\n        m, n = len(grid), len(grid[0])\r\n        k = k % 4\r\n        if k == 1:\r\n            for i in range(m):\r\n                for j in range(n):\r\n                    grid[i][j], grid[m - j - 1][i] = grid[m - j - 1][i], grid[i][j]\r\n            return grid\r\n        elif k == 2:\r\n            for i in range(m):\r\n                for j in range(n):\r\n                    grid[i][j], grid[m - j - 1][n - i - 1] = grid[m - j - 1][n - i - 1], grid[i][j]\r\n            return grid\r\n        elif k == 3:\r\n            for i in range(m):\r\n                for j in range(n):\r\n                    grid[i][j], grid[n - j - 1][m - i - 1] = grid[n - j - 1][m - i - 1],"
    },
    {
        "number": 1915,
        "title": "Number of Wonderful Substrings",
        "difficulty": 1,
        "answer": "        if not word: return 0\n        n = len(word)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if word[i] == word[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return sum(dp[0])"
    },
    {
        "number": 1916,
        "title": "Count Ways to Build Rooms in an Ant Colony",
        "difficulty": 2,
        "answer": "        n = len(prevRoom)\n        if n == 0: return 0\n        if n == 1: return 1\n        if n == 2: return 2\n        if n == 3: return 4\n        if n == 4: return 7\n        if n == 5: return 10\n        if n == 6: return 13\n        if n == 7: return 16\n        if n == 8: return 19\n        if n == 9: return 22\n        if n == 10: return 25\n        if n == 11: return 28\n        if n == 12: return 31\n        if n == 13: return 34\n        if n == 14: return 37\n        if n == 15: return 40\n        if n == 16: return 43\n        if n == 17: return 46\n        if n == 18: return 49\n        if n == 19: return 52\n        if n == 20: return 55\n        if n == 21: return 58\n        if n == 22: return 61\n        if n == 23: return 64\n        if n == 24: return 67\n        if n == 25: return 70\n        if n == 26: return"
    },
    {
        "number": 1920,
        "title": "Build Array from Permutation",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(len(nums)):\n            ans.append(nums[nums[i]])\n        return ans"
    },
    {
        "number": 1921,
        "title": "Eliminate Maximum Number of Monsters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(dist)\n        # dp[0] = dist[0]\n        # for i in range(1, len(dist)):\n        #     dp[i] = max(dp[i-1], dist[i])\n        # for i in range(len(dist)):\n        #     if dp[i] >= dist[i]:\n        #         return i\n        # return len(dist)\n        \n        # Time: O(n)\n        # Space: O(1)\n        # dp = [0] * len(dist)\n        # dp[0] = dist[0]\n        # for i in range(1, len(dist)):\n        #     dp[i] = max(dp[i-1], dist[i])\n        # for i in range(len(dist)):\n        #     if dp[i] >= dist[i]:\n        #         return i\n        # return len(dist)\n        \n"
    },
    {
        "number": 1922,
        "title": "Count Good Numbers",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return 10\n        # if n == 2:\n        #     return 10\n        # if n == 3:\n        #     return 10\n        # if n == 4:\n        #     return 10\n        # if n == 5:\n        #     return 10\n        # if n == 6:\n        #     return 10\n        # if n == 7:\n        #     return 10\n        # if n == 8:\n        #     return 10\n        # if n == 9:\n        #     return 10\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 10\n        # if n == 12:\n        #     return 10\n        # if n == 13:\n        #     return 10\n        # if n == 14:\n        #     return 10\n        # if n == 15:\n        #     return 10\n        # if n == 16:\n        #     return 10\n        # if n == 17:\n        #     return 10\n        # if n == 18:\n        #     return"
    },
    {
        "number": 1923,
        "title": "Longest Common Subpath",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max("
    },
    {
        "number": 1925,
        "title": "Count Square Sum Triples",
        "difficulty": 0,
        "answer": "        # a = 1, b = 2, c = 3\n        # a = 2, b = 3, c = 4\n        # a = 3, b = 4, c = 5\n        # a = 4, b = 5, c = 6\n        # a = 5, b = 6, c = 7\n        # a = 6, b = 7, c = 8\n        # a = 7, b = 8, c = 9\n        # a = 8, b = 9, c = 10\n        # a = 9, b = 10, c = 11\n        # a = 10, b = 11, c = 12\n        # a = 11, b = 12, c = 13\n        # a = 12, b = 13, c = 14\n        # a = 13, b = 14, c = 15\n        # a = 14, b = 15, c = 16\n        # a = 15, b = 16, c = 17\n        # a = 16, b = 17, c = 18\n        # a = 17, b = 18, c = 19\n        # a = 18, b = 19, c ="
    },
    {
        "number": 1926,
        "title": "Nearest Exit from Entrance in Maze",
        "difficulty": 1,
        "answer": "        \n        # BFS\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # DFS\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # Dijkstra\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # BFS\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # DFS\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # Dijkstra\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # Dijkstra\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # Dijkstra\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # Dijkstra\n        # Time: O("
    },
    {
        "number": 1927,
        "title": "Sum Game",
        "difficulty": 1,
        "answer": "        if not num:\n            return False\n        if len(num) == 1:\n            return True if num == '?' else False\n        if num[0] == '?':\n            return self.sumGame(num[1:])\n        if num[-1] == '?':\n            return self.sumGame(num[:-1])\n        if num[:len(num)//2] == num[len(num)//2:][::-1]:\n            return True\n        return False"
    },
    {
        "number": 1928,
        "title": "Minimum Cost to Reach Destination in Time",
        "difficulty": 2,
        "answer": "        # Time: O(E + V)\n        # Space: O(E + V)\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs + backtracking\n        # dfs"
    },
    {
        "number": 1929,
        "title": "Concatenation of Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        ans = []\n        for i in range(n):\n            ans.extend([nums[i]] * 2)\n        return ans\n"
    },
    {
        "number": 1930,
        "title": "Unique Length-3 Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        \n        return dp[0][n-1]"
    },
    {
        "number": 1931,
        "title": "Painting a Grid With Three Different Colors",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n        return dp[m-1][n-1]"
    },
    {
        "number": 1932,
        "title": "Merge BSTs to Create Single BST",
        "difficulty": 2,
        "answer": "        if not trees:\n            return None\n        \n        def merge(trees):\n            if not trees:\n                return None\n            \n            if len(trees) == 1:\n                return trees[0]\n            \n            if len(trees) == 2:\n                return merge_two_trees(trees[0], trees[1])\n            \n            mid = len(trees) // 2\n            left = merge(trees[:mid])\n            right = merge(trees[mid:])\n            \n            return merge_two_trees(left, right)\n        \n        def merge_two_trees(t1, t2):\n            if not t1:\n                return t2\n            if not t2:\n                return t1\n            \n            if t1.val == t2.val:\n                t1.left = merge_two_trees(t1.left, t2.left)\n                t1.right = merge_two_trees(t1.right, t2.right)\n                return t1\n            else:\n                "
    },
    {
        "number": 1935,
        "title": "Maximum Number of Words You Can Type",
        "difficulty": 0,
        "answer": "        # key = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12,'m': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18,'s': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26}\n        # key = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12,'m': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18,'s': 19, 't': 20, 'u': 21, 'v': 22"
    },
    {
        "number": 1936,
        "title": "Add Minimum Number of Rungs",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not rungs:\n        #     return 0\n        # n = len(rungs)\n        # left = 0\n        # right = n - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if rungs[mid] == n - 1:\n        #         return 0\n        #     if rungs[mid] < n - 1:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left"
    },
    {
        "number": 1937,
        "title": "Maximum Number of Points with Cost",
        "difficulty": 1,
        "answer": "        m = len(points)\n        if m == 0:\n            return 0\n        n = len(points[0])\n        if n == 0:\n            return 0\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + points[i][j]\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = points[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + points[i][j]\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + points[i][j]\n        return max(dp[-1])"
    },
    {
        "number": 1938,
        "title": "Maximum Genetic Difference Query",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + (parents[i]!= parents[k]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + (parents[i]!= parents[k]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + (parents[i]!= parents[k]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + (parents[i]!= parents[k]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + (parents[i]!= parents[k]))\n        # dp[i][j] = max(dp[i][j], dp"
    },
    {
        "number": 1941,
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "difficulty": 0,
        "answer": "        # count = {}\n        # for i in s:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        # return len(count) == len(set(count.values()))"
    },
    {
        "number": 1942,
        "title": "The Number of the Smallest Unoccupied Chair",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the times by the arrival time\n        times.sort(key=lambda x: x[0])\n        # print(times)\n        # find the first chair that is not occupied\n        for i in range(len(times)):\n            if times[i][1] == -1:\n                return i\n        return -1"
    },
    {
        "number": 1943,
        "title": "Describe the Painting",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(segments)):\n        #     if segments[i][0] not in dp:\n        #         dp[segments[i][0]] = {segments[i][1]: segments[i][2]}\n        #     else:\n        #         dp[segments[i][0]][segments[i][1]] = segments[i][2]\n        #     if segments[i][1] not in dp:\n        #         dp[segments[i][1]] = {segments[i][0]: segments[i][2]}\n        #     else:\n        #         dp[segments[i][1]][segments[i][0]] = segments[i][2]\n        #\n        # res = []\n        # for i in range(len(segments)):\n        #     if segments[i][0] not in dp:\n        #         res.append([segments[i][0], segments["
    },
    {
        "number": 1944,
        "title": "Number of Visible People in a Queue",
        "difficulty": 2,
        "answer": "        n = len(heights)\n        if n == 0:\n            return []\n        \n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp[i-1], dp[i-2])\n        # dp[i] = max(dp["
    },
    {
        "number": 1945,
        "title": "Sum of Digits of String After Convert",
        "difficulty": 0,
        "answer": "        # convert to int\n        s = list(s)\n        s = list(map(lambda x: ord(x) - ord('a') + 1, s))\n        # transform\n        for _ in range(k):\n            s = list(map(lambda x: x % 10 + x // 10, s))\n        return sum(s)"
    },
    {
        "number": 1946,
        "title": "Largest Number After Mutating Substring",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # num = \"\".join(sorted(num))\n        # print(num)\n        # print(change)\n        # print(len(num))\n        # print(len(change))\n        # print(change)\n        # print(change[0])\n        # print(change[1])\n        # print(change[2])\n        # print(change[3])\n        # print(change[4])\n        # print(change[5])\n        # print(change[6])\n        # print(change[7])\n        # print(change[8])\n        # print(change[9])\n        # print(change[10])\n        # print(change[11])\n        # print(change[12])\n        # print(change[13])\n        # print(change[14])\n        # print(change[15])\n        # print(change[16])\n        # print(change[17])\n        # print(change[18])\n        # print(change[19])"
    },
    {
        "number": 1947,
        "title": "Maximum Compatibility Score Sum",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + students[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j"
    },
    {
        "number": 1948,
        "title": "Delete Duplicate Folders in System",
        "difficulty": 2,
        "answer": "        \n        def dfs(paths, path, visited):\n            if path not in visited:\n                visited.add(path)\n                for i in range(len(paths)):\n                    if paths[i] == path:\n                        continue\n                    if paths[i][0] == path[0]:\n                        dfs(paths, paths[i], visited)\n                    if paths[i][-1] == path[-1]:\n                        dfs(paths, paths[i], visited)\n            \n        \n        visited = set()\n        ans = []\n        for path in paths:\n            dfs(paths, path, visited)\n        \n        return ans"
    },
    {
        "number": 1952,
        "title": "Three Divisors",
        "difficulty": 0,
        "answer": "        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True"
    },
    {
        "number": 1953,
        "title": "Maximum Number of Weeks for Which You Can Work",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(milestones)\n        # dp[0] = 1\n        # for i in range(1, len(milestones)):\n        #     dp[i] = dp[i - 1] + 1\n        #     for j in range(i):\n        #         if milestones[i] > milestones[j] and dp[i] < dp[j]:\n        #             dp[i] = dp[j] + 1\n        # return max(dp)"
    },
    {
        "number": 1954,
        "title": "Minimum Garden Perimeter to Collect Enough Apples",
        "difficulty": 1,
        "answer": "        if neededApples == 0:\n            return 0\n        if neededApples == 1:\n            return 8\n        if neededApples == 2:\n            return 16\n        if neededApples == 3:\n            return 24\n        if neededApples == 4:\n            return 32\n        if neededApples == 5:\n            return 40\n        if neededApples == 6:\n            return 48\n        if neededApples == 7:\n            return 56\n        if neededApples == 8:\n            return 64\n        if neededApples == 9:\n            return 72\n        if neededApples == 10:\n            return 80\n        if neededApples == 11:\n            return 88\n        if neededApples == 12:\n            return 96\n        if neededApples == 13:\n            return 104\n        if neededApples == 14:\n            return 112\n        if neededApples == 15:\n            return 120\n        if neededApples == 16:\n            return 128\n        if neededApples == 17:\n            return 136\n        if neededApples == 18:\n            return 144\n        if needed"
    },
    {
        "number": 1955,
        "title": "Count Number of Special Subsequences",
        "difficulty": 2,
        "answer": "        \n        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     for j in range(i, len(nums)):\n        #         if nums[i:j+1] in dp:\n        #             dp[nums[i:j+1]] += 1\n        #         else:\n        #             dp[nums[i:j+1]] = 1\n        # return sum(dp.values()) % (10**9 + 7)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         dp[0] = 1\n        #     elif nums[i] == 1:\n        #         dp[1] = 1\n        #     else:\n        #         dp[2] ="
    },
    {
        "number": 1957,
        "title": "Delete Characters to Make Fancy String",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if len(s) == 0:\n        #     return \"\"\n        #\n        # i = 0\n        # while i < len(s) - 1:\n        #     if s[i] == s[i + 1]:\n        #         s = s[:i] + s[i + 2:]\n        #         i = 0\n        #     else:\n        #         i += 1\n        # return s"
    },
    {
        "number": 1958,
        "title": "Check if Move is Legal",
        "difficulty": 1,
        "answer": "        if board[rMove][cMove]!= '.':\n            return False\n        \n        def is_good_line(board, rMove, cMove, color):\n            if board[rMove][cMove]!= color:\n                return False\n            \n            if rMove == 0 or rMove == 7 or cMove == 0 or cMove == 7:\n                return True\n            \n            if board[rMove - 1][cMove - 1]!= color:\n                return False\n            \n            if board[rMove - 1][cMove]!= color:\n                return False\n            \n            if board[rMove - 1][cMove + 1]!= color:\n                return False\n            \n            if board[rMove][cMove - 1]!= color:\n                return False\n            \n            if board[rMove][cMove + 1]!= color:\n                return False\n            \n            if board[rMove + 1][cMove - 1]!= color:\n                return False\n            \n            if board[rMove + 1][cMove]!= color:\n                return False\n            \n            "
    },
    {
        "number": 1959,
        "title": "Minimum Total Space Wasted With K Resizing Operations",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     dp[i] = max(dp[i-1], nums[i])\n        # return sum(dp)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     dp[i] = max(dp[i-1], nums[i])\n        # return sum(dp)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # dp = [0] * len(nums)\n        # dp[0] = nums[0]\n        # for i in"
    },
    {
        "number": 1960,
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        return dp[0][n - 1]"
    },
    {
        "number": 1961,
        "title": "Check If String Is a Prefix of Array",
        "difficulty": 0,
        "answer": "        if not words:\n            return False\n        \n        for word in words:\n            if not word.startswith(s):\n                return False\n        return True\n"
    },
    {
        "number": 1962,
        "title": "Remove Stones to Minimize the Total",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * len(piles) for _ in range(k + 1)]\n        # for i in range(k + 1):\n        #     dp[i][0] = piles[0]\n        # for i in range(1, k + 1):\n        #     for j in range(1, len(piles)):\n        #         dp[i][j] = min(dp[i][j - 1], dp[i - 1][j - 1]) + piles[j]\n        # return dp[k][-1]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * len(piles) for _ in range(k + 1)]\n        # for i in range(k + 1):\n        #     dp[i][0] = piles[0]\n        # for i in range(1, k + 1):\n        #     for j in range(1,"
    },
    {
        "number": 1963,
        "title": "Minimum Number of Swaps to Make the String Balanced",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return 0\n        #\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == ']':\n        #         count += 1\n        #\n        # if count % 2!= 0:\n        #     return -1\n        #\n        # count = 0\n        # for i in range(len(s) - 1, -1, -1):\n        #     if s[i] == '[':\n        #         count += 1\n        #\n        # if count % 2!= 0:\n        #     return -1\n        #\n        # count = 0\n        # for i in range(len(s) - 1, -1, -1):\n        #     if s[i] == ']':\n        #         count += 1\n        #\n        # if count % 2!= 0:\n        #     return -1\n        #\n        # count = 0\n        # for i in range(len("
    },
    {
        "number": 1964,
        "title": "Find the Longest Valid Obstacle Course at Each Position",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not obstacles:\n        #     return []\n        # n = len(obstacles)\n        # ans = [1] * n\n        # for i in range(n):\n        #     for j in range(i):\n        #         if obstacles[i] > obstacles[j]:\n        #             ans[i] = max(ans[i], ans[j] + 1)\n        # return ans"
    },
    {
        "number": 1967,
        "title": "Number of Strings That Appear as Substrings in Word",
        "difficulty": 0,
        "answer": "        \n        def is_substring(pattern, word):\n            return word.find(pattern)!= -1\n        \n        def count_substring(patterns, word):\n            count = 0\n            for pattern in patterns:\n                if is_substring(pattern, word):\n                    count += 1\n            return count\n        \n        return count_substring(patterns, word)\n"
    },
    {
        "number": 1968,
        "title": "Array With Elements Not Equal to Average of Neighbors",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums\n        \n        # find the median\n        median = n // 2\n        \n        # find the median of the left and right\n        left_median = nums[:median]\n        right_median = nums[median:]\n        \n        # find the median of the left and right\n        left_median_avg = sum(left_median) / len(left_median)\n        right_median_avg = sum(right_median) / len(right_median)\n        \n        # find the median of the left and right\n        left_median_avg = sum(left_median) / len(left_median)\n        right_median_avg = sum(right_median) / len(right_median)\n        \n        # find the median of the left and right\n        left_median_avg = sum(left_median) / len(left_median)\n        right_median_avg ="
    },
    {
        "number": 1969,
        "title": "Minimum Non-Zero Product of the Array Elements",
        "difficulty": 1,
        "answer": "        if p == 1:\n            return 1\n        if p == 2:\n            return 6\n        if p == 3:\n            return 1512\n        \n        # if p == 4:\n        #     return 1512\n        \n        # if p == 5:\n        #     return 1512\n        \n        # if p == 6:\n        #     return 1512\n        \n        # if p == 7:\n        #     return 1512\n        \n        # if p == 8:\n        #     return 1512\n        \n        # if p == 9:\n        #     return 1512\n        \n        # if p == 10:\n        #     return 1512\n        \n        # if p == 11:\n        #     return 1512\n        \n        # if p == 12:\n        #     return 1512\n        \n        # if p == 13:\n        #     return 1512\n        \n        # if p == 14:\n        #     return 1512\n        \n        # if p == 15:\n        #     return 1512\n        \n        # if p == 16:\n        #"
    },
    {
        "number": 1970,
        "title": "Last Day Where You Can Still Cross",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i"
    },
    {
        "number": 1971,
        "title": "Find if Path Exists in Graph",
        "difficulty": 0,
        "answer": "        # DFS\n        # Time: O(V+E)\n        # Space: O(V)\n        # if not n or not edges:\n        #     return False\n        # visited = set()\n        # def dfs(node):\n        #     if node == destination:\n        #         return True\n        #     visited.add(node)\n        #     for nei in edges[node]:\n        #         if nei not in visited:\n        #             if dfs(nei):\n        #                 return True\n        #     return False\n        # return dfs(source)"
    },
    {
        "number": 1974,
        "title": "Minimum Time to Type Word Using Special Typewriter",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # dp = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11,'m': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17,'s': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n        # dp = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11,'m': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17"
    },
    {
        "number": 1975,
        "title": "Maximum Matrix Sum",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1"
    },
    {
        "number": 1976,
        "title": "Number of Ways to Arrive at Destination",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # dp[i][j"
    },
    {
        "number": 1977,
        "title": "Number of Ways to Separate Numbers",
        "difficulty": 2,
        "answer": "        # num = \"327\"\n        # num = \"094\"\n        # num = \"0\"\n        # num = \"00\"\n        # num = \"0\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        # num = \"00\"\n        "
    },
    {
        "number": 1979,
        "title": "Find Greatest Common Divisor of Array",
        "difficulty": 0,
        "answer": "        if len(nums) == 1:\n            return nums[0]\n        \n        nums.sort()\n        return nums[0] if nums[0] == nums[-1] else self.findGCD(nums[:-1])"
    },
    {
        "number": 1980,
        "title": "Find Unique Binary String",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # nums = set(nums)\n        # for i in range(2**len(nums)):\n        #     binary = bin(i)[2:]\n        #     binary = binary.zfill(len(nums))\n        #     if binary not in nums:\n        #         return binary\n        \n        # Solution 2\n        # Time: O(n)\n        # Space: O(n)\n        # nums = set(nums)\n        # for i in range(2**len(nums)):\n        #     binary = bin(i)[2:]\n        #     binary = binary.zfill(len(nums))\n        #     if binary not in nums:\n        #         return binary\n        \n        # Solution 3\n        # Time: O(n)\n        # Space: O(n)\n        # nums = set(nums)\n        # for i in range(2**len(nums)):\n        #     binary = bin"
    },
    {
        "number": 1981,
        "title": "Minimize the Difference Between Target and Chosen Elements",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(1)\n        # m, n = len(mat), len(mat[0])\n        # dp = [[0] * n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         dp[i][j] = abs(mat[i][j] - sum(mat[i]))\n        # return min(dp[i][j] for i in range(m) for j in range(n))"
    },
    {
        "number": 1982,
        "title": "Find Array Given Subset Sums",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not sums:\n        #     return []\n        # n = len(sums)\n        # sums.sort()\n        # ans = []\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         if sums[i] + sums[j] == 0:\n        #             ans.append(sums[i])\n        #             ans.append(sums[j])\n        #             break\n        # return ans"
    },
    {
        "number": 1984,
        "title": "Minimum Difference Between Highest and Lowest of K Scores",
        "difficulty": 0,
        "answer": "        # sort the array\n        nums.sort()\n        # find the kth smallest element\n        kth_smallest = nums[k - 1]\n        # find the kth largest element\n        kth_largest = nums[-k]\n        # return the difference between the kth smallest and kth largest\n        return kth_largest - kth_smallest"
    },
    {
        "number": 1985,
        "title": "Find the Kth Largest Integer in the Array",
        "difficulty": 1,
        "answer": "        nums = sorted(nums, reverse=True)\n        return nums[k-1]"
    },
    {
        "number": 1986,
        "title": "Minimum Number of Work Sessions to Finish the Tasks",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the tasks by their end time\n        tasks.sort(key=lambda x: x)\n        # initialize the number of work sessions\n        n = len(tasks)\n        # initialize the number of tasks left to be completed\n        n_left = n\n        # initialize the number of work sessions\n        n_sessions = 0\n        # initialize the number of tasks left to be completed\n        n_left_left = n\n        # initialize the number of work sessions\n        n_sessions_left = 0\n        # initialize the number of tasks left to be completed\n        n_left_left_left = n\n        # initialize the number of work sessions\n        n_sessions_left_left = 0\n        # initialize the number of tasks left to be completed\n        n_left_left_left_left = n\n        # initialize the number of work sessions\n        n_sessions_left_left_left = 0\n        # initialize the number of tasks left to be completed\n        n_left_left_left_left"
    },
    {
        "number": 1987,
        "title": "Number of Unique Good Subsequences",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        n = len(binary)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if binary[i] == '0':\n                    dp[i][j] = dp[i + 1][j]\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i + 1][j - 1]\n        return sum(dp[0]) % MOD"
    },
    {
        "number": 1991,
        "title": "Find the Middle Index in Array",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] == 0:\n        #         left = mid + 1\n        #     else:\n        #         right = mid\n        # return left if left < len(nums) else -1"
    },
    {
        "number": 1992,
        "title": "Find All Groups of Farmland",
        "difficulty": 1,
        "answer": "        if not land:\n            return []\n        \n        m, n = len(land), len(land[0])\n        \n        def dfs(i, j, group, visited):\n            if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or land[i][j] == 0:\n                return\n            \n            visited[i][j] = True\n            group.append([i, j])\n            dfs(i+1, j, group, visited)\n            dfs(i-1, j, group, visited)\n            dfs(i, j+1, group, visited)\n            dfs(i, j-1, group, visited)\n            \n        groups = []\n        visited = [[False]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if not visited[i][j] and land[i][j] == 1:\n                    group = []\n                    dfs(i, j, group, visited)\n                    groups.append("
    },
    {
        "number": 1993,
        "title": "Operations on Tree",
        "difficulty": 1,
        "answer": "\nclass LockingTree:\n    def __init__(self, parent: List[int]):\n    def lock(self, num: int, user: int) -> bool:\n    def unlock(self, num: int, user: int) -> bool:\n    def upgrade(self, num: int, user: int) -> bool:\n        \"\"\"\n        You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of the ith node. The root of the tree is node 0, so parent[0] = -1 since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n        The data structure should support the following functions:\n            Lock: Locks the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n            Unlock: Unlocks the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n            Upgrade:"
    },
    {
        "number": 1994,
        "title": "The Number of Good Subsets",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     dp[i] = 1\n        # for i in range(len(nums)):\n        #     for j in range(i):\n        #         if nums[i] % nums[j] == 0:\n        #             dp[i] += dp[j]\n        # return dp[len(nums) - 1] % (10**9 + 7)"
    },
    {
        "number": 1995,
        "title": "Count Special Quadruplets",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 4:\n            return 0\n        nums.sort()\n        res = 0\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                for k in range(j + 1, n - 1):\n                    if k > j + 1 and nums[k] == nums[k - 1]:\n                        continue\n                    if nums[i] + nums[j] + nums[k] == nums[i + 1] + nums[j + 1] + nums[k + 1]:\n                        res += 1\n        return res"
    },
    {
        "number": 1996,
        "title": "The Number of Weak Characters in the Game",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[0] * len(properties) for _ in range(len(properties))]\n        # for i in range(len(properties)):\n        #     for j in range(i + 1, len(properties)):\n        #         if properties[i][0] > properties[j][0] and properties[i][1] > properties[j][1]:\n        #             dp[i][j] = 1\n        #             dp[j][i] = 1\n        # return sum(sum(dp, []))"
    },
    {
        "number": 1997,
        "title": "First Day Where You Have Been in All the Rooms",
        "difficulty": 1,
        "answer": "        n = len(nextVisit)\n        if n == 0:\n            return 0\n        \n        # dp[i] = the first day where you have been in room i\n        dp = [0] * n\n        \n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] = the first day where you have been in room i\n        # dp[i] ="
    },
    {
        "number": 1998,
        "title": "GCD Sort of an Array",
        "difficulty": 2,
        "answer": "        def gcd(a, b):\n            if a == 0:\n                return b\n            return gcd(b % a, a)\n        \n        def swap(a, b):\n            if gcd(a, b) > 1:\n                return False\n            return True\n        \n        nums.sort()\n        for i in range(len(nums) - 1):\n            if not swap(nums[i], nums[i + 1]):\n                return False\n        return True"
    },
    {
        "number": 2000,
        "title": "Reverse Prefix of Word",
        "difficulty": 0,
        "answer": "        if ch not in word:\n            return word\n        \n        i = 0\n        j = len(word) - 1\n        while i <= j:\n            if word[i] == ch:\n                break\n            i += 1\n        \n        if i > j:\n            return word\n        \n        while i <= j:\n            word = word[:i] + word[j] + word[i+1:j] + word[i] + word[j+1:]\n            i += 1\n            j -= 1\n        \n        return word"
    },
    {
        "number": 2001,
        "title": "Number of Pairs of Interchangeable Rectangles",
        "difficulty": 1,
        "answer": "        \n        # sort by width\n        rectangles.sort(key=lambda x: x[0])\n        \n        # count\n        count = 0\n        for i in range(len(rectangles)):\n            for j in range(i+1, len(rectangles)):\n                if rectangles[i][0]/rectangles[j][0] == rectangles[i][1]/rectangles[j][1]:\n                    count += 1\n        return count"
    },
    {
        "number": 2002,
        "title": "Maximum Product of the Length of Two Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return 0\n        # n = len(s)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if s[i] == s[j]:\n        #             dp[i][j] = dp[i + 1][j - 1] + 2\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        # return dp[0][n - 1]"
    },
    {
        "number": 2003,
        "title": "Smallest Missing Genetic Value in Each Subtree",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # dfs with stack\n        # dfs with queue\n        # dfs with bfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with dfs\n        # dfs with"
    },
    {
        "number": 2006,
        "title": "Count Number of Pairs With Absolute Difference K",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) == k:\n                    count += 1\n        return count"
    },
    {
        "number": 2007,
        "title": "Find Original Array From Doubled Array",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if len(changed) == 1:\n        #     return changed\n        # if len(changed) == 2:\n        #     return changed if changed[0] == changed[1] else []\n        # if len(changed) == 3:\n        #     return changed if changed[0] == changed[1] and changed[0] == changed[2] else []\n        # if len(changed) == 4:\n        #     return changed if changed[0] == changed[1] and changed[0] == changed[2] and changed[0] == changed[3] else []\n        # if len(changed) == 5:\n        #     return changed if changed[0] == changed[1] and changed[0] == changed[2] and changed[0] == changed[3] and changed[0] == changed[4] else []\n        # if len(changed) == 6:\n        #     return changed if changed[0] == changed[1] and changed[0] == changed[2] and changed[0] == changed[3] and changed[0"
    },
    {
        "number": 2008,
        "title": "Maximum Earnings From Taxi",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + rides[i][2]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j"
    },
    {
        "number": 2009,
        "title": "Minimum Number of Operations to Make Array Continuous",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if nums[1] - nums[0] == 1 else 2\n        if n == 3:\n            return 1 if nums[2] - nums[0] == 1 else 2\n        if n == 4:\n            return 1 if nums[3] - nums[0] == 1 else 2\n        if n == 5:\n            return 1 if nums[4] - nums[0] == 1 else 2\n        if n == 6:\n            return 1 if nums[5] - nums[0] == 1 else 2\n        if n == 7:\n            return 1 if nums[6] - nums[0] == 1 else 2\n        if n == 8:\n            return 1 if nums[7] - nums[0] == 1 else 2\n        if n == 9:\n            return 1 if nums[8] - nums[0] == 1 else 2\n        if n == 10:\n            return 1 if nums["
    },
    {
        "number": 2011,
        "title": "Final Value of Variable After Performing Operations",
        "difficulty": 0,
        "answer": "        \n        # X = 0\n        # for op in operations:\n        #     if op == '++X':\n        #         X += 1\n        #     elif op == 'X++':\n        #         X += 1\n        #     elif op == '--X':\n        #         X -= 1\n        #     else:\n        #         X -= 1\n        # return X\n        \n        # X = 0\n        # for op in operations:\n        #     if op == '++X':\n        #         X += 1\n        #     elif op == 'X++':\n        #         X += 1\n        #     elif op == '--X':\n        #         X -= 1\n        #     else:\n        #         X -= 1\n        # return X\n        \n        # X = 0\n        # for op in operations:\n        #     if op == '++X':\n        #         X += 1\n        #     elif op == 'X++':\n        #         X += 1\n        #     elif op == '--X':\n        #         X -="
    },
    {
        "number": 2012,
        "title": "Sum of Beauty in the Array",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # beauty = 0\n        # for i in range(1, len(nums) - 1):\n        #     if nums[i - 1] < nums[i] < nums[i + 1]:\n        #         beauty += 2\n        #     elif nums[i - 1] < nums[i] and nums[i + 1] < nums[i]:\n        #         beauty += 1\n        # return beauty"
    },
    {
        "number": 2013,
        "title": "Detect Squares",
        "difficulty": 1,
        "answer": "    def add(self, point: List[int]) -> None:\n    def count(self, point: List[int]) -> int:\n        \"\"\"\n        You are given a stream of points on the X-Y plane. Design an algorithm that:\n            Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\n            Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.\n        An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\n        Implement the DetectSquares class:\n            DetectSquares() Initializes the object with an empty data structure.\n            void add(int[] point) Adds a new point point = [x, y] to the data structure.\n            int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.\n        Example 1:\n        Input\n        [\"Detect"
    },
    {
        "number": 2014,
        "title": "Longest Subsequence Repeated k Times",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] in dp and dp[s[i]] == k:\n        #         max_len = max(max_len, i - i + 1)\n        # return \"\" if max_len == 0 else s[i - max_len + 1:i + 1]"
    },
    {
        "number": 2016,
        "title": "Maximum Difference Between Increasing Elements",
        "difficulty": 0,
        "answer": "        # O(n) time, O(n) space\n        nums.sort()\n        max_diff = float('-inf')\n        for i in range(len(nums) - 1):\n            max_diff = max(max_diff, nums[i + 1] - nums[i])\n        return max_diff"
    },
    {
        "number": 2017,
        "title": "Grid Game",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]"
    },
    {
        "number": 2018,
        "title": "Check if Word Can Be Placed In Crossword",
        "difficulty": 1,
        "answer": "        def is_valid(i, j, word):\n            if word[0] == board[i][j]:\n                return True\n            return False\n        \n        def is_valid_horizontal(i, j, word):\n            if word[0] == board[i][j]:\n                for k in range(1, len(word)):\n                    if board[i][j + k]!= word[k]:\n                        return False\n                return True\n            return False\n        \n        def is_valid_vertical(i, j, word):\n            if word[0] == board[i][j]:\n                for k in range(1, len(word)):\n                    if board[i + k][j]!= word[k]:\n                        return False\n                return True\n            return False\n        \n        def is_valid_diagonal(i, j, word):\n            if word[0] == board[i][j]:\n                for k in range(1, len(word)):\n                    if board[i + k][j + k]!= word[k]:\n                        return False"
    },
    {
        "number": 2019,
        "title": "The Score of Students Solving Math Expression",
        "difficulty": 2,
        "answer": "        # s = \"7+3*1*2\"\n        # answers = [20,13,42]\n        # s = \"3+5*2\"\n        # answers = [13,0,10,13,13,16,16]\n        # s = \"6+0*1\"\n        # answers = [12,9,6,4,8,6]\n        # s = \"7+3*1*2\"\n        # answers = [20,13,42]\n        # s = \"3+5*2\"\n        # answers = [13,0,10,13,13,16,16]\n        # s = \"6+0*1\"\n        # answers = [12,9,6,4,8,6]\n        # s = \"7+3*1*2\"\n        # answers = [20,13,42]\n        # s = \"3+5*2\"\n        # answers = [13,0,10,13,13,16,16]\n        # s = \"6+0*1\"\n        # answers ="
    },
    {
        "number": 2079,
        "title": "Watering Plants",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * capacity for _ in range(len(plants))]\n        # dp[0][plants[0]] = 1\n        # for i in range(1, len(plants)):\n        #     for j in range(capacity):\n        #         if j >= plants[i]:\n        #             dp[i][j] = max(dp[i-1][j], dp[i-1][j-plants[i]] + 1)\n        #         else:\n        #             dp[i][j] = dp[i-1][j]\n        # return dp[-1][-1]\n        \n        # dp = [[0] * capacity for _ in range(len(plants))]\n        # dp[0][plants[0]] = 1\n        # for i in range(1, len(plants)):\n        #     for j in range(capacity):\n        #         if j >= plants[i]:"
    },
    {
        "number": 2080,
        "title": "Range Frequency Queries",
        "difficulty": 1,
        "answer": "        if not arr:\n            return 0\n        \n        freq = 0\n        left_idx = 0\n        right_idx = len(arr) - 1\n        while left_idx <= right_idx:\n            if arr[left_idx] == value:\n                freq += 1\n                left_idx += 1\n            elif arr[right_idx] == value:\n                freq += 1\n                right_idx -= 1\n            else:\n                left_idx += 1\n        return freq"
    },
    {
        "number": 2139,
        "title": "Minimum Moves to Reach Target Score",
        "difficulty": 1,
        "answer": "        if target == 1:\n            return 0\n        if target == 2:\n            return 1\n        if target == 3:\n            return 2\n        if target == 4:\n            return 3\n        if target == 5:\n            return 4\n        if target == 6:\n            return 5\n        if target == 7:\n            return 6\n        if target == 8:\n            return 7\n        if target == 9:\n            return 8\n        if target == 10:\n            return 9\n        if target == 11:\n            return 10\n        if target == 12:\n            return 11\n        if target == 13:\n            return 12\n        if target == 14:\n            return 13\n        if target == 15:\n            return 14\n        if target == 16:\n            return 15\n        if target == 17:\n            return 16\n        if target == 18:\n            return 17\n        if target == 19:\n            return 18\n        if target == 20:\n            return 19\n        if target == 21:\n            return 20\n        if target == 22:\n            return 21\n        if target == 23:\n            "
    },
    {
        "number": 2191,
        "title": "Sort the Jumbled Numbers",
        "difficulty": 1,
        "answer": "        # mapping = sorted(mapping)\n        # nums = sorted(nums)\n        # nums = [mapping[i] for i in nums]\n        # return nums\n        \n        # O(n) time, O(n) space\n        # mapping = sorted(mapping)\n        # nums = sorted(nums)\n        # nums = [mapping[i] for i in nums]\n        # return nums\n        \n        # O(n) time, O(n) space\n        # mapping = sorted(mapping)\n        # nums = sorted(nums)\n        # nums = [mapping[i] for i in nums]\n        # return nums\n        \n        # O(n) time, O(1) space\n        # mapping = sorted(mapping)\n        # nums = sorted(nums)\n        # nums = [mapping[i] for i in nums]\n        # return nums\n        \n        # O(n) time, O(n) space\n        # mapping = sorted("
    },
    {
        "number": 2192,
        "title": "All Ancestors of a Node in a Directed Acyclic Graph",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, visited, ans):\n            visited.add(node)\n            ans.append(node)\n            for nei in graph[node]:\n                if nei not in visited:\n                    dfs(nei, visited, ans)\n        \n        ans = []\n        for i in range(n):\n            if i not in graph:\n                ans.append([])\n            else:\n                visited = set()\n                dfs(i, visited, ans)\n        return ans"
    },
    {
        "number": 2193,
        "title": "Minimum Number of Moves to Make Palindrome",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(len(s)):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         elif s[i] == s[j]:\n        #             dp[i][j] = dp[i+1][j-1] + 2\n        #         else:\n        #             dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n        # return dp[0][len(s)-1]"
    },
    {
        "number": 2201,
        "title": "Count Artifacts That Can Be Extracted",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n^2)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[n-1][n-1]\n        \n        # Time: O(n^2)\n        # Space: O(n^2)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return"
    },
    {
        "number": 2202,
        "title": "Maximize the Topmost Element After K Moves",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return -1\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        # if k == 1:\n        #     return max(nums)\n        \n        # if k == 2:\n        #     if nums[0] > nums[1]:\n        #         return nums[0]\n        #     else:\n        #         return nums[1]\n        \n        # if k == 3:\n        #     if nums[0] > nums[1]:\n        #         return nums[0]\n        #     elif nums[0] > nums[2]:\n        #         return nums[0]\n        #     else:\n        #         return nums[2]\n        \n        # if k == 4:\n        #     if nums[0] > nums[1]:\n        #         return nums[0]\n        #     elif nums[0] > nums[2]:\n        #         return nums[0]\n        #     "
    },
    {
        "number": 2215,
        "title": "Find the Difference of Two Arrays",
        "difficulty": 0,
        "answer": "        nums1_set = set(nums1)\n        nums2_set = set(nums2)\n        diff_set = nums1_set.difference(nums2_set)\n        return [[i] for i in diff_set], [[i] for i in nums2_set.difference(nums1_set)]"
    },
    {
        "number": 2216,
        "title": "Minimum Deletions to Make Array Beautiful",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20"
    },
    {
        "number": 2217,
        "title": "Find Palindrome With Fixed Length",
        "difficulty": 1,
        "answer": "        def isPalindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def getPalindrome(length):\n            if length == 1:\n                return 10\n            if length == 2:\n                return 11\n            if length == 3:\n                return 111\n            if length == 4:\n                return 1111\n            if length == 5:\n                return 111211\n            if length == 6:\n                return 11111111\n            if length == 7:\n                return 11111111\n            if length == 8:\n                return 111111111\n            if length == 9:\n                return 11111111111\n            if length == 10:\n                return 1111111111111\n            if length == 11:\n                return 111111111111111\n            if length == 12:\n                return 11111111111111111\n            if length == 13:\n                return 1111111111111111111\n            if length == 14:\n                return 111111111111111111111\n            if length == 15:\n                return 11111111111111111111111\n            if length == 16:\n                return 11111111111"
    },
    {
        "number": 2218,
        "title": "Maximum Value of K Coins From Piles",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-coins[i]] + coins[i])\n        # dp[i][j] = max(dp[i-"
    },
    {
        "number": 2225,
        "title": "Find Players With Zero or One Losses",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(matches)\n        # res = []\n        # for i in range(n):\n        #     if len(res) == 0:\n        #         res.append(i)\n        #     else:\n        #         if matches[i][0]!= matches[res[-1]][1]:\n        #             res.append(i)\n        #         else:\n        #             res.pop()\n        # return res"
    },
    {
        "number": 2226,
        "title": "Maximum Candies Allocated to K Children",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * (len(candies) + 1)\n        # for i in range(1, len(candies) + 1):\n        #     dp[i] = max(dp[i - 1], candies[i - 1])\n        # return sum(dp[-k:])"
    },
    {
        "number": 2227,
        "title": "Encrypt and Decrypt Strings",
        "difficulty": 2,
        "answer": "        # Your Encrypter object will be instantiated and called as such:\n        # obj = Encrypter(keys, values, dictionary)\n        # param_1 = obj.encrypt(word1)\n        # param_2 = obj.decrypt(word2)\n        \n        # Your Encrypter object will be instantiated and called as such:\n        # obj = Encrypter(keys, values, dictionary)\n        # param_1 = obj.encrypt(word1)\n        # param_2 = obj.decrypt(word2)\n        \n        # Your Encrypter object will be instantiated and called as such:\n        # obj = Encrypter(keys, values, dictionary)\n        # param_1 = obj.encrypt(word1)\n        # param_2 = obj.decrypt(word2)\n        \n        # Your Encrypter object will be instantiated and called as such:\n        # obj = Encrypter(keys, values, dictionary)\n        # param_1 = obj.encrypt(word1)\n        # param_2 = obj.decrypt("
    },
    {
        "number": 2269,
        "title": "Find the K-Beauty of a Number",
        "difficulty": 0,
        "answer": "        if k == 1:\n            return num\n        if k == 2:\n            return num // 10 + num % 10\n        if k == 3:\n            return num // 100 + num // 10 % 10 + num % 10\n        if k == 4:\n            return num // 1000 + num // 100 % 10 + num // 10 % 10 + num % 10\n        if k == 5:\n            return num // 10000 + num // 1000 % 10 + num // 100 % 10 + num // 10 % 10 + num % 10\n        if k == 6:\n            return num // 100000 + num // 10000 % 10 + num // 1000 % 10 + num // 100 % 10 + num // 10 % 10 + num % 10\n        if k == 7:\n            return num // 1000000 + num // 100000 % 10 + num // 10000 % 10 + num // 1000 % 10 + num // 100 % 10 + num // 10 % 10 + num % 10\n        if k == 8:\n            return num // 10000000 + num // 1000000 % 10 + num // 100000 % 10 + num // 10000 % 10 + num // 1000 % 10 + num // 100 %"
    },
    {
        "number": 2273,
        "title": "Find Resultant Array After Removing Anagrams",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not words:\n        #     return []\n        \n        # res = []\n        # for i in range(len(words)):\n        #     if i == 0:\n        #         res.append(words[i])\n        #     else:\n        #         if words[i] == res[-1]:\n        #             res.append(words[i])\n        #         else:\n        #             res = res[:-1]\n        #             res.append(words[i])\n        # return res\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not words:\n        #     return []\n        \n        # res = []\n        # for i in range(len(words)):\n        #     if i == 0:\n        #         res.append(words[i])\n        #     else:\n        #         if words[i] == res[-1]:\n        #             res.append(words"
    },
    {
        "number": 2303,
        "title": "Calculate Amount Paid in Taxes",
        "difficulty": 0,
        "answer": "        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n        # Brackets are sorted by upper bound\n"
    },
    {
        "number": 2304,
        "title": "Minimum Path Cost in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]"
    },
    {
        "number": 2305,
        "title": "Fair Distribution of Cookies",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(cookies) + 1)]\n        # for i in range(1, len(cookies) + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if j >= cookies[i - 1]:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j - cookies[i - 1]] + cookies[i - 1])\n        # return max(dp[-1])"
    },
    {
        "number": 2309,
        "title": "Greatest English Letter in Upper and Lower Case",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # for i in range(len(s)):\n        #     if s[i].isupper():\n        #         return s[i]\n        # return \"\""
    },
    {
        "number": 2310,
        "title": "Sum of Numbers With Units Digit K",
        "difficulty": 1,
        "answer": "        if num == 0:\n            return 0\n        if k == 0:\n            return 0\n        if k == 1:\n            return num\n        if k == 2:\n            return num + 1\n        if k == 3:\n            return num + 2\n        if k == 4:\n            return num + 3\n        if k == 5:\n            return num + 4\n        if k == 6:\n            return num + 5\n        if k == 7:\n            return num + 6\n        if k == 8:\n            return num + 7\n        if k == 9:\n            return num + 8\n        if k == 10:\n            return num + 9\n        if k == 11:\n            return num + 10\n        if k == 12:\n            return num + 11\n        if k == 13:\n            return num + 12\n        if k == 14:\n            return num + 13\n        if k == 15:\n            return num + 14\n        if k == 16:\n            return num + 15\n        if k == 17:\n            return num + 16\n        if k == 18:\n            return"
    },
    {
        "number": 2312,
        "title": "Selling Pieces of Wood",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + prices[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1"
    },
    {
        "number": 2321,
        "title": "Maximum Score Of Spliced Array",
        "difficulty": 2,
        "answer": "        n1 = len(nums1)\n        n2 = len(nums2)\n        if n1 == 0 or n2 == 0:\n            return 0\n        if n1 == 1 and n2 == 1:\n            return max(nums1[0], nums2[0])\n        if n1 == 1 and n2 == 2:\n            return max(nums1[0], nums2[1])\n        if n1 == 2 and n2 == 1:\n            return max(nums1[1], nums2[0])\n        if n1 == 2 and n2 == 2:\n            return max(nums1[1], nums2[1])\n        \n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n                if nums1[i - 1"
    },
    {
        "number": 2022,
        "title": "Convert 1D Array Into 2D Array",
        "difficulty": 0,
        "answer": "        if m == 0 or n == 0:\n            return []\n        if m * n > len(original):\n            return []\n        \n        res = []\n        for i in range(m):\n            res.append(original[i*n:i*n+n])\n        return res"
    },
    {
        "number": 2023,
        "title": "Number of Pairs of Strings With Concatenation Equal to Target",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        #\n        # res = 0\n        # for i in range(len(nums)):\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             res += 1\n        # return res"
    },
    {
        "number": 2024,
        "title": "Maximize the Confusion of an Exam",
        "difficulty": 1,
        "answer": "        if not answerKey:\n            return 0\n        \n        count = 0\n        ans = 0\n        for i in range(len(answerKey)):\n            if answerKey[i] == 'T':\n                count += 1\n                ans = max(ans, count)\n            else:\n                count = 0\n            if count == k:\n                return ans\n        return ans"
    },
    {
        "number": 2025,
        "title": "Maximum Number of Ways to Partition an Array",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        # for i in range(len(nums) + 1):\n        #     dp[i][0] = 1\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, k + 1):\n        #         if j - nums[i - 1] >= 0:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i - 1]]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 2027,
        "title": "Minimum Moves to Convert String",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2028,
        "title": "Find Missing Observations",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # if not n:\n        #     return []\n        # if n == 1:\n        #     return [mean]\n        # if n == 2:\n        #     return [mean - rolls[0] - rolls[1], mean - 2 * rolls[0] - 2 * rolls[1]]\n        # if n == 3:\n        #     return [mean - rolls[0] - rolls[1] - rolls[2], mean - 3 * rolls[0] - 3 * rolls[1] - 3 * rolls[2],\n        #             mean - 4 * rolls[0] - 4 * rolls[1] - 4 * rolls[2]]\n        # if n == 4:\n        #     return [mean - rolls[0] - rolls[1] - rolls[2] - rolls[3],\n        #             mean - 4 * rolls[0] - 4 * rolls[1] - 4 * rolls[2] - 4 * rolls[3],\n        #             mean - 5 * rolls[0] -"
    },
    {
        "number": 2029,
        "title": "Stone Game IX",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # def helper(stones, i, j):\n        #     if (i, j) in dp:\n        #         return dp[(i, j)]\n        #     if i == j:\n        #         return True\n        #     if i > j:\n        #         return False\n        #     if stones[i] == stones[j]:\n        #         return helper(stones, i + 1, j - 1)\n        #     if stones[i]!= stones[j]:\n        #         dp[(i, j)] = helper(stones, i + 1, j) or helper(stones, i, j - 1)\n        #         return dp[(i, j)]\n        # return helper(stones, 0, len(stones) - 1)"
    },
    {
        "number": 2030,
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return s\n        # if k == 0:\n        #     return ''\n        # if k == 1:\n        #     if letter in s:\n        #         return s\n        #     else:\n        #         return ''\n        # if k == 2:\n        #     if letter in s:\n        #         if repetition == 1:\n        #             return s\n        #         else:\n        #             return ''\n        #     else:\n        #         return ''\n        # if k == 3:\n        #     if letter in s:\n        #         if repetition == 1:\n        #             return s\n        #         else:\n        #             return ''\n        #     else:\n        #         return ''\n        # if k == 4:\n        #     if letter in s:\n        #         if repetition == 1:\n        #             return s\n        #         else:\n        #             return ''\n        #     else:\n        #"
    },
    {
        "number": 2032,
        "title": "Two Out of Three",
        "difficulty": 0,
        "answer": "        nums1 = set(nums1)\n        nums2 = set(nums2)\n        nums3 = set(nums3)\n        return list(nums1.intersection(nums2, nums3))\n"
    },
    {
        "number": 2033,
        "title": "Minimum Operations to Make a Uni-Value Grid",
        "difficulty": 1,
        "answer": "        # Time: O(mn)\n        # Space: O(mn)\n        # dp = [[0] * len(grid[0]) for _ in range(len(grid))]\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == x:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = float('inf')\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == x:\n        #             continue\n        #         for k in range(len(grid)):\n        #             for l in range(len(grid[0])):\n        #                 if grid[k][l] == x:\n        #                     continue\n        #                 if dp[i][j] + dp[k][l] < dp[i][l]:\n        #                     dp["
    },
    {
        "number": 2034,
        "title": "Stock Price Fluctuation ",
        "difficulty": 1,
        "answer": "    def update(self, timestamp: int, price: int) -> None:\n        \"\"\"\n        You are given a stream of records about a particular stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.\n        Unfortunately due to the volatile nature of the stock market, the records do not come in order. Even worse, some records may be incorrect.\n        Design an algorithm that:\n            Updates the price of the stock at a particular timestamp, correcting the price from any previous records at the timestamp.\n            Finds the latest price of the stock based on the current records. The latest price is the price at the latest timestamp recorded.\n            Finds the maximum price the stock has been based on the current records.\n            Finds the minimum price the stock has been based on the current records.\n        Implement the StockPrice class:\n            StockPrice() Initializes the object with no price records.\n            void update(int timestamp, int price) Updates the price of the stock at the given timestamp.\n            int current() Returns the latest price of the stock.\n            int maximum() Returns the maximum price of the stock.\n            int minimum()"
    },
    {
        "number": 2035,
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        nums.sort()\n        diff = float('inf')\n        for i in range(n):\n            diff = min(diff, abs(nums[i] - nums[n - 1 - i]))\n        return diff\n"
    },
    {
        "number": 2037,
        "title": "Minimum Number of Moves to Seat Everyone",
        "difficulty": 0,
        "answer": "        # seats = [3,1,5]\n        # students = [2,7,4]\n        # seats = [4,1,5,9]\n        # students = [1,3,2,6]\n        # seats = [2,2,6,6]\n        # students = [1,3,2,6]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        # seats = [1,1,1,1]\n        # students = [1,1,1,1]\n        #"
    },
    {
        "number": 2038,
        "title": "Remove Colored Pieces if Both Neighbors are the Same Color",
        "difficulty": 1,
        "answer": "        n = len(colors)\n        if n == 1:\n            return True\n        if n == 2:\n            return colors[0]!= colors[1]\n        if n == 3:\n            return colors[0]!= colors[1] and colors[1]!= colors[2]\n        if n == 4:\n            return colors[0]!= colors[1] and colors[1]!= colors[2] and colors[2]!= colors[3]\n        if n == 5:\n            return colors[0]!= colors[1] and colors[1]!= colors[2] and colors[2]!= colors[3] and colors[3]!= colors[4]\n        if n == 6:\n            return colors[0]!= colors[1] and colors[1]!= colors[2] and colors[2]!= colors[3] and colors[3]!= colors[4] and colors[4]!= colors[5]\n        if n == 7:\n            return colors[0]!= colors[1] and colors[1]!= colors[2] and colors[2]!= colors"
    },
    {
        "number": 2039,
        "title": "The Time When the Network Becomes Idle",
        "difficulty": 1,
        "answer": "        n = len(patience)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, time):\n            if node == 0:\n                return time\n            \n            for nei in graph[node]:\n                if nei not in visited:\n                    visited.add(nei)\n                    time = dfs(nei, time + patience[node])\n                    visited.remove(nei)\n            return time\n        \n        visited = set()\n        return dfs(0, 0)"
    },
    {
        "number": 2040,
        "title": "Kth Smallest Product of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        \n        def product(nums1, nums2, k):\n            if k == 1:\n                return nums1[0] * nums2[0]\n            \n            if k == 2:\n                return nums1[0] * nums2[1] * nums1[1]\n            \n            if k == 3:\n                return nums1[0] * nums2[2] * nums1[2] * nums2[1]\n            \n            if k == 4:\n                return nums1[0] * nums2[3] * nums1[3] * nums2[2]\n            \n            if k == 5:\n                return nums1[0] * nums2[4] * nums1[4] * nums2[3]\n            \n            if k == 6:\n                return nums1[0] * nums2[5] * nums1[5] * nums2[4]\n            \n            if k == 7:\n                return nums1[0] * nums2["
    },
    {
        "number": 2042,
        "title": "Check if Numbers Are Ascending in a Sentence",
        "difficulty": 0,
        "answer": "        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"hello world 5 x 5\"\n        # s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\"\n        # s"
    },
    {
        "number": 2043,
        "title": "Simple Bank System",
        "difficulty": 1,
        "answer": "\nclass Solution:\n    def __init__(self, balance: List[int]):\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n    def deposit(self, account: int, money: int) -> bool:\n    def withdraw(self, account: int, money: int) -> bool:\n        \"\"\"\n        You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].\n        Execute all the valid transactions. A transaction is valid if:\n            The given account number(s) are between 1 and n, and\n            The amount of money withdrawn or transferred from is less than or equal to the balance of the account.\n        Implement the Bank class:\n            Bank(long[] balance) Initializes the object with the 0-indexed integer array balance.\n            boolean transfer(int account"
    },
    {
        "number": 2044,
        "title": "Count Number of Maximum Bitwise-OR Subsets",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] | dp[i][j - 1]\n        return max(max(row) for row in dp)"
    },
    {
        "number": 2045,
        "title": "Second Minimum Time to Reach Destination",
        "difficulty": 2,
        "answer": "        # Time O(n^2) | Space O(n)\n        # dp = [[float('inf')] * n for _ in range(n)]\n        # dp[0][0] = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             continue\n        #         for k in range(n):\n        #             if k == i or k == j:\n        #                 continue\n        #             if edges[i][0] == edges[j][0] or edges[i][0] == edges[k][0] or edges[j][0] == edges[k][0]:\n        #                 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + time)\n        # return min(dp[0])"
    },
    {
        "number": 2047,
        "title": "Number of Valid Words in a Sentence",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # count = 0\n        # for i in range(len(sentence)):\n        #     if sentence[i] =='':\n        #         count += 1\n        #     elif sentence[i] == '-':\n        #         if sentence[i-1] == '-' or sentence[i+1] == '-':\n        #             count += 1\n        #         else:\n        #             continue\n        #     elif sentence[i] == '!':\n        #         if sentence[i-1] == '-' or sentence[i+1] == '-':\n        #             count += 1\n        #         else:\n        #             continue\n        #     elif sentence[i] == '.':\n        #         if sentence[i-1] == '-' or sentence[i+1] == '-':\n        #             count += 1\n        #         else:\n        #             continue\n        #     else:\n        #         if sentence[i-1]."
    },
    {
        "number": 2048,
        "title": "Next Greater Numerically Balanced Number",
        "difficulty": 1,
        "answer": "        def is_balanced(n):\n            count = 0\n            while n:\n                count += 1\n                n //= 10\n            return count"
    },
    {
        "number": 2049,
        "title": "Count Nodes With the Highest Score",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(parents)):\n        #     dp[i] = 1\n        #     for j in range(i):\n        #         if parents[i] == parents[j]:\n        #             dp[i] = max(dp[i], dp[j] + 1)\n        # return max(dp.values())"
    },
    {
        "number": 2050,
        "title": "Parallel Courses III",
        "difficulty": 2,
        "answer": "        # Time O(n^2) | Space O(n)\n        # dp = [[0] * (n+1) for _ in range(n+1)]\n        # for i in range(1, n+1):\n        #     for j in range(1, n+1):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         else:\n        #             for k in range(1, n+1):\n        #                 if relations[j-1][0] == k:\n        #                     dp[i][j] = max(dp[i][j], dp[i][k] + time[k-1])\n        # return max(dp[1])\n        \n        # Time O(n^2) | Space O(n)\n        # dp = [[0] * (n+1) for _ in range(n+1)]\n        # for i in range(1, n+1):\n        #     for j in range(1, n+1):\n        #         if i == j:\n"
    },
    {
        "number": 2053,
        "title": "Kth Distinct String in an Array",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        # Hashmap\n        # Time: O(n)\n        # Space: O(n)\n        #"
    },
    {
        "number": 2054,
        "title": "Two Best Non-Overlapping Events",
        "difficulty": 1,
        "answer": "        events.sort(key=lambda x: x[1])\n        n = len(events)\n        dp = [[0] * 3 for _ in range(n)]\n        dp[0][0] = events[0][2]\n        dp[0][1] = events[0][2]\n        dp[0][2] = events[0][2]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) + events[i][2]\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + events[i][2]\n            dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + events[i][2]\n        return max(dp[-1])"
    },
    {
        "number": 2055,
        "title": "Plates Between Candles",
        "difficulty": 1,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = [[0] * len(s) for _ in range(len(s))]\n        # for i in range(len(s)):\n        #     if s[i] == '*':\n        #         dp[i][i] = 1\n        # for i in range(len(s) - 1, -1, -1):\n        #     if s[i] == '*':\n        #         dp[i][i] = 1\n        # for i in range(len(s) - 2, -1, -1):\n        #     for j in range(i + 1, len(s)):\n        #         if s[i] == '*' and s[j] == '*':\n        #             dp[i][j] = dp[i + 1][j - 1] + 1\n        #         elif s[i] == '*' and s[j]!= '*':\n        #             dp[i][j] = dp[i + 1"
    },
    {
        "number": 2056,
        "title": "Number of Valid Move Combinations On Chessboard",
        "difficulty": 2,
        "answer": "        def get_pos(pos):\n            return pos[0] - 1, pos[1] - 1\n        \n        def get_dir(pos):\n            if pos[0] == 0:\n                return 0, 1\n            elif pos[0] == 7:\n                return 0, -1\n            elif pos[1] == 0:\n                return 1, 0\n            elif pos[1] == 7:\n                return -1, 0\n            else:\n                return 1, 1\n        \n        def get_dir_opposite(pos):\n            if pos[0] == 0:\n                return 0, -1\n            elif pos[0] == 7:\n                return 0, 1\n            elif pos[1] == 0:\n                return -1, 0\n            elif pos[1] == 7:\n                return 1, 0\n            else:\n                return -1, -1\n        \n        def get_dir_opposite_diag(pos):\n            if pos[0] == 0:\n                return 0, -1\n            elif pos[0"
    },
    {
        "number": 2057,
        "title": "Smallest Index With Equal Value",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # for i in range(len(nums)):\n        #     if nums[i] % 10 == nums[i]:\n        #         return i\n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # for i in range(len(nums)):\n        #     if nums[i] % 10 == nums[i]:\n        #         return i\n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # for i in range(len(nums)):\n        #     if nums[i] % 10 == nums[i]:\n        #         return i\n        # return -1\n        \n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted("
    },
    {
        "number": 2058,
        "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
        "difficulty": 1,
        "answer": "        if not head:\n            return [-1, -1]\n        \n        # find the first local maxima\n        first_max = self.find_first_max(head)\n        \n        # find the first local minima\n        first_min = self.find_first_min(head)\n        \n        # find the second local maxima\n        second_max = self.find_second_max(head, first_max)\n        \n        # find the second local minima\n        second_min = self.find_second_min(head, first_min)\n        \n        # find the third local maxima\n        third_max = self.find_third_max(head, second_max)\n        \n        # find the third local minima\n        third_min = self.find_third_min(head, second_min)\n        \n        # find the fourth local maxima\n        fourth_max = self.find_fourth_max(head, third_max)\n        \n        # find the fourth local minima\n        fourth_min = self.find_fourth_min(head,"
    },
    {
        "number": 2059,
        "title": "Minimum Operations to Convert Number",
        "difficulty": 1,
        "answer": "        if start == goal:\n            return 0\n        \n        if start > goal:\n            return -1\n        \n        if start == 0:\n            return len(nums) - 1\n        \n        if start == 1:\n            return len(nums)\n        \n        if start == 2:\n            return len(nums)\n        \n        if start == 3:\n            return len(nums)\n        \n        if start == 4:\n            return len(nums)\n        \n        if start == 5:\n            return len(nums)\n        \n        if start == 6:\n            return len(nums)\n        \n        if start == 7:\n            return len(nums)\n        \n        if start == 8:\n            return len(nums)\n        \n        if start == 9:\n            return len(nums)\n        \n        if start == 10:\n            return len(nums)\n        \n        if start == 11:\n            return len(nums)\n        \n        if start == 12:\n            return len(nums)\n        \n"
    },
    {
        "number": 2060,
        "title": "Check if an Original String Exists Given Two Encoded Strings",
        "difficulty": 2,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if len(s1) == 0:\n            return True\n        if len(s1) == 1:\n            return s1 == s2\n        if len(s1) == 2:\n            return s1[0] == s2[0] and s1[1] == s2[1]\n        if len(s1) == 3:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2]\n        if len(s1) == 4:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3]\n        if len(s1) == 5:\n            return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1"
    },
    {
        "number": 2062,
        "title": "Count Vowel Substrings of a String",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        count = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                count += 1\n            for j in range(i + 1, len(word)):\n                if word[j] in vowels:\n                    count += 1\n        return count"
    },
    {
        "number": 2063,
        "title": "Vowels of All Substrings",
        "difficulty": 1,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        count = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                count += 1\n        return count"
    },
    {
        "number": 2064,
        "title": "Minimized Maximum of Products Distributed to Any Store",
        "difficulty": 1,
        "answer": "        \n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1], dp[i-1] + quantities[i])\n        # dp[i] = max(dp[i-1],"
    },
    {
        "number": 2065,
        "title": "Maximum Path Quality of a Graph",
        "difficulty": 2,
        "answer": "        # dfs\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + memo\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + stack\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + queue\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + heap\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + priority queue\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + priority queue + heap\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + priority queue + stack\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # dfs + priority queue + queue\n        # Time"
    },
    {
        "number": 2068,
        "title": "Check Whether Two Strings are Almost Equivalent",
        "difficulty": 0,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        freq1 = {}\n        freq2 = {}\n        for c in word1:\n            if c not in freq1:\n                freq1[c] = 0\n            freq1[c] += 1\n        for c in word2:\n            if c not in freq2:\n                freq2[c] = 0\n            freq2[c] += 1\n        for c in freq1:\n            if c not in freq2:\n                return False\n            if abs(freq1[c] - freq2[c]) > 3:\n                return False\n        return True"
    },
    {
        "number": 2069,
        "title": "Walking Robot Simulation II",
        "difficulty": 1,
        "answer": "    def __init__(self, width: int, height: int):\n    def step(self, num: int) -> None:\n    def getPos(self) -> List[int]:\n    def getDir(self) -> str:\n        \"\"\"\n        A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (\"North\", \"East\", \"South\", and \"West\"). A robot is initially at cell (0, 0) facing direction \"East\".\n        The robot can be instructed to move for a specific number of steps. For each step, it does the following.\n            Attempts to move forward one cell in the direction it is facing.\n            If the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.\n        After the robot finishes moving the number of steps required, it stops and awaits the next instruction.\n        Implement the Robot class:\n            Robot(int width, int height) Initializes the width"
    },
    {
        "number": 2070,
        "title": "Most Beautiful Item for Each Query",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[0] * (len(queries) + 1) for _ in range(len(items) + 1)]\n        # for i in range(1, len(items) + 1):\n        #     for j in range(1, len(queries) + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if items[i - 1][0] <= queries[j - 1]:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + items[i - 1][1])\n        # return [dp[-1][-1]]\n        \n        # O(n^2)\n        # dp = [[0] * (len(queries) + 1) for _ in range(len(items) + 1)]\n        # for i in range(1, len(items) + 1):\n        #     for j in range(1, len(queries) + 1):\n        #         dp"
    },
    {
        "number": 2071,
        "title": "Maximum Number of Tasks You Can Assign",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + tasks[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + pills\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + strength\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + tasks[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + pills\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + strength\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + tasks[i]\n        # dp[i][j] = max"
    },
    {
        "number": 2073,
        "title": "Time Needed to Buy Tickets",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if k == 0:\n        #     return 0\n        # if k > len(tickets):\n        #     return -1\n        # if k == len(tickets):\n        #     return 0\n        #\n        # # if k == 0:\n        # #     return 0\n        #\n        # # if k == len(tickets):\n        # #     return 0\n        #\n        # # if k == 0:\n        # #     return 0\n        #\n        # # if k == len(tickets):\n        # #     return 0\n        #\n        # # if k == 0:\n        # #     return 0\n        #\n        # # if k == len(tickets):\n        # #     return 0\n        #\n        # # if k == 0:\n        # #     return 0\n        #\n        # # if k == len(tickets):\n        # #     return 0\n        #\n        # # if k == 0:\n        # #     return 0\n"
    },
    {
        "number": 2074,
        "title": "Reverse Nodes in Even Length Groups",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        # find the length of the longest group\n        longest_group_length = 0\n        curr = head\n        while curr:\n            longest_group_length += 1\n            curr = curr.next\n        \n        # reverse the nodes in each group with an even length\n        curr = head\n        for i in range(longest_group_length):\n            if i % 2 == 0:\n                curr.next, curr = curr, curr.next\n            curr = curr.next\n        \n        return head"
    },
    {
        "number": 2075,
        "title": "Decode the Slanted Ciphertext",
        "difficulty": 1,
        "answer": "        # print(encodedText)\n        # print(rows)\n        # print(len(encodedText))\n        # print(len(encodedText) % rows)\n        # print(len(encodedText) // rows)\n        # print(len(encodedText) // rows + 1)\n        # print(len(encodedText) // rows + 2)\n        # print(len(encodedText) // rows + 3)\n        # print(len(encodedText) // rows + 4)\n        # print(len(encodedText) // rows + 5)\n        # print(len(encodedText) // rows + 6)\n        # print(len(encodedText) // rows + 7)\n        # print(len(encodedText) // rows + 8)\n        # print(len(encodedText) // rows + 9)\n        # print(len(encodedText) // rows + 10)\n        # print(len(encodedText) // rows + 11)\n        # print(len(encodedText) // rows + 12)\n        # print"
    },
    {
        "number": 2076,
        "title": "Process Restricted Friend Requests",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # dfs\n        # dfs(i, j) = True if i and j can be friends\n        # dfs(i, j) = False if i and j cannot be friends\n        # dfs(i, j) = True if i and j are already friends\n        # dfs(i, j) = False if i and j are not friends\n        # dfs(i, j) = True if i and j are friends\n        # dfs(i, j) = False if i and j are not friends\n        # dfs(i, j) = True if i and j are friends\n        # dfs(i, j) = False if i and j are not friends\n        # dfs(i, j) = True if i and j are friends\n        # dfs(i, j) = False if i and j are not friends\n        # dfs(i, j) = True if i and j are friends\n        # dfs(i, j) = False if i and"
    },
    {
        "number": 2078,
        "title": "Two Furthest Houses With Different Colors",
        "difficulty": 0,
        "answer": "        n = len(colors)\n        if n == 1:\n            return 0\n        \n        # dp[i][j] = max distance between i and j\n        dp = [[0] * n for _ in range(n)]\n        \n        # dp[i][i] = 0\n        for i in range(n):\n            dp[i][i] = 0\n        \n        # dp[i][i+1] = abs(i - i+1)\n        for i in range(n-1):\n            dp[i][i+1] = abs(i - i+1)\n        \n        # dp[i][i+2] = abs(i - i+2)\n        for i in range(n-2):\n            dp[i][i+2] = abs(i - i+2)\n        \n        # dp[i][i+3] = abs(i - i+3)\n        for i in range(n-3):\n            dp[i][i+3] = abs(i - i+3)\n        \n        "
    },
    {
        "number": 2081,
        "title": "Sum of k-Mirror Numbers",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return n\n        if k == 2:\n            return n * (n + 1) // 2\n        if k == 3:\n            return n * (n + 1) * (2 * n + 1) // 6\n        if k == 4:\n            return n * (n + 1) * (3 * n + 1) // 6\n        if k == 5:\n            return n * (n + 1) * (4 * n + 1) // 6\n        if k == 6:\n            return n * (n + 1) * (5 * n + 1) // 6\n        if k == 7:\n            return n * (n + 1) * (6 * n + 1) // 6\n        if k == 8:\n            return n * (n + 1) * (7 * n + 1) // 6\n        if k == 9:\n            return n * (n + 1) * (8 * n + 1) // 6\n        if k == 10:\n            return n * (n + 1) * (9 * n + 1) // 6\n        if k =="
    },
    {
        "number": 2085,
        "title": "Count Common Words With One Occurrence",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(m + n)\n        # Space: O(m + n)\n        # m = len(words1)\n        # n = len(words2)\n        # dp = [[0] * (n + 1) for _ in range(m + 1)]\n        # for i in range(1, m + 1):\n        #     for j in range(1, n + 1):\n        #         if words1[i - 1] == words2[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        # return dp[m][n]"
    },
    {
        "number": 2086,
        "title": "Minimum Number of Food Buckets to Feed the Hamsters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(hamsters)\n        # if n == 0:\n        #     return -1\n        #\n        # buckets = 0\n        # for i in range(n):\n        #     if hamsters[i] == 'H':\n        #         buckets += 1\n        #\n        # if buckets == 0:\n        #     return -1\n        #\n        # left = 0\n        # right = n - 1\n        #\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if hamsters[mid] == 'H':\n        #         if mid - 1 >= 0 and hamsters[mid - 1] == '.':\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        #     else:\n        #         if mid + 1 <= n - 1 and hamsters[mid + 1] == '.':\n        #             right = mid - 1\n        #         else:\n        #"
    },
    {
        "number": 2087,
        "title": "Minimum Cost Homecoming of a Robot in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(rowCosts), len(colCosts)\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[startPos[0]][startPos[1]] = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1] + colCosts[j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + rowCosts[i]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + min(colCosts[j], rowCosts[i])\n        return dp[-1][-1]"
    },
    {
        "number": 2088,
        "title": "Count Fertile Pyramids in a Land",
        "difficulty": 2,
        "answer": "        def is_pyramid(grid, r, c):\n            if r == 0 or c == 0:\n                return False\n            if grid[r][c] == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:\n                return False\n            if r == 0 or c == 0:"
    },
    {
        "number": 2089,
        "title": "Find Target Indices After Sorting Array",
        "difficulty": 0,
        "answer": "        if not nums:\n            return []\n        \n        # find the first index of target\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # find the first index of target\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # find the last index of target\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n"
    },
    {
        "number": 2090,
        "title": "K Radius Subarray Averages",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        \n        n = len(nums)\n        if k == 0:\n            return [nums[i] for i in range(n)]\n        \n        avg = [0] * n\n        for i in range(n):\n            avg[i] = (nums[i] + nums[i - k] + nums[i + k]) / 3\n        \n        return avg"
    },
    {
        "number": 2091,
        "title": "Removing Minimum and Maximum From Array",
        "difficulty": 1,
        "answer": "        # O(n)\n        # min_val = float('inf')\n        # max_val = float('-inf')\n        # for num in nums:\n        #     if num < min_val:\n        #         min_val = num\n        #     if num > max_val:\n        #         max_val = num\n        # return min_val + max_val\n        \n        # O(n)\n        # min_val = float('inf')\n        # max_val = float('-inf')\n        # for num in nums:\n        #     if num < min_val:\n        #         min_val = num\n        #     if num > max_val:\n        #         max_val = num\n        # return min_val + max_val\n        \n        # O(n)\n        # min_val = float('inf')\n        # max_val = float('-inf')\n        # for num in nums:\n        #     if num < min_val:\n        #         min_val = num\n        #     if num > max"
    },
    {
        "number": 2092,
        "title": "Find All People With Secret",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[-1] * n for _ in range(n)]\n        # dp[0][0] = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         if dp[i][j] == -1:\n        #             continue\n        #         for k in range(n):\n        #             if dp[i][k] == -1:\n        #                 continue\n        #             if k == j:\n        #                 continue\n        #             if dp[k][j] == -1:\n        #                 dp[k][j] = dp[i][k] + 1\n        #             else:\n        #                 dp[k][j] = min(dp[k][j], dp[i][k] + 1)\n        # return [i for i in range(n) if dp[i][0] == -1]"
    },
    {
        "number": 2094,
        "title": "Finding 3-Digit Even Numbers",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # res = []\n        # for i in range(len(digits)):\n        #     if digits[i] % 2 == 0:\n        #         res.append(digits[i])\n        # return sorted(res)"
    },
    {
        "number": 2095,
        "title": "Delete the Middle Node of a Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        slow.next = slow.next.next\n        \n        return head\n"
    },
    {
        "number": 2096,
        "title": "Step-By-Step Directions From a Binary Tree Node to Another",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(n)\n        # Space: O(n)\n        # if not root:\n        #     return \"\"\n        # directions = []\n        # stack = [(root, startValue, directions)]\n        # while stack:\n        #     node, value, directions = stack.pop()\n        #     if node.val == destValue:\n        #         return \"\".join(directions)\n        #     if value > node.val:\n        #         if node.left:\n        #             stack.append((node.left, value - 1, directions + [\"L\"]))\n        #         if node.right:\n        #             stack.append((node.right, value - 1, directions + [\"R\"]))\n        #     else:\n        #         if node.right:\n        #             stack.append((node.right, value + 1, directions + [\"R\"]))\n        #         if node.left:\n        #             stack.append((node.left, value + 1, directions + [\"L\"]))\n        # return \"\""
    },
    {
        "number": 2097,
        "title": "Valid Arrangement of Pairs",
        "difficulty": 2,
        "answer": "        n = len(pairs)\n        pairs.sort(key=lambda x: x[1])\n        visited = set()\n        res = []\n        \n        def dfs(i, curr):\n            if i == n:\n                res.append(curr)\n                return\n            for j in range(pairs[i][0], pairs[i][1]+1):\n                if j not in visited:\n                    visited.add(j)\n                    dfs(i+1, curr+[j])\n                    visited.remove(j)\n        \n        dfs(0, [])\n        return res"
    },
    {
        "number": 2099,
        "title": "Find Subsequence of Length K With the Largest Sum",
        "difficulty": 0,
        "answer": "        \n        # Solution 1: DP\n        # Time: O(nk)\n        # Space: O(nk)\n        # dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + nums[i - 1])\n        # return dp[-1][-1]\n        \n        # Solution 2: Greedy\n        # Time: O(nk)\n        # Space: O(nk)\n        # dp = [0] * (k + 1)\n        # for i in range(len(nums)):\n        #     for j in range(k, 0, -1):\n        #         dp[j] = max(dp[j], dp[j - 1] + nums[i])\n        # return d"
    },
    {
        "number": 2100,
        "title": "Find Good Days to Rob the Bank",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not security:\n        #     return []\n        # n = len(security)\n        # if n == 1:\n        #     return [0]\n        # if n == 2:\n        #     return [0, 1] if security[0] >= security[1] else []\n        # if n == 3:\n        #     return [0, 1, 2] if security[0] >= security[1] >= security[2] else []\n        # if n == 4:\n        #     return [0, 1, 2, 3] if security[0] >= security[1] >= security[2] >= security[3] else []\n        # if n == 5:\n        #     return [0, 1, 2, 3, 4] if security[0] >= security[1] >= security[2] >= security[3] >= security[4] else []\n        # if n == 6:\n        #     return [0, 1, 2, 3, 4, 5] if security[0] >= security"
    },
    {
        "number": 2101,
        "title": "Detonate the Maximum Bombs",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * len(bombs) for _ in range(len(bombs))]\n        # for i in range(len(bombs)):\n        #     for j in range(i + 1, len(bombs)):\n        #         if bombs[i][2] + bombs[j][2] <= bombs[i][0] + bombs[i][1]:\n        #             dp[i][j] = 1\n        #             dp[j][i] = 1\n        # return max(max(row) for row in dp)"
    },
    {
        "number": 2102,
        "title": "Sequentially Ordinal Rank Tracker",
        "difficulty": 2,
        "answer": "    def add(self, name: str, score: int) -> None:\n        \"\"\"\n        A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.\n        You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\n            Adding scenic locations, one at a time.\n            Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).\n                For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.\n        Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.\n        Implement the SORTracker class:\n            SORTracker() Initializes the tracker system.\n            void add"
    },
    {
        "number": 2103,
        "title": "Rings and Rods",
        "difficulty": 0,
        "answer": "        # n = len(rings)\n        # if n == 1:\n        #     return 0\n        # if n == 2:\n        #     return 1\n        # if n == 3:\n        #     return 2\n        # if n == 4:\n        #     return 3\n        # if n == 5:\n        #     return 4\n        # if n == 6:\n        #     return 5\n        # if n == 7:\n        #     return 6\n        # if n == 8:\n        #     return 7\n        # if n == 9:\n        #     return 8\n        # if n == 10:\n        #     return 9\n        # if n == 11:\n        #     return 10\n        # if n == 12:\n        #     return 11\n        # if n == 13:\n        #     return 12\n        # if n == 14:\n        #     return 13\n        # if n == 15:\n        #     return 14\n        # if n == 16:\n        #     return 15\n        # if n == 17:\n        #     return 16\n        # if"
    },
    {
        "number": 2104,
        "title": "Sum of Subarray Ranges",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if not nums:\n        #     return 0\n        # res = 0\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         res += nums[i]\n        #     else:\n        #         res += nums[i] - nums[i-1]\n        # return res"
    },
    {
        "number": 2105,
        "title": "Watering Plants II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # dp = [[0] * (capacityB + 1) for _ in range(capacityA + 1)]\n        # for i in range(capacityA + 1):\n        #     for j in range(capacityB + 1):\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 0\n        #         elif plants[i - 1] <= j:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - plants[i - 1]] + 1)\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[capacityA][capacityB]"
    },
    {
        "number": 2106,
        "title": "Maximum Fruits Harvested After at Most K Steps",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * len(fruits) for _ in range(len(fruits))]\n        # for i in range(len(fruits)):\n        #     dp[i][i] = fruits[i][1]\n        # for i in range(len(fruits) - 1):\n        #     for j in range(i + 1, len(fruits)):\n        #         dp[i][j] = max(dp[i][j - 1], dp[i + 1][j] + fruits[i][1])\n        # return max(dp[0])\n        \n        # dp = [[0] * len(fruits) for _ in range(len(fruits))]\n        # for i in range(len(fruits)):\n        #     dp[i][i] = fruits[i][1]\n        # for i in range(len(fruits) - 1):\n        #     for j in range(i + 1, len("
    },
    {
        "number": 2108,
        "title": "Find First Palindromic String in the Array",
        "difficulty": 0,
        "answer": "        def is_palindrome(word):\n            return word == word[::-1]\n        \n        def is_palindrome_helper(word):\n            if not word:\n                return True\n            if not is_palindrome(word):\n                return False\n            if word[0] == word[-1]:\n                return is_palindrome_helper(word[1:-1])\n            else:\n                return False\n        \n        for word in words:\n            if is_palindrome_helper(word):\n                return word\n        return \"\""
    },
    {
        "number": 2109,
        "title": "Adding Spaces to a String",
        "difficulty": 1,
        "answer": "        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,2,3,4,5,6]\n        # s = \"spacing\"\n        # spaces = [0,1,"
    },
    {
        "number": 2110,
        "title": "Number of Smooth Descent Periods of a Stock",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if not prices:\n        #     return 0\n        # n = len(prices)\n        # dp = [0] * n\n        # dp[0] = 1\n        # for i in range(1, n):\n        #     if prices[i] < prices[i - 1]:\n        #         dp[i] = dp[i - 1] + 1\n        # return max(dp)"
    },
    {
        "number": 2111,
        "title": "Minimum Operations to Make the Array K-Increasing",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if k == 1:\n        #     return len(arr)\n        \n        # n = len(arr)\n        # if n == 1:\n        #     return 0\n        \n        # if k == 2:\n        #     for i in range(n):\n        #         if arr[i] > arr[i+1]:\n        #             return i\n        #     return n\n        \n        # if k == 3:\n        #     for i in range(n):\n        #         if arr[i] > arr[i+1]:\n        #             return i\n        #     return n\n        \n        # if k == 4:\n        #     for i in range(n):\n        #         if arr[i] > arr[i+1]:\n        #             return i\n        #     return n\n        \n        # if k == 5:\n        #     for i in range(n):\n        #         if arr[i] > arr[i+1]:\n        #"
    },
    {
        "number": 2114,
        "title": "Maximum Number of Words Found in Sentences",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # count = {}\n        # for sentence in sentences:\n        #     for word in sentence.split():\n        #         if word not in count:\n        #             count[word] = 1\n        #         else:\n        #             count[word] += 1\n        # return max(count.values())"
    },
    {
        "number": 2115,
        "title": "Find All Possible Recipes from Given Supplies",
        "difficulty": 1,
        "answer": "        def dfs(curr, used, res):\n            if len(curr) == len(ingredients):\n                res.append(curr)\n                return\n            for i in range(len(ingredients)):\n                if ingredients[i] not in used:\n                    used.add(ingredients[i])\n                    dfs(curr + ingredients[i], used, res)\n                    used.remove(ingredients[i])\n        \n        res = []\n        for i in range(len(recipes)):\n            dfs(\"\", set(supplies), res)\n        return res"
    },
    {
        "number": 2116,
        "title": "Check if a Parentheses String Can Be Valid",
        "difficulty": 1,
        "answer": "        if not s or not locked:\n            return False\n        \n        if len(locked)!= len(s):\n            return False\n        \n        if len(locked) == 1 and locked[0] == '0':\n            return False\n        \n        if len(locked) == 1 and locked[0] == '1':\n            return True\n        \n        if len(locked) == 2 and locked[0] == '0' and locked[1] == '0':\n            return False\n        \n        if len(locked) == 2 and locked[0] == '1' and locked[1] == '1':\n            return True\n        \n        if len(locked) == 3 and locked[0] == '0' and locked[1] == '0' and locked[2] == '0':\n            return False\n        \n        if len(locked) == 3 and locked[0] == '1' and locked[1] == '1' and locked[2] == '1':\n            return True\n        \n        if len(locked) == 4 and locked[0] == '0' and locked"
    },
    {
        "number": 2117,
        "title": "Abbreviating the Product of a Range",
        "difficulty": 2,
        "answer": "        # if left == right:\n        #     return str(left)\n        # if left == right - 1:\n        #     return str(left) + 'e'\n        # if left == right - 2:\n        #     return str(left) + 'e0'\n        # if left == right - 3:\n        #     return str(left) + 'e00'\n        # if left == right - 4:\n        #     return str(left) + 'e000'\n        # if left == right - 5:\n        #     return str(left) + 'e0000'\n        # if left == right - 6:\n        #     return str(left) + 'e00000'\n        # if left == right - 7:\n        #     return str(left) + 'e000000'\n        # if left == right - 8:\n        #     return str(left) + 'e0000000'\n        # if left == right - 9:\n        #     return str(left) + 'e00000000'\n        # if left == right - 10:\n        #     return str(left)"
    },
    {
        "number": 2119,
        "title": "A Number After a Double Reversal",
        "difficulty": 0,
        "answer": "        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str(num)[::-1])\n        # return num == num[::-1]\n        # num = int(str"
    },
    {
        "number": 2120,
        "title": "Execution of All Suffix Instructions Staying in a Grid",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if s[i] == 'R':\n        #             dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        #         elif s[i] == 'L':\n        #             dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        #         elif s[i] == 'U':\n        #             dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n        #         elif s[i] == 'D':\n        #             dp[i]["
    },
    {
        "number": 2121,
        "title": "Intervals Between Identical Elements",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not arr:\n        #     return []\n        # d = {}\n        # for i in range(len(arr)):\n        #     if arr[i] in d:\n        #         d[arr[i]] += 1\n        #     else:\n        #         d[arr[i]] = 1\n        # res = []\n        # for i in range(len(arr)):\n        #     if i == 0:\n        #         res.append(d[arr[i]])\n        #     else:\n        #         res.append(d[arr[i]] + res[i - 1])\n        # return res"
    },
    {
        "number": 2122,
        "title": "Recover the Original Array",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # lower = []\n        # higher = []\n        # for i in range(len(nums)):\n        #     if i % 2 == 0:\n        #         lower.append(nums[i])\n        #     else:\n        #         higher.append(nums[i])\n        # return lower + higher"
    },
    {
        "number": 2124,
        "title": "Check if All A\"s Appears Before All B\"s",
        "difficulty": 0,
        "answer": "        # return s.count('a') == s.count('b')\n        return all(s.count(i) == s.count(j) for i, j in zip('ab', 'ba'))"
    },
    {
        "number": 2125,
        "title": "Number of Laser Beams in a Bank",
        "difficulty": 1,
        "answer": "        m, n = len(bank), len(bank[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = 1 if bank[i][j] == '1' else 0\n                else:\n                    if bank[i][j] == '1':\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                    else:\n                        dp[i][j] = dp[i - 1][j]\n        return sum(dp[-1])"
    },
    {
        "number": 2126,
        "title": "Destroying Asteroids",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the asteroids in ascending order\n        # if the planet is smaller than the asteroid, the planet is destroyed\n        # if the planet is bigger than the asteroid, the planet is destroyed\n        # if the planet is equal to the asteroid, the planet is destroyed\n        # if the planet is bigger than the asteroid, the planet is destroyed\n        # if the planet is smaller than the asteroid, the planet is destroyed\n        # if the planet is equal to the asteroid, the planet is destroyed\n        # if the planet is bigger than the asteroid, the planet is destroyed\n        # if the planet is smaller than the asteroid, the planet is destroyed\n        # if the planet is equal to the asteroid, the planet is destroyed\n        # if the planet is bigger than the asteroid, the planet is destroyed\n        # if the planet is smaller than the asteroid, the planet is destroyed\n        # if the planet is equal to the asteroid, the planet is destroyed\n        # if the planet is bigger than the asteroid, the planet is destroyed\n        # if the planet is smaller than the asteroid, the planet is destroyed"
    },
    {
        "number": 2127,
        "title": "Maximum Employees to Be Invited to a Meeting",
        "difficulty": 2,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(favorite)):\n        #     if favorite[i] in dp:\n        #         dp[favorite[i]] += 1\n        #     else:\n        #         dp[favorite[i]] = 1\n        # return max(dp.values())\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(favorite)):\n        #     if favorite[i] in dp:\n        #         dp[favorite[i]] += 1\n        #     else:\n        #         dp[favorite[i]] = 1\n        # return max(dp.values())\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(favorite)):\n        #     if favorite["
    },
    {
        "number": 2129,
        "title": "Capitalize the Title",
        "difficulty": 0,
        "answer": "        # title = title.split()\n        # for i in range(len(title)):\n        #     if len(title[i]) == 1:\n        #         title[i] = title[i].lower()\n        #     else:\n        #         title[i] = title[i][0].upper() + title[i][1:].lower()\n        # return \" \".join(title)"
    },
    {
        "number": 2130,
        "title": "Maximum Twin Sum of a Linked List",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not head:\n        #     return 0\n        # d = {}\n        # curr = head\n        # while curr:\n        #     if curr.val in d:\n        #         d[curr.val] += 1\n        #     else:\n        #         d[curr.val] = 1\n        #     curr = curr.next\n        # max_val = 0\n        # for val in d:\n        #     if d[val] > max_val:\n        #         max_val = d[val]\n        # return max_val * 2\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # if not head:\n        #     return 0\n        # d = {}\n        # curr = head\n        # while curr:\n        #     if curr.val in d:\n        #         d[curr.val] += 1\n        "
    },
    {
        "number": 2131,
        "title": "Longest Palindrome by Concatenating Two Letter Words",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for word in words:\n        #     for i in range(len(word)):\n        #         for j in range(i, len(word)):\n        #             if word[i:j+1] in dp:\n        #                 dp[word[i:j+1]] += 1\n        #             else:\n        #                 dp[word[i:j+1]] = 1\n        # return max(dp.values())"
    },
    {
        "number": 2132,
        "title": "Stamping the Grid",
        "difficulty": 2,
        "answer": "        # Time: O(m*n*s)\n        # Space: O(m*n)\n        # if not grid or not grid[0]:\n        #     return False\n        # m, n = len(grid), len(grid[0])\n        # for i in range(m):\n        #     for j in range(n):\n        #         if grid[i][j] == 1:\n        #             grid[i][j] = 0\n        #             if self.is_valid(grid, i, j, m, n, stampHeight, stampWidth):\n        #                 return True\n        #             grid[i][j] = 1\n        # return False"
    },
    {
        "number": 2133,
        "title": "Check if Every Row and Column Contains All Numbers",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return True\n        n = len(matrix)\n        for i in range(n):\n            if not self.check_row(matrix, i):\n                return False\n        for i in range(n):\n            if not self.check_col(matrix, i):\n                return False\n        return True"
    },
    {
        "number": 2134,
        "title": "Minimum Swaps to Group All 1\"s Together II",
        "difficulty": 1,
        "answer": "        # if not nums:\n        #     return 0\n        #\n        # count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 1:\n        #         count += 1\n        #\n        # if count == len(nums):\n        #     return 0\n        #\n        # if count == 0:\n        #     return 0\n        #\n        # if count == 1:\n        #     return 1\n        #\n        # if count == 2:\n        #     return 2\n        #\n        # if count == 3:\n        #     return 3\n        #\n        # if count == 4:\n        #     return 4\n        #\n        # if count == 5:\n        #     return 5\n        #\n        # if count == 6:\n        #     return 6\n        #\n        # if count == 7:\n        #     return 7\n        #\n        # if count == 8:\n        #     return 8\n        #\n        # if count == 9:\n        #     return 9\n        #\n"
    },
    {
        "number": 2135,
        "title": "Count Words Obtained After Adding a Letter",
        "difficulty": 1,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # m = len(startWords)\n        # n = len(targetWords)\n        # dp = [[0]*(n+1) for _ in range(m+1)]\n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if startWords[i-1] == targetWords[j-1]:\n        #             dp[i][j] = dp[i-1][j-1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # return dp[m][n]"
    },
    {
        "number": 2136,
        "title": "Earliest Possible Day of Full Bloom",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the array\n        plantTime.sort()\n        growTime.sort()\n        n = len(plantTime)\n        # print(plantTime, growTime)\n        # print(n)\n        # print(plantTime[0], growTime[0])\n        # print(plantTime[1], growTime[1])\n        # print(plantTime[2], growTime[2])\n        # print(plantTime[3], growTime[3])\n        # print(plantTime[4], growTime[4])\n        # print(plantTime[5], growTime[5])\n        # print(plantTime[6], growTime[6])\n        # print(plantTime[7], growTime[7])\n        # print(plantTime[8], growTime[8])\n        # print(plantTime[9], growTime[9])\n        # print(plantTime[10], growTime[10])\n        # print(plantTime[11], growTime[11])\n        # print(plant"
    },
    {
        "number": 2138,
        "title": "Divide a String Into Groups of Size k",
        "difficulty": 0,
        "answer": "        def get_groups(s, k, fill):\n            if len(s) < k:\n                return [s]\n            if len(s) == k:\n                return [s]\n            groups = []\n            for i in range(0, len(s), k):\n                groups.append(s[i:i+k])\n            if len(s) % k!= 0:\n                groups.append(s[-1] * (len(s) % k))\n            return groups"
    },
    {
        "number": 2140,
        "title": "Solving Questions With Brainpower",
        "difficulty": 1,
        "answer": "        points = 0\n        brainpower = 0\n        for i in range(len(questions)):\n            if i == 0:\n                points += questions[i][0]\n                brainpower += questions[i][1]\n            else:\n                points += questions[i][0]\n                brainpower += questions[i][1]\n                if points >= brainpower:\n                    points -= questions[i][1]\n                    brainpower = 0\n                else:\n                    brainpower -= questions[i][1]\n        return points"
    },
    {
        "number": 2141,
        "title": "Maximum Running Time of N Computers",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = batteries[i]\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         dp[i][j] = max(dp[i][j], dp[i][j - 1] + batteries[j])\n        # return max(dp[0])"
    },
    {
        "number": 2144,
        "title": "Minimum Cost of Buying Candies With Discount",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not cost:\n        #     return 0\n        # n = len(cost)\n        # min_cost = float('inf')\n        # for i in range(n):\n        #     if i == 0:\n        #         min_cost = min(min_cost, cost[i])\n        #     else:\n        #         min_cost = min(min_cost, cost[i] + min_cost)\n        # return min_cost"
    },
    {
        "number": 2145,
        "title": "Count the Hidden Sequences",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (upper + 1) for _ in range(lower + 1)]\n        # for i in range(lower, upper + 1):\n        #     dp[i][i] = 1\n        # for i in range(lower, upper + 1):\n        #     for j in range(i + 1, upper + 1):\n        #         dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]\n        # return dp[lower][upper]"
    },
    {
        "number": 2146,
        "title": "K Highest Ranked Items Within a Price Range",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(mn)\n        # Space: O(mn)\n        # m = len(grid)\n        # n = len(grid[0])\n        # dp = [[0] * n for _ in range(m)]\n        # dp[start[0]][start[1]] = 1\n        # seen = set()\n        # seen.add(start)\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start[1]))\n        # seen.add((start[0], start["
    },
    {
        "number": 2147,
        "title": "Number of Ways to Divide a Long Corridor",
        "difficulty": 2,
        "answer": "        if not corridor:\n            return 0\n        n = len(corridor)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            if corridor[i - 1] == 'S':\n                dp[i][i] = 1\n            else:\n                dp[i][i] = 0\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n + 1):\n                if corridor[i] == 'S':\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp[0][n] % (10 ** 9 + 7)"
    },
    {
        "number": 2148,
        "title": "Count Elements With Strictly Smaller and Greater Elements ",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] > nums[j]:\n                    count += 1\n        return count"
    },
    {
        "number": 2149,
        "title": "Rearrange Array Elements by Sign",
        "difficulty": 1,
        "answer": "        \n        # if not nums:\n        #     return nums\n        \n        # nums.sort()\n        # if nums[0] < 0:\n        #     nums.reverse()\n        \n        # i = 0\n        # j = len(nums) - 1\n        # while i < j:\n        #     if nums[i] < 0 and nums[j] < 0:\n        #         nums[i], nums[j] = nums[j], nums[i]\n        #         i += 1\n        #         j -= 1\n        #     elif nums[i] < 0:\n        #         nums[i], nums[j] = nums[j], nums[i]\n        #         j -= 1\n        #     elif nums[j] < 0:\n        #         nums[i], nums[j] = nums[j], nums[i]\n        #         i += 1\n        #     else:\n        #         i += 1\n        #         j -= 1\n        \n"
    },
    {
        "number": 2150,
        "title": "Find All Lonely Numbers in the Array",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # res = []\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         if nums[i]!= nums[i+1]:\n        #             res.append(nums[i])\n        #     elif i == len(nums) - 1:\n        #         if nums[i]!= nums[i-1]:\n        #             res.append(nums[i])\n        #     else:\n        #         if nums[i]!= nums[i-1] and nums[i]!= nums[i+1]:\n        #             res.append(nums[i])\n        # return res"
    },
    {
        "number": 2151,
        "title": "Maximum Good People Based on Statements",
        "difficulty": 2,
        "answer": "        # key:\n        #   - if statement[i][j] == 0, then person i is a bad person\n        #   - if statement[i][j] == 1, then person i is a good person\n        #   - if statement[i][j] == 2, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 3, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 4, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 5, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 6, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 7, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] == 8, then person i is neither a bad person nor a good person\n        #   - if statement[i][j] =="
    },
    {
        "number": 2154,
        "title": "Keep Multiplying Found Values by Two",
        "difficulty": 0,
        "answer": "        while True:\n            if original in nums:\n                original = 2 * original\n            else:\n                break\n        return original"
    },
    {
        "number": 2155,
        "title": "All Divisions With the Highest Score of a Binary Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i + 1][j] + nums[i] - nums[j]\n        res = []\n        for i in range(n):\n            max_score = 0\n            for j in range(i, n):\n                max_score = max(max_score, dp[i][j])\n            res.append(max_score)\n        return res"
    },
    {
        "number": 2156,
        "title": "Find Substring With Given Hash Value",
        "difficulty": 2,
        "answer": "        # s = \"leetcode\"\n        # power = 7\n        # modulo = 20\n        # k = 2\n        # hashValue = 0\n        # return \"ee\"\n        # s = \"fbxzaad\"\n        # power = 31\n        # modulo = 100\n        # k = 3\n        # hashValue = 32\n        # return \"fbx\"\n        # s = \"leetcode\"\n        # power = 7\n        # modulo = 20\n        # k = 2\n        # hashValue = 0\n        # return \"ee\"\n        # s = \"fbxzaad\"\n        # power = 31\n        # modulo = 100\n        # k = 3\n        # hashValue = 32\n        # return \"fbx\"\n        # s = \"leetcode\"\n        # power = 7\n        # modulo = 20\n        # k = 2\n        # hashValue = 0\n        # return \"ee\"\n        # s = \"fbxzaad\"\n        # power = 31\n        # modulo = 100\n        # k = 3\n        "
    },
    {
        "number": 2157,
        "title": "Groups of Strings",
        "difficulty": 2,
        "answer": "        \n        def get_letter_set(word):\n            letter_set = set()\n            for letter in word:\n                letter_set.add(letter)\n            return letter_set\n        \n        def get_letter_set_from_group(group):\n            letter_set = set()\n            for word in group:\n                letter_set = letter_set.union(get_letter_set(word))\n            return letter_set\n        \n        def get_letter_set_from_group_with_replacement(group):\n            letter_set = set()\n            for word in group:\n                for letter in get_letter_set(word):\n                    letter_set.add(letter)\n            return letter_set\n        \n        def get_letter_set_from_group_with_deletion(group):\n            letter_set = set()\n            for word in group:\n                for letter in get_letter_set(word):\n                    letter_set.add(letter)\n            return letter_set\n        \n        def get_letter_set_from_group_with"
    },
    {
        "number": 2160,
        "title": "Minimum Sum of Four Digit Number After Splitting Digits",
        "difficulty": 0,
        "answer": "        # num = str(num)\n        # num = num.zfill(4)\n        # print(num)\n        # print(num[0])\n        # print(num[1])\n        # print(num[2])\n        # print(num[3])\n        # print(num[4])\n        # print(num[5])\n        # print(num[6])\n        # print(num[7])\n        # print(num[8])\n        # print(num[9])\n        # print(num[10])\n        # print(num[11])\n        # print(num[12])\n        # print(num[13])\n        # print(num[14])\n        # print(num[15])\n        # print(num[16])\n        # print(num[17])\n        # print(num[18])\n        # print(num[19])\n        # print(num[20])\n        # print(num[21])\n        # print(num[22])\n        # print(num[23])\n        # print(num["
    },
    {
        "number": 2161,
        "title": "Partition Array According to Given Pivot",
        "difficulty": 1,
        "answer": "        \n        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 2\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 3\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 4\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 5\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 6\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 7\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 8\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 9\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 10\n        # Time: O(n)\n        # Space: O(1)\n"
    },
    {
        "number": 2162,
        "title": "Minimum Cost to Set Cooking Time",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(str(targetSeconds))\n        # if n == 1:\n        #     return targetSeconds\n        # if n == 2:\n        #     return targetSeconds\n        # if n == 3:\n        #     return targetSeconds\n        # if n == 4:\n        #     return targetSeconds\n        # if n == 5:\n        #     return targetSeconds\n        # if n == 6:\n        #     return targetSeconds\n        # if n == 7:\n        #     return targetSeconds\n        # if n == 8:\n        #     return targetSeconds\n        # if n == 9:\n        #     return targetSeconds\n        # if n == 10:\n        #     return targetSeconds\n        # if n == 11:\n        #     return targetSeconds\n        # if n == 12:\n        #     return targetSeconds\n        # if n == 13:\n        #     return targetSeconds\n        # if n == 14:\n        #     "
    },
    {
        "number": 2163,
        "title": "Minimum Difference in Sums After Removal of Elements",
        "difficulty": 2,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # n = len(nums)\n        # if n == 1:\n        #     return 0\n        # if n == 2:\n        #     return abs(nums[0] - nums[1])\n        # if n == 3:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2])\n        # if n == 4:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3])\n        # if n == 5:\n        #     return abs(nums[0] - nums[1]) + abs(nums[1] - nums[2]) + abs(nums[2] - nums[3]) + abs(nums[3] - nums[4])\n        # if n == 6:\n        #     return"
    },
    {
        "number": 2164,
        "title": "Sort Even and Odd Indices Independently",
        "difficulty": 0,
        "answer": "        odd = []\n        even = []\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                even.append(nums[i])\n            else:\n                odd.append(nums[i])\n        return even + odd"
    },
    {
        "number": 2165,
        "title": "Smallest Value of the Rearranged Number",
        "difficulty": 1,
        "answer": "        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num))\n        # return num\n        \n        # num = str(num)\n        # num = sorted(num)\n        # num = int(''.join(num"
    },
    {
        "number": 2166,
        "title": "Design Bitset",
        "difficulty": 1,
        "answer": "    def __init__(self, size: int):\n    def fix(self, idx: int) -> None:\n    def unfix(self, idx: int) -> None:\n    def flip(self) -> None:\n    def all(self) -> bool:\n    def one(self) -> bool:\n    def count(self) -> int:\n    def toString(self) -> str:\n        \"\"\"\n        A Bitset is a data structure that compactly stores bits.\n        Implement the Bitset class:\n            Bitset(int size) Initializes the Bitset with size bits, all of which are 0.\n            void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs.\n            void unfix(int idx) Updates the value of the bit at the index idx to 0. If the value was already 0, no change occurs.\n            void flip() Flips the values of each bit in the Bitset. In other words, all bits with value 0 will now have value 1 and vice versa.\n"
    },
    {
        "number": 2167,
        "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 5:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 6:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 7:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 8:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 9:\n        # Time: O(n)\n        # Space: O"
    },
    {
        "number": 2169,
        "title": "Count Operations to Obtain Zero",
        "difficulty": 0,
        "answer": "        # num1 = 10, num2 = 10\n        # num1 = 10, num2 = 9\n        # num1 = 10, num2 = 8\n        # num1 = 10, num2 = 7\n        # num1 = 10, num2 = 6\n        # num1 = 10, num2 = 5\n        # num1 = 10, num2 = 4\n        # num1 = 10, num2 = 3\n        # num1 = 10, num2 = 2\n        # num1 = 10, num2 = 1\n        # num1 = 9, num2 = 10\n        # num1 = 9, num2 = 9\n        # num1 = 9, num2 = 8\n        # num1 = 9, num2 = 7\n        # num1 = 9, num2 = 6\n        # num1 = 9, num2 = 5\n        # num1 = 9, num2 = 4\n        # num1 = 9, num2 = 3\n        # num1 = 9, num2 = 2\n        # num1 = 9, num2 = 1\n        # num1 = 8, num2 ="
    },
    {
        "number": 2170,
        "title": "Minimum Operations to Make the Array Alternating",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if not nums:\n        #     return 0\n        # count = 0\n        # for i in range(1, len(nums)):\n        #     if nums[i - 1] == nums[i]:\n        #         count += 1\n        #     else:\n        #         count += 2\n        # return count"
    },
    {
        "number": 2171,
        "title": "Removing Minimum Number of Magic Beans",
        "difficulty": 1,
        "answer": "        \n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # j = 1, 2, 3,..., i\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min(dp[i], dp[i-j] + 1)\n        # dp[i] = min"
    },
    {
        "number": 2172,
        "title": "Maximum AND Sum of Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [[0] * (numSlots + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, numSlots + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n        return dp[-1][-1]"
    },
    {
        "number": 2176,
        "title": "Count Equal and Divisible Pairs in an Array",
        "difficulty": 0,
        "answer": "        if k == 0:\n            return 0\n        \n        nums.sort()\n        \n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    continue\n                if (nums[i] * nums[j]) % k == 0:\n                    count += 1\n        return count"
    },
    {
        "number": 2177,
        "title": "Find Three Consecutive Integers That Sum to a Given Number",
        "difficulty": 1,
        "answer": "        if num < 0:\n            return []\n        if num == 0:\n            return [0, 0, 0]\n        if num == 1:\n            return [1, 1, 1]\n        if num == 2:\n            return [1, 2, 3]\n        if num == 3:\n            return [1, 3, 4]\n        if num == 4:\n            return [1, 4, 5]\n        if num == 5:\n            return [1, 5, 6]\n        if num == 6:\n            return [1, 6, 7]\n        if num == 7:\n            return [1, 7, 8]\n        if num == 8:\n            return [1, 8, 9]\n        if num == 9:\n            return [1, 9, 10]\n        if num == 10:\n            return [1, 10, 11]\n        if num == 11:\n            return [1, 11, 12]\n        if num == 12:\n            return [1, 12, 13]\n        if num == 13:\n            return [1, 13, 14]\n        "
    },
    {
        "number": 2178,
        "title": "Maximum Split of Positive Even Integers",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 10:\n        # Time: O(n)"
    },
    {
        "number": 2179,
        "title": "Count Good Triplets in an Array",
        "difficulty": 2,
        "answer": "        nums1.sort()\n        nums2.sort()\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] < nums2[j]:\n                    count += 1\n                    break\n        return count"
    },
    {
        "number": 2180,
        "title": "Count Integers With Even Digit Sum",
        "difficulty": 0,
        "answer": "        if num <= 0:\n            return 0\n        \n        count = 0\n        while num > 0:\n            count += num % 10 % 2 == 0\n            num //= 10\n        return count"
    },
    {
        "number": 2181,
        "title": "Merge Nodes in Between Zeros",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        curr = head\n        while curr and curr.next:\n            if curr.val == 0:\n                curr = curr.next\n                continue\n            \n            prev = curr\n            curr = curr.next\n            while curr and curr.val == 0:\n                curr = curr.next\n            \n            if not curr:\n                break\n            \n            prev.next = curr.next\n            curr.next = None\n            curr = prev\n        \n        return head"
    },
    {
        "number": 2182,
        "title": "Construct String With Repeat Limit",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #     if dp[s[i]] > repeatLimit:\n        #         return s[:i]\n        # return s"
    },
    {
        "number": 2183,
        "title": "Count Array Pairs Divisible by K",
        "difficulty": 2,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] * nums[j] % k == 0:\n                    count += 1\n        return count"
    },
    {
        "number": 2185,
        "title": "Counting Words With a Given Prefix",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # hashmap = {}\n        # for word in words:\n        #     if pref in word:\n        #         hashmap[word] = hashmap.get(word, 0) + 1\n        # return len(hashmap)"
    },
    {
        "number": 2186,
        "title": "Minimum Number of Steps to Make Two Strings Anagram II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[s[i]] = dp.get(s[i], 0) + 1\n        # for i in range(len(t)):\n        #     dp[t[i]] = dp.get(t[i], 0) - 1\n        # return sum(abs(x) for x in dp.values())"
    },
    {
        "number": 2187,
        "title": "Minimum Time to Complete Trips",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1)\n        # Time: O(n)\n        # Space: O(1"
    },
    {
        "number": 2188,
        "title": "Minimum Time to Finish the Race",
        "difficulty": 2,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = [[0] * len(tires) for _ in range(numLaps + 1)]\n        # dp[0][0] = changeTime\n        # for i in range(1, numLaps + 1):\n        #     for j in range(len(tires)):\n        #         for k in range(len(tires)):\n        #             if j!= k:\n        #                 dp[i][j] = max(dp[i][j], dp[i - 1][k] + tires[j][0] * tires[k][1])\n        # return max(dp[numLaps])"
    },
    {
        "number": 2190,
        "title": "Most Frequent Number Following Key In an Array",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     if nums[i] == key:\n        #         if nums[i + 1] in hashmap:\n        #             hashmap[nums[i + 1]] += 1\n        #         else:\n        #             hashmap[nums[i + 1]] = 1\n        # return max(hashmap, key=hashmap.get)"
    },
    {
        "number": 2194,
        "title": "Cells in a Range on an Excel Sheet",
        "difficulty": 0,
        "answer": "        # s = \"A1:F1\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2\"\n        # s = \"K1:L2"
    },
    {
        "number": 2195,
        "title": "Append K Integers With Minimal Sum",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        if k > n:\n            return 0\n        if k == n:\n            return sum(nums)\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + nums[i]\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + nums[i - 1]\n        return dp[n][k]"
    },
    {
        "number": 2196,
        "title": "Create Binary Tree From Descriptions",
        "difficulty": 1,
        "answer": "        def createBinaryTree(descriptions, index):\n            if index >= len(descriptions):\n                return None\n            root = TreeNode(descriptions[index][0])\n            if descriptions[index][2] == 1:\n                root.left = createBinaryTree(descriptions, 2 * index + 1)\n            if descriptions[index][2] == 0:\n                root.right = createBinaryTree(descriptions, 2 * index + 2)\n            return root\n        return createBinaryTree(descriptions, 0)"
    },
    {
        "number": 2197,
        "title": "Replace Non-Coprime Numbers in Array",
        "difficulty": 2,
        "answer": "        nums = sorted(nums)\n        while True:\n            found = False\n            for i in range(len(nums)-1):\n                if nums[i] % nums[i+1]!= 0:\n                    found = True\n                    break\n            if not found:\n                break\n            nums.pop(i)\n            nums.pop(i)\n            nums.append(nums[i] * nums[i+1])\n        return nums"
    },
    {
        "number": 2200,
        "title": "Find All K-Distant Indices in an Array",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2203,
        "title": "Minimum Weighted Subgraph With the Required Paths",
        "difficulty": 2,
        "answer": "        # Solution 1: BFS\n        # Time: O(V+E)\n        # Space: O(V+E)\n        # if not n or not edges:\n        #     return -1\n        #\n        # graph = defaultdict(list)\n        # for u, v, w in edges:\n        #     graph[u].append((v, w))\n        #\n        # seen = set()\n        # seen.add(src1)\n        # seen.add(src2)\n        # seen.add(dest)\n        #\n        # queue = deque([(src1, 0)])\n        # while queue:\n        #     node, weight = queue.popleft()\n        #     if node == dest:\n        #         return weight\n        #     for nei, w in graph[node]:\n        #         if nei not in seen:\n        #             seen.add(nei)\n        #             queue.append((nei, weight + w))\n        # return -1"
    },
    {
        "number": 2206,
        "title": "Divide Array Into Equal Pairs",
        "difficulty": 0,
        "answer": "        if len(nums) % 2!= 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums) - 1):\n            if nums[i]!= nums[i+1]:\n                return False\n        \n        return True\n"
    },
    {
        "number": 2207,
        "title": "Maximize Number of Subsequences in a String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(text)):\n        #     if text[i] in dp:\n        #         dp[text[i]] += 1\n        #     else:\n        #         dp[text[i]] = 1\n        #\n        # for i in range(len(pattern)):\n        #     if pattern[i] in dp:\n        #         dp[pattern[i]] += 1\n        #     else:\n        #         dp[pattern[i]] = 1\n        #\n        # max_count = 0\n        # for i in dp:\n        #     if dp[i] > max_count:\n        #         max_count = dp[i]\n        # return max_count"
    },
    {
        "number": 2208,
        "title": "Minimum Operations to Halve Array Sum",
        "difficulty": 1,
        "answer": "        \n        # O(n) time | O(1) space\n        # n = len(nums)\n        # if n == 1:\n        #     return 0\n        # if n == 2:\n        #     return 1\n        # if n == 3:\n        #     return 2\n        # if n == 4:\n        #     return 3\n        # if n == 5:\n        #     return 4\n        # if n == 6:\n        #     return 5\n        # if n == 7:\n        #     return 6\n        # if n == 8:\n        #     return 7\n        # if n == 9:\n        #     return 8\n        # if n == 10:\n        #     return 9\n        # if n == 11:\n        #     return 10\n        # if n == 12:\n        #     return 11\n        # if n == 13:\n        #     return 12\n        # if n == 14:\n        #     return 13\n        # if n == 15:\n        #     return 14\n        # if n == 16:\n        #     return 15\n"
    },
    {
        "number": 2209,
        "title": "Minimum White Tiles After Covering With Carpets",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (carpetLen + 1) for _ in range(numCarpets + 1)]\n        # for i in range(1, numCarpets + 1):\n        #     for j in range(1, carpetLen + 1):\n        #         dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        # for i in range(1, numCarpets + 1):\n        #     for j in range(carpetLen, 0, -1):\n        #         dp[i][j] = dp[i][j] + dp[i - 1][j]\n        # for i in range(1, numCarpets + 1):\n        #     for j in range(carpetLen, 0, -1):\n        #         dp[i][j] = dp[i][j] + dp[i - 1][j]\n        # for i in range(1, numC"
    },
    {
        "number": 2210,
        "title": "Count Hills and Valleys in an Array",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not nums:\n        #     return 0\n        \n        # count = 0\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         if nums[i] < nums[i+1]:\n        #             count += 1\n        #     elif i == len(nums) - 1:\n        #         if nums[i] < nums[i-1]:\n        #             count += 1\n        #     else:\n        #         if nums[i] < nums[i-1] and nums[i] < nums[i+1]:\n        #             count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not nums:\n        #     return 0\n        \n        # count = 0\n        # for i in range(len(nums)):\n        #     if i == 0:\n"
    },
    {
        "number": 2211,
        "title": "Count Collisions on a Road",
        "difficulty": 1,
        "answer": "        # directions = \"RLRSLL\"\n        # directions = \"LLRR\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RRLL\"\n        # directions = \"RR"
    },
    {
        "number": 2212,
        "title": "Maximum Points in an Archery Competition",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i"
    },
    {
        "number": 2213,
        "title": "Longest Substring of One Repeating Character",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * len(s) for _ in range(len(s))]\n        # for i in range(len(s)):\n        #     dp[i][i] = 1\n        # for i in range(len(s) - 1):\n        #     if s[i] == s[i + 1]:\n        #         dp[i][i + 1] = 1\n        # for i in range(len(s) - 2):\n        #     if s[i] == s[i + 2]:\n        #         dp[i][i + 2] = 1\n        # for i in range(len(s) - 3):\n        #     if s[i] == s[i + 3]:\n        #         dp[i][i + 3] = 1\n        # for i in range(len(s) - 4):\n        #     if s[i] == s[i + 4]:\n        #         dp[i][i + 4] = 1\n        # for"
    },
    {
        "number": 2220,
        "title": "Minimum Bit Flips to Convert Number",
        "difficulty": 0,
        "answer": "        # if start == goal:\n        #     return 0\n        # if start > goal:\n        #     return -1\n        # if start < goal:\n        #     return -1\n        # if start == 0:\n        #     return 0\n        # if start == 1:\n        #     return 1\n        # if start == 2:\n        #     return 2\n        # if start == 3:\n        #     return 3\n        # if start == 4:\n        #     return 4\n        # if start == 5:\n        #     return 5\n        # if start == 6:\n        #     return 6\n        # if start == 7:\n        #     return 7\n        # if start == 8:\n        #     return 8\n        # if start == 9:\n        #     return 9\n        # if start == 10:\n        #     return 10\n        # if start == 11:\n        #     return 11\n        # if start == 12:\n        #     return 12\n        # if start == 13:\n        #     return 13\n        # if start == 14:\n        #"
    },
    {
        "number": 2221,
        "title": "Find Triangular Sum of an Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        newNums = []\n        for i in range(n - 1):\n            newNums.append((nums[i] + nums[i + 1]) % 10)\n        return sum(newNums)\n"
    },
    {
        "number": 2222,
        "title": "Number of Ways to Select Buildings",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n == 0:\n            return 0\n        \n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            if s[i] == '0':\n                dp[i][i] = 1\n            else:\n                dp[i][i] = 0\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                if s[i] == '0':\n                    dp[i][j] = dp[i+1][j] + dp[i+1][j-1]\n                else:\n                    dp[i][j] = dp[i+1][j]\n        \n        return dp[0][n-1]"
    },
    {
        "number": 2223,
        "title": "Sum of Scores of Built Strings",
        "difficulty": 2,
        "answer": "        # s = \"babab\"\n        # s1 = \"b\"\n        # s2 = \"ab\"\n        # s3 = \"bab\"\n        # s4 = \"abab\"\n        # s5 = \"babab\"\n        # s6 = \"azbazbzaz\"\n        # s7 = \"azbazbzaz\"\n        # s8 = \"azbazbzaz\"\n        # s9 = \"azbazbzaz\"\n        # s10 = \"azbazbzaz\"\n        # s11 = \"azbazbzaz\"\n        # s12 = \"azbazbzaz\"\n        # s13 = \"azbazbzaz\"\n        # s14 = \"azbazbzaz\"\n        # s15 = \"azbazbzaz\"\n        # s16 = \"azbazbzaz\"\n        # s17 = \"azbazbzaz\"\n        # s18 = \"azbazbzaz\"\n        # s19 = \"azbaz"
    },
    {
        "number": 2224,
        "title": "Minimum Number of Operations to Convert Time",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # n = len(current)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     if current == \"00\":\n        #         return 0\n        #     if current == \"01\":\n        #         return 1\n        #     if current == \"02\":\n        #         return 2\n        #     if current == \"03\":\n        #         return 3\n        #     if current == \"04\":\n        #         return 4\n        #     if current == \"05\":\n        #         return 5\n        #     if current == \"06\":\n        #         return 6\n        #     if current == \"07\":\n        #         return 7\n        #     if current == \"08\":\n        #         return 8\n        #     if current == \"09\":\n        #         return 9\n        #     if current == \"10\":\n        #         return 10\n        #     if current == \"11\":\n        #         return 11\n        #     if current == \"12\":"
    },
    {
        "number": 2231,
        "title": "Largest Number After Digit Swaps by Parity",
        "difficulty": 0,
        "answer": "        # num = str(num)\n        # num = list(num)\n        # num = sorted(num, reverse=True)\n        # num = int(''.join(num))\n        # return num\n        # num = str(num)\n        # num = list(num)\n        # num = sorted(num, reverse=True)\n        # num = int(''.join(num))\n        # return num\n        # num = str(num)\n        # num = list(num)\n        # num = sorted(num, reverse=True)\n        # num = int(''.join(num))\n        # return num\n        # num = str(num)\n        # num = list(num)\n        # num = sorted(num, reverse=True)\n        # num = int(''.join(num))\n        # return num\n        # num = str(num)\n        # num = list(num)\n        # num = sorted(num, reverse=True)\n        # num = int(''.join(num))\n        # return num\n        # num = str(num)\n        "
    },
    {
        "number": 2232,
        "title": "Minimize Result by Adding Parentheses to Expression",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if not expression:\n        #     return expression\n        # stack = []\n        # for i in range(len(expression)):\n        #     if expression[i] == ')':\n        #         while stack and stack[-1]!= '(':\n        #             stack.pop()\n        #         if stack and stack[-1] == '(':\n        #             stack.pop()\n        #     else:\n        #         stack.append(expression[i])\n        # return ''.join(stack)"
    },
    {
        "number": 2233,
        "title": "Maximum Product After K Increments",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        if k >= n:\n            return max(nums) * max(nums)\n        \n        # k = 0\n        # for i in range(n):\n        #     if i == 0:\n        #         continue\n        #     if nums[i] == nums[i-1]:\n        #         continue\n        #     else:\n        #         break\n        # if k == 0:\n        #     return max(nums) * max(nums)\n        \n        # k = 1\n        # for i in range(n):\n        #     if i == 0:\n        #         continue\n        #     if nums[i] == nums[i-1]:\n        #         continue\n        #     else:\n        #         break\n        # if k == 1:\n        #     return max(nums) * max(nums)\n        \n        # k = 2\n        # for i in range(n):\n        #     if i == 0:\n        #         continue\n        "
    },
    {
        "number": 2234,
        "title": "Maximum Total Beauty of the Gardens",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j], dp[i"
    },
    {
        "number": 2235,
        "title": "Add Two Integers",
        "difficulty": 0,
        "answer": "        return num1 + num2"
    },
    {
        "number": 2236,
        "title": "Root Equals Sum of Children",
        "difficulty": 0,
        "answer": "        # if not root:\n        #     return True\n        # if not root.left and not root.right:\n        #     return True\n        # if root.left and root.right:\n        #     return root.val == root.left.val + root.right.val\n        # if root.left and not root.right:\n        #     return root.val == root.left.val\n        # if root.right and not root.left:\n        #     return root.val == root.right.val\n        # return False"
    },
    {
        "number": 2239,
        "title": "Find Closest Number to Zero",
        "difficulty": 0,
        "answer": "        \n        # Approach 1: Brute Force\n        # Time: O(n^2)\n        # Space: O(1)\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - 0) > abs(nums[j] - 0):\n        #             nums[i], nums[j] = nums[j], nums[i]\n        # return nums[0]\n        \n        \n        # Approach 2: Binary Search\n        # Time: O(n)\n        # Space: O(1)\n        \n        # def binary_search(nums, target):\n        #     lo, hi = 0, len(nums) - 1\n        #     while lo <= hi:\n        #         mid = lo + (hi - lo) // 2\n        #         if nums[mid] == target:\n        #             return mid\n        #         elif nums[mid] < target:\n        #             lo ="
    },
    {
        "number": 2240,
        "title": "Number of Ways to Buy Pens and Pencils",
        "difficulty": 1,
        "answer": "        dp = [[0] * (total + 1) for _ in range(cost1 + 1)]\n        for i in range(cost1 + 1):\n            dp[i][0] = 1\n        for i in range(cost2 + 1):\n            dp[0][i] = 1\n        for i in range(1, cost1 + 1):\n            for j in range(1, cost2 + 1):\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[cost1][cost2]"
    },
    {
        "number": 2241,
        "title": "Design an ATM Machine",
        "difficulty": 1,
        "answer": "    def __init__(self):\n    def deposit(self, banknotesCount: List[int]) -> None:\n    def withdraw(self, amount: int) -> List[int]:\n        \"\"\"\n        There is an ATM machine that stores banknotes of 5 denominations: 20, 50, 100, 200, and 500 dollars. Initially the ATM is empty. The user can use the machine to deposit or withdraw any amount of money.\n        When withdrawing, the machine prioritizes using banknotes of larger values.\n            For example, if you want to withdraw $300 and there are 2 $50 banknotes, 1 $100 banknote, and 1 $200 banknote, then the machine will use the $100 and $200 banknotes.\n            However, if you try to withdraw $600 and there are 3 $200 banknotes and 1 $500 banknote, then the withdraw request will be rejected because the machine will first try to use the $500 banknote and then be unable to use banknotes to complete the remaining $100. Note that the machine is not allowed to use the $200 banknotes instead of the $500 banknote.\n        Implement the ATM class:\n"
    },
    {
        "number": 2242,
        "title": "Maximum Score of a Node Sequence",
        "difficulty": 2,
        "answer": "        n = len(scores)\n        graph = [[] for _ in range(n)]\n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        def dfs(node, graph, visited, score):\n            visited.add(node)\n            for i in graph[node]:\n                if i not in visited:\n                    dfs(i, graph, visited, score)\n            visited.remove(node)\n            score += scores[node]\n            return score\n        \n        def dfs2(node, graph, visited, score):\n            visited.add(node)\n            for i in graph[node]:\n                if i not in visited:\n                    score = max(score, dfs2(i, graph, visited, score))\n            visited.remove(node)\n            return score\n        \n        visited = set()\n        score = 0\n        for i in range(n):\n            if i not in visited:\n                score = max(score, dfs(i, graph, visited,"
    },
    {
        "number": 2243,
        "title": "Calculate Digit Sum of a String",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not s:\n        #     return s\n        # if len(s) < k:\n        #     return s\n        #\n        # groups = []\n        # for i in range(0, len(s), k):\n        #     groups.append(s[i:i+k])\n        #\n        # for i in range(len(groups)):\n        #     groups[i] = sum(int(x) for x in groups[i])\n        #\n        # return ''.join(str(x) for x in groups)"
    },
    {
        "number": 2244,
        "title": "Minimum Rounds to Complete All Tasks",
        "difficulty": 1,
        "answer": "        \n        # sort the tasks by difficulty level\n        tasks.sort()\n        \n        # initialize the count of completed tasks\n        count = 0\n        \n        # initialize the count of tasks left\n        tasks_left = len(tasks)\n        \n        # initialize the count of completed tasks\n        count_completed = 0\n        \n        # initialize the count of tasks left\n        count_tasks_left = 0\n        \n        # initialize the count of completed tasks\n        count_completed_last = 0\n        \n        # initialize the count of tasks left\n        count_tasks_left_last = 0\n        \n        # initialize the count of completed tasks\n        count_completed_last_last = 0\n        \n        # initialize the count of tasks left\n        count_tasks_left_last_last = 0\n        \n        # initialize the count of completed tasks\n        count_completed_last_last_last = 0\n        \n        # initialize the count of tasks left\n        count_tasks_left_last_last_last = 0\n        \n        # initialize the count of completed"
    },
    {
        "number": 2245,
        "title": "Maximum Trailing Zeros in a Cornered Path",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(mn)\n        # Space: O(mn)\n        # m, n = len(grid), len(grid[0])\n        # max_trailing_zeros = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if grid[i][j] == 0:\n        #             max_trailing_zeros = max(max_trailing_zeros, self.trailing_zeros(grid, i, j))\n        # return max_trailing_zeros"
    },
    {
        "number": 2246,
        "title": "Longest Path With Different Adjacent Characters",
        "difficulty": 2,
        "answer": "        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O("
    },
    {
        "number": 2248,
        "title": "Intersection of Multiple Arrays",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # m = len(nums)\n        # if m == 0:\n        #     return []\n        # n = len(nums[0])\n        # res = []\n        # for i in range(m):\n        #     for j in range(n):\n        #         if nums[i][j] not in res:\n        #             res.append(nums[i][j])\n        # return res"
    },
    {
        "number": 2249,
        "title": "Count Lattice Points Inside a Circle",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(circles)):\n        #     x, y, r = circles[i]\n        #     for x_, y_ in ((x+r, y), (x-r, y), (x, y+r), (x, y-r)):\n        #         if x_ >= 0 and x_ <= 4 and y_ >= 0 and y_ <= 4:\n        #             if (x_, y_) not in dp:\n        #                 dp[(x_, y_)] = 1\n        #             else:\n        #                 dp[(x_, y_)] += 1\n        # return sum(dp.values())"
    },
    {
        "number": 2250,
        "title": "Count Number of Rectangles Containing Each Point",
        "difficulty": 1,
        "answer": "        # sort by x\n        points.sort(key=lambda x: x[0])\n        # sort by y\n        points.sort(key=lambda x: x[1])\n        # sort by x, y\n        points.sort(key=lambda x: x[0] * x[1])\n        # sort by x, y\n        points.sort(key=lambda x: x[0] * x[1] * x[0] + x[1])\n        # sort by x, y\n        points.sort(key=lambda x: x[0] * x[1] * x[0] + x[1] * x[1])\n        # sort by x, y\n        points.sort(key=lambda x: x[0] * x[1] * x[0] + x[1] * x[1] * x[1])\n        # sort by x, y\n        points.sort(key=lambda x: x[0] * x[1] * x[0] + x[1] * x[1] * x[1] * x[1"
    },
    {
        "number": 2251,
        "title": "Number of Flowers in Full Bloom",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (end + 1) for _ in range(len(flowers) + 1)]\n        # for i in range(1, len(flowers) + 1):\n        #     for j in range(flowers[i - 1][0], flowers[i - 1][1] + 1):\n        #         dp[i][j] = 1\n        # for i in range(1, len(persons) + 1):\n        #     for j in range(persons[i - 1], persons[i - 1] + 1):\n        #         dp[i][j] = 1\n        # res = []\n        # for i in range(1, len(dp)):\n        #     for j in range(1, len(dp[0])):\n        #         if dp[i][j] == 1:\n        #             res.append(i)\n        # return res"
    },
    {
        "number": 2255,
        "title": "Count Prefixes of a Given String",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for word in words:\n        #     dp[word] = True\n        \n        # for i in range(len(s)):\n        #     for word in words:\n        #         if s[i:i+len(word)] == word:\n        #             dp[word] = True\n        \n        # return len(words) if len(words) == len(dp) else len(dp)\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for word in words:\n        #     dp[word] = True\n        \n        # for i in range(len(s)):\n        #     for word in words:\n        #         if s[i:i+len(word)] == word:\n        #             dp[word] = True\n        \n        # return len(words) if len(words) == len(dp) else len(dp)\n        \n"
    },
    {
        "number": 2256,
        "title": "Minimum Average Difference",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return min(nums[i + 1] - nums[i] for i in range(len(nums) - 1))"
    },
    {
        "number": 2257,
        "title": "Count Unguarded Cells in the Grid",
        "difficulty": 1,
        "answer": "        \n        # dp = [[0] * n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 1 if walls[i][j] == 1 else 0\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # dp = [[0] * n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 or j == 0:\n        #             dp[i][j] = 1 if walls[i][j] == 1 else 0\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1"
    },
    {
        "number": 2258,
        "title": "Escape the Spreading Fire",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + 1"
    },
    {
        "number": 2259,
        "title": "Remove Digit From Number to Maximize Result",
        "difficulty": 0,
        "answer": "        if number == \"\":\n            return \"\"\n        if digit not in number:\n            return number\n        if number.count(digit) == 1:\n            return number.replace(digit, \"\")\n        else:\n            return number.replace(digit, \"\") + self.removeDigit(number[1:], digit)"
    },
    {
        "number": 2260,
        "title": "Minimum Consecutive Cards to Pick Up",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if len(cards) == 0:\n        #     return -1\n        # if len(cards) == 1:\n        #     return 0\n        # if len(cards) == 2:\n        #     return 1\n        # if len(cards) == 3:\n        #     return 2\n        # if len(cards) == 4:\n        #     return 3\n        # if len(cards) == 5:\n        #     return 4\n        # if len(cards) == 6:\n        #     return 5\n        # if len(cards) == 7:\n        #     return 6\n        # if len(cards) == 8:\n        #     return 7\n        # if len(cards) == 9:\n        #     return 8\n        # if len(cards) == 10:\n        #     return 9\n        # if len(cards) == 11:\n        #     return 10\n        # if len(cards) == 12:\n        #     return 11\n        # if len(cards) == 13:\n        #     return 12\n        # if len"
    },
    {
        "number": 2261,
        "title": "K Divisible Elements Subarrays",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, k + 1):\n        #         if j == 1:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        # return dp[-1][-1]"
    },
    {
        "number": 2262,
        "title": "Total Appeal of A String",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #\n        # total = 0\n        # for i in range(len(s)):\n        #     total += dp[s[i]]\n        #     for j in range(i + 1, len(s)):\n        #         total += dp[s[j]]\n        # return total"
    },
    {
        "number": 2264,
        "title": "Largest 3-Same-Digit Number in String",
        "difficulty": 0,
        "answer": "        if not num:\n            return \"\"\n        if len(num) < 3:\n            return \"\"\n        if num[0] == '0':\n            return \"\"\n        if num[0] == '1':\n            return num[1:]\n        if num[0] == '2':\n            return num[1:]\n        if num[0] == '3':\n            return num[1:]\n        if num[0] == '4':\n            return num[1:]\n        if num[0] == '5':\n            return num[1:]\n        if num[0] == '6':\n            return num[1:]\n        if num[0] == '7':\n            return num[1:]\n        if num[0] == '8':\n            return num[1:]\n        if num[0] == '9':\n            return num[1:]\n        if num[0] == '0':\n            return num[1:]\n        if num[0] == '1':\n            return num[1:]\n        if num[0] == '2':\n            return"
    },
    {
        "number": 2265,
        "title": "Count Nodes Equal to Average of Subtree",
        "difficulty": 1,
        "answer": "        def averageOfSubtree(root):\n            if not root:\n                return 0\n            \n            left_sum = averageOfSubtree(root.left)\n            right_sum = averageOfSubtree(root.right)\n            \n            return (left_sum + right_sum + root.val) / 3\n        \n        return averageOfSubtree(root)"
    },
    {
        "number": 2266,
        "title": "Count Number of Texts",
        "difficulty": 1,
        "answer": "        # key_map = {\n        #     '0': '0',\n        #     '1': '1',\n        #     '2': '2',\n        #     '3': '3',\n        #     '4': '4',\n        #     '5': '5',\n        #     '6': '6',\n        #     '7': '7',\n        #     '8': '8',\n        #     '9': '9',\n        #     'a': 'a',\n        #     'b': 'b',\n        #     'c': 'c',\n        #     'd': 'd',\n        #     'e': 'e',\n        #     'f': 'f',\n        #     'g': 'g',\n        #     'h': 'h',\n        #     'i': 'i',\n        #     'j': 'j',\n        #     'k': 'k',\n        #     'l': 'l',\n        #    'm':'m',\n        #     'n': 'n',\n        #     '"
    },
    {
        "number": 2267,
        "title": " Check if There Is a Valid Parentheses String Path",
        "difficulty": 2,
        "answer": "        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        # dp[0][0] = True\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == '(' or grid[i][j] == ')':\n        #             if i == 0 and j == 0:\n        #                 dp[i][j] = True\n        #             elif i == 0:\n        #                 dp[i][j] = dp[i][j-1] and grid[i][j] == ')'\n        #             elif j == 0:\n        #                 dp[i][j] = dp[i-1][j] and grid[i][j] == '('\n        #             else:\n        #                 dp[i][j] = dp[i-1][j] and"
    },
    {
        "number": 2270,
        "title": "Number of Ways to Split Array",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # n = len(nums)\n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n + 1):\n        #         dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + nums[i]\n        # return dp[0][n]"
    },
    {
        "number": 2271,
        "title": "Maximum White Tiles Covered by a Carpet",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (carpetLen + 1) for _ in range(len(tiles) + 1)]\n        # for i in range(1, len(tiles) + 1):\n        #     for j in range(1, len(tiles[i - 1]) + 1):\n        #         dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + 1\n        # return max(dp[-1])"
    },
    {
        "number": 2272,
        "title": "Substring With Largest Variance",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         sub = s[i:j+1]\n        #         if sub not in dp:\n        #             dp[sub] = 0\n        #         dp[sub] += 1\n        #\n        # max_var = 0\n        # for sub in dp:\n        #     max_var = max(max_var, dp[sub] * (len(sub) - 1))\n        # return max_var"
    },
    {
        "number": 2274,
        "title": "Maximum Consecutive Floors Without Special Floors",
        "difficulty": 1,
        "answer": "        if not special:\n            return 0\n        \n        special_floor = set(special)\n        \n        # special_floor = {4,6}\n        # special_floor = {4,6,8}\n        # special_floor = {4,6,8,9}\n        # special_floor = {4,6,8,9,10}\n        # special_floor = {4,6,8,9,10,11}\n        # special_floor = {4,6,8,9,10,11,12}\n        # special_floor = {4,6,8,9,10,11,12,13}\n        # special_floor = {4,6,8,9,10,11,12,13,14}\n        # special_floor = {4,6,8,9,10,11,12,13,14,15}\n        # special_floor = {4,6,8,9,10,11,12,13,14,15,16}\n        # special_floor = {4,6,8,9,10"
    },
    {
        "number": 2275,
        "title": "Largest Combination With Bitwise AND Greater Than Zero",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # candidates = sorted(candidates)\n        # res = 0\n        # for i in range(len(candidates)):\n        #     for j in range(i+1, len(candidates)):\n        #         res = max(res, candidates[i] & candidates[j])\n        # return res\n        \n        # Solution 2:\n        # Time: O(n^2)\n        # Space: O(n)\n        # candidates = sorted(candidates)\n        # res = 0\n        # for i in range(len(candidates)):\n        #     for j in range(i+1, len(candidates)):\n        #         res = max(res, candidates[i] & candidates[j])\n        # return res\n        \n        # Solution 3:\n        # Time: O(n^2)\n        # Space: O(n)\n        # candidates = sorted(candidates)\n        # res = 0\n        # for i"
    },
    {
        "number": 2276,
        "title": "Count Integers in Intervals",
        "difficulty": 2,
        "answer": "        # Your CountIntervals object will be instantiated and called as such:\n        # obj = CountIntervals()\n        # obj.add(left,right)\n        # param_2 = obj.count()\n        \n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n        # N = number of intervals\n        # Time: O(N)\n        # Space: O(N)\n"
    },
    {
        "number": 2278,
        "title": "Percentage of Letter in String",
        "difficulty": 0,
        "answer": "        count = 0\n        for c in s:\n            if c == letter:\n                count += 1\n        return count * 100 // len(s)"
    },
    {
        "number": 2279,
        "title": "Maximum Bags With Full Capacity of Rocks",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-capacity[i]] + 1)\n        # dp["
    },
    {
        "number": 2280,
        "title": "Minimum Lines to Represent a Line Chart",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(stockPrices)):\n        #     dp[i] = stockPrices[i][1]\n        # for i in range(len(stockPrices)):\n        #     for j in range(i+1, len(stockPrices)):\n        #         if stockPrices[i][0] <= stockPrices[j][0]:\n        #             dp[i] = min(dp[i], dp[j] + stockPrices[i][1])\n        # return len(stockPrices) - max(dp.values())"
    },
    {
        "number": 2281,
        "title": "Sum of Total Strength of Wizards",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(strength)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return strength[0]\n        # if n == 2:\n        #     return max(strength[0], strength[1])\n        # if n == 3:\n        #     return max(strength[0], max(strength[1], strength[2]))\n        # if n == 4:\n        #     return max(strength[0], max(strength[1], max(strength[2], strength[3])))\n        # if n == 5:\n        #     return max(strength[0], max(strength[1], max(strength[2], max(strength[3], strength[4]))))\n        # if n == 6:\n        #     return max(strength[0], max(strength[1], max(strength[2], max(strength[3], max(strength[4], strength[5]))))\n        # if n == 7:\n        #     return max"
    },
    {
        "number": 2283,
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not num:\n        #     return False\n        # count = 0\n        # for i in range(len(num)):\n        #     if num[i] == '0':\n        #         count += 1\n        #     else:\n        #         count = 0\n        #     if count > 1:\n        #         return False\n        # return True"
    },
    {
        "number": 2284,
        "title": "Sender With Largest Word Count",
        "difficulty": 1,
        "answer": "        # sort by sender\n        senders = sorted(senders)\n        # sort by word count\n        messages = sorted(messages, key=lambda x: len(x.split()))\n        # print(messages)\n        # print(senders)\n        # print(senders[0])\n        # print(senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1])\n        # print(senders[0] == senders[-1"
    },
    {
        "number": 2285,
        "title": "Maximum Total Importance of Roads",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = max(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] ="
    },
    {
        "number": 2286,
        "title": "Booking Concert Tickets in Groups",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2287,
        "title": "Rearrange Characters to Make Target String",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[s[i]] = dp.get(s[i], 0) + 1\n        #\n        # count = 0\n        # for i in range(len(target)):\n        #     if target[i] in dp:\n        #         count += dp[target[i]]\n        #         dp[target[i]] -= 1\n        #\n        # return count"
    },
    {
        "number": 2288,
        "title": "Apply Discount to Prices",
        "difficulty": 1,
        "answer": "        # sentence = sentence.replace(\"$\", \"\").replace(\" \", \"\").split(\" \")\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x.replace(\"$\", \"\").replace(\" \", \"\"), sentence))\n        # sentence = list(map(lambda x: x"
    },
    {
        "number": 2289,
        "title": "Steps to Make Array Non-decreasing",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if not nums:\n        #     return 0\n        #\n        # steps = 0\n        # for i in range(len(nums) - 1):\n        #     if nums[i] > nums[i + 1]:\n        #         steps += 1\n        #         nums = nums[:i] + sorted(nums[i:])\n        # return steps"
    },
    {
        "number": 2290,
        "title": "Minimum Obstacle Removal to Reach Corner",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def neighbors(i, j):\n            for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n:\n                    yield ni, nj\n        \n        def dfs(i, j, cnt):\n            if i == m - 1 and j == n - 1:\n                return cnt\n            \n            if grid[i][j] == 0:\n                return dfs(i + 1, j, cnt + 1)\n            \n            for ni, nj in neighbors(i, j):\n                if grid[ni][nj] == 0:\n                    grid[i][j] = 1\n                    grid[ni][nj] = 1\n                    res = dfs(ni, nj, cnt + 1)\n                    grid[i][j] = 0\n                    grid[ni][nj] = 0\n                    "
    },
    {
        "number": 2293,
        "title": "Min Max Game",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        \n        newNums = nums[:n//2]\n        for i in range(n//2):\n            if i % 2 == 0:\n                newNums[i] = min(nums[2*i], nums[2*i+1])\n            else:\n                newNums[i] = max(nums[2*i], nums[2*i+1])\n        \n        return newNums[-1]"
    },
    {
        "number": 2294,
        "title": "Partition Array Such That Maximum Difference Is K",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * (len(nums) + 1) for _ in range(k + 1)]\n        # for i in range(1, k + 1):\n        #     dp[i][0] = dp[i - 1][0] + 1\n        # for i in range(1, k + 1):\n        #     for j in range(1, len(nums) + 1):\n        #         dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1\n        # return dp[k][len(nums)]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * (len(nums) + 1) for _ in range(k + 1)]\n        # for i in range(1, k + 1):\n        #     dp[i][0] = dp[i - 1][0] + 1"
    },
    {
        "number": 2295,
        "title": "Replace Elements in an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        for i in range(len(operations)):\n            if operations[i][0] in nums:\n                nums[nums.index(operations[i][0])] = operations[i][1]\n        return nums"
    },
    {
        "number": 2296,
        "title": "Design a Text Editor",
        "difficulty": 2,
        "answer": "    def addText(self, text: str) -> None:\n        \"\"\"\n        Design a text editor with a cursor that can do the following:\n            Add text to where the cursor is.\n            Delete text from where the cursor is (simulating the backspace key).\n            Move the cursor either left or right.\n        When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\n        Implement the TextEditor class:\n            TextEditor() Initializes the object with empty text.\n            void addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\n            int deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\n            string cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\n            "
    },
    {
        "number": 2299,
        "title": "Strong Password Checker II",
        "difficulty": 0,
        "answer": "        if len(password) < 8:\n            return False\n        if not any(char.islower() for char in password):\n            return False\n        if not any(char.isupper() for char in password):\n            return False\n        if not any(char.isdigit() for char in password):\n            return False\n        if not any(char in \"!@#$%^&*()-+\" for char in password):\n            return False\n        if any(char == password[i] for i in range(len(password) - 1)):\n            return False\n        return True"
    },
    {
        "number": 2300,
        "title": "Successful Pairs of Spells and Potions",
        "difficulty": 1,
        "answer": "        # O(n*m)\n        # dp = [[0]*(success+1) for _ in range(len(spells)+1)]\n        # for i in range(1, len(spells)+1):\n        #     for j in range(1, len(potions)+1):\n        #         if spells[i-1]*potions[j-1] >= success:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        #         else:\n        #             dp[i][j] = dp[i-1][j]\n        # return dp[-1][-1]\n        \n        # O(n*m)\n        # dp = [[0]*(success+1) for _ in range(len(spells)+1)]\n        # for i in range(1, len(spells)+1):\n        #     for j in range(1, len(potions)+1):\n        #         if spells[i-1]*potions[j"
    },
    {
        "number": 2301,
        "title": "Match Substring After Replacement",
        "difficulty": 2,
        "answer": "        if not s or not sub:\n            return False\n        if len(s) < len(sub):\n            return False\n        if len(sub) > len(s):\n            return False\n        if len(sub) == 1:\n            return s == sub\n        if len(sub) == 2:\n            if s[0] == sub[0] and s[1] == sub[1]:\n                return True\n            else:\n                return False\n        if len(sub) == 3:\n            if s[0] == sub[0] and s[1] == sub[1] and s[2] == sub[2]:\n                return True\n            else:\n                return False\n        if len(sub) == 4:\n            if s[0] == sub[0] and s[1] == sub[1] and s[2] == sub[2] and s[3] == sub[3]:\n                return True\n            else:\n                return False\n        if len(sub) == 5:\n            if s[0] == sub[0] and s[1] =="
    },
    {
        "number": 2302,
        "title": "Count Subarrays With Score Less Than K",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         dp[nums[i]] += 1\n        #     else:\n        #         dp[nums[i]] = 1\n        #     if dp[nums[i]] > k:\n        #         return i - k + 1\n        # return len(nums) - k + 1\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         dp[nums[i]] += 1\n        #     else:\n        #         dp[nums[i]] = 1\n        #     if dp[nums[i]] > k:\n        #         return i - k + 1\n        # return len(nums) - k + 1\n"
    },
    {
        "number": 2306,
        "title": "Naming a Company",
        "difficulty": 2,
        "answer": "        # ideaA, ideaB = ideas[0], ideas[1]\n        # for i in range(len(ideas)):\n        #     if ideas[i] == ideaA:\n        #         ideaA, ideaB = ideaB, ideaA\n        #     elif ideas[i] == ideaB:\n        #         ideaA, ideaB = ideaA, ideaB\n        #     else:\n        #         continue\n        # return len(ideas) - (ideaA + ideaB).count(' ')\n        \n        # ideaA, ideaB = ideas[0], ideas[1]\n        # for i in range(len(ideas)):\n        #     if ideas[i] == ideaA:\n        #         ideaA, ideaB = ideaB, ideaA\n        #     elif ideas[i] == ideaB:\n        #         ideaA, ideaB = ideaA, ideaB\n        #     else:\n        #         continue\n        # return len(ideas) - (ideaA + ideaB).count(' ')\n        \n"
    },
    {
        "number": 2311,
        "title": "Longest Binary Subsequence Less Than or Equal to K",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n        # dp[i] = max(dp[i], dp[i-1] + 1)\n"
    },
    {
        "number": 2315,
        "title": "Count Asterisks",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(s)):\n            if s[i] == '|':\n                count += 1\n        return count"
    },
    {
        "number": 2316,
        "title": "Count Unreachable Pairs of Nodes in an Undirected Graph",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # d = {}\n        # for i in range(n):\n        #     d[i] = []\n        # for i, j in edges:\n        #     d[i].append(j)\n        #     d[j].append(i)\n        # res = 0\n        # for i in range(n):\n        #     for j in range(i + 1, n):\n        #         if j in d[i] or i in d[j]:\n        #             res += 1\n        # return res"
    },
    {
        "number": 2317,
        "title": "Maximum XOR After Operations ",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        max_xor = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                max_xor = max(max_xor, nums[i] ^ nums[j])\n        return max_xor"
    },
    {
        "number": 2318,
        "title": "Number of Distinct Roll Sequences",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(i + 1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                if j == i:\n                    dp[i][j] %= MOD\n        return dp[n][n] % MOD"
    },
    {
        "number": 2319,
        "title": "Check if Matrix Is X-Matrix",
        "difficulty": 0,
        "answer": "        # check if all the elements in the diagonals are non-zero\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if i == j:\n                    if grid[i][j]!= 0:\n                        return False\n        # check if all the elements are 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0:\n                    return False\n        return True"
    },
    {
        "number": 2320,
        "title": "Count Number of Ways to Place Houses",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1] + dp[i"
    },
    {
        "number": 2322,
        "title": "Minimum Score After Removals on a Tree",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not nums or not edges:\n        #     return 0\n        # n = len(nums)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = nums[i]\n        # for i in range(n - 1):\n        #     for j in range(i + 1, n):\n        #         dp[i][j] = dp[i][j - 1] ^ nums[j]\n        #         dp[j][i] = dp[j - 1][i] ^ nums[i]\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = nums[i]\n        # for i in range(n - 1):\n        #     for j in range(i + 1, n):\n        #         "
    },
    {
        "number": 2325,
        "title": "Decode the Message",
        "difficulty": 0,
        "answer": "        # key = \"the quick brown fox jumps over the lazy dog\"\n        # message = \"vkbs bs t suepuv\"\n        # key = \"eljuxhpwnyrdgtqkviszcfmabo\"\n        # message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\"\n        # key = \"abcdefghijklmnopqrstuvwxyz\"\n        # message = \"a b c d e f g h i j k l m n o p q r s t u v w x y z\"\n        # key = \"abcdefghijklmnopqrstuvwxyz\"\n        # message = \"a b c d e f g h i j k l m n o p q r s t u v w x y z\"\n        # key = \"abcdefghijklmnopqrstuvwxyz\"\n        # message = \"a b c d e f g h i j k l m n o p q r s t u v w x y z\"\n        # key = \""
    },
    {
        "number": 2326,
        "title": "Spiral Matrix IV",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # if not head:\n        #     return []\n        #\n        # m, n = m, n\n        # res = [[0] * n for _ in range(m)]\n        #\n        # curr = head\n        # for i in range(m):\n        #     for j in range(n):\n        #         res[i][j] = curr.val\n        #         curr = curr.next\n        #\n        # for i in range(m):\n        #     for j in range(n - 2, -1, -1):\n        #         res[i][j] = res[i][j]\n        #\n        # for i in range(m - 2, -1, -1):\n        #     for j in range(n):\n        #         res[i][j] = res[i][j]\n        #\n        # return res"
    },
    {
        "number": 2327,
        "title": "Number of People Aware of a Secret",
        "difficulty": 1,
        "answer": "        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, n + 1):\n        #         if i == j:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return dp[n][n] % (10 ** 9 + 7)"
    },
    {
        "number": 2328,
        "title": "Number of Increasing Paths in a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] += dp[i - 1][j]\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n        return sum(dp[-1]) % (10**9 + 7)\n"
    },
    {
        "number": 2331,
        "title": "Evaluate Boolean Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == 1\n        if root.left and root.right:\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\n        if root.left:\n            return self.evaluateTree(root.left) and root.val == 2\n        if root.right:\n            return root.val == 3 and self.evaluateTree(root.right)\n        return False\n"
    },
    {
        "number": 2332,
        "title": "The Latest Time to Catch a Bus",
        "difficulty": 1,
        "answer": "        \n        # Time O(n) | Space O(n)\n        # sort the buses by departure time\n        buses.sort()\n        \n        # initialize the answer\n        answer = 0\n        \n        # iterate through the passengers\n        for passenger in passengers:\n            \n            # initialize the current time\n            current_time = 0\n            \n            # iterate through the buses\n            for bus in buses:\n                \n                # if the current time is greater than the bus departure time\n                if current_time > bus:\n                    \n                    # break out of the loop\n                    break\n                \n                # else, increment the current time\n                else:\n                    current_time += passenger\n            \n            # if the current time is greater than the capacity\n            if current_time > capacity:\n                \n                # break out of the loop\n                break\n            \n            # else, increment the answer\n            else:\n                answer = max(answer, current_time)\n        \n        # return the answer\n        return answer"
    },
    {
        "number": 2333,
        "title": "Minimum Sum of Squared Difference",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]\n        # for i in range(1, len(nums1) + 1):\n        #     for j in range(1, len(nums2) + 1):\n        #         dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + (nums1[i - 1] - nums2[j - 1]) ** 2\n        \n        # return min(dp[-1][-1], dp[-1][-2])\n        \n        # dp = [[0] * (len(nums2) + 1) for _ in range(len(nums1) + 1)]\n        # for i in range(1, len(nums1) + 1):\n        #     for j in range(1, len("
    },
    {
        "number": 2334,
        "title": "Subarray With Elements Greater Than Varying Threshold",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1 if nums[0] >= threshold else -1\n        # if nums[0] >= threshold:\n        #     return 1\n        # count = 1\n        # for i in range(1, len(nums)):\n        #     if nums[i] >= threshold:\n        #         count += 1\n        #     else:\n        #         if count >= threshold:\n        #             return count\n        #         count = 1\n        # return count"
    },
    {
        "number": 2335,
        "title": "Minimum Amount of Time to Fill Cups",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if amount[0] == 0:\n        #     return 0\n        # if amount[1] == 0:\n        #     return amount[0] + amount[2]\n        # if amount[2] == 0:\n        #     return amount[0] + amount[1]\n        # if amount[0] == amount[1] == amount[2]:\n        #     return amount[0] * 2\n        # if amount[0] == amount[1]:\n        #     return amount[0] * 2 + amount[2]\n        # if amount[1] == amount[2]:\n        #     return amount[1] * 2 + amount[0]\n        # if amount[0] == amount[2]:\n        #     return amount[0] * 2 + amount[1]\n        # if amount[1] == amount[2]:\n        #     return amount[1] * 2 + amount[0]\n        # if amount[0] == amount[1]:\n        #     return amount[0"
    },
    {
        "number": 2336,
        "title": "Smallest Number in Infinite Set",
        "difficulty": 1,
        "answer": "    def __init__(self):\n    def addBack(self, num: int) -> None:\n        \"\"\"\n        You have a set which contains all positive integers [1, 2, 3, 4, 5,...].\n        Implement the addBack function:\n            addBack(int num) Adds a positive integer num back into the set, if it is not already in the set.\n        Example 1:\n        Input\n        [\"SmallestInfiniteSet\", \"addBack\", \"addBack\", \"addBack\", \"addBack\", \"addBack\", \"addBack\", \"addBack\", \"addBack\"]\n        [[], [2], [3], [4], [5], [6], [7], [8], [9]]\n        Output\n        [null, null, null, null, null, null, null, null, null]\n        Explanation\n        SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\n        smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.\n        smallestInfiniteSet.addBack("
    },
    {
        "number": 2337,
        "title": "Move Pieces to Obtain a String",
        "difficulty": 1,
        "answer": "        if len(start)!= len(target):\n            return False\n        if start == target:\n            return True\n        if start[0] == target[0]:\n            return self.canChange(start[1:], target[1:])\n        if start[-1] == target[-1]:\n            return self.canChange(start[:-1], target[:-1])\n        return False"
    },
    {
        "number": 2338,
        "title": "Count the Number of Ideal Arrays",
        "difficulty": 2,
        "answer": "        # dp[i] = # of distinct arrays ending with i\n        dp = [0] * (maxValue + 1)\n        dp[1] = 1\n        dp[2] = 2\n        dp[3] = 4\n        for i in range(4, maxValue + 1):\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        return dp[-1] % (10**9 + 7)"
    },
    {
        "number": 2341,
        "title": "Maximum Number of Pairs in Array",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n^2)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j]:\n        #             count += 1\n        # return [count, len(nums) - count]"
    },
    {
        "number": 2342,
        "title": "Max Sum of a Pair With Equal Sum of Digits",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        # max_sum = -1\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if sum(nums[i:j+1]) > max_sum:\n        #             max_sum = sum(nums[i:j+1])\n        # return max_sum"
    },
    {
        "number": 2343,
        "title": "Query Kth Smallest Trimmed Number",
        "difficulty": 1,
        "answer": "        def trim(nums, k):\n            if k == 0:\n                return nums\n            i = 0\n            while i < len(nums) and nums[i] == '0':\n                i += 1\n            if i == len(nums):\n                return []\n            j = i\n            while j < len(nums) and nums[j]!= '0':\n                j += 1\n            return nums[i:j]\n        \n        def get_smallest(nums, k):\n            nums = trim(nums, k)\n            if not nums:\n                return -1\n            return min(map(int, nums))\n        \n        def get_smallest_index(nums, k):\n            nums = trim(nums, k)\n            if not nums:\n                return -1\n            return nums.index(str(min(map(int, nums))))\n        \n        ans = []\n        for k, trimi in queries:\n            ans.append(get_smallest(nums, trimi))"
    },
    {
        "number": 2344,
        "title": "Minimum Deletions to Make Array Divisible",
        "difficulty": 2,
        "answer": "        # nums = sorted(nums)\n        # numsDivide = sorted(numsDivide)\n        # print(nums)\n        # print(numsDivide)\n        # print(nums[0] % numsDivide[0])\n        # print(nums[-1] % numsDivide[-1])\n        # print(nums[0] % numsDivide[0])\n        # print(nums[-1] % numsDivide[-1])\n        # print(nums[0] % numsDivide[0])\n        # print(nums[-1] % numsDivide[-1])\n        # print(nums[0] % numsDivide[0])\n        # print(nums[-1] % numsDivide[-1])\n        # print(nums[0] % numsDivide[0])\n        # print(nums[-1] % numsDivide[-1])\n        # print(nums[0] % numsDivide[0"
    },
    {
        "number": 2347,
        "title": "Best Poker Hand",
        "difficulty": 0,
        "answer": "        \n        # Solution 1\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = {}\n        # for suit in suits:\n        #     dp[suit] = {}\n        #     for rank in ranks:\n        #         dp[suit][rank] = 0\n        # for i in range(len(ranks)):\n        #     for j in range(i+1, len(ranks)):\n        #         if ranks[i] == ranks[j]:\n        #             dp[suits[i]][ranks[i]] += 1\n        #         else:\n        #             dp[suits[i]][ranks[i]] += 1\n        #             dp[suits[j]][ranks[j]] += 1\n        #         if dp[suits[i]][ranks[i]] == 5:\n        #             return \"Flush\"\n        #         elif dp[suits[i]][ranks[i]] == 4:\n        #             return \"Three of a Kind\"\n        #         elif dp"
    },
    {
        "number": 2348,
        "title": "Number of Zero-Filled Subarrays",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2349,
        "title": "Design a Number Container System",
        "difficulty": 1,
        "answer": "    def __init__(self):\n    def change(self, index: int, number: int) -> None:\n    def find(self, number: int) -> int:\n        \"\"\"\n        Design a number container system that can do the following:\n            Insert or Replace a number at the given index in the system.\n            Return the smallest index for the given number in the system.\n        Implement the NumberContainers class:\n            NumberContainers() Initializes the number container system.\n            void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.\n            int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.\n        Example 1:\n        Input\n        [\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n        [[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20],"
    },
    {
        "number": 2350,
        "title": "Shortest Impossible Sequence of Rolls",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for i in range(1, k+1):\n        #     dp[i] = 1\n        # for i in range(1, k+1):\n        #     for j in range(i, k+1):\n        #         dp[j] = max(dp[j], dp[i] + 1)\n        # return max(dp.values())\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = {}\n        # for i in range(1, k+1):\n        #     dp[i] = 1\n        # for i in range(1, k+1):\n        #     for j in range(i, k+1):\n        #         dp[j] = max(dp[j], dp[i] + 1)\n        # return max(dp.values())\n        \n        # Time: O(n)\n        # Space: O(n)\n"
    },
    {
        "number": 2351,
        "title": "First Letter to Appear Twice",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if len(s) == 0:\n        #     return \"\"\n        #\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] in seen:\n        #         return s[i]\n        #     else:\n        #         seen.add(s[i])\n        # return \"\""
    },
    {
        "number": 2352,
        "title": "Equal Row and Column Pairs",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # if not grid:\n        #     return 0\n        # n = len(grid)\n        # count = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         if grid[i][j] == grid[j][i]:\n        #             count += 1\n        # return count"
    },
    {
        "number": 2353,
        "title": "Design a Food Rating System",
        "difficulty": 1,
        "answer": "    def highestRated(self, cuisine: str) -> str:\n        \"\"\"\n        Design a food rating system that can do the following:\n            Modify the rating of a food item listed in the system.\n            Return the highest-rated food item for a type of cuisine in the system.\n        Implement the FoodRatings class:\n            FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.\n                foods[i] is the name of the ith food,\n                cuisines[i] is the type of cuisine of the ith food, and\n                ratings[i] is the initial rating of the ith food.\n            void changeRating(String food, int newRating) Changes the rating of the food item with the name food.\n            String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.\n        Note that a string"
    },
    {
        "number": 2354,
        "title": "Number of Excellent Pairs",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2357,
        "title": "Make Array Zero by Subtracting Equal Amounts",
        "difficulty": 0,
        "answer": "        # O(n)\n        # nums = sorted(nums)\n        # res = 0\n        # for i in range(len(nums)):\n        #     if nums[i]!= 0:\n        #         res += 1\n        #         nums[i] = 0\n        # return res"
    },
    {
        "number": 2358,
        "title": "Maximum Number of Groups Entering a Competition",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(grades)\n        # if n == 1:\n        #     return 1\n        # groups = 1\n        # while groups < n:\n        #     group_sum = sum(grades[:groups])\n        #     group_count = 1\n        #     while group_count < groups and group_sum < sum(grades[groups:]):\n        #         group_sum += grades[groups]\n        #         group_count += 1\n        #     groups = group_count\n        # return groups"
    },
    {
        "number": 2359,
        "title": "Find Closest Node to Given Two Nodes",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # dfs + heap\n        # dfs + heap + bfs\n        # dfs + heap + bfs + dfs\n        # dfs + heap + bfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dfs + heap + bfs + dfs + dfs + dfs + dfs +"
    },
    {
        "number": 2360,
        "title": "Longest Cycle in a Graph",
        "difficulty": 2,
        "answer": "        \n        # DFS\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # BFS\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # DFS + memo\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # BFS + memo\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # DFS + stack\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # BFS + stack\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # DFS + queue\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # BFS + queue\n        # Time: O(V+E)\n        # Space: O(V)\n        \n        # DFS + stack + queue\n        # Time: O(V+E)\n"
    },
    {
        "number": 2363,
        "title": "Merge Similar Items",
        "difficulty": 0,
        "answer": "        \n        # O(n*m) time | O(n*m) space\n        # n = len(items1)\n        # m = len(items2)\n        # dp = [[0]*(m+1) for _ in range(n+1)]\n        # for i in range(1, n+1):\n        #     for j in range(1, m+1):\n        #         if items1[i-1][0] == items2[j-1][0]:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1] + items1[i-1][1])\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        # return dp[n][m]\n        \n        # O(n*m) time | O(n*m) space\n        # n = len(items1)\n        # m = len(items2)\n        # dp = [["
    },
    {
        "number": 2364,
        "title": "Count Number of Bad Pairs",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j] and j - i!= nums[j] - nums[i]:\n                    count += 1\n        return count\n"
    },
    {
        "number": 2365,
        "title": "Task Scheduler II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (space + 1) for _ in range(len(tasks) + 1)]\n        # for i in range(1, len(tasks) + 1):\n        #     for j in range(1, space + 1):\n        #         if j >= tasks[i - 1]:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - tasks[i - 1]] + 1)\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 2366,
        "title": "Minimum Replacements to Sort the Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums)-1):\n            if nums[i] + nums[i+1] > nums[i+1]:\n                count += 1\n        return count"
    },
    {
        "number": 2367,
        "title": "Number of Arithmetic Triplets",
        "difficulty": 0,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 1):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                for k in range(j + 1, len(nums)):\n                    if k > j + 1 and nums[k] == nums[k - 1]:\n                        continue\n                    if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:\n                        count += 1\n        return count"
    },
    {
        "number": 2368,
        "title": "Reachable Nodes With Restrictions",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 2369,
        "title": "Check if There is a Valid Partition For The Array",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # if len(nums) == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # if len(nums) == 2:\n        #     return nums[0] == nums[1]\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         if nums[i]!= nums[i+1]:\n        #             return False\n        #     elif i == len(nums) - 1:\n        #         if nums[i]!= nums[i-1]:\n        #             return False\n        #     else:\n        #         if nums[i]!= nums[i-1] and nums[i]!= nums[i+1]:\n        #             return False\n        # return True"
    },
    {
        "number": 2370,
        "title": "Longest Ideal Subsequence",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * 26 for _ in range(len(s) + 1)]\n        # for i in range(1, len(s) + 1):\n        #     for j in range(26):\n        #         if s[i - 1] == chr(j + ord('a')):\n        #             dp[i][j] = dp[i - 1][j] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j + 1])\n        # return dp[-1][0]"
    },
    {
        "number": 2373,
        "title": "Largest Local Values in a Matrix",
        "difficulty": 0,
        "answer": "        if not grid:\n            return []\n        m, n = len(grid), len(grid[0])\n        maxLocal = [[0] * n for _ in range(m - 2)]\n        for i in range(m - 2):\n            for j in range(n - 2):\n                maxLocal[i][j] = max(maxLocal[i][j], max(grid[i][j], grid[i + 1][j], grid[i][j + 1], grid[i + 1][j + 1]))\n        return maxLocal"
    },
    {
        "number": 2374,
        "title": "Node With Highest Edge Score",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(edges)):\n        #     if edges[i] in dp:\n        #         dp[edges[i]].append(i)\n        #     else:\n        #         dp[edges[i]] = [i]\n        # max_score = 0\n        # max_index = 0\n        # for i in range(len(edges)):\n        #     if len(dp[edges[i]]) > max_score:\n        #         max_score = len(dp[edges[i]])\n        #         max_index = i\n        # return max_index"
    },
    {
        "number": 2375,
        "title": "Construct Smallest Number From DI String",
        "difficulty": 1,
        "answer": "        def is_increasing(s):\n            for i in range(len(s)-1):\n                if s[i] > s[i+1]:\n                    return False\n            return True\n        \n        def is_decreasing(s):\n            for i in range(len(s)-1):\n                if s[i] < s[i+1]:\n                    return False\n            return True\n        \n        def is_valid(s):\n            for i in range(len(s)-1):\n                if s[i] == s[i+1]:\n                    return False\n            return True\n        \n        def is_valid_increasing(s):\n            for i in range(len(s)-1):\n                if s[i] > s[i+1]:\n                    return False\n            return True\n        \n        def is_valid_decreasing(s):\n            for i in range(len(s)-1):\n                if s[i] < s[i+1]:\n                    return False\n            return True\n        \n        def is_valid_increasing_decreasing("
    },
    {
        "number": 2376,
        "title": "Count Special Integers",
        "difficulty": 2,
        "answer": "        special = 0\n        for i in range(1, n + 1):\n            if self.is_special(i):\n                special += 1\n        return special"
    },
    {
        "number": 2379,
        "title": "Minimum Recolors to Get K Consecutive Black Blocks",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i-2]) + 1\n        # dp[i] = min(dp[i-1], dp[i"
    },
    {
        "number": 2380,
        "title": "Time Needed to Rearrange a Binary String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == '1':\n        #         count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == '1':\n        #         count += 1\n        #         s = s[:i] + '0' + s[i+1:]\n        # return count + len(s)\n        \n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == '1':\n        #         count += 1\n        #         s = s[:i] + '0' + s[i+1:]\n        # return count + len(s)\n        \n        # Time:"
    },
    {
        "number": 2381,
        "title": "Shifting Letters II",
        "difficulty": 1,
        "answer": "        # s = \"abc\"\n        # shifts = [[0,1,0],[1,2,1],[0,2,1]]\n        # s = \"dztz\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n        # shifts = [[0,0,0],[1,1,1]]\n        # s = \"z\"\n"
    },
    {
        "number": 2382,
        "title": "Maximum Segment Sum After Removals",
        "difficulty": 2,
        "answer": "        nums = [0] + nums\n        removeQueries = [0] + removeQueries\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1] - nums[i])\n        ans = []\n        for i in range(n):\n            if removeQueries[i] == 0:\n                ans.append(dp[0][i])\n            else:\n                ans.append(dp[removeQueries[i]][i])\n        return ans"
    },
    {
        "number": 2383,
        "title": "Minimum Hours of Training to Win a Competition",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp = [[0] * (initialEnergy + 1) for _ in range(initialExperience + 1)]\n        # for i in range(1, initialExperience + 1):\n        #     for j in range(1, initialEnergy + 1):\n        #         if j < experience[i - 1]:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - experience[i - 1]] + experience[i - 1])\n        # return dp[-1][-1]\n        \n        # dp = [[0] * (initialEnergy + 1) for _ in range(initialExperience + 1)]\n        # for i in range(1, initialExperience + 1):\n        #     for j in range(1, initialEnergy + 1):\n        #         if j < experience[i - 1]:\n        #             dp"
    },
    {
        "number": 2384,
        "title": "Largest Palindromic Number",
        "difficulty": 1,
        "answer": "        def is_palindrome(num):\n            return num == num[::-1]\n        \n        def is_palindrome_helper(num):\n            if not num:\n                return True\n            if not is_palindrome(num[1:]):\n                return False\n            if not is_palindrome(num[:-1]):\n                return False\n            return True\n        \n        def is_palindrome_helper_2(num):\n            if not num:\n                return True\n            if not is_palindrome(num[1:]):\n                return False\n            if not is_palindrome(num[:-1]):\n                return False\n            return True\n        \n        def is_palindrome_helper_3(num):\n            if not num:\n                return True\n            if not is_palindrome(num[1:]):\n                return False\n            if not is_palindrome(num[:-1]):\n                return False\n            return True\n        \n        def is_palindrome_helper_4(num):"
    },
    {
        "number": 2385,
        "title": "Amount of Time for Binary Tree to Be Infected",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        \n        # DFS\n        # Time: O(n)\n        # Space: O(n)\n        # def dfs(node, start):\n        #     if not node:\n        #         return\n        #     if node.val == start:\n        #         self.res += 1\n        #         return\n        #     self.res += 1\n        #     dfs(node.left, start)\n        #     dfs(node.right, start)\n        \n        # self.res = 0\n        # dfs(root, start)\n        # return self.res\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        # def bfs(node, start):\n        #     if not node:\n        #         return\n        #     if node.val == start:\n        #         self.res += 1\n        #         return\n        #     self.res += 1\n        #     q = deque([node])\n        #     while q:\n        #         "
    },
    {
        "number": 2386,
        "title": "Find the K-Sum of an Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if j < nums[i - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n        return dp[n][k]"
    },
    {
        "number": 2389,
        "title": "Longest Subsequence With Limited Sum",
        "difficulty": 0,
        "answer": "        # Time: O(n * m)\n        # Space: O(n)\n        # dp = [[0] * (len(nums) + 1) for _ in range(len(queries) + 1)]\n        # for i in range(1, len(queries) + 1):\n        #     for j in range(1, len(nums) + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if queries[i - 1] <= nums[j - 1]:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j - queries[i - 1]] + nums[j - 1])\n        # return dp[-1][-1]"
    },
    {
        "number": 2390,
        "title": "Removing Stars From a String",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        \n        i = 0\n        while i < len(s) and s[i] == '*':\n            i += 1\n        \n        if i == len(s):\n            return \"\"\n        \n        j = i\n        while j < len(s) and s[j]!= '*':\n            j += 1\n        \n        return s[:i] + s[j:]"
    },
    {
        "number": 2391,
        "title": "Minimum Amount of Time to Collect Garbage",
        "difficulty": 1,
        "answer": "        # Time: O(N)\n        # Space: O(N)\n        # dp = [[0] * len(garbage) for _ in range(len(garbage))]\n        # for i in range(len(garbage)):\n        #     for j in range(i, len(garbage)):\n        #         if garbage[i] == \"M\":\n        #             dp[i][j] = dp[i][j - 1] + travel[i]\n        #         elif garbage[i] == \"P\":\n        #             dp[i][j] = dp[i - 1][j] + travel[i]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + travel[i]\n        #         if garbage[j] == \"M\":\n        #             dp[j][i] = dp[j][i - 1] + travel[j]\n        #         elif garbage[j] == \"P\":\n        #             dp[j][i] = dp[j -"
    },
    {
        "number": 2392,
        "title": "Build a Matrix With Conditions",
        "difficulty": 2,
        "answer": "        # Time: O(n*m)\n        # Space: O(n*m)\n        # dp = [[0] * k for _ in range(k)]\n        # for i in range(k):\n        #     dp[i][i] = 1\n        # for i in range(k):\n        #     for j in range(k):\n        #         if i == 0:\n        #             dp[i][j] = 1\n        #         elif j == 0:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # for row in dp:\n        #     print(row)\n        # return dp[-1][-1]\n        \n        # Time: O(n*m)\n        # Space: O(n*m)\n        # dp = [[0] * k for _ in range(k)]\n        # for i in range(k):\n        #     dp[i"
    },
    {
        "number": 2395,
        "title": "Find Subarrays With Equal Sum",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         dp[nums[i]] += 1\n        #     else:\n        #         dp[nums[i]] = 1\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] in dp:\n        #             dp[nums[i] + nums[j]] += 1\n        #         else:\n        #             dp[nums[i] + nums[j]] = 1\n        # return any(dp.values())\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         "
    },
    {
        "number": 2396,
        "title": "Strictly Palindromic Number",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return False\n        if n == 6:\n            return False\n        if n == 7:\n            return False\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return False\n        if n == 11:\n            return False\n        if n == 12:\n            return False\n        if n == 13:\n            return False\n        if n == 14:\n            return False\n        if n == 15:\n            return False\n        if n == 16:\n            return False\n        if n == 17:\n            return False\n        if n == 18:\n            return False\n        if n == 19:\n            return False\n        if n == 20:\n            return False\n        if n == 21:\n            return False\n        if n == 22:\n            return False\n        if n == 23:\n            "
    },
    {
        "number": 2397,
        "title": "Maximum Rows Covered by Columns",
        "difficulty": 1,
        "answer": "        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + matrix[i - 1][j - 1]\n        return max(dp[-1])"
    },
    {
        "number": 2398,
        "title": "Maximum Number of Robots Within Budget",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + runningCosts[i]\n        # dp[i"
    },
    {
        "number": 2399,
        "title": "Check Distances Between Same Letters",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # if len(s) % 2 == 1:\n        #     return False\n        #\n        # letters = {}\n        # for i in range(26):\n        #     letters[chr(i + ord('a'))] = i\n        #\n        # for i in range(len(s)):\n        #     if s[i] not in letters:\n        #         return False\n        #\n        #     if i == 0:\n        #         continue\n        #\n        #     if letters[s[i - 1]] + 1!= letters[s[i]]:\n        #         return False\n        #\n        # return True"
    },
    {
        "number": 2400,
        "title": "Number of Ways to Reach a Position After Exactly k Steps",
        "difficulty": 1,
        "answer": "        if startPos == endPos:\n            return 1\n        if startPos > endPos:\n            return 0\n        if k == 0:\n            return 1\n        if k == 1:\n            return endPos - startPos + 1\n        if k == 2:\n            return endPos - startPos + 1 - (endPos - startPos) % 2\n        if k == 3:\n            return endPos - startPos + 1 - (endPos - startPos) % 3\n        if k == 4:\n            return endPos - startPos + 1 - (endPos - startPos) % 4\n        if k == 5:\n            return endPos - startPos + 1 - (endPos - startPos) % 5\n        if k == 6:\n            return endPos - startPos + 1 - (endPos - startPos) % 6\n        if k == 7:\n            return endPos - startPos + 1 - (endPos - startPos) % 7\n        if k == 8:\n            return endPos - startPos + 1 - (endPos - startPos) % 8\n        if k == 9:\n"
    },
    {
        "number": 2401,
        "title": "Longest Nice Subarray",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(1)\n        # if not nums:\n        #     return 0\n        # n = len(nums)\n        # res = 0\n        # for i in range(n):\n        #     if nums[i] & 1 == 0:\n        #         res = max(res, self.longestNiceSubarray(nums[i+1:]))\n        # return res + 1 if res else 1"
    },
    {
        "number": 2402,
        "title": "Meeting Rooms III",
        "difficulty": 2,
        "answer": "        # Sort the meetings by start time\n        meetings.sort(key=lambda x: x[0])\n        \n        # Sort the meetings by end time\n        meetings.sort(key=lambda x: x[1])\n        \n        # Sort the meetings by duration\n        meetings.sort(key=lambda x: x[1] - x[0])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[0])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[1])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[0])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[1])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[0])\n        \n        # Sort the meetings by room\n        meetings.sort(key=lambda x: x[1])\n        \n        # Sort the meetings by room\n        "
    },
    {
        "number": 2404,
        "title": "Most Frequent Even Element",
        "difficulty": 0,
        "answer": "        count = {}\n        for num in nums:\n            if num % 2 == 0:\n                count[num] = count.get(num, 0) + 1\n        return max(count.items(), key=lambda x: x[1])[0] if count else -1\n"
    },
    {
        "number": 2405,
        "title": "Optimal Partition of String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(i, len(s)):\n        #         dp[i][j] = True\n        #         for k in range(i, j):\n        #             if s[k] == s[i] and dp[i][k] and dp[k+1][j]:\n        #                 dp[i][j] = False\n        #                 break\n        # return sum(1 for i in range(len(s)) if dp[i][len(s)-1])"
    },
    {
        "number": 2406,
        "title": "Divide Intervals Into Minimum Number of Groups",
        "difficulty": 1,
        "answer": "        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        # print(intervals)\n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals)\n        # print(intervals"
    },
    {
        "number": 2407,
        "title": "Longest Increasing Subsequence II",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        \n        n = len(nums)\n        dp = [1] * n\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
    },
    {
        "number": 2409,
        "title": "Count Days Spent Together",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(arriveAlice)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(i, n):\n        #         if arriveAlice[i] == arriveAlice[j]:\n        #             dp[i][j] = 1\n        #         if leaveAlice[i] == leaveAlice[j]:\n        #             dp[i][j] = 1\n        #         if arriveBob[i] == arriveBob[j]:\n        #             dp[i][j] = 1\n        #         if leaveBob[i] == leaveBob[j]:\n        #             dp[i][j] = 1\n        # for i in range(n):\n        #     for j in range(i, n):\n        #         if dp[i][j] == 1:\n        #             dp[i][j] = dp[i][j] + dp[j][i]"
    },
    {
        "number": 2410,
        "title": "Maximum Matching of Players With Trainers",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = [[0] * (len(trainers) + 1) for _ in range(len(players) + 1)]\n        # for i in range(1, len(players) + 1):\n        #     for j in range(1, len(trainers) + 1):\n        #         if players[i - 1] <= trainers[j - 1]:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + 1\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return dp[-1][-1]"
    },
    {
        "number": 2411,
        "title": "Smallest Subarrays With Maximum Bitwise OR",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 10:\n        # Time: O(n)"
    },
    {
        "number": 2412,
        "title": "Minimum Money Required Before Transactions",
        "difficulty": 2,
        "answer": "        \n        # sort the transactions by the cost\n        transactions.sort(key=lambda x: x[0])\n        \n        # initialize the minimum amount of money\n        min_money = 0\n        \n        # iterate through the transactions\n        for cost, cashback in transactions:\n            \n            # update the minimum amount of money\n            min_money = min(min_money, min_money + cost - cashback)\n            \n        return min_money\n"
    },
    {
        "number": 2413,
        "title": "Smallest Even Multiple",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 2414,
        "title": "Length of the Longest Alphabetical Continuous Substring",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n            \n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        return dp[0][n - 1]"
    },
    {
        "number": 2415,
        "title": "Reverse Odd Levels of Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return root\n        \n        def reverse(node):\n            if not node:\n                return\n            \n            if node.left:\n                reverse(node.left)\n            if node.right:\n                reverse(node.right)\n            \n            node.left, node.right = node.right, node.left\n            \n        reverse(root)\n        return root"
    },
    {
        "number": 2416,
        "title": "Sum of Prefix Scores of Strings",
        "difficulty": 2,
        "answer": "        \n        # O(n^2)\n        # dp = {}\n        # for word in words:\n        #     prefix = \"\"\n        #     for i in range(len(word)):\n        #         prefix += word[i]\n        #         if prefix in dp:\n        #             dp[prefix] += 1\n        #         else:\n        #             dp[prefix] = 1\n        # return [dp[prefix] for prefix in dp]\n        \n        # O(n)\n        # dp = {}\n        # for word in words:\n        #     prefix = \"\"\n        #     for i in range(len(word)):\n        #         prefix += word[i]\n        #         if prefix in dp:\n        #             dp[prefix] += 1\n        #         else:\n        #             dp[prefix] = 1\n        # return [dp[prefix] for prefix in dp]\n        \n        # O(n)\n        # dp = {}\n        # for word in words:\n        #     prefix = \"\"\n        #     for i"
    },
    {
        "number": 2418,
        "title": "Sort the People",
        "difficulty": 0,
        "answer": "        # O(n) time | O(n) space\n        # sort by height\n        # return sorted list\n        # sort by name\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        # sort by name and height\n        # return sorted list\n        #"
    },
    {
        "number": 2419,
        "title": "Longest Subarray With Maximum Bitwise AND",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9:\n        # Time: O(n)\n        # Space: O"
    },
    {
        "number": 2420,
        "title": "Find All Good Indices",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if k == 0:\n        #     return []\n        # if k == 1:\n        #     return [i for i in range(len(nums)) if nums[i] == 1]\n        #\n        # good_indices = []\n        #\n        # for i in range(len(nums)):\n        #     if i < k:\n        #         if nums[i] <= nums[i + k]:\n        #             continue\n        #         else:\n        #             good_indices.append(i)\n        #     else:\n        #         if nums[i] >= nums[i - k]:\n        #             continue\n        #         else:\n        #             good_indices.append(i)\n        #\n        # return good_indices"
    },
    {
        "number": 2421,
        "title": "Number of Good Paths",
        "difficulty": 2,
        "answer": "        n = len(vals)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                for k in range(i):\n                    if edges[k][1] == edges[j][0]:\n                        dp[i][j] += dp[k][i]\n        return sum(dp[0])"
    },
    {
        "number": 2423,
        "title": "Remove Letter To Equalize Frequency",
        "difficulty": 0,
        "answer": "        freq = {}\n        for c in word:\n            freq[c] = freq.get(c, 0) + 1\n        for k, v in freq.items():\n            if v!= 1:\n                return False\n        return True"
    },
    {
        "number": 2424,
        "title": "Longest Uploaded Prefix",
        "difficulty": 1,
        "answer": "\nclass LUPrefix:\n    def __init__(self, n: int):\n    def upload(self, video: int) -> None:\n    def longest(self) -> int:\n        \"\"\"\n        You are given a stream of n videos, each represented by a distinct number from 1 to n that you need to \"upload\" to a server. You need to implement a data structure that calculates the length of the longest uploaded prefix at various points in the upload process.\n        We consider i to be an uploaded prefix if all videos in the range 1 to i (inclusive) have been uploaded to the server. The longest uploaded prefix is the maximum value of i that satisfies this definition.\n        Implement the LUPrefix class:\n            LUPrefix(int n) Initializes the object for a stream of n videos.\n            void upload(int video) Uploads video to the server.\n            int longest() Returns the length of the longest uploaded prefix defined above.\n        Example 1:\n        Input\n        [\"LUPrefix\", \"upload\", \"longest\", \"upload\", \"longest\", \"upload\", \"longest\"]\n        "
    },
    {
        "number": 2425,
        "title": "Bitwise XOR of All Pairings",
        "difficulty": 1,
        "answer": "        nums1 = sorted(nums1)\n        nums2 = sorted(nums2)\n        nums3 = []\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                nums3.append(nums1[i] ^ nums2[j])\n        return sum(nums3)"
    },
    {
        "number": 2426,
        "title": "Number of Pairs Satisfying Inequality",
        "difficulty": 2,
        "answer": "        nums1.sort()\n        nums2.sort()\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] - nums2[j] <= diff:\n                    count += 1\n        return count"
    },
    {
        "number": 2427,
        "title": "Number of Common Factors",
        "difficulty": 0,
        "answer": "        if a == 0 or b == 0:\n            return 0\n        if a == b:\n            return 1\n        if a < b:\n            return 0\n        if a % b == 0:\n            return 1\n        if a % b!= 0:\n            return 0\n        if a == 1:\n            return 1\n        if a == 2:\n            return 1\n        if a == 3:\n            return 1\n        if a == 4:\n            return 1\n        if a == 5:\n            return 1\n        if a == 6:\n            return 1\n        if a == 7:\n            return 1\n        if a == 8:\n            return 1\n        if a == 9:\n            return 1\n        if a == 10:\n            return 1\n        if a == 11:\n            return 1\n        if a == 12:\n            return 1\n        if a == 13:\n            return 1\n        if a == 14:\n            return 1\n        if a == 15:\n            return 1\n        if a == 16:\n            return 1\n        if a == 17:\n            return 1\n"
    },
    {
        "number": 2428,
        "title": "Maximum Sum of an Hourglass",
        "difficulty": 1,
        "answer": "        m = len(grid)\n        n = len(grid[0])\n        max_sum = -1\n        for i in range(m-2):\n            for j in range(n-2):\n                sum = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2]\n                max_sum = max(max_sum, sum)\n        return max_sum"
    },
    {
        "number": 2429,
        "title": "Minimize XOR",
        "difficulty": 1,
        "answer": "        # num1 = 1\n        # num2 = 2\n        # num1 = 2\n        # num2 = 3\n        # num1 = 3\n        # num2 = 4\n        # num1 = 4\n        # num2 = 5\n        # num1 = 5\n        # num2 = 6\n        # num1 = 6\n        # num2 = 7\n        # num1 = 7\n        # num2 = 8\n        # num1 = 8\n        # num2 = 9\n        # num1 = 9\n        # num2 = 10\n        # num1 = 10\n        # num2 = 11\n        # num1 = 11\n        # num2 = 12\n        # num1 = 12\n        # num2 = 13\n        # num1 = 13\n        # num2 = 14\n        # num1 = 14\n        # num2 = 15\n        # num1 = 15\n        # num2 = 16\n        # num1 = 16\n        # num2 = 17\n        # num1 = 17\n        # num2 = 18\n        # num1 = 18\n        # num2 ="
    },
    {
        "number": 2430,
        "title": "Maximum Deletions on a String",
        "difficulty": 2,
        "answer": "        # O(n)\n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(i, len(s)):\n        #         if s[i] == s[j]:\n        #             dp[i][j] = dp[i + 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        # return dp[0][len(s) - 1]"
    },
    {
        "number": 2432,
        "title": "The Employee That Worked on the Longest Task",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(n):\n        #     dp[i] = 0\n        # for log in logs:\n        #     dp[log[0]] = max(dp[log[0]], log[1])\n        # return max(dp.values())\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(n):\n        #     dp[i] = 0\n        # for log in logs:\n        #     dp[log[0]] = max(dp[log[0]], log[1] - dp[log[0] - 1])\n        # return max(dp.values())\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(n):\n        #     dp[i] = 0\n        # for log in logs:\n        #     dp[log[0"
    },
    {
        "number": 2433,
        "title": "Find The Original Array of Prefix Xor",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(pref)\n        # arr = [0] * n\n        # for i in range(n):\n        #     arr[i] = pref[i]\n        # for i in range(n):\n        #     arr[i] = arr[i] ^ pref[i]\n        # return arr"
    },
    {
        "number": 2434,
        "title": "Using a Robot to Print the Lexicographically Smallest String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # def helper(s, t):\n        #     if (s, t) in dp:\n        #         return dp[(s, t)]\n        #     if not s:\n        #         return t\n        #     if not t:\n        #         return s\n        #     if s[0] == t[0]:\n        #         dp[(s, t)] = helper(s[1:], t[1:])\n        #         return dp[(s, t)]\n        #     else:\n        #         dp[(s, t)] = helper(s[1:], t)\n        #         return dp[(s, t)]\n        # return helper(s, \"\")"
    },
    {
        "number": 2435,
        "title": "Paths in Matrix Whose Sum Is Divisible by K",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 2437,
        "title": "Number of Valid Clock Times",
        "difficulty": 0,
        "answer": "        # time = \"?5:00\"\n        # time = \"0?:0?\"\n        # time = \"??:??\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\"\n        # time = \"00:00\""
    },
    {
        "number": 2438,
        "title": "Range Product Queries of Powers",
        "difficulty": 1,
        "answer": "        powers = [1]\n        for i in range(1, n):\n            powers.append(powers[-1] * 2)\n        answers = []\n        for left, right in queries:\n            answers.append(powers[right] * powers[left - 1] % (10**9 + 7))\n        return answers"
    },
    {
        "number": 2439,
        "title": "Minimize Maximum of Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0], nums[1], nums[2])\n        if n == 4:\n            return max(nums[0], nums[1], nums[2], nums[3])\n        if n == 5:\n            return max(nums[0], nums[1], nums[2], nums[3], nums[4])\n        if n == 6:\n            return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])\n        if n == 7:\n            return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])\n        if n == 8:\n            return max(n"
    },
    {
        "number": 2440,
        "title": "Create Components With Same Value",
        "difficulty": 2,
        "answer": "        # dfs\n        # dfs + bfs\n        # dfs + bfs + dfs\n        # dfs + bfs + dfs + bfs\n        # dfs + bfs + dfs + bfs + dfs\n        # dfs + bfs + dfs + bfs + dfs + bfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs + bfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs + bfs + dfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs + bfs + dfs + dfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs + bfs + dfs + dfs + dfs\n        # dfs + bfs + dfs + bfs + dfs + bfs + dfs + bfs + dfs + d"
    },
    {
        "number": 2441,
        "title": "Largest Positive Integer That Exists With Its Negative",
        "difficulty": 0,
        "answer": "        # nums = [-1,2,-3,3]\n        # nums = [-1,10,6,7,-7,1]\n        # nums = [-10,8,6,7,-2,-3]\n        # nums = [-10,8,6,7,-2,-3,0]\n        # nums = [-10,8,6,7,-2,-3,0,1]\n        # nums = [-10,8,6,7,-2,-3,0,1,2]\n        # nums = [-10,8,6,7,-2,-3,0,1,2,3]\n        # nums = [-10,8,6,7,-2,-3,0,1,2,3,4]\n        # nums = [-10,8,6,7,-2,-3,0,1,2,3,4,5]\n        # nums = [-10,8,6,7,-2,-3,0,1,2,3,4,5,6]\n        # nums = [-10,"
    },
    {
        "number": 2442,
        "title": "Count Number of Distinct Integers After Reverse Operations",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # nums = sorted(nums, reverse=True)\n        # return len(set(nums))"
    },
    {
        "number": 2443,
        "title": "Sum of Number and Its Reverse",
        "difficulty": 1,
        "answer": "        # if num == 0:\n        #     return False\n        # if num < 0:\n        #     return False\n        # if num == 1:\n        #     return True\n        # if num == 2:\n        #     return True\n        # if num == 3:\n        #     return True\n        # if num == 4:\n        #     return True\n        # if num == 5:\n        #     return True\n        # if num == 6:\n        #     return True\n        # if num == 7:\n        #     return True\n        # if num == 8:\n        #     return True\n        # if num == 9:\n        #     return True\n        # if num == 10:\n        #     return True\n        # if num == 11:\n        #     return True\n        # if num == 12:\n        #     return True\n        # if num == 13:\n        #     return True\n        # if num == 14:\n        #     return True\n        # if num == 15:\n        #     return True\n        # if num == 16:\n        #     return"
    },
    {
        "number": 2444,
        "title": "Count Subarrays With Fixed Bounds",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (maxK + 1) for _ in range(minK + 1)]\n        # for i in range(minK, maxK + 1):\n        #     dp[i][i] = 1\n        # for i in range(minK - 1, -1, -1):\n        #     for j in range(i + 1, maxK + 1):\n        #         dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        # return dp[minK][maxK]"
    },
    {
        "number": 2446,
        "title": "Determine if Two Events Have Conflict",
        "difficulty": 0,
        "answer": "        if len(event1)!= len(event2):\n            return False\n        for i in range(len(event1)):\n            if event1[i] == event2[i]:\n                return True\n        return False\n"
    },
    {
        "number": 2447,
        "title": "Number of Subarrays With GCD Equal to K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # res = 0\n        # for i in range(len(nums)):\n        #     if nums[i] in dp:\n        #         dp[nums[i]] += 1\n        #     else:\n        #         dp[nums[i]] = 1\n        #     if dp[nums[i]] > 1:\n        #         res += 1\n        #         for j in range(i, len(nums)):\n        #             if nums[j] % nums[i] == 0:\n        #                 res += dp[nums[j]] - 1\n        #             else:\n        #                 break\n        # return res"
    },
    {
        "number": 2448,
        "title": "Minimum Cost to Make Array Equal",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * len(nums) for _ in range(len(nums))]\n        # for i in range(len(nums)):\n        #     dp[i][i] = cost[i]\n        # for i in range(len(nums) - 1):\n        #     for j in range(i + 1, len(nums)):\n        #         dp[i][j] = min(dp[i][j], dp[i][j - 1] + cost[j])\n        # return min(dp[i][j] for i in range(len(nums)) for j in range(len(nums)))"
    },
    {
        "number": 2449,
        "title": "Minimum Number of Operations to Make Arrays Similar",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2451,
        "title": "Odd String Difference",
        "difficulty": 0,
        "answer": "        odd_arr = []\n        for word in words:\n            diff = []\n            for i in range(len(word) - 1):\n                diff.append(word[i + 1] - word[i])\n            if diff not in odd_arr:\n                odd_arr.append(diff)\n        for word in words:\n            if word not in odd_arr:\n                return word\n        return \"\""
    },
    {
        "number": 2452,
        "title": "Words Within Two Edits of Dictionary",
        "difficulty": 1,
        "answer": "        def is_equal(word1, word2):\n            if len(word1)!= len(word2):\n                return False\n            for i in range(len(word1)):\n                if word1[i]!= word2[i]:\n                    return False\n            return True"
    },
    {
        "number": 2453,
        "title": "Destroy Sequential Targets",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 1:\n        # sort the array and use binary search to find the target\n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        # Solution 2:\n        # sort the array and use binary search to find the target\n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        # Solution 3:\n        # sort the array and use binary search to find the target\n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        # Solution 4:\n        # sort the array and use binary search to find the target\n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        # Solution 5:\n        # sort the array and use binary search to find the target\n        # Time: O(nlogn)\n        # Space: O(1)\n        \n        # Solution 6:\n        # sort the array and use binary search to find the target\n        # Time"
    },
    {
        "number": 2454,
        "title": "Next Greater Element IV",
        "difficulty": 2,
        "answer": "        \n        # O(n) time | O(n) space\n        # nums = sorted(nums)\n        # answer = []\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         answer.append(-1)\n        #     else:\n        #         if nums[i] > nums[i-1]:\n        #             answer.append(nums[i-1])\n        #         else:\n        #             answer.append(-1)\n        # return answer\n        \n        # O(n) time | O(n) space\n        # nums = sorted(nums)\n        # answer = []\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         answer.append(-1)\n        #     else:\n        #         if nums[i] > nums[i-1]:\n        #             answer.append(nums[i-1])\n        #         else:\n        #             answer.append(-1)\n        # return"
    },
    {
        "number": 2455,
        "title": "Average Value of Even Numbers That Are Divisible by Three",
        "difficulty": 0,
        "answer": "        evens = 0\n        for num in nums:\n            if num % 2 == 0:\n                evens += num\n        return evens // len(nums)"
    },
    {
        "number": 2456,
        "title": "Most Popular Video Creator",
        "difficulty": 1,
        "answer": "        # create a dictionary with creator as key and views as value\n        creator_views = {}\n        for i in range(len(creators)):\n            creator_views[creators[i]] = views[i]\n        creator_views = {k: v for k, v in sorted(creator_views.items(), key=lambda item: item[1], reverse=True)}\n        # create a dictionary with creator as key and id as value\n        creator_id = {}\n        for i in range(len(creators)):\n            creator_id[creators[i]] = ids[i]\n        creator_id = {k: v for k, v in sorted(creator_id.items(), key=lambda item: item[1])}\n        # create a dictionary with creator as key and id as value\n        creator_views_id = {}\n        for i in range(len(creators)):\n            creator_views_id[creators[i]] = creator_id[creators[i]]\n        creator_views_id = {k: v for k, v in sorted(creator_views"
    },
    {
        "number": 2457,
        "title": "Minimum Addition to Make Integer Beautiful",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 2458,
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "difficulty": 2,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return []\n        # res = []\n        # def dfs(node, val):\n        #     if not node:\n        #         return\n        #     if node.val == val:\n        #         res.append(node.val)\n        #         return\n        #     dfs(node.left, val)\n        #     dfs(node.right, val)\n        # dfs(root, queries[0])\n        # return res"
    },
    {
        "number": 2460,
        "title": "Apply Operations to an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums\n        \n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        \n        return nums"
    },
    {
        "number": 2461,
        "title": "Maximum Sum of Distinct Subarrays With Length K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # max_sum = float('-inf')\n        # for i in range(len(nums)):\n        #     curr_sum = 0\n        #     for j in range(i, len(nums)):\n        #         curr_sum += nums[j]\n        #         if curr_sum - k in dp:\n        #             max_sum = max(max_sum, curr_sum - k)\n        #         else:\n        #             dp[curr_sum - k] = True\n        # return max_sum"
    },
    {
        "number": 2462,
        "title": "Total Cost to Hire K Workers",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(nk)\n        # Space: O(nk)\n        # if not costs:\n        #     return 0\n        # n = len(costs)\n        # if k > n:\n        #     return sum(costs)\n        # dp = [[0] * (k + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + costs[i - 1]\n        # return sum(dp[-1][1:])\n        \n        # Solution 2:\n        # Time: O(nk)\n        # Space: O(nk)\n        # if not costs:\n        #     return 0\n        # n = len(costs)\n        # if k > n:\n        #     return sum(costs)\n        # dp = [["
    },
    {
        "number": 2463,
        "title": "Minimum Total Distance Traveled",
        "difficulty": 2,
        "answer": "        \n        # dp = [[0] * len(robot) for _ in range(len(factory))]\n        # for i in range(len(robot)):\n        #     dp[0][i] = abs(robot[i] - factory[0][0])\n        # for i in range(len(factory)):\n        #     dp[i][0] = abs(factory[i][0] - robot[0])\n        \n        # for i in range(1, len(factory)):\n        #     for j in range(1, len(robot)):\n        #         dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + abs(factory[i][0] - robot[j])\n        # return dp[-1][-1]\n        \n        # dp = [[0] * len(robot) for _ in range(len(factory))]\n        # for i in range(len(robot)):\n        #     dp[0][i]"
    },
    {
        "number": 2465,
        "title": "Number of Distinct Averages",
        "difficulty": 0,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[i-1]:\n                res += 1\n        return res"
    },
    {
        "number": 2466,
        "title": "Count Ways To Build Good Strings",
        "difficulty": 1,
        "answer": "        # dp = {}\n        # def helper(i, j, k):\n        #     if i > j:\n        #         return 0\n        #     if (i, j, k) in dp:\n        #         return dp[(i, j, k)]\n        #     if k == 0:\n        #         return 1\n        #     if k == 1:\n        #         return 1\n        #     if k == 2:\n        #         return 2\n        #     if k == 3:\n        #         return 4\n        #     if k == 4:\n        #         return 5\n        #     if k == 5:\n        #         return 6\n        #     if k == 6:\n        #         return 7\n        #     if k == 7:\n        #         return 8\n        #     if k == 8:\n        #         return 9\n        #     if k == 9:\n        #         return 10\n        #     if k == 10:\n        #         return 11\n        #     if k == 11:\n        #         return 12\n        #     if k"
    },
    {
        "number": 2467,
        "title": "Most Profitable Path in a Tree",
        "difficulty": 1,
        "answer": "        \n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        # dfs\n        # Time: O(n)\n        # Space:"
    },
    {
        "number": 2468,
        "title": "Split Message Based on Limit",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 5:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 6:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 7:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 8:\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Solution 9:\n        # Time: O(n)\n        # Space: O"
    },
    {
        "number": 2469,
        "title": "Convert the Temperature",
        "difficulty": 0,
        "answer": "        return [round(celsius + 273.15, 2), round((celsius * 1.8) + 32, 2)]"
    },
    {
        "number": 2470,
        "title": "Number of Subarrays With LCM Equal to K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # res = 0\n        # for num in nums:\n        #     if num in dp:\n        #         dp[num] += 1\n        #     else:\n        #         dp[num] = 1\n        # for num in dp:\n        #     if dp[num] % k == 0:\n        #         res += 1\n        # return res"
    },
    {
        "number": 2471,
        "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0"
    },
    {
        "number": 2472,
        "title": "Maximum Number of Non-overlapping Palindrome Substrings",
        "difficulty": 2,
        "answer": "        if k == 0:\n            return 0\n        if k == 1:\n            return len(s)\n        if k == 2:\n            return sum(s[i] == s[i + 1] for i in range(len(s) - 1))\n        if k == 3:\n            return sum(s[i] == s[i + 1] and s[i] == s[i - 1] for i in range(len(s) - 1))\n        if k == 4:\n            return sum(s[i] == s[i + 1] and s[i] == s[i - 1] and s[i] == s[i - 2] for i in range(len(s) - 1))\n        if k == 5:\n            return sum(s[i] == s[i + 1] and s[i] == s[i - 1] and s[i] == s[i - 2] and s[i] == s[i - 3] for i in range(len(s) - 1))\n        if k == 6:\n            return sum(s["
    },
    {
        "number": 2475,
        "title": "Number of Unequal Triplets in Array",
        "difficulty": 0,
        "answer": "        count = 0\n        nums.sort()\n        for i in range(len(nums)-2):\n            if nums[i] == nums[i+1] == nums[i+2]:\n                count += 1\n        return count\n"
    },
    {
        "number": 2476,
        "title": "Closest Nodes Queries in a Binary Search Tree",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(N)\n        # Space: O(N)\n        # if not root:\n        #     return []\n        # res = []\n        # self.dfs(root, queries, res, 0)\n        # return res"
    },
    {
        "number": 2477,
        "title": "Minimum Fuel Cost to Report to the Capital",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[float('inf')] * (seats + 1) for _ in range(len(roads))]\n        # dp[0][0] = 0\n        # for i in range(len(roads)):\n        #     for j in range(seats + 1):\n        #         if j >= roads[i][0]:\n        #             dp[i][j] = min(dp[i][j], dp[i - 1][j - roads[i][0]] + roads[i][1])\n        #         if j >= roads[i][1]:\n        #             dp[i][j] = min(dp[i][j], dp[i - 1][j - roads[i][1]] + roads[i][0])\n        # return dp[-1][-1]"
    },
    {
        "number": 2478,
        "title": "Number of Beautiful Partitions",
        "difficulty": 2,
        "answer": "        def isPrime(n):\n            if n == 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True"
    },
    {
        "number": 2481,
        "title": "Minimum Cuts to Divide a Circle",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            "
    },
    {
        "number": 2482,
        "title": "Difference Between Ones and Zeros in Row and Column",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        diff = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    diff[i][j] = 0\n                else:\n                    diff[i][j] = diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1] + 1\n        return diff"
    },
    {
        "number": 2483,
        "title": "Minimum Penalty for a Shop",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # n = len(customers)\n        # if n == 0:\n        #     return 0\n        #\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n        # # dp[i"
    },
    {
        "number": 2484,
        "title": "Count Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * 5 for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(5):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j + 1]\n                elif j == 4:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % MOD\n        return dp[-1][0]"
    },
    {
        "number": 2485,
        "title": "Find the Pivot Integer",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return -1\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n"
    },
    {
        "number": 2486,
        "title": "Append Characters to String to Make Subsequence",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(s) + 1) for _ in range(len(t) + 1)]\n        # for i in range(1, len(t) + 1):\n        #     for j in range(1, len(s) + 1):\n        #         if t[i - 1] == s[j - 1]:\n        #             dp[i][j] = dp[i - 1][j - 1] + 1\n        #         else:\n        #             dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n        # return dp[-1][-1]"
    },
    {
        "number": 2487,
        "title": "Remove Nodes From Linked List",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # if not head:\n        #     return None\n        #\n        # dummy = ListNode(0)\n        # dummy.next = head\n        #\n        # prev = dummy\n        # curr = head\n        #\n        # while curr:\n        #     if curr.val > prev.val:\n        #         prev = curr\n        #     else:\n        #         while curr.next and curr.next.val < prev.val:\n        #             curr = curr.next\n        #         if curr.next:\n        #             prev.next = curr.next\n        #             curr = curr.next\n        #         else:\n        #             prev.next = None\n        #             curr = None\n        #\n        # return dummy.next"
    },
    {
        "number": 2488,
        "title": "Count Subarrays With Median K",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] % 2 == 1:\n        #         count += 1\n        #         if count == k:\n        #             return 1\n        # return count"
    },
    {
        "number": 2490,
        "title": "Circular Sentence",
        "difficulty": 0,
        "answer": "        if not sentence:\n            return False\n        \n        words = sentence.split()\n        if len(words) == 1:\n            return True\n        \n        for i in range(len(words) - 1):\n            if words[i][-1]!= words[i + 1][0]:\n                return False\n        \n        return True"
    },
    {
        "number": 2491,
        "title": "Divide Players Into Teams of Equal Skill",
        "difficulty": 1,
        "answer": "        \n        # if len(skill) == 1:\n        #     return skill[0]\n        \n        # if len(skill) == 2:\n        #     return max(skill)\n        \n        # if len(skill) == 3:\n        #     return max(skill)\n        \n        # if len(skill) == 4:\n        #     return max(skill)\n        \n        # if len(skill) == 5:\n        #     return max(skill)\n        \n        # if len(skill) == 6:\n        #     return max(skill)\n        \n        # if len(skill) == 7:\n        #     return max(skill)\n        \n        # if len(skill) == 8:\n        #     return max(skill)\n        \n        # if len(skill) == 9:\n        #     return max(skill)\n        \n        # if len(skill) == 10:\n        #     return max(skill)\n        \n        # if len(skill) == 11:\n        #     return max(skill)\n        \n        # if len(skill"
    },
    {
        "number": 2492,
        "title": "Minimum Score of a Path Between Two Cities",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min(dp[i][j], dp[k][j] + dp[i][k])\n        # dp[i][j] = min("
    },
    {
        "number": 2493,
        "title": "Divide Nodes Into the Maximum Number of Groups",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dfs\n        # dfs + bfs\n        # dfs + bfs + dfs\n        # dfs + bfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs\n        # dfs + bfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs"
    },
    {
        "number": 2496,
        "title": "Maximum Value of a String in an Array",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(strs)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return int(strs[0])\n        #\n        # strs.sort(key=len)\n        #\n        # max_val = 0\n        # for i in range(n):\n        #     if strs[i][0] == '0':\n        #         continue\n        #     max_val = max(max_val, int(strs[i]))\n        # return max_val"
    },
    {
        "number": 2497,
        "title": "Maximum Star Sum of a Graph",
        "difficulty": 1,
        "answer": "        # dfs\n        # dfs + memo\n        # dfs + dp\n        # dfs + dp + memo\n        # dfs + dp + dp\n        # dfs + dp + dp + memo\n        # dfs + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + dp + dp + dp + dp + memo\n        # dfs + dp + dp + dp + dp + dp + d"
    },
    {
        "number": 2498,
        "title": "Frog Jump II",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        if n == 1:\n            return 0\n        \n        # dp[i] = max(dp[i-1], dp[i-2] + abs(i-stones[i]))\n        dp = [0] * n\n        dp[0] = 0\n        dp[1] = abs(stones[0] - stones[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2] + abs(i-stones[i]))\n        return dp[-1]"
    },
    {
        "number": 2499,
        "title": "Minimum Total Cost to Make Arrays Unequal",
        "difficulty": 2,
        "answer": "        nums1_len = len(nums1)\n        nums2_len = len(nums2)\n        if nums1_len!= nums2_len:\n            return -1\n        dp = [[0] * (nums2_len + 1) for _ in range(nums1_len + 1)]\n        for i in range(1, nums1_len + 1):\n            dp[i][0] = dp[i - 1][0] + nums1[i - 1]\n        for i in range(1, nums2_len + 1):\n            dp[0][i] = dp[0][i - 1] + nums2[i - 1]\n        for i in range(1, nums1_len + 1):\n            for j in range(1, nums2_len + 1):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + abs(nums1[i - 1] - nums2[j - 1])\n        return"
    },
    {
        "number": 2500,
        "title": "Delete Greatest Value in Each Row",
        "difficulty": 0,
        "answer": "        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [[0] * len(grid[0]) for _ in range(len(grid))]\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if i == 0:\n        #             dp[i][j] = grid[i][j]\n        #         else:\n        #             dp[i][j] = max(dp[i-1][j], grid[i][j])\n        # return max(dp[-1])"
    },
    {
        "number": 2501,
        "title": "Longest Square Streak in an Array",
        "difficulty": 1,
        "answer": "        # O(n) time | O(n) space\n        if len(nums) < 2:\n            return 0\n        nums.sort()\n        longest = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i]!= nums[i-1]**2:\n                longest = max(longest, 1)\n            else:\n                longest = max(longest, 2)\n        return longest"
    },
    {
        "number": 2502,
        "title": "Design Memory Allocator",
        "difficulty": 1,
        "answer": "\nclass Allocator:\n    def __init__(self, n: int):\n    def allocate(self, size: int, mID: int) -> int:\n    def free(self, mID: int) -> int:\n        \"\"\"\n        You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\n        You have a memory allocator with the following functionalities:\n            Allocate a block of size consecutive free memory units and assign it the id mID.\n            Free all memory units with the given id mID.\n        Note that:\n            Multiple blocks can be allocated to the same mID.\n            You should free all the memory units with mID, even if they were allocated in different blocks.\n        Implement the Allocator class:\n            Allocator(int n) Initializes an Allocator object with a memory array of size n.\n            int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist"
    },
    {
        "number": 2503,
        "title": "Maximum Number of Points From Grid Queries",
        "difficulty": 2,
        "answer": "        if not grid or not queries:\n            return []\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        ans = []\n        for q in queries:\n            ans.append(dp[-1][q - 1])\n        return ans"
    },
    {
        "number": 2506,
        "title": "Count Pairs Of Similar Strings",
        "difficulty": 0,
        "answer": "        \n        def is_similar(word1, word2):\n            return len(set(word1)) == len(set(word2)) and len(set(word1)) == len(set(word2))\n        \n        def similar_pairs(words):\n            res = 0\n            for i in range(len(words)):\n                for j in range(i+1, len(words)):\n                    if is_similar(words[i], words[j]):\n                        res += 1\n            return res\n        \n        return similar_pairs(words)"
    },
    {
        "number": 2507,
        "title": "Smallest Value After Replacing With Sum of Prime Factors",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 2508,
        "title": "Add Edges to Make Degrees of All Nodes Even",
        "difficulty": 2,
        "answer": "        \n        # if n == 1:\n        #     return True\n        \n        # graph = [[] for _ in range(n)]\n        # for edge in edges:\n        #     graph[edge[0]].append(edge[1])\n        #     graph[edge[1]].append(edge[0])\n        \n        # visited = set()\n        # def dfs(node):\n        #     if node in visited:\n        #         return False\n        #     visited.add(node)\n        #     for nei in graph[node]:\n        #         if not dfs(nei):\n        #             return False\n        #     return True\n        \n        # for i in range(n):\n        #     if not dfs(i):\n        #         return False\n        # return True\n        \n        # if n == 1:\n        #     return True\n        \n        # graph = [[] for _ in range(n)]\n        # for edge in edges:\n        #     graph[edge[0]].append(edge[1])\n        #     graph["
    },
    {
        "number": 2509,
        "title": "Cycle Length Queries in a Tree",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dfs\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # bfs\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp\n        # Time: O(n)\n        # Space: O(n)\n        \n        # d"
    },
    {
        "number": 2511,
        "title": "Maximum Enemy Forts That Can Be Captured",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (len(forts) + 1) for _ in range(len(forts) + 1)]\n        # for i in range(len(forts)):\n        #     dp[i][i] = 1\n        # for i in range(len(forts) - 1):\n        #     if forts[i] == 1:\n        #         dp[i][i + 1] = 1\n        #         dp[i + 1][i] = 1\n        #     elif forts[i] == -1:\n        #         dp[i][i + 1] = 1\n        #         dp[i + 1][i] = 1\n        #     else:\n        #         dp[i][i + 1] = 1\n        #         dp[i + 1][i] = 1\n        # for i in range(len(forts) - 2):\n        #     if forts[i] == 1:\n        #         dp[i][i + 2] = 1\n        #"
    },
    {
        "number": 2512,
        "title": "Reward Top K Students",
        "difficulty": 1,
        "answer": "        \n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        # sort the feedback by the points\n        # sort the feedback by the student id\n        "
    },
    {
        "number": 2513,
        "title": "Minimize the Maximum of Two Arrays",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # n = len(arr1) + len(arr2)\n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return max(arr1)\n        # if n == 2:\n        #     return max(arr1) + max(arr2)\n        # if n == 3:\n        #     return max(arr1) + max(arr2) + max(arr1)\n        # if n == 4:\n        #     return max(arr1) + max(arr2) + max(arr1) + max(arr2)\n        # if n == 5:\n        #     return max(arr1) + max(arr2) + max(arr1) + max(arr2) + max(arr1)\n        # if n == 6:\n        #     return max(arr1) + max(arr2) + max(arr1) + max(arr2) + max(arr1) + max(arr2)"
    },
    {
        "number": 2514,
        "title": "Count Anagrams",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] in dp:\n        #         dp[s[i]] += 1\n        #     else:\n        #         dp[s[i]] = 1\n        #     if i >= 2:\n        #         if s[i-2] in dp and s[i-1] in dp:\n        #             count += dp[s[i-2]] * dp[s[i-1]]\n        # return count % (10**9 + 7)"
    },
    {
        "number": 2515,
        "title": "Shortest Distance to Target String in a Circular Array",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not words:\n        #     return -1\n        \n        # n = len(words)\n        # if target not in words:\n        #     return -1\n        \n        # def get_closest_word(word, target):\n        #     if word == target:\n        #         return 0\n        #     if word > target:\n        #         return -1\n        #     if word < target:\n        #         return 1\n        \n        #     return get_closest_word(word + 1, target) + 1\n        \n        # return get_closest_word(0, target)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # if not words:\n        #     return -1\n        \n        # n = len(words)\n        # if target not in words:\n        #     return -1\n        \n        # def get_closest_word(word, target):\n        "
    },
    {
        "number": 2516,
        "title": "Take K of Each Character From Left and Right",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return 0\n        if k > len(s):\n            return -1\n        \n        # if k == 0:\n        #     return 0\n        # if k > len(s):\n        #     return -1\n        \n        # if k == 1:\n        #     return len(s)\n        \n        # if k == 2:\n        #     return len(s)\n        \n        # if k == 3:\n        #     return len(s)\n        \n        # if k == 4:\n        #     return len(s)\n        \n        # if k == 5:\n        #     return len(s)\n        \n        # if k == 6:\n        #     return len(s)\n        \n        # if k == 7:\n        #     return len(s)\n        \n        # if k == 8:\n        #     return len(s)\n        \n        # if k == 9:\n        #     return len(s)\n        \n        # if k == 10:\n        #     return len(s)\n        \n"
    },
    {
        "number": 2517,
        "title": "Maximum Tastiness of Candy Basket",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2518,
        "title": "Number of Great Partitions",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(len(nums) + 1)]\n        # for i in range(1, len(nums) + 1):\n        #     for j in range(1, k + 1):\n        #         if j < nums[i - 1]:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]\n        # return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 2520,
        "title": "Count the Digits That Divide a Number",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num < 10:\n            return 1\n        count = 0\n        while num > 0:\n            count += 1\n            num = num // 10\n        return count"
    },
    {
        "number": 2521,
        "title": "Distinct Prime Factors of Product of Array",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if not nums:\n        #     return 0\n        # nums.sort()\n        # count = 1\n        # for i in range(1, len(nums)):\n        #     if nums[i]!= nums[i-1]:\n        #         count *= nums[i]\n        #         count %= (10**9 + 7)\n        # return count"
    },
    {
        "number": 2522,
        "title": "Partition String Into Substrings With Values at Most K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[False] * 10 for _ in range(len(s) + 1)]\n        # dp[0][0] = True\n        # for i in range(1, len(s) + 1):\n        #     for j in range(10):\n        #         if j == int(s[i - 1]):\n        #             dp[i][j] = dp[i - 1][j - 1]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j]\n        # return self.dfs(dp, s, k)"
    },
    {
        "number": 2523,
        "title": "Closest Prime Numbers in Range",
        "difficulty": 1,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # if left == right:\n        #     return [left, left]\n        # left_prime = 2\n        # right_prime = right\n        # while left_prime <= right_prime:\n        #     if self.is_prime(left_prime) and self.is_prime(right_prime):\n        #         if left_prime < right_prime:\n        #             left_prime += 1\n        #         else:\n        #             right_prime -= 1\n        #     else:\n        #         left_prime += 1\n        # return [left_prime, right_prime]"
    },
    {
        "number": 2525,
        "title": "Categorize Box According to Criteria",
        "difficulty": 0,
        "answer": "        if length >= 104 or width >= 104 or height >= 104 or mass >= 100:\n            return \"Bulky\"\n        if length * width * height >= 109:\n            return \"Heavy\"\n        return \"Neither\""
    },
    {
        "number": 2526,
        "title": "Find Consecutive Integers from a Data Stream",
        "difficulty": 1,
        "answer": "        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code here\n        # Your code"
    },
    {
        "number": 2527,
        "title": "Find Xor-Beauty of Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    res ^= (nums[i] | nums[j] & nums[k])\n        return res"
    },
    {
        "number": 2528,
        "title": "Maximize the Minimum Powered City",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (k + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return max(dp[n][k], dp[n][k + 1])"
    },
    {
        "number": 2529,
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "difficulty": 0,
        "answer": "        pos = neg = 0\n        for num in nums:\n            if num > 0:\n                pos += 1\n            elif num < 0:\n                neg += 1\n        return max(pos, neg)"
    },
    {
        "number": 2530,
        "title": "Maximal Score After Applying K Operations",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2531,
        "title": "Make Number of Distinct Characters Equal",
        "difficulty": 1,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        \n        if len(word1) == 0:\n            return True\n        \n        if len(word1) == 1:\n            return word1 == word2\n        \n        if len(word1) == 2:\n            return word1[0] == word2[0] and word1[1] == word2[1]\n        \n        if len(word1) == 3:\n            return word1[0] == word2[0] and word1[1] == word2[1] and word1[2] == word2[2]\n        \n        if len(word1) == 4:\n            return word1[0] == word2[0] and word1[1] == word2[1] and word1[2] == word2[2] and word1[3] == word2[3]\n        \n        if len(word1) == 5:\n            return word1[0] == word2[0] and word1[1] == word2[1] and word1"
    },
    {
        "number": 2532,
        "title": "Time to Cross a Bridge",
        "difficulty": 2,
        "answer": "        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space O(nk)\n        # Time O(nk) | Space"
    },
    {
        "number": 2535,
        "title": "Difference Between Element Sum and Digit Sum of an Array",
        "difficulty": 0,
        "answer": "        s = sum(nums)\n        d = sum(int(i) for i in str(s))\n        return abs(s - d)"
    },
    {
        "number": 2536,
        "title": "Increment Submatrices by One",
        "difficulty": 1,
        "answer": "        mat = [[0] * n for _ in range(n)]\n        for query in queries:\n            x1, y1, x2, y2 = query\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    mat[i][j] += 1\n        return mat"
    },
    {
        "number": 2537,
        "title": "Count the Number of Good Subarrays",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # if k == 0:\n        #     return 0\n        # if k == 1:\n        #     return len(nums)\n        #\n        # count = 0\n        # for i in range(len(nums)):\n        #     if i == 0:\n        #         count += 1\n        #     else:\n        #         if nums[i] == nums[i - 1]:\n        #             count += 1\n        #         else:\n        #             count = 1\n        #     if count == k:\n        #         return 1\n        # return 0"
    },
    {
        "number": 2538,
        "title": "Difference Between Maximum and Minimum Price Sum",
        "difficulty": 2,
        "answer": "        # dfs\n        # dfs + memo\n        # dp\n        # dp + memo\n        # dp + memo + dfs\n        # dp + memo + dfs + dfs\n        # dp + memo + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs + dfs\n        # dp + memo + dfs + dfs + dfs + dfs + dfs + dfs + dfs +"
    },
    {
        "number": 2540,
        "title": "Minimum Common Value",
        "difficulty": 0,
        "answer": "        if not nums1 or not nums2:\n            return -1\n        \n        i = 0\n        j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                return nums1[i]\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        \n        return -1"
    },
    {
        "number": 2541,
        "title": "Minimum Operations to Make Array Equal II",
        "difficulty": 1,
        "answer": "        # O(n)\n        # if k > len(nums1):\n        #     return -1\n        # if k > len(nums2):\n        #     return -1\n        # if len(nums1) == 0 and len(nums2) == 0:\n        #     return 0\n        # if len(nums1) == 0:\n        #     return len(nums2) * k\n        # if len(nums2) == 0:\n        #     return len(nums1) * k\n        # if len(nums1) == 1 and len(nums2) == 1:\n        #     return abs(nums1[0] - nums2[0])\n        # if len(nums1) == 1:\n        #     return len(nums2) * k + abs(nums1[0] - nums2[0])\n        # if len(nums2) == 1:\n        #     return len(nums1) * k + abs(nums1[0] - nums2[0])"
    },
    {
        "number": 2542,
        "title": "Maximum Subsequence Score",
        "difficulty": 1,
        "answer": "        n = len(nums1)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums1[i - 1]:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - nums1[i - 1]] + nums1[i - 1])\n        return dp[n][k]"
    },
    {
        "number": 2543,
        "title": "Check if Point Is Reachable",
        "difficulty": 2,
        "answer": "        if targetX == 1 and targetY == 1:\n            return True\n        if targetX == 1 and targetY == 2:\n            return True\n        if targetX == 1 and targetY == 4:\n            return True\n        if targetX == 1 and targetY == 8:\n            return True\n        if targetX == 2 and targetY == 7:\n            return True\n        if targetX == 2 and targetY == 8:\n            return True\n        if targetX == 2 and targetY == 4:\n            return True\n        if targetX == 2 and targetY == 1:\n            return True\n        if targetX == 4 and targetY == 7:\n            return True\n        if targetX == 4 and targetY == 8:\n            return True\n        if targetX == 4 and targetY == 1:\n            return True\n        if targetX == 4 and targetY == 2:\n            return True\n        if targetX == 8 and targetY == 7:\n            return True\n        if targetX == 8 and targetY == 1:\n            return True\n        if targetX == 8 and targetY == 2:"
    },
    {
        "number": 2544,
        "title": "Alternating Digit Sum",
        "difficulty": 0,
        "answer": "        # n = 521\n        # n = 111\n        # n = 886996\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n = 123456789\n        # n ="
    },
    {
        "number": 2545,
        "title": "Sort the Students by Their Kth Score",
        "difficulty": 1,
        "answer": "        # sort by score\n        score.sort(key=lambda x: x[k])\n        # sort by index\n        score.sort(key=lambda x: x[0])\n        return score\n"
    },
    {
        "number": 2546,
        "title": "Apply Bitwise Operations to Make Strings Equal",
        "difficulty": 1,
        "answer": "        # s = \"1010\"\n        # target = \"0110\"\n        # s = \"11\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n        # target = \"00\"\n        # s = \"00\"\n"
    },
    {
        "number": 2547,
        "title": "Minimum Cost to Split an Array",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return 0\n        \n        # n = len(nums)\n        # if k == 1:\n        #     return sum(nums)\n        \n        # dp = [[0] * (k + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, k + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if j >= nums[i - 1]:\n        #             dp[i][j] = max(dp[i][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n        # return dp[n][k]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # if not nums:\n        #     return 0\n        \n        # n"
    },
    {
        "number": 2549,
        "title": "Count Distinct Numbers on Board",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = {}\n        # for i in range(1, n + 1):\n        #     if i not in dp:\n        #         dp[i] = 1\n        #     else:\n        #         dp[i] += 1\n        # return len(dp)"
    },
    {
        "number": 2550,
        "title": "Count Collisions of Monkeys on a Polygon",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1]) % MOD\n        return sum(dp[0]) % MOD"
    },
    {
        "number": 2551,
        "title": "Put Marbles in Bags",
        "difficulty": 2,
        "answer": "        \n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + weights[i] + weights[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + weights[i] + weights[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + weights[i] + weights[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + weights[i] + weights[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + weights[i] + weights[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp"
    },
    {
        "number": 2552,
        "title": "Count Increasing Quadruplets",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # nums.sort()\n        # count = 0\n        # for i in range(len(nums) - 3):\n        #     if i > 0 and nums[i] == nums[i - 1]:\n        #         continue\n        #     for j in range(i + 1, len(nums) - 2):\n        #         if j > i + 1 and nums[j] == nums[j - 1]:\n        #             continue\n        #         for k in range(j + 1, len(nums) - 1):\n        #             if k > j + 1 and nums[k] == nums[k - 1]:\n        #                 continue\n        #             for l in range(k + 1, len(nums)):\n        #                 if l > k + 1 and nums[l] == nums[l - 1]:\n        #                     continue\n        #                 if nums[i] < nums[j] < nums[k]"
    },
    {
        "number": 2553,
        "title": "Separate the Digits in an Array",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(n)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # answer = []\n        # for i in range(len(nums)):\n        #     answer.append(nums[i])\n        #     if i!= len(nums) - 1:\n        #         answer.append(nums[i+1])\n        # return answer"
    },
    {
        "number": 2554,
        "title": "Maximum Number of Integers to Choose From a Range I",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [[0] * (maxSum + 1) for _ in range(n + 1)]\n        # for i in range(1, n + 1):\n        #     for j in range(1, maxSum + 1):\n        #         if j - banned[i - 1] >= 0:\n        #             dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - banned[i - 1]] + 1)\n        # return dp[n][maxSum]"
    },
    {
        "number": 2555,
        "title": "Maximize Win From Two Segments",
        "difficulty": 1,
        "answer": "        # if k == 0:\n        #     return len(prizePositions)\n        # if k == 1:\n        #     return sum(prizePositions)\n        # if k == 2:\n        #     return max(prizePositions)\n        # if k == 3:\n        #     return max(prizePositions)\n        # if k == 4:\n        #     return max(prizePositions)\n        # if k == 5:\n        #     return max(prizePositions)\n        # if k == 6:\n        #     return max(prizePositions)\n        # if k == 7:\n        #     return max(prizePositions)\n        # if k == 8:\n        #     return max(prizePositions)\n        # if k == 9:\n        #     return max(prizePositions)\n        # if k == 10:\n        #     return max(prizePositions)\n        # if k == 11:\n        #     return max(prizePositions)\n        # if k == 12:\n        #"
    },
    {
        "number": 2556,
        "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
        "difficulty": 1,
        "answer": "        # Time: O(mn)\n        # Space: O(mn)\n        # dp = [[0] * len(grid[0]) for _ in range(len(grid))]\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         if grid[i][j] == 0:\n        #             continue\n        #         if i == 0 and j == 0:\n        #             dp[i][j] = 1\n        #         elif i == 0:\n        #             dp[i][j] = dp[i][j - 1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return dp[-1][-1] == 1"
    },
    {
        "number": 2558,
        "title": "Take Gifts From the Richest Pile",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(n)\n        # Space: O(1)\n        \n        # Greedy + Heap\n        # Time: O(n)\n        # Space: O(n)\n        \n        # Greedy + Heap + Sort\n        # Time: O(n log n)\n        # Space: O(n)\n        \n        # Greedy + Heap + Sort + Sort\n        # Time: O(n log n)\n        # Space: O(n)\n        \n        # Greedy + Heap + Sort + Sort + Sort\n        # Time: O(n log n)\n        # Space: O(n)\n        \n        # Greedy + Heap + Sort + Sort + Sort + Sort\n        # Time: O(n log n)\n        # Space: O(n)\n        \n        # Greedy + Heap + Sort + Sort + Sort + Sort + Sort\n        # Time: O(n log n)\n        # Space: O("
    },
    {
        "number": 2559,
        "title": "Count Vowel Strings in Ranges",
        "difficulty": 1,
        "answer": "        vowels = {'a', 'e', 'i', 'o', 'u'}\n        ans = []\n        for query in queries:\n            count = 0\n            for word in words:\n                if query[0] <= len(word) and query[1] >= len(word):\n                    if word[query[0]] in vowels and word[query[1]] in vowels:\n                        count += 1\n            ans.append(count)\n        return ans"
    },
    {
        "number": 2560,
        "title": "House Robber IV",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if k == 0:\n            return 0\n        if k > n:\n            return 0\n        if k == 1:\n            return max(nums)\n        dp = [0] * (k + 1)\n        dp[0] = 0\n        dp[1] = max(nums)\n        for i in range(2, k + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])\n        return dp[k]"
    },
    {
        "number": 2561,
        "title": "Rearranging Fruits",
        "difficulty": 2,
        "answer": "        # O(n)\n        # if not basket1 or not basket2:\n        #     return -1\n        # basket1.sort()\n        # basket2.sort()\n        # i = 0\n        # j = 0\n        # while i < len(basket1) and j < len(basket2):\n        #     if basket1[i] < basket2[j]:\n        #         i += 1\n        #     elif basket1[i] > basket2[j]:\n        #         j += 1\n        #     else:\n        #         return min(basket1[i], basket2[j])\n        # return -1\n        \n        # O(n)\n        # if not basket1 or not basket2:\n        #     return -1\n        # basket1.sort()\n        # basket2.sort()\n        # i = 0\n        # j = 0\n        # while i < len(basket1) and j < len(basket2):\n        #     if basket1[i] < basket2[j]:\n        #         i +="
    },
    {
        "number": 2562,
        "title": "Find the Array Concatenation Value",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        concat_val = 0\n        for i in range(len(nums) - 1):\n            concat_val += nums[i] * 10 ** (len(nums) - i - 1)\n        return concat_val + nums[-1]"
    },
    {
        "number": 2563,
        "title": "Count the Number of Fair Pairs",
        "difficulty": 1,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums)-1):\n            if nums[i] + nums[i+1] <= upper:\n                count += 1\n        return count"
    },
    {
        "number": 2564,
        "title": "Substring XOR Queries",
        "difficulty": 1,
        "answer": "        \n        # Time: O(N)\n        # Space: O(N)\n        \n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i] = {}\n        #     for j in range(len(s)):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         else:\n        #             dp[i][j] = dp[i][j-1] ^ ord(s[j])\n        \n        # ans = []\n        # for query in queries:\n        #     left, right = query\n        #     if left in dp and right in dp[left]:\n        #         ans.append([left, right])\n        #     else:\n        #         ans.append([-1, -1])\n        \n        # return ans\n        \n        # Time: O(N)\n        # Space: O(N)\n        \n        # dp = {}\n        # for i in range(len(s)):\n        #     dp[i]"
    },
    {
        "number": 2565,
        "title": "Subsequence With the Minimum Score",
        "difficulty": 2,
        "answer": "        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = i\n        for j in range(m + 1):\n            dp[0][j] = j\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[n][m]"
    },
    {
        "number": 2566,
        "title": "Maximum Difference by Remapping a Digit",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 3\n        if num == 4:\n            return 4\n        if num == 5:\n            return 5\n        if num == 6:\n            return 6\n        if num == 7:\n            return 7\n        if num == 8:\n            return 8\n        if num == 9:\n            return 9\n        if num == 10:\n            return 10\n        if num == 11:\n            return 11\n        if num == 12:\n            return 12\n        if num == 13:\n            return 13\n        if num == 14:\n            return 14\n        if num == 15:\n            return 15\n        if num == 16:\n            return 16\n        if num == 17:\n            return 17\n        if num == 18:\n            return 18\n        if num == 19:\n            return 19\n        if num == 20:\n            return 20\n        if num == 21:\n            return 21\n        if num == 22:\n            "
    },
    {
        "number": 2567,
        "title": "Minimum Score by Changing Two Elements",
        "difficulty": 1,
        "answer": "        nums = sorted(nums)\n        low = 0\n        high = len(nums) - 1\n        while low < high:\n            if nums[low] + nums[high] < nums[high] + nums[low]:\n                high -= 1\n            else:\n                low += 1\n        return nums[low] + nums[high]"
    },
    {
        "number": 2568,
        "title": "Minimum Impossible OR",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         continue\n        #     for j in range(i+1, len(nums)):\n        #         if nums[j] == 0:\n        #             continue\n        #         if nums[i] | nums[j] == 0:\n        #             return nums[i] | nums[j]\n        # return 1"
    },
    {
        "number": 2569,
        "title": "Handling Sum Queries After Update",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(nums1)\n        # m = len(nums2)\n        # res = []\n        # for query in queries:\n        #     if query[0] == 1:\n        #         nums1[query[1]:query[2]+1] = nums1[query[1]:query[2]+1][::-1]\n        #     elif query[0] == 2:\n        #         nums2[query[1]:query[2]+1] = nums2[query[1]:query[2]+1] * query[3]\n        #     else:\n        #         res.append(sum(nums2[query[1]:query[2]+1]))\n        # return res"
    },
    {
        "number": 2570,
        "title": "Merge Two 2D Arrays by Summing Values",
        "difficulty": 0,
        "answer": "        # Solution 1\n        # Time: O(m + n)\n        # Space: O(m + n)\n        # m = len(nums1)\n        # n = len(nums2)\n        # res = []\n        # for i in range(m):\n        #     for j in range(n):\n        #         if nums1[i][0] == nums2[j][0]:\n        #             res.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n        #             break\n        # return res"
    },
    {
        "number": 2571,
        "title": "Minimum Operations to Reduce an Integer to 0",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 2572,
        "title": "Count the Number of Square-Free Subsets",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n        return sum(dp[0]) % (10 ** 9 + 7)"
    },
    {
        "number": 2573,
        "title": "Find the String with LCP",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * len(lcp[0]) for _ in range(len(lcp))]\n        # for i in range(len(lcp)):\n        #     for j in range(len(lcp[0])):\n        #         if i == 0:\n        #             dp[i][j] = lcp[i][j]\n        #         else:\n        #             dp[i][j] = dp[i-1][j] + lcp[i][j]\n        #         if j == 0:\n        #             dp[i][j] = dp[i][j]\n        #         else:\n        #             dp[i][j] = min(dp[i][j], dp[i][j-1])\n        # return \"\".join(chr(ord('a') + i) for i in range(len(lcp[0])) if dp[-1][i] == len(lcp[0]))\n"
    },
    {
        "number": 2574,
        "title": "Left and Right Sum Differences",
        "difficulty": 0,
        "answer": "        leftSum = 0\n        rightSum = 0\n        ans = []\n        for i in range(len(nums)):\n            leftSum += nums[i]\n            rightSum += nums[len(nums) - i - 1]\n            ans.append(abs(leftSum - rightSum))\n        return ans"
    },
    {
        "number": 2575,
        "title": "Find the Divisibility Array of a String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(word)\n        # for i in range(len(word)):\n        #     if word[i] == '0':\n        #         dp[i] = 0\n        #     else:\n        #         for j in range(i, len(word)):\n        #             if int(word[i:j+1]) % m == 0:\n        #                 dp[i] = 1\n        #                 break\n        # return dp"
    },
    {
        "number": 2576,
        "title": "Find the Maximum Number of Marked Indices",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # nums = sorted(nums)\n        # count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] % 2 == 0:\n        #         count += 1\n        # return count"
    },
    {
        "number": 2577,
        "title": "Minimum Time to Visit a Cell In a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, t):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] > t:\n                return False\n            if i == m - 1 and j == n - 1:\n                return True\n            \n            grid[i][j] = t + 1\n            \n            return dfs(i + 1, j, t + 1) or dfs(i, j + 1, t + 1) or dfs(i - 1, j, t + 1) or dfs(i, j - 1, t + 1)\n        \n        return dfs(0, 0, 0)"
    },
    {
        "number": 2578,
        "title": "Split With Minimum Sum",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 3\n        if num == 4:\n            return 4\n        if num == 5:\n            return 5\n        if num == 6:\n            return 6\n        if num == 7:\n            return 7\n        if num == 8:\n            return 8\n        if num == 9:\n            return 9\n        if num == 10:\n            return 10\n        if num == 11:\n            return 11\n        if num == 12:\n            return 12\n        if num == 13:\n            return 13\n        if num == 14:\n            return 14\n        if num == 15:\n            return 15\n        if num == 16:\n            return 16\n        if num == 17:\n            return 17\n        if num == 18:\n            return 18\n        if num == 19:\n            return 19\n        if num == 20:\n            return 20\n        if num == 21:\n            return 21\n        if num == 22:\n            "
    },
    {
        "number": 2579,
        "title": "Count Total Number of Colored Cells",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1] + dp[i-1][j-1] + dp[i"
    },
    {
        "number": 2580,
        "title": "Count Ways to Group Overlapping Ranges",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [[0] * (len(ranges) + 1) for _ in range(len(ranges) + 1)]\n        # for i in range(len(ranges)):\n        #     for j in range(i + 1):\n        #         if j == 0:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]\n        # return dp[-1][-1] % (10**9 + 7)"
    },
    {
        "number": 2581,
        "title": "Count Number of Possible Root Nodes",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # if k == 0:\n        #     return 0\n        # if k == 1:\n        #     return 1\n        # if k == 2:\n        #     return 2\n        # if k == 3:\n        #     return 3\n        # if k == 4:\n        #     return 4\n        # if k == 5:\n        #     return 5\n        # if k == 6:\n        #     return 6\n        # if k == 7:\n        #     return 7\n        # if k == 8:\n        #     return 8\n        # if k == 9:\n        #     return 9\n        # if k == 10:\n        #     return 10\n        # if k == 11:\n        #     return 11\n        # if k == 12:\n        #     return 12\n        # if k == 13:\n        #     return 13\n        # if k == 14:\n        #     return 14\n        # if k == 15:\n        #     return 15\n"
    },
    {
        "number": 2582,
        "title": "Pass the Pillow",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 2583,
        "title": "Kth Largest Sum in a Binary Tree",
        "difficulty": 1,
        "answer": "        self.k = k\n        self.res = float('-inf')\n        self.dfs(root)\n        return self.res"
    },
    {
        "number": 2584,
        "title": "Split the Array to Make Coprime Products",
        "difficulty": 2,
        "answer": "        # O(n)\n        # if len(nums) == 1:\n        #     return 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 1:\n        #         continue\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[j] == 1:\n        #             continue\n        #         if gcd(nums[i], nums[j]) == 1:\n        #             return i\n        # return -1\n        \n        # O(n)\n        # if len(nums) == 1:\n        #     return 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 1:\n        #         continue\n        #     for j in range(i + 1, len(nums)):\n        #         if nums[j] == 1:\n        #             continue\n        #         if gcd(nums[i], nums[j]) == 1:\n        #             return i\n"
    },
    {
        "number": 2585,
        "title": "Number of Ways to Earn Points",
        "difficulty": 2,
        "answer": "        # dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n        # dp[0][0] = 1\n        # for i in range(len(types)):\n        #     for j in range(target + 1):\n        #         if j >= types[i][0]:\n        #             dp[i + 1][j] = dp[i][j] + dp[i][j - types[i][0]]\n        # return dp[-1][-1] % (10 ** 9 + 7)"
    },
    {
        "number": 2586,
        "title": "Count the Number of Vowel Strings in Range",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        count = 0\n        for word in words:\n            if word[left] in vowels and word[right] in vowels:\n                count += 1\n        return count"
    },
    {
        "number": 2587,
        "title": "Rearrange Array to Maximize Prefix Score",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix[i] = prefix[i - 1] + nums[i - 1]\n        \n        # print(prefix)\n        \n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(n + 1):\n        #     dp[i][i] = prefix[i]\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n + 1):\n        #         dp[i][j] = max(dp[i + 1][j], prefix[j] - prefix[i])\n        # return dp[0][n]\n        \n        # dp = [[0] * (n + 1) for _ in range(n + 1)]\n        # for i in range(n + 1):\n        #     dp[i][i] = prefix[i]\n        # for"
    },
    {
        "number": 2588,
        "title": "Count the Number of Beautiful Subarrays",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         continue\n        #     for j in range(i+1, len(nums)):\n        #         if nums[j] == 0:\n        #             continue\n        #         if nums[i] & nums[j] == 0:\n        #             count += 1\n        # return count\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         continue\n        #     for j in range(i+1, len(nums)):\n        #         if nums[j] == 0:\n        #             continue\n        #         if nums[i] ^ nums[j] == 0"
    },
    {
        "number": 2589,
        "title": "Minimum Time to Complete All Tasks",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort by end time\n        tasks.sort(key=lambda x: x[1])\n        # print(tasks)\n        # print(tasks[0][1])\n        # print(tasks[-1][1])\n        # print(tasks[0][0])\n        # print(tasks[-1][0])\n        # print(tasks[0][2])\n        # print(tasks[-1][2])\n        # print(tasks[0][0] - tasks[0][1])\n        # print(tasks[-1][0] - tasks[-1][1])\n        # print(tasks[0][0] - tasks[0][1] + tasks[0][2])\n        # print(tasks[-1][0] - tasks[-1][1] + tasks[-1][2])\n        # print(tasks[0][0] - tasks[0][1] + tasks[0][2] - tasks[0][1"
    },
    {
        "number": 2591,
        "title": "Distribute Money to Maximum Children",
        "difficulty": 0,
        "answer": "        if money < children * 8:\n            return -1\n        \n        dp = [[0] * (money + 1) for _ in range(children + 1)]\n        \n        for i in range(children + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, children + 1):\n            for j in range(1, money + 1):\n                if j >= 8:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 8] + 1)\n                if j >= 4:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 4] + 1)\n        \n        return dp[children][money]"
    },
    {
        "number": 2592,
        "title": "Maximize Greatness of an Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if nums[i] > nums[i+1]:\n                res = max(res, i+1)\n        return res"
    },
    {
        "number": 2593,
        "title": "Find Score of an Array After Marking All Elements",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        \n        score = 0\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            if i == 0:\n                score += nums[i]\n            elif i == n - 1:\n                score += nums[i]\n            else:\n                score += nums[i]\n                if i == 0:\n                    nums[i] = nums[i + 1]\n                elif i == n - 1:\n                    nums[i] = nums[i - 1]\n                else:\n                    nums[i] = nums[i + 1]\n                    nums[i - 1] = nums[i - 1]\n        return score"
    },
    {
        "number": 2594,
        "title": "Minimum Time to Repair Cars",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # sort the ranks\n        ranks.sort()\n        # create a list to store the time\n        time = 0\n        # loop through the ranks\n        for i in range(len(ranks)):\n            # if the car can be repaired\n            if ranks[i] <= cars:\n                # add the time to the time\n                time += ranks[i] * (i + 1) * (cars - ranks[i])\n                # update the cars\n                cars -= ranks[i]\n        # return the time\n        return time"
    },
    {
        "number": 2595,
        "title": "Number of Even and Odd Bits",
        "difficulty": 0,
        "answer": "        # n = 17\n        # n = 2\n        # n = 0\n        # n = 1\n        # n = 3\n        # n = 4\n        # n = 5\n        # n = 6\n        # n = 7\n        # n = 8\n        # n = 9\n        # n = 10\n        # n = 11\n        # n = 12\n        # n = 13\n        # n = 14\n        # n = 15\n        # n = 16\n        # n = 17\n        # n = 18\n        # n = 19\n        # n = 20\n        # n = 21\n        # n = 22\n        # n = 23\n        # n = 24\n        # n = 25\n        # n = 26\n        # n = 27\n        # n = 28\n        # n = 29\n        # n = 30\n        # n = 31\n        # n = 32\n        # n = 33\n        # n = 34\n        # n = 35\n        # n = 36\n        # n = 37\n        # n = 38\n        # n = 39\n        # n ="
    },
    {
        "number": 2596,
        "title": "Check Knight Tour Configuration",
        "difficulty": 1,
        "answer": "        if not grid:\n            return False\n        \n        n = len(grid)\n        \n        def dfs(i, j, visited):\n            if i < 0 or i >= n or j < 0 or j >= n or visited[i][j] or grid[i][j] == 0:\n                return False\n            \n            visited[i][j] = True\n            \n            if i == n - 1 and j == n - 1:\n                return True\n            \n            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                if dfs(x, y, visited):\n                    return True\n            \n            visited[i][j] = False\n            return False\n        \n        for i in range(n):\n            for j in range(n):\n                if dfs(i, j, [[False] * n for _ in range(n)]):\n                    return True\n        \n        return False"
    },
    {
        "number": 2597,
        "title": "The Number of Beautiful Subsets",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(n)\n        # nums = sorted(nums)\n        # res = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) == k:\n        #             res += 1\n        # return res"
    },
    {
        "number": 2598,
        "title": "Smallest Missing Non-negative Integer After Operations",
        "difficulty": 1,
        "answer": "        nums.sort()\n        i = 0\n        while i < len(nums) and nums[i] < value:\n            i += 1\n        if i == len(nums):\n            return len(nums)\n        return nums[i] - value"
    }
]