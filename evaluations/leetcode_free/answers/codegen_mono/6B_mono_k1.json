[
    {
        "number": 1,
        "title": "Two Sum",
        "difficulty": 0,
        "answer": "        # Time: O(n^2)\n        # Space: O(1)\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"
    },
    {
        "number": 2,
        "title": "Add Two Numbers",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # ans = ListNode(0)\n        # curr = ans\n        # carry = 0\n        # while l1 or l2:\n        #     x = l1.val if l1 else 0\n        #     y = l2.val if l2 else 0\n        #     sum = x + y + carry\n        #     carry = sum // 10\n        #     curr.next = ListNode(sum % 10)\n        #     curr = curr.next\n        #     if l1:\n        #         l1 = l1.next\n        #     if l2:\n        #         l2 = l2.next\n        # if carry:\n        #     curr.next = ListNode(carry)\n        # return ans.next"
    },
    {
        "number": 3,
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": 1,
        "answer": "        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \u6ed1\u52a8\u7a97\u53e3\n        # \u53cc\u6307\u9488\n        # \u5b57\u5178\n        # \u54c8\u5e0c\n        # \ufffd"
    },
    {
        "number": 4,
        "title": "Median of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        if n == 0:\n            raise ValueError"
    },
    {
        "number": 5,
        "title": "Longest Palindromic Substring",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if len(s) == 1:\n            return s\n        max_len = 1\n        res = s[0]\n        for i in range(len(s)):\n            # odd case, like \"aba\"\n            tmp = self.helper(s, i, i)\n            if len(tmp) > max_len:\n                max_len = len(tmp)\n                res = tmp\n            # even case, like \"abba\"\n            tmp = self.helper(s, i, i + 1)\n            if len(tmp) > max_len:\n                max_len = len(tmp)\n                res = tmp\n        return res"
    },
    {
        "number": 6,
        "title": "Zigzag Conversion",
        "difficulty": 1,
        "answer": "        if numRows == 1:\n            return s\n        rows = [[] for _ in range(numRows)]\n        row = 0\n        going_down = False\n        for c in s:\n            rows[row].append(c)\n            if row == 0 or row == numRows - 1:\n                going_down = not going_down\n            row += 1 if going_down else -1\n        return ''.join(''.join(row) for row in rows)"
    },
    {
        "number": 7,
        "title": "Reverse Integer",
        "difficulty": 1,
        "answer": "        # if x < 0:\n        #     x = -x\n        #     x = str(x)\n        #     x = x[::-1]\n        #     x = int(x)\n        #     if x < -2**31 or x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         return -x\n        # else:\n        #     x = str(x)\n        #     x = x[::-1]\n        #     x = int(x)\n        #     if x < -2**31 or x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         return x"
    },
    {
        "number": 8,
        "title": "String to Integer (atoi)",
        "difficulty": 1,
        "answer": "        s = s.lstrip()\n        if not s:\n            return 0\n        sign = -1 if s[0] == '-' else 1\n        if s[0] in '+-':\n            s = s[1:]\n        res, i = 0, 0\n        while i < len(s) and s[i].isdigit():\n            res = res * 10 + ord(s[i]) - ord('0')\n            i += 1\n        return max(-2 ** 31, min(sign * res, 2 ** 31 - 1))"
    },
    {
        "number": 9,
        "title": "Palindrome Number",
        "difficulty": 0,
        "answer": "        if x < 0:\n            return False\n        elif x < 10:\n            return True\n        else:\n            x_str = str(x)\n            x_str_rev = x_str[::-1]\n            if x_str == x_str_rev:\n                return True\n            else:\n                return False"
    },
    {
        "number": 10,
        "title": "Regular Expression Matching",
        "difficulty": 2,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 11,
        "title": "Container With Most Water",
        "difficulty": 1,
        "answer": "        left, right = 0, len(height) - 1\n        max_area = 0\n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"
    },
    {
        "number": 12,
        "title": "Integer to Roman",
        "difficulty": 1,
        "answer": "        # Roman numerals are usually written largest to smallest from left to right.\n        # However, the numeral for four is not IIII. Instead, the number four is written as IV.\n        # Because the one is before the five we subtract it making four.\n        # The same principle applies to the number nine, which is written as IX.\n        # There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        # Given an integer, convert it to a roman numeral.\n        # Example 1:\n        # Input: num = 3\n        # Output: \"III\"\n        # Example 2:\n        # Input: num = 58\n        # Output: \"LVIII\"\n        # Explanation: L = 50, V = 5, III = 3.\n        # Example 3:\n        # Input: num = 1994"
    },
    {
        "number": 13,
        "title": "Roman to Integer",
        "difficulty": 0,
        "answer": "        # Roman numerals are usually written largest to smallest from left to right.\n        # However, the numeral for four is not IIII. Instead, the number four is written as IV.\n        # Because the one is before the five we subtract it making four.\n        # The same principle applies to the number nine, which is written as IX.\n        # There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        # Given a roman numeral, convert it to an integer.\n        # Example 1:\n        # Input: s = \"III\"\n        # Output: 3\n        # Example 2:\n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Example 3:\n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Constraints:"
    },
    {
        "number": 14,
        "title": "Longest Common Prefix",
        "difficulty": 0,
        "answer": "        # if len(strs) == 0:\n        #     return \"\"\n        # if len(strs) == 1:\n        #     return strs[0]\n        # if len(strs) == 2:\n        #     if strs[0] == strs[1]:\n        #         return strs[0]\n        #     else:\n        #         return \"\"\n        # if len(strs) == 3:\n        #     if strs[0] == strs[1] and strs[0] == strs[2]:\n        #         return strs[0]\n        #     elif strs[0] == strs[1] and strs[0]!= strs[2]:\n        #         return strs[0]\n        #     elif strs[0]!= strs[1] and strs[0] == strs[2]:\n        #         return strs[0]\n        #     elif strs[0]!= strs[1] and strs[0]!= strs[2]:\n        #         "
    },
    {
        "number": 15,
        "title": "3Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # nums.sort()\n        # result = []\n        # for i in range(len(nums)):\n        #     if i > 0 and nums[i] == nums[i-1]:\n        #         continue\n        #     left = i + 1\n        #     right = len(nums) - 1\n        #     while left < right:\n        #         sum = nums[i] + nums[left] + nums[right]\n        #         if sum == 0:\n        #             result.append([nums[i], nums[left], nums[right]])\n        #             left += 1\n        #             right -= 1\n        #             while left < right and nums[left] == nums[left-1]:\n        #                 left += 1\n        #             while left < right and nums[right] == nums[right+1]:\n        #                 right -= 1\n        #         elif sum < 0:\n        #             left += 1"
    },
    {
        "number": 16,
        "title": "3Sum Closest",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == target:\n                    return s\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s < target:\n                    j += 1\n                elif s > target:\n                    k -= 1\n        return res"
    },
    {
        "number": 17,
        "title": "Letter Combinations of a Phone Number",
        "difficulty": 1,
        "answer": "        if not digits:\n            return []\n        \n        phone = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r','s'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map \n                # the next available digit\n                for letter in phone[next_digits[0]]:\n                    #"
    },
    {
        "number": 18,
        "title": "4Sum",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left = j + 1\n                right = n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n"
    },
    {
        "number": 19,
        "title": "Remove Nth Node From End of List",
        "difficulty": 1,
        "answer": "        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        # find the node to be removed\n        if n == length:\n            return head.next\n        curr = head\n        for _ in range(length - n - 1):\n            curr = curr.next\n        curr.next = curr.next.next\n        return head"
    },
    {
        "number": 20,
        "title": "Valid Parentheses",
        "difficulty": 0,
        "answer": "        # stack = []\n        # for i in s:\n        #     if i in ['(', '{', '[']:\n        #         stack.append(i)\n        #     else:\n        #         if len(stack) == 0:\n        #             return False\n        #         if i == ')' and stack[-1] == '(':\n        #             stack.pop()\n        #         elif i == '}' and stack[-1] == '{':\n        #             stack.pop()\n        #         elif i == ']' and stack[-1] == '[':\n        #             stack.pop()\n        #         else:\n        #             return False\n        # if len(stack) == 0:\n        #     return True\n        # return False"
    },
    {
        "number": 21,
        "title": "Merge Two Sorted Lists",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time complexity: O(n+m)\n        # Space complexity: O(1)\n        # if not list1:\n        #     return list2\n        # if not list2:\n        #     return list1\n        # if list1.val < list2.val:\n        #     list1.next = self.mergeTwoLists(list1.next, list2)\n        #     return list1\n        # else:\n        #     list2.next = self.mergeTwoLists(list1, list2.next)\n        #     return list2"
    },
    {
        "number": 22,
        "title": "Generate Parentheses",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - 1 - i):\n                    res.append(\"({}){}\".format(left, right))\n        return res"
    },
    {
        "number": 23,
        "title": "Merge k Sorted Lists",
        "difficulty": 2,
        "answer": "        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        return self.merge(left, right)"
    },
    {
        "number": 24,
        "title": "Swap Nodes in Pairs",
        "difficulty": 1,
        "answer": "        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            prev.next = curr.next\n            curr.next = curr.next.next\n            prev.next.next = curr\n            \n            prev = curr\n            curr = curr.next\n        \n        return dummy.next\n"
    },
    {
        "number": 25,
        "title": "Reverse Nodes in k-Group",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        if not head:\n            return None\n        \n        curr = head\n        count = 0\n        while curr and count < k:\n            curr = curr.next\n            count += 1\n        if count == k:\n            curr = self.reverseKGroup(curr, k)\n            while count:\n                tmp = head.next\n                head.next = curr\n                curr = head\n                head = tmp\n                count -= 1\n            head = curr\n        return head"
    },
    {
        "number": 26,
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": 0,
        "answer": "        if len(nums) == 0:\n            return 0\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j]!= nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"
    },
    {
        "number": 27,
        "title": "Remove Element",
        "difficulty": 0,
        "answer": "        i = 0\n        for j in range(len(nums)):\n            if nums[j]!= val:\n                nums[i] = nums[j]\n                i += 1\n        return i"
    },
    {
        "number": 28,
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": 0,
        "answer": "        if not needle:\n            return 0\n        if not haystack:\n            return -1\n        if len(needle) > len(haystack):\n            return -1\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
    },
    {
        "number": 29,
        "title": "Divide Two Integers",
        "difficulty": 1,
        "answer": "        if dividend == 0:\n            return 0\n        if divisor == 0:\n            return None\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        if dividend == 0 and divisor == 1:\n            return 0\n        if dividend == 0 and divisor == -1:\n            return 0\n        if dividend == 0 and divisor == 0:\n            return 0\n        if dividend == 0 and divisor == 1:\n            return 0\n        if dividend == 0 and divisor == -1:\n            return 0\n        if dividend == 0 and divisor == 0:\n            return 0\n        if dividend == 0 and divisor == 1:\n            return 0"
    },
    {
        "number": 30,
        "title": "Substring with Concatenation of All Words",
        "difficulty": 2,
        "answer": "        if not s or not words:\n            return []\n        n, m = len(s), len(words)\n        if m > n:\n            return []\n        words_dict = {}\n        for word in words:\n            if word not in words_dict:\n                words_dict[word] = 1\n            else:\n                words_dict[word] += 1\n        ans = []\n        for i in range(n - m * m + 1):\n            words_dict_copy = words_dict.copy()\n            for j in range(m):\n                word = s[i + j * m:i + j * m + m]\n                if word not in words_dict_copy:\n                    break\n                else:\n                    words_dict_copy[word] -= 1\n                    if words_dict_copy[word] < 0:\n                        break\n            else:\n                ans.append(i)\n        return ans"
    },
    {
        "number": 31,
        "title": "Next Permutation",
        "difficulty": 1,
        "answer": "        if len(nums) <= 1:\n            return nums\n        for i in range(len(nums)-1, 0, -1):\n            if nums[i] > nums[i-1]:\n                break\n        if i == 1 and nums[i] <= nums[i-1]:\n            nums.reverse()\n            return nums\n        for j in range(len(nums)-1, i-1, -1):\n            if nums[j] > nums[i-1]:\n                break\n        nums[i-1], nums[j] = nums[j], nums[i-1]\n        nums[i:] = sorted(nums[i:])\n        return nums"
    },
    {
        "number": 32,
        "title": "Longest Valid Parentheses",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        dp = [0] * len(s)\n        for i in range(1, len(s)):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2 if i >= 2 else 2\n                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':\n                    dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2] if i - dp[i - 1] >= 2 else dp[i - 1] + 2\n        return max(dp)"
    },
    {
        "number": 33,
        "title": "Search in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        # binary search\n        # time complexity: O(log n)\n        # space complexity: O(1)\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1"
    },
    {
        "number": 34,
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": 1,
        "answer": "        if not nums:\n            return [-1, -1]\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                left = mid\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if left > len(nums) - 1 or nums[left]!= target:\n            return [-1, -1]\n        right = len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                right = mid\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return [left, right]"
    },
    {
        "number": 35,
        "title": "Search Insert Position",
        "difficulty": 0,
        "answer": "        # binary search\n        # time complexity: O(log n)\n        # space complexity: O(1)\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"
    },
    {
        "number": 36,
        "title": "Valid Sudoku",
        "difficulty": 1,
        "answer": "        rows = [{} for _ in range(9)]\n        cols = [{} for _ in range(9)]\n        boxes = [{} for _ in range(9)]\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num!= '.':\n                    num = int(num)\n                    box_index = (i // 3) * 3 + j // 3\n                    rows[i][num] = rows[i].get(num, 0) + 1\n                    cols[j][num] = cols[j].get(num, 0) + 1\n                    boxes[box_index][num] = boxes[box_index].get(num, 0) + 1\n                    if rows[i][num] > 1 or cols[j][num] > 1 or boxes[box_index][num] > 1:\n                        return False\n        return True"
    },
    {
        "number": 37,
        "title": "Sudoku Solver",
        "difficulty": 2,
        "answer": "        self.board = board\n        self.solve()"
    },
    {
        "number": 38,
        "title": "Count and Say",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"1\"\n        else:\n            prev = self.countAndSay(n-1)\n            res = \"\"\n            count = 1\n            for i in range(len(prev)-1):\n                if prev[i] == prev[i+1]:\n                    count += 1\n                else:\n                    res += str(count) + prev[i]\n                    count = 1\n            res += str(count) + prev[-1]\n            return res"
    },
    {
        "number": 39,
        "title": "Combination Sum",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.candidates = candidates\n        self.target = target\n        self.dfs(0, [], 0)\n        return self.res"
    },
    {
        "number": 40,
        "title": "Combination Sum II",
        "difficulty": 1,
        "answer": "        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res"
    },
    {
        "number": 41,
        "title": "First Missing Positive",
        "difficulty": 2,
        "answer": "        nums.sort()\n        if nums[0] > 1:\n            return 1\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i - 1] > 1:\n                return nums[i - 1] + 1\n        return nums[-1] + 1"
    },
    {
        "number": 42,
        "title": "Trapping Rain Water",
        "difficulty": 2,
        "answer": "        # Approach 1: Two Pointers\n        # Time O(n)\n        # Space O(1)\n        # left, right = 0, len(height) - 1\n        # left_max, right_max = 0, 0\n        # res = 0\n        # while left < right:\n        #     left_max = max(left_max, height[left])\n        #     right_max = max(right_max, height[right])\n        #     if left_max <= right_max:\n        #         res += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         res += right_max - height[right]\n        #         right -= 1\n        # return res"
    },
    {
        "number": 43,
        "title": "Multiply Strings",
        "difficulty": 1,
        "answer": "        if num1 == '0' or num2 == '0':\n            return '0'\n        if len(num1) == 1 and len(num2) == 1:\n            return str(int(num1) * int(num2))\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = [0] * (len(num1) + len(num2))\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i + j] += int(num1[i]) * int(num2[j])\n                res[i + j + 1] += res[i + j] // 10\n                res[i + j] %= 10\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        res = res[::-1]\n        return ''.join(map("
    },
    {
        "number": 44,
        "title": "Wildcard Matching",
        "difficulty": 2,
        "answer": "        if not p:\n            return not s"
    },
    {
        "number": 45,
        "title": "Jump Game II",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return 0\n        if len(nums) == 2:\n            return 1\n        if len(nums) == 3:\n            return 2\n        if len(nums) == 4:\n            return 2\n        if len(nums) == 5:\n            return 2\n        if len(nums) == 6:\n            return 2\n        if len(nums) == 7:\n            return 2\n        if len(nums) == 8:\n            return 2\n        if len(nums) == 9:\n            return 2\n        if len(nums) == 10:\n            return 2\n        if len(nums) == 11:\n            return 2\n        if len(nums) == 12:\n            return 2\n        if len(nums) == 13:\n            return 2\n        if len(nums) == 14:\n            return 2\n        if len(nums) == 15:\n            return 2\n        if len(nums) == 16:\n            return 2\n        if len(nums) == 17:"
    },
    {
        "number": 46,
        "title": "Permutations",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return [nums]\n        elif len(nums) == 2:\n            return [nums, nums[::-1]]\n        else:\n            result = []\n            for i in range(len(nums)):\n                for j in self.permute(nums[:i] + nums[i+1:]):\n                    result.append([nums[i]] + j)\n            return result"
    },
    {
        "number": 47,
        "title": "Permutations II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        nums.sort()\n        self.res = []\n        self.dfs(nums, [])\n        return self.res"
    },
    {
        "number": 48,
        "title": "Rotate Image",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                matrix[i][j], matrix[j][n - i - 1], matrix[n - i - 1][n - j - 1], matrix[n - j - 1][i] = \\\n                    matrix[n - j - 1][i], matrix[i][j], matrix[j][n - i - 1], matrix[n - i - 1][n - j - 1]"
    },
    {
        "number": 49,
        "title": "Group Anagrams",
        "difficulty": 1,
        "answer": "        # Time complexity: O(nklogk)\n        # Space complexity: O(nk)\n        # n = len(strs)\n        # if n == 0:\n        #     return []\n        # d = {}\n        # for s in strs:\n        #     key = tuple(sorted(s))\n        #     if key in d:\n        #         d[key].append(s)\n        #     else:\n        #         d[key] = [s]\n        # return list(d.values())"
    },
    {
        "number": 50,
        "title": "Pow(x, n)",
        "difficulty": 1,
        "answer": "        if x == 0:\n            return 0\n        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n        if n % 2 == 0:\n            return self.myPow(x * x, n // 2)\n        else:\n            return x * self.myPow(x, n - 1)"
    },
    {
        "number": 51,
        "title": "N-Queens",
        "difficulty": 2,
        "answer": "        self.res = []\n        self.n = n\n        self.cols = set()\n        self.pie = set()\n        self.na = set()\n        self.dfs(0, [])\n        return self.res"
    },
    {
        "number": 52,
        "title": "N-Queens II",
        "difficulty": 2,
        "answer": "        self.res = 0\n        self.dfs(n, 0, 0, 0, 0)\n        return self.res"
    },
    {
        "number": 53,
        "title": "Maximum Subarray",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return nums[0]\n        max_sum = nums[0]\n        curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"
    },
    {
        "number": 54,
        "title": "Spiral Matrix",
        "difficulty": 1,
        "answer": "        if not matrix: return []\n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            for i in range(top + 1, bottom + 1):\n                res.append(matrix[i][right])\n            if left < right and top < bottom:\n                for i in range(right - 1, left, -1):\n                    res.append(matrix[bottom][i])\n                for i in range(bottom, top, -1):\n                    res.append(matrix[i][left])\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n        return res"
    },
    {
        "number": 55,
        "title": "Jump Game",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return True\n        if nums[0] == 0:\n            return False\n        dp = [False] * n\n        dp[0] = True\n        for i in range(1, n):\n            for j in range(i):\n                if dp[j] and j + nums[j] >= i:\n                    dp[i] = True\n                    break\n        return dp[-1]"
    },
    {
        "number": 56,
        "title": "Merge Intervals",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res\n"
    },
    {
        "number": 57,
        "title": "Insert Interval",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        intervals.append(newInterval)\n        intervals.sort()\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res"
    },
    {
        "number": 58,
        "title": "Length of Last Word",
        "difficulty": 0,
        "answer": "        s = s.strip()\n        if not s:\n            return 0\n        return len(s.split()[-1])"
    },
    {
        "number": 59,
        "title": "Spiral Matrix II",
        "difficulty": 1,
        "answer": "        res = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            for i in range(top + 1, bottom):\n                res[i][right] = num\n                num += 1\n            if left < right and top < bottom:\n                for i in range(right - 1, left, -1):\n                    res[bottom][i] = num\n                    num += 1\n                for i in range(bottom, top, -1):\n                    res[i][left] = num\n                    num += 1\n            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1\n        return res"
    },
    {
        "number": 60,
        "title": "Permutation Sequence",
        "difficulty": 2,
        "answer": "        nums = [str(i) for i in range(1, n + 1)]\n        res = []\n        k -= 1\n        while n > 0:\n            n -= 1\n            index, k = divmod(k, math.factorial(n))\n            res.append(nums.pop(index))\n        return ''.join(res)"
    },
    {
        "number": 61,
        "title": "Rotate List",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        # find the length of the list\n        curr = head\n        length = 1\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        # find the tail\n        curr = head\n        for _ in range(length - k % length - 1):\n            curr = curr.next\n        \n        # find the new head\n        new_head = curr.next\n        curr.next = None\n        \n        # find the new tail\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        # connect the new head and the new tail\n        curr.next = head\n        \n        return new_head\n"
    },
    {
        "number": 62,
        "title": "Unique Paths",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] ="
    },
    {
        "number": 63,
        "title": "Unique Paths II",
        "difficulty": 1,
        "answer": "        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 - obstacleGrid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] * (1 - obstacleGrid[i][0])\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] * (1 - obstacleGrid[0][j])\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) * (1 - obstacleGrid[i][j])\n        return dp[-1][-1]"
    },
    {
        "number": 64,
        "title": "Minimum Path Sum",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 65,
        "title": "Valid Number",
        "difficulty": 2,
        "answer": "        s = s.strip()\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if s[0] in ['"
    },
    {
        "number": 66,
        "title": "Plus One",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # for i in range(len(digits) - 1, -1, -1):\n        #     if digits[i] < 9:\n        #         digits[i] += 1\n        #         return digits\n        #     else:\n        #         digits[i] = 0\n        # digits.insert(0, 1)\n        # return digits"
    },
    {
        "number": 67,
        "title": "Add Binary",
        "difficulty": 0,
        "answer": "        if len(a) < len(b):\n            a, b = b, a\n        a = a[::-1]\n        b = b[::-1]\n        carry = 0\n        res = ''\n        for i in range(len(a)):\n            if i < len(b):\n                tmp = int(a[i]) + int(b[i]) + carry\n            else:\n                tmp = int(a[i]) + carry\n            if tmp == 0:\n                res += '0'\n                carry = 0\n            elif tmp == 1:\n                res += '1'\n                carry = 0\n            elif tmp == 2:\n                res += '0'\n                carry = 1\n            elif tmp == 3:\n                res += '1'\n                carry = 1\n        if carry == 1:\n            res += '1'\n        return res[::-1]"
    },
    {
        "number": 68,
        "title": "Text Justification",
        "difficulty": 2,
        "answer": "        res = []\n        cur_line = []\n        cur_len = 0\n        for w in words:\n            if cur_len + len(w) + len(cur_line) > maxWidth:\n                if len(cur_line) == 1:\n                    res.append(cur_line[0] +'' * (maxWidth - cur_len))\n                else:\n                    num_spaces = maxWidth - cur_len + len(cur_line) - 1\n                    space_between_words = num_spaces // (len(cur_line) - 1)\n                    extra_spaces = num_spaces % (len(cur_line) - 1)\n                    res.append((''* space_between_words).join(cur_line) +'' * extra_spaces)\n                cur_line = [w]\n                cur_len = len(w)\n            else:\n                cur_line.append(w)\n                cur_len += len(w)\n        res.append(' '.join(cur_line) +'' * (maxWidth - cur_"
    },
    {
        "number": 69,
        "title": "Sqrt(x)",
        "difficulty": 0,
        "answer": "        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        left = 0\n        right = x\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left - 1"
    },
    {
        "number": 70,
        "title": "Climbing Stairs",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
    },
    {
        "number": 71,
        "title": "Simplify Path",
        "difficulty": 1,
        "answer": "        path_list = path.split('/')\n        stack = []\n        for item in path_list:\n            if item == '..':\n                if stack:\n                    stack.pop()\n            elif item and item!= '.':\n                stack.append(item)\n        return '/' + '/'.join(stack)"
    },
    {
        "number": 72,
        "title": "Edit Distance",
        "difficulty": 2,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"
    },
    {
        "number": 73,
        "title": "Set Matrix Zeroes",
        "difficulty": 1,
        "answer": "        m = len(matrix)\n        n = len(matrix[0])\n        row_set = set()\n        col_set = set()\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row_set.add(i)\n                    col_set.add(j)\n        for i in range(m):\n            for j in range(n):\n                if i in row_set or j in col_set:\n                    matrix[i][j] = 0\n        return matrix"
    },
    {
        "number": 74,
        "title": "Search a 2D Matrix",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return False\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            num = matrix[mid // n][mid % n]\n            if num == target:\n                return True\n            elif num < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n"
    },
    {
        "number": 75,
        "title": "Sort Colors",
        "difficulty": 1,
        "answer": "        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n        # [0, 1, 2]\n"
    },
    {
        "number": 76,
        "title": "Minimum Window Substring",
        "difficulty": 2,
        "answer": "        if not t or not s:\n            return \"\""
    },
    {
        "number": 77,
        "title": "Combinations",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return [[]]\n        if n == 0:\n            return []\n        if k == 1:\n            return [[i] for i in range(1, n + 1)]\n        if k == n:\n            return [[i for i in range(1, n + 1)]]\n        return self.combine(n - 1, k) + [j + [n] for j in self.combine(n - 1, k - 1)]"
    },
    {
        "number": 78,
        "title": "Subsets",
        "difficulty": 1,
        "answer": "        res = []\n        self.dfs(nums, 0, [], res)\n        return res"
    },
    {
        "number": 79,
        "title": "Word Search",
        "difficulty": 1,
        "answer": "        if not board:\n            return False\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if self.dfs(board, i, j, word):\n                    return True\n        return False"
    },
    {
        "number": 80,
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": 1,
        "answer": "        if len(nums) <= 2:\n            return len(nums)\n        i = 0\n        for j in range(2, len(nums)):\n            if nums[i]!= nums[j]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1"
    },
    {
        "number": 81,
        "title": "Search in Rotated Sorted Array II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return False\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return True\n            if nums[l] == nums[mid] == nums[r]:\n                l += 1\n                r -= 1\n            elif nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return False"
    },
    {
        "number": 82,
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": 1,
        "answer": "        # if not head:\n        #     return head\n        # cur = head\n        # while cur:\n        #     if cur.next and cur.val == cur.next.val:\n        #         cur.next = cur.next.next\n        #     else:\n        #         cur = cur.next\n        # return head"
    },
    {
        "number": 83,
        "title": "Remove Duplicates from Sorted List",
        "difficulty": 0,
        "answer": "        # if not head:\n        #     return head\n        # cur = head\n        # while cur and cur.next:\n        #     if cur.val == cur.next.val:\n        #         cur.next = cur.next.next\n        #     else:\n        #         cur = cur.next\n        # return head"
    },
    {
        "number": 84,
        "title": "Largest Rectangle in Histogram",
        "difficulty": 2,
        "answer": "        if not heights:\n            return 0\n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            while stack[-1]!= -1 and heights[stack[-1]] >= heights[i]:\n                max_area = max(max_area, heights[stack.pop()] * (i - stack[-1] - 1))\n            stack.append(i)\n        while stack[-1]!= -1:\n            max_area = max(max_area, heights[stack.pop()] * (len(heights) - stack[-1] - 1))\n        return max_area"
    },
    {
        "number": 85,
        "title": "Maximal Rectangle",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        left, right = [0] * n, [n] * n\n        height = [0] * n\n        max_area = 0\n        for i in range(m):\n            cur_left, cur_right = 0, n\n            # update height\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            # update left\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    left[j] = max(left[j], cur_left)\n                else:\n                    left[j] = 0\n                    cur_left = j + 1\n            # update right\n            for j in range(n - 1, -1, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], cur_right)\n                else:"
    },
    {
        "number": 86,
        "title": "Partition List",
        "difficulty": 1,
        "answer": "        # find the node before the pivot\n        # find the node after the pivot\n        # reverse the second half\n        # merge the two lists\n        # return the head of the merged list\n        \n        # find the node before the pivot\n        before_pivot = before_pivot = ListNode(0)\n        while head and head.val < x:\n            before_pivot.next = head\n            before_pivot = head\n            head = head.next\n        \n        # find the node after the pivot\n        after_pivot = after_pivot = ListNode(0)\n        while head:\n            after_pivot.next = head\n            after_pivot = head\n            head = head.next\n        \n        # reverse the second half\n        after_pivot.next = None\n        before_pivot.next = after_pivot.next\n        \n        # merge the two lists\n        while before_pivot.next:\n            before_pivot = before_pivot.next\n        return before_pivot.next\n"
    },
    {
        "number": 87,
        "title": "Scramble String",
        "difficulty": 2,
        "answer": "        if len(s1)!= len(s2):\n            return False\n        if len(s1) == 1:\n            return s1 == s2\n        if sorted(s1)!= sorted(s2):\n            return False\n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"
    },
    {
        "number": 88,
        "title": "Merge Sorted Array",
        "difficulty": 0,
        "answer": "        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        # nums1 = [1,2,3,0,0,0]\n"
    },
    {
        "number": 89,
        "title": "Gray Code",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return [0]\n        if n == 1:\n            return [0, 1]\n        res = [0, 1]\n        for i in range(2, n + 1):\n            for j in range(len(res) - 1, -1, -1):\n                res.append(res[j] + 2 ** i)\n        return res"
    },
    {
        "number": 90,
        "title": "Subsets II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = []\n        self.dfs(nums, 0, [], res)\n        return res"
    },
    {
        "number": 91,
        "title": "Decode Ways",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 0 if s[0] == '0' else 1\n        for i in range(2, len(s) + 1):\n            if 0 < int(s[i - 1:i]) <= 9:\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[-1]"
    },
    {
        "number": 92,
        "title": "Reverse Linked List II",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        # find the node before the left-most node to be reversed\n        prev, curr = None, head\n        while left > 1:\n            prev = curr\n            curr = curr.next\n            left -= 1\n            right -= 1\n        \n        # reverse the nodes between the two nodes\n        tail, con = curr, prev\n        while right:\n            third = curr.next\n            curr.next = prev\n            prev = curr\n            curr = third\n            right -= 1\n        \n        # connect with the previous part\n        if prev:\n            prev.next = prev\n        else:\n            head = prev\n        if con:\n            con.next = prev\n        else:\n            tail = prev\n        tail.next = curr\n        return head\n"
    },
    {
        "number": 93,
        "title": "Restore IP Addresses",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.dfs(s, 0, \"\", 0)\n        return self.res"
    },
    {
        "number": 94,
        "title": "Binary Tree Inorder Traversal",
        "difficulty": 0,
        "answer": "        # Recursive\n        # if not root:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)"
    },
    {
        "number": 95,
        "title": "Unique Binary Search Trees II",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return []\n        return self.generate_trees(1, n)"
    },
    {
        "number": 96,
        "title": "Unique Binary Search Trees",
        "difficulty": 1,
        "answer": "        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        return dp[n]"
    },
    {
        "number": 97,
        "title": "Interleaving String",
        "difficulty": 1,
        "answer": "        m, n = len(s1), len(s2)\n        if m + n!= len(s3):\n            return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        return"
    },
    {
        "number": 98,
        "title": "Validate Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return True\n        return self.isValidBSTHelper(root, float('-inf'), float('inf'))"
    },
    {
        "number": 99,
        "title": "Recover Binary Search Tree",
        "difficulty": 1,
        "answer": "        self.first, self.second = None, None\n        self.prev = TreeNode(float('-inf'))"
    },
    {
        "number": 100,
        "title": "Same Tree",
        "difficulty": 0,
        "answer": "        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val!= q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
    },
    {
        "number": 101,
        "title": "Symmetric Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return True\n        return self.isMirror(root.left, root.right)"
    },
    {
        "number": 102,
        "title": "Binary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        queue = [root]\n        res = []\n        while queue:\n            temp = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(temp)\n        return res\n"
    },
    {
        "number": 103,
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        queue = [root]\n        res = []\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        for i in range(len(res)):\n            if i % 2 == 1:\n                res[i] = res[i][::-1]\n        return res\n"
    },
    {
        "number": 104,
        "title": "Maximum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
    },
    {
        "number": 105,
        "title": "Construct Binary Tree from Preorder and Inorder Traversal",
        "difficulty": 1,
        "answer": "        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,15,7]\n        # inorder = [9,3,15,20,7]\n        # preorder = [3,9,20,"
    },
    {
        "number": 106,
        "title": "Construct Binary Tree from Inorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        # inorder: [9, 3, 15, 20, 7]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7, 20, 3]\n        # postorder: [9, 15, 7,"
    },
    {
        "number": 107,
        "title": "Binary Tree Level Order Traversal II",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        queue = [root]\n        res = []\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res[::-1]\n"
    },
    {
        "number": 108,
        "title": "Convert Sorted Array to Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root\n"
    },
    {
        "number": 109,
        "title": "Convert Sorted List to Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        if not head.next:\n            return TreeNode(head.val)\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n"
    },
    {
        "number": 110,
        "title": "Balanced Binary Tree",
        "difficulty": 0,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1"
    },
    {
        "number": 111,
        "title": "Minimum Depth of Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"
    },
    {
        "number": 112,
        "title": "Path Sum",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == targetSum\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n"
    },
    {
        "number": 113,
        "title": "Path Sum II",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        if not root.left and not root.right and root.val == targetSum:\n            return [[root.val]]\n        left = self.pathSum(root.left, targetSum - root.val)\n        right = self.pathSum(root.right, targetSum - root.val)\n        return [[root.val] + l for l in left] + [[root.val] + r for r in right]"
    },
    {
        "number": 114,
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": 1,
        "answer": "        if not root:\n            return\n        self.flatten(root.left)\n        self.flatten(root.right)\n        if root.left:\n            left = root.left\n            while left.right:\n                left = left.right\n            left.right = root.right\n            root.right = root.left\n            root.left = None\n        return root"
    },
    {
        "number": 115,
        "title": "Distinct Subsequences",
        "difficulty": 2,
        "answer": "        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for j in range(n + 1):\n            dp[0][j] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[-1][-1]"
    },
    {
        "number": 116,
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n                self.val = val\n                self.left = left\n                self.right = right\n                self.next = next\n        \"\"\"\n        self.next = None\n        self.populateNext()"
    },
    {
        "number": 117,
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n        \"\"\"\n        # Definition for a Node.\n        class Node:\n            def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n                self.val = val\n                self.left = left\n                self.right = right\n                self.next = next\n        Given a binary tree\n        struct Node {\n          int val;\n          Node *left;\n          Node *right;\n          Node *next;\n        }\n        Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n        Initially, all next pointers are set to NULL.\n        Example 1:\n        Input: root = [1,2,3,4,5,null,7]\n        Output: [1,#,2,3,#,4,5,7,#]\n        Explanation: Given the above binary"
    },
    {
        "number": 118,
        "title": "Pascal\"s Triangle",
        "difficulty": 0,
        "answer": "        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1, 1]]\n        res = [[1], [1, 1]]\n        for i in range(2, numRows):\n            tmp = [1]\n            for j in range(1, i):\n                tmp.append(res[i - 1][j - 1] + res[i - 1][j])\n            tmp.append(1)\n            res.append(tmp)\n        return res"
    },
    {
        "number": 119,
        "title": "Pascal\"s Triangle II",
        "difficulty": 0,
        "answer": "        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1, 1]\n        if rowIndex == 2:\n            return [1, 2, 1]\n        if rowIndex == 3:\n            return [1, 3, 3, 1]\n        if rowIndex == 4:\n            return [1, 4, 6, 4, 1]\n        if rowIndex == 5:\n            return [1, 5, 10, 10, 5, 1]\n        if rowIndex == 6:\n            return [1, 6, 15, 20, 15, 6, 1]\n        if rowIndex == 7:\n            return [1, 7, 21, 35, 35, 21, 7, 1]\n        if rowIndex == 8:\n            return [1, 8, 28, 56, 70, 56, 28, 8, 1]\n        if rowIndex == 9:\n            return [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n        if rowIndex == 10:\n            return [1, 10, 45, 120, 210"
    },
    {
        "number": 120,
        "title": "Triangle",
        "difficulty": 1,
        "answer": "        if not triangle:\n            return 0\n        if len(triangle) == 1:\n            return triangle[0][0]\n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j])\n        return min(triangle[-1])"
    },
    {
        "number": 121,
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": 0,
        "answer": "        if len(prices) < 2:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price > max_profit:\n                max_profit = prices[i] - min_price\n        return max_profit"
    },
    {
        "number": 122,
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # buy_price = float('inf')\n        # sell_price = 0\n        # for price in prices:\n        #     buy_price = min(buy_price, price)\n        #     sell_price = max(sell_price, price - buy_price)\n        # return sell_price"
    },
    {
        "number": 123,
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": 2,
        "answer": "        if len(prices) < 2:\n            return 0\n        dp = [[0, 0] for _ in range(len(prices))]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, len(prices)):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n        return dp[-1][0]"
    },
    {
        "number": 124,
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": 2,
        "answer": "        self.max_sum = float('-inf')\n        self.dfs(root)\n        return self.max_sum"
    },
    {
        "number": 125,
        "title": "Valid Palindrome",
        "difficulty": 0,
        "answer": "        s = s.lower()\n        s = re.sub('[^a-z0-9]', '', s)\n        return s == s[::-1]"
    },
    {
        "number": 126,
        "title": "Word Ladder II",
        "difficulty": 2,
        "answer": "        wordList = set(wordList)\n        res = []\n        layer = {}\n        layer[beginWord] = [[beginWord]]"
    },
    {
        "number": 127,
        "title": "Word Ladder",
        "difficulty": 2,
        "answer": "        if endWord not in wordList:\n            return 0\n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i + 1:]\n                    if new_word in wordList:\n                        wordList.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0"
    },
    {
        "number": 128,
        "title": "Longest Consecutive Sequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        nums.sort()\n        max_len = 1\n        cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1] + 1:\n                cur_len += 1\n            else:\n                max_len = max(max_len, cur_len)\n                cur_len = 1\n        return max(max_len, cur_len)"
    },
    {
        "number": 129,
        "title": "Sum Root to Leaf Numbers",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if not node:\n                return 0\n            path = path * 10 + node.val\n            if not node.left and not node.right:\n                return path\n            return dfs(node.left, path) + dfs(node.right, path)\n        return dfs(root, 0)"
    },
    {
        "number": 130,
        "title": "Surrounded Regions",
        "difficulty": 1,
        "answer": "        if not board:\n            return\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or i == m - 1 or j == 0 or j == n - 1) and board[i][j] == 'O':\n                    self.dfs(board, i, j)"
    },
    {
        "number": 131,
        "title": "Palindrome Partitioning",
        "difficulty": 1,
        "answer": "        # dp[i][j] = True if s[i:j+1] is palindrome\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] or dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] or dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] or dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i]["
    },
    {
        "number": 132,
        "title": "Palindrome Partitioning II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1])\n        res = [0]\n        for i in range(n):\n            if dp[0][i]:\n                res.append(0)\n            else:\n                res.append(1 + min(res[j] for j in range(i) if dp[j][i]))\n        return res[-1]"
    },
    {
        "number": 133,
        "title": "Clone Graph",
        "difficulty": 1,
        "answer": "        self.visited = set()\n        self.graph = {}\n        self.dfs(root)\n        return self.graph"
    },
    {
        "number": 134,
        "title": "Gas Station",
        "difficulty": 1,
        "answer": "        if sum(gas) < sum(cost):\n            return -1\n        start, curr_sum, min_sum = 0, 0, float('inf')\n        for i in range(len(gas)):\n            curr_sum += gas[i] - cost[i]\n            min_sum = min(min_sum, curr_sum)\n            if curr_sum < 0:\n                start = i + 1\n                curr_sum = 0\n        return start if min_sum >= 0 else -1"
    },
    {
        "number": 135,
        "title": "Candy",
        "difficulty": 2,
        "answer": "        if not ratings:\n            return 0\n        candies = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)"
    },
    {
        "number": 136,
        "title": "Single Number",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # nums.sort()\n        # for i in range(0, len(nums), 2):\n        #     if i + 1 == len(nums):\n        #         return nums[i]\n        #     if nums[i]!= nums[i + 1]:\n        #         return nums[i]"
    },
    {
        "number": 137,
        "title": "Single Number II",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # nums.sort()\n        # for i in range(0, len(nums), 3):\n        #     if i + 1 < len(nums) and nums[i] == nums[i + 1]:\n        #         continue\n        #     return nums[i]"
    },
    {
        "number": 138,
        "title": "Copy List with Random Pointer",
        "difficulty": 1,
        "answer": "        self.dummy = Node(0)\n        self.cur = self.dummy\n        self.visited = {}\n        self.copy_node(head)\n        return self.dummy.next"
    },
    {
        "number": 139,
        "title": "Word Break",
        "difficulty": 1,
        "answer": "        # dp[i] means whether s[:i+1] can be segmented into words in the dictionary\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if dp[i] and s[i:j+1] in wordDict:\n                    dp[j+1] = True\n        return dp[-1]"
    },
    {
        "number": 140,
        "title": "Word Break II",
        "difficulty": 2,
        "answer": "        self.memo = {}\n        self.wordDict = set(wordDict)\n        return self.dfs(s)"
    },
    {
        "number": 141,
        "title": "Linked List Cycle",
        "difficulty": 0,
        "answer": "        if not head:\n            return False\n        slow = head\n        fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n"
    },
    {
        "number": 142,
        "title": "Linked List Cycle II",
        "difficulty": 1,
        "answer": "        # 1. Find the intersection point of the two runners.\n        # 2. Once the two runners meet, the meeting point is the start of the cycle.\n        # 3. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 4. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 5. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 6. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 7. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 8. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 9. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 10. The two runners will eventually meet again, and the meeting point is the start of the cycle.\n        # 11. The two runners will eventually meet again, and the meeting point is the start of the cycle."
    },
    {
        "number": 143,
        "title": "Reorder List",
        "difficulty": 1,
        "answer": "        if not head:\n            return\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        head2 = slow.next\n        slow.next = None\n        prev = None\n        curr = head2\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        curr = head\n        while prev:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        curr.next = None\n        return head"
    },
    {
        "number": 144,
        "title": "Binary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        # iterative\n        # if not root:\n        #     return []\n        # stack, res = [root], []\n        # while stack:\n        #     node = stack.pop()\n        #     if node:\n        #         res.append(node.val)\n        #         stack.append(node.right)\n        #         stack.append(node.left)\n        # return res"
    },
    {
        "number": 145,
        "title": "Binary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        # Recursive\n        # Time: O(n)\n        # Space: O(n)\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]"
    },
    {
        "number": 146,
        "title": "LRU Cache",
        "difficulty": 1,
        "answer": "        self.capacity = capacity\n        self.cache = {}\n        self.lru = []\n        self.size = 0"
    },
    {
        "number": 147,
        "title": "Insertion Sort List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr and curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                pre = dummy\n                while pre.next.val <= curr.next.val:\n                    pre = pre.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = pre.next\n                pre.next = temp\n        return dummy.next\n"
    },
    {
        "number": 148,
        "title": "Sort List",
        "difficulty": 1,
        "answer": "        # 1. \u5feb\u6392\n        # 2. \u5f52\u5e76\u6392\u5e8f\n        # 3. \u5806\u6392\u5e8f\n        # 4. \u57fa\u6570\u6392\u5e8f\n        # 5. \u57fa\u6570\u6392\u5e8f2\n        # 6. \u57fa\u6570\u6392\u5e8f3\n        # 7. \u57fa\u6570\u6392\u5e8f4\n        # 8. \u57fa\u6570\u6392\u5e8f5\n        # 9. \u57fa\u6570\u6392\u5e8f6\n        # 10. \u57fa\u6570\u6392\u5e8f7\n        # 11. \u57fa\u6570\u6392\u5e8f8\n        # 12. \u57fa\u6570\u6392\u5e8f9\n        # 13. \u57fa\u6570\u6392\u5e8f10\n        # 14. \u57fa\u6570\u6392\u5e8f11\n        # 15. \u57fa\u6570\u6392\u5e8f12\n        # 16. \u57fa\u6570\u6392\u5e8f13\n        # 17. \ufffd"
    },
    {
        "number": 149,
        "title": "Max Points on a Line",
        "difficulty": 2,
        "answer": "        if len(points) == 1:\n            return 1\n        \n        max_points = 1\n        for i in range(len(points)):\n            slope_dict = {}\n            same_points = 1\n            for j in range(i+1, len(points)):\n                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\n                    same_points += 1\n                    continue\n                if points[i][0] == points[j][0]:\n                    slope = 'inf'\n                else:\n                    slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                if slope not in slope_dict:\n                    slope_dict[slope] = 1\n                else:\n                    slope_dict[slope] += 1\n            for slope in slope_dict:\n                max_points = max(max_points, slope_dict[slope] + same_points)\n        return max_points\n"
    },
    {
        "number": 150,
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": 1,
        "answer": "        stack = []\n        for token in tokens:\n            if token in [\"+\", \"-\", \"*\", \"/\"]:\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"
    },
    {
        "number": 151,
        "title": "Reverse Words in a String",
        "difficulty": 1,
        "answer": "        # split the string into a list of words\n        # reverse the list\n        # join the list with a space\n        return \" \".join(reversed(s.split()))"
    },
    {
        "number": 152,
        "title": "Maximum Product Subarray",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1]*nums[i], dp[i-1]*nums[i], nums[i])\n        # dp[i] = min(dp[i-1]*nums[i], dp[i-1]*nums[i], nums[i])\n        # dp[i] = max(dp[i-1]*nums[i], nums[i])\n        # dp[i] = min(dp[i-1]*nums[i], nums[i])\n        # dp[i] = max(dp[i-1]*nums[i], nums[i])\n        # dp[i] = min(dp[i-1]*nums[i], nums[i])\n        # dp[i] = max(dp[i-1]*nums[i], nums[i])\n        # dp[i] = min(dp[i-1]*nums[i], nums[i])\n"
    },
    {
        "number": 153,
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]"
    },
    {
        "number": 154,
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": 2,
        "answer": "        if not nums:\n            return None\n        if len(nums) == 1:\n            return nums[0]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]"
    },
    {
        "number": 155,
        "title": "Min Stack",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 160,
        "title": "Intersection of Two Linked Lists",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time O(n)\n        # Space O(1)\n        # currA, currB = headA, headB\n        # while currA!= currB:\n        #     currA = currA.next if currA else headB\n        #     currB = currB.next if currB else headA\n        # return currA"
    },
    {
        "number": 162,
        "title": "Find Peak Element",
        "difficulty": 1,
        "answer": "        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = l + (r - l) // 2\n            if nums[mid] < nums[mid + 1]:\n                l = mid + 1\n            else:\n                r = mid\n        return l"
    },
    {
        "number": 164,
        "title": "Maximum Gap",
        "difficulty": 2,
        "answer": "        if len(nums) < 2:\n            return 0\n        nums.sort()\n        return max(nums[i+1] - nums[i] for i in range(len(nums)-1))\n"
    },
    {
        "number": 165,
        "title": "Compare Version Numbers",
        "difficulty": 1,
        "answer": "        v1 = version1.split('.')\n        v2 = version2.split('.')\n        for i in range(max(len(v1), len(v2))):\n            v1_i = 0 if i >= len(v1) else int(v1[i])\n            v2_i = 0 if i >= len(v2) else int(v2[i])\n            if v1_i > v2_i:\n                return 1\n            elif v1_i < v2_i:\n                return -1\n        return 0"
    },
    {
        "number": 166,
        "title": "Fraction to Recurring Decimal",
        "difficulty": 1,
        "answer": "        if numerator == 0:\n            return \"0\"\n        res = \"\"\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        numerator %= denominator\n        if numerator == 0:\n            return res\n        res += \".\"\n        # use a dict to store the repeating part\n        d = {}\n        while numerator:\n            if numerator in d:\n                res = res[:d[numerator]] + \"(\" + res[d[numerator]:] + \")\"\n                break\n            d[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        return res"
    },
    {
        "number": 167,
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": 1,
        "answer": "        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        return [left + 1, right + 1]"
    },
    {
        "number": 168,
        "title": "Excel Sheet Column Title",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # res = ''\n        # while columnNumber:\n        #     columnNumber, mod = divmod(columnNumber - 1, 26)\n        #     res = chr(mod + ord('A')) + res\n        # return res"
    },
    {
        "number": 169,
        "title": "Majority Element",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 2:\n        # return collections.Counter(nums).most_common(1)[0][0]\n        # Solution 3:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 4:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 5:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 6:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 7:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 8:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 9:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 10:\n        # return sorted(nums)[len(nums)//2]\n        # Solution 11:\n        # return sorted(nums)[len("
    },
    {
        "number": 171,
        "title": "Excel Sheet Column Number",
        "difficulty": 0,
        "answer": "        # ord('A') = 65\n        # ord('Z') = 90\n        # ord('a') = 97\n        # ord('z') = 122\n        # ord('A') - ord('A') + 1 = 1\n        # ord('Z') - ord('A') + 1 = 26\n        # ord('a') - ord('A') + 1 = 1\n        # ord('z') - ord('A') + 1 = 26\n        # ord('A') - ord('A') + 1 = 1\n        # ord('Z') - ord('A') + 1 = 26\n        # ord('a') - ord('A') + 1 = 1\n        # ord('z') - ord('A') + 1 = 26\n        # ord('A') - ord('A') + 1 = 1\n        # ord('Z') - ord('A') + 1 = 26\n        # ord('a') - ord('A') + 1 = 1\n        # ord('z') - ord('A') + 1 = 26\n        # ord('A') - ord('A') + 1 = 1\n        # ord('Z')"
    },
    {
        "number": 172,
        "title": "Factorial Trailing Zeroes",
        "difficulty": 1,
        "answer": "        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1\n        # n! = n * (n - 1)!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1\n        # n! = n * (n - 1)! / 5!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1 / 5!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1 / 5! / 2!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1 / 5! / 2! / 3!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1 / 5! / 2! / 3! / 4!\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1 / 5!"
    },
    {
        "number": 173,
        "title": "Binary Search Tree Iterator",
        "difficulty": 1,
        "answer": "        self.stack = []\n        while root:\n            self.stack.append(root)\n            root = root.left\n        return self.stack"
    },
    {
        "number": 174,
        "title": "Dungeon Game",
        "difficulty": 2,
        "answer": "        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n        dp[m - 1][n], dp[m][n - 1] = 1, 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        return dp[0][0]"
    },
    {
        "number": 179,
        "title": "Largest Number",
        "difficulty": 1,
        "answer": "        nums = [str(num) for num in nums]\n        nums.sort(key=lambda x: x[0], reverse=True)\n        return ''.join(nums) if nums[0]!= '0' else '0'"
    },
    {
        "number": 187,
        "title": "Repeated DNA Sequences",
        "difficulty": 1,
        "answer": "        if len(s) < 10:\n            return []\n        d = {}\n        for i in range(len(s) - 9):\n            sub = s[i:i + 10]\n            if sub in d:\n                d[sub] += 1\n            else:\n                d[sub] = 1\n        return [k for k, v in d.items() if v > 1]\n"
    },
    {
        "number": 188,
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": 2,
        "answer": "        if not prices:\n            return 0\n        n = len(prices)\n        if k >= n // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        dp = [[0] * n for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            tmp = float('-inf')\n            for j in range(1, n):\n                tmp = max(tmp, dp[i - 1][j - 1] - prices[j - 1])\n                dp[i][j] = max(dp[i][j - 1], prices[j] + tmp)\n        return dp[-1][-1]"
    },
    {
        "number": 189,
        "title": "Rotate Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        k %= n\n        nums[:] = nums[n-k:] + nums[:n-k]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 190,
        "title": "Reverse Bits",
        "difficulty": 0,
        "answer": "        # 32 bits\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0xffffffff\n        # n = n >> 16\n        # n = n | (n << 16)\n        # n = n & 0x"
    },
    {
        "number": 191,
        "title": "Number of 1 Bits",
        "difficulty": 0,
        "answer": "        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count"
    },
    {
        "number": 198,
        "title": "House Robber",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]"
    },
    {
        "number": 199,
        "title": "Binary Tree Right Side View",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        queue = [root]\n        res = []\n        while queue:\n            res.append(queue[-1].val)\n            temp = []\n            for node in queue:\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n        return res\n"
    },
    {
        "number": 200,
        "title": "Number of Islands",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j]!= '1':\n                return\n            grid[i][j] = '0'\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n        return count"
    },
    {
        "number": 201,
        "title": "Bitwise AND of Numbers Range",
        "difficulty": 1,
        "answer": "        if left == right:\n            return left\n        if left == 0:\n            return 0\n        if left == 1:\n            return 1\n        if left == 2147483647:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 2147483646:\n            return 0\n        if right == 2147483647:\n            return 0\n        if right == 214748"
    },
    {
        "number": 202,
        "title": "Happy Number",
        "difficulty": 0,
        "answer": "        def get_next(n):\n            total = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total += digit ** 2\n            return total"
    },
    {
        "number": 203,
        "title": "Remove Linked List Elements",
        "difficulty": 0,
        "answer": "        # if not head:\n        #     return head\n        # if head.val == val:\n        #     head = self.removeElements(head.next, val)\n        #     return head\n        # else:\n        #     head.next = self.removeElements(head.next, val)\n        #     return head\n        # return head\n        \n        # if not head:\n        #     return head\n        # if head.val == val:\n        #     head = self.removeElements(head.next, val)\n        #     return head\n        # else:\n        #     head.next = self.removeElements(head.next, val)\n        #     return head\n        \n        # if not head:\n        #     return head\n        # if head.val == val:\n        #     head = self.removeElements(head.next, val)\n        #     return head\n        # else:\n        #     head.next = self.removeElements(head.next, val)\n        #     return head\n        \n        # if not head"
    },
    {
        "number": 204,
        "title": "Count Primes",
        "difficulty": 1,
        "answer": "        # \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u6cd5\n        # if n < 2:\n        #     return 0\n        # count = 0\n        # for i in range(2, n):\n        #     for j in range(2, i):\n        #         if i % j == 0:\n        #             break\n        #     else:\n        #         count += 1\n        # return count"
    },
    {
        "number": 205,
        "title": "Isomorphic Strings",
        "difficulty": 0,
        "answer": "        # if len(s)!= len(t):\n        #     return False\n        # dic = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dic:\n        #         dic[s[i]] = t[i]\n        #     else:\n        #         if dic[s[i]]!= t[i]:\n        #             return False\n        # return True"
    },
    {
        "number": 206,
        "title": "Reverse Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return head\n        \n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev"
    },
    {
        "number": 207,
        "title": "Course Schedule",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = {}\n        for i in range(numCourses):\n            graph[i] = []\n        for pre in prerequisites:\n            graph[pre[1]].append(pre[0])\n        # print(graph)\n        # bfs\n        visited = set()\n        queue = []\n        for i in range(numCourses):\n            if i not in visited:\n                queue.append(i)\n                while queue:\n                    cur = queue.pop(0)\n                    visited.add(cur)\n                    for j in graph[cur]:\n                        if j not in visited:\n                            queue.append(j)\n        # print(visited)\n        return len(visited) == numCourses"
    },
    {
        "number": 208,
        "title": "Implement Trie (Prefix Tree)",
        "difficulty": 1,
        "answer": "        self.root = {}\n        self.end_of_word = \"#\"\n        self.word = word\n        for i in range(len(word)):\n            self.insert(word[i:])\n        return self.search(word)"
    },
    {
        "number": 209,
        "title": "Minimum Size Subarray Sum",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        left, right = 0, 0\n        curr_sum = 0\n        min_len = float('inf')\n        while right < len(nums):\n            curr_sum += nums[right]\n            while curr_sum >= target:\n                min_len = min(min_len, right - left + 1)\n                curr_sum -= nums[left]\n                left += 1\n            right += 1\n        return min_len if min_len!= float('inf') else 0"
    },
    {
        "number": 210,
        "title": "Course Schedule II",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for u, v in prerequisites:\n            graph[u].append(v)\n        # dfs\n        visited = [0] * numCourses\n        path = []\n        for i in range(numCourses):\n            if not self.dfs(graph, visited, i, path):\n                return []\n        return path"
    },
    {
        "number": 211,
        "title": "Design Add and Search Words Data Structure",
        "difficulty": 1,
        "answer": "        self.word_dict = {}\n        self.word_dict[word] = True\n        return True"
    },
    {
        "number": 212,
        "title": "Word Search II",
        "difficulty": 2,
        "answer": "        self.m = len(board)\n        self.n = len(board[0])\n        self.board = board\n        self.words = words\n        self.visited = [[False for _ in range(self.n)] for _ in range(self.m)]\n        self.result = set()\n        for word in words:\n            if self.search(word):\n                self.result.add(word)\n        return list(self.result)"
    },
    {
        "number": 213,
        "title": "House Robber II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        if len(nums) == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]"
    },
    {
        "number": 214,
        "title": "Shortest Palindrome",
        "difficulty": 2,
        "answer": "        if not s:\n            return s\n        if s == s[::-1]:\n            return s\n        for i in range(len(s), -1, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[i:][::-1] + s"
    },
    {
        "number": 215,
        "title": "Kth Largest Element in an Array",
        "difficulty": 1,
        "answer": "        # \u5feb\u901f\u6392\u5e8f\n        def partition(left, right, pivot_index):\n            pivot = nums[pivot_index]\n            # 1. move pivot to end\n            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]"
    },
    {
        "number": 216,
        "title": "Combination Sum III",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.dfs(k, n, 1, [])\n        return self.res"
    },
    {
        "number": 217,
        "title": "Contains Duplicate",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if nums[i] == nums[i+1]:\n        #         return True\n        # return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if nums[i] == nums[i+1]:\n        #         return True\n        # return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if nums[i] == nums[i+1]:\n        #         return True\n        # return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if nums[i] == nums[i+1]:\n        #         return True\n        # return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if nums[i] == num"
    },
    {
        "number": 218,
        "title": "The Skyline Problem",
        "difficulty": 2,
        "answer": "        # Solution 1: O(n) space, O(nlogn) time\n        # Solution 2: O(n) space, O(nlogn) time\n        # Solution 3: O(n) space, O(nlogn) time\n        # Solution 4: O(n) space, O(nlogn) time\n        # Solution 5: O(n) space, O(nlogn) time\n        # Solution 6: O(n) space, O(nlogn) time\n        # Solution 7: O(n) space, O(nlogn) time\n        # Solution 8: O(n) space, O(nlogn) time\n        # Solution 9: O(n) space, O(nlogn) time\n        # Solution 10: O(n) space, O(nlogn) time\n        # Solution 11: O(n) space, O(nlogn) time\n        # Solution 12: O(n) space, O(nlogn) time\n        # Solution 13: O(n) space, O(nlogn) time\n        # Solution 14: O(n) space, O(nlogn)"
    },
    {
        "number": 219,
        "title": "Contains Duplicate II",
        "difficulty": 0,
        "answer": "        # O(n)\n        # hash table\n        # if len(nums) < 2:\n        #     return False\n        # dic = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in dic:\n        #         if i - dic[nums[i]] <= k:\n        #             return True\n        #         else:\n        #             dic[nums[i]] = i\n        #     else:\n        #         dic[nums[i]] = i\n        # return False"
    },
    {
        "number": 220,
        "title": "Contains Duplicate III",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 221,
        "title": "Maximal Square",
        "difficulty": 1,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_side = 0\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    max_side = max(max_side, dp[i][j])\n        return max_side ** 2"
    },
    {
        "number": 222,
        "title": "Count Complete Tree Nodes",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"
    },
    {
        "number": 223,
        "title": "Rectangle Area",
        "difficulty": 1,
        "answer": "        # compute the area of the first rectangle\n        area_1 = (ax2 - ax1) * (ay2 - ay1)\n        # compute the area of the second rectangle\n        area_2 = (bx2 - bx1) * (by2 - by1)\n        # compute the area of the intersection rectangle\n        area_intersection = max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))\n        # return the sum of the areas\n        return area_1 + area_2 - area_intersection"
    },
    {
        "number": 224,
        "title": "Basic Calculator",
        "difficulty": 2,
        "answer": "        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-*/' or i == len(s) - 1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                else:\n                    stack.append(int(stack.pop() / num))\n                num = 0\n                sign = s[i]\n        return sum(stack)"
    },
    {
        "number": 225,
        "title": "Implement Stack using Queues",
        "difficulty": 0,
        "answer": "        pass"
    },
    {
        "number": 226,
        "title": "Invert Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return root\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"
    },
    {
        "number": 227,
        "title": "Basic Calculator II",
        "difficulty": 1,
        "answer": "        # stack = []\n        # num = 0\n        # sign = '+'\n        # for i in range(len(s)):\n        #     if s[i].isdigit():\n        #         num = num*10 + int(s[i])\n        #     if s[i] in '+-*/' or i == len(s)-1:\n        #         if sign == '+':\n        #             stack.append(num)\n        #         elif sign == '-':\n        #             stack.append(-num)\n        #         elif sign == '*':\n        #             stack.append(stack.pop()*num)\n        #         elif sign == '/':\n        #             stack.append(int(stack.pop()/num))\n        #         sign = s[i]\n        #         num = 0\n        # return sum(stack)\n        \n        # stack = []\n        # num = 0\n        # sign = '+'\n        # for i in range(len(s)):\n        #     if s[i].isdig"
    },
    {
        "number": 228,
        "title": "Summary Ranges",
        "difficulty": 0,
        "answer": "        if not nums:\n            return []\n        if len(nums) == 1:\n            return [str(nums[0])]\n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1] + 1:\n                continue\n            if nums[i] == nums[i - 1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + \"->\" + str(nums[i - 1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(nums[-1]))\n        return res"
    },
    {
        "number": 229,
        "title": "Majority Element II",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # return [n for n in set(nums) if nums.count(n) > len(nums) // 3]"
    },
    {
        "number": 230,
        "title": "Kth Smallest Element in a BST",
        "difficulty": 1,
        "answer": "        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right"
    },
    {
        "number": 231,
        "title": "Power of Two",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"
    },
    {
        "number": 232,
        "title": "Implement Queue using Stacks",
        "difficulty": 0,
        "answer": "        self.stack = []\n        self.stack2 = []\n        \n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        \n    def pop(self) -> int:\n        if len(self.stack2) == 0:\n            while len(self.stack)!= 0:\n                self.stack2.append(self.stack.pop())\n        return self.stack2.pop()\n        \n    def peek(self) -> int:\n        if len(self.stack2) == 0:\n            while len(self.stack)!= 0:\n                self.stack2.append(self.stack.pop())\n        return self.stack2[-1]\n        \n    def empty(self) -> bool:\n        return len(self.stack) == 0 and len(self.stack2) == 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 233,
        "title": "Number of Digit One",
        "difficulty": 2,
        "answer": "        # \u601d\u8def\uff1a\n        # \u5148\u628an\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u5316\u4e3a\u5217\u8868\uff0c\u7136\u540e\u628a\u5217\u8868\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u5316\u4e3a\u5217\u8868\uff0c\u7136\u540e\u628a\u5217\u8868\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u5316\u4e3a\u5217\u8868"
    },
    {
        "number": 234,
        "title": "Palindrome Linked List",
        "difficulty": 0,
        "answer": "        if not head:\n            return True\n        \n        # find the middle node\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first and the second half nodes\n        first_half_end = prev\n        second_half_start = head\n        while first_half_end:\n            if first_half_end.val!= second_half_start.val:\n                return False\n            first_half_end = first_half_end.next\n            second_half_start = second_half_start.next\n        return True\n"
    },
    {
        "number": 235,
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val > p.val and root.val > q.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        if root.val < p.val and root.val < q.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        return root"
    },
    {
        "number": 236,
        "title": "Lowest Common Ancestor of a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        if left:\n            return left\n        if right:\n            return right\n        return None"
    },
    {
        "number": 237,
        "title": "Delete Node in a Linked List",
        "difficulty": 1,
        "answer": "        if node.next is None:\n            node = None\n        else:\n            node.val = node.next.val\n            node.next = node.next.next\n        return node"
    },
    {
        "number": 238,
        "title": "Product of Array Except Self",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        left = [1] * n\n        right = [1] * n\n        for i in range(1, n):\n            left[i] = left[i - 1] * nums[i - 1]\n        for i in range(n - 2, -1, -1):\n            right[i] = right[i + 1] * nums[i + 1]\n        return [left[i] * right[i] for i in range(n)]"
    },
    {
        "number": 239,
        "title": "Sliding Window Maximum",
        "difficulty": 2,
        "answer": "        # \u53cc\u7aef\u961f\u5217\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)\n        # \u53cc\u7aef\u961f\u5217\u7684\u5165\u961f\u548c\u51fa\u961f\u90fd\u662fO(1)"
    },
    {
        "number": 240,
        "title": "Search a 2D Matrix II",
        "difficulty": 1,
        "answer": "        # binary search\n        # time complexity: O(log(m+n))\n        # space complexity: O(1)\n        if not matrix:\n            return False\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            num = matrix[mid // n][mid % n]\n            if num == target:\n                return True\n            elif num < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"
    },
    {
        "number": 241,
        "title": "Different Ways to Add Parentheses",
        "difficulty": 1,
        "answer": "        if expression.isdigit():\n            return [int(expression)]\n        res = []\n        for i in range(len(expression)):\n            if expression[i] in '+-*':\n                left = self.diffWaysToCompute(expression[:i])\n                right = self.diffWaysToCompute(expression[i+1:])\n                for l in left:\n                    for r in right:\n                        if expression[i] == '+':\n                            res.append(l+r)\n                        elif expression[i] == '-':\n                            res.append(l-r)\n                        else:\n                            res.append(l*r)\n        return res\n"
    },
    {
        "number": 242,
        "title": "Valid Anagram",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        if len(s)!= len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = 1\n            else:\n                s_dict[s[i]] += 1\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = 1\n            else:\n                t_dict[t[i]] += 1\n        \n        return s_dict == t_dict"
    },
    {
        "number": 257,
        "title": "Binary Tree Paths",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        if not root.left and not root.right:\n            return [str(root.val)]\n        return [str(root.val) + '->' + path for path in self.binaryTreePaths(root.left)] + \\\n               [str(root.val) + '->' + path for path in self.binaryTreePaths(root.right)]"
    },
    {
        "number": 258,
        "title": "Add Digits",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9"
    },
    {
        "number": 260,
        "title": "Single Number III",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(1) space\n        # nums.sort()\n        # for i in range(0, len(nums), 2):\n        #     if i + 1 < len(nums) and nums[i] == nums[i + 1]:\n        #         continue\n        #     return [nums[i], nums[i + 1]]"
    },
    {
        "number": 263,
        "title": "Ugly Number",
        "difficulty": 0,
        "answer": "        if n <= 0:\n            return False\n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        return n == 1"
    },
    {
        "number": 264,
        "title": "Ugly Number II",
        "difficulty": 1,
        "answer": "        ugly = [1]\n        i2, i3, i5 = 0, 0, 0\n        while len(ugly) < n:\n            while ugly[i2] * 2 <= ugly[-1]:\n                i2 += 1\n            while ugly[i3] * 3 <= ugly[-1]:\n                i3 += 1\n            while ugly[i5] * 5 <= ugly[-1]:\n                i5 += 1\n            ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))\n        return ugly[-1]"
    },
    {
        "number": 268,
        "title": "Missing Number",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)"
    },
    {
        "number": 273,
        "title": "Integer to English Words",
        "difficulty": 2,
        "answer": "        if num == 0:\n            return \"Zero\"\n        \n        def one(num):\n            switcher = {\n                1: \"One\",\n                2: \"Two\",\n                3: \"Three\",\n                4: \"Four\",\n                5: \"Five\",\n                6: \"Six\",\n                7: \"Seven\",\n                8: \"Eight\",\n                9: \"Nine\",\n                10: \"Ten\",\n                11: \"Eleven\",\n                12: \"Twelve\",\n                13: \"Thirteen\",\n                14: \"Fourteen\",\n                15: \"Fifteen\",\n                16: \"Sixteen\",\n                17: \"Seventeen\",\n                18: \"Eighteen\",\n                19: \"Nineteen\",\n            }\n            return switcher.get(num)\n        \n        def two_less_20(num):\n            switcher = {\n                10: \"Ten\",\n                11: \"Eleven\",\n                12: \"Twelve\",\n                13: \"Thirteen\",\n                14: \"Fourteen\",\n                15: \"Fifteen\",\n"
    },
    {
        "number": 274,
        "title": "H-Index",
        "difficulty": 1,
        "answer": "        # \u6392\u5e8f\n        # citations.sort()\n        # n = len(citations)\n        # for i in range(n):\n        #     if citations[i] >= n - i:\n        #         return n - i\n        # return 0"
    },
    {
        "number": 275,
        "title": "H-Index II",
        "difficulty": 1,
        "answer": "        if not citations:\n            return 0\n        n = len(citations)\n        l, r = 0, n - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if citations[mid] >= n - mid:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return n - l"
    },
    {
        "number": 278,
        "title": "First Bad Version",
        "difficulty": 0,
        "answer": "        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 279,
        "title": "Perfect Squares",
        "difficulty": 1,
        "answer": "        if n < 2:\n            return n\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        for i in range(2, n + 1):\n            j = 1\n            while j * j <= i:\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n        return dp[-1]"
    },
    {
        "number": 282,
        "title": "Expression Add Operators",
        "difficulty": 2,
        "answer": "        self.res = []\n        self.target = target\n        self.dfs(num, 0, 0, 0, 0, '')\n        return self.res"
    },
    {
        "number": 283,
        "title": "Move Zeroes",
        "difficulty": 0,
        "answer": "        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n        # two pointer\n"
    },
    {
        "number": 284,
        "title": "Peeking Iterator",
        "difficulty": 1,
        "answer": "        self.iter = iter(iterable)\n        self.cache = []"
    },
    {
        "number": 287,
        "title": "Find the Duplicate Number",
        "difficulty": 1,
        "answer": "        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        slow = nums[0]\n        while slow!= fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow"
    },
    {
        "number": 289,
        "title": "Game of Life",
        "difficulty": 1,
        "answer": "        if not board:\n            return\n        m, n = len(board), len(board[0])\n        for i in range(m):\n            for j in range(n):\n                count = 0\n                for x, y in [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]:\n                    if 0 <= x < m and 0 <= y < n and abs(board[x][y]) == 1:\n                        count += 1\n                if board[i][j] == 1 and (count < 2 or count > 3):\n                    board[i][j] = -1\n                if board[i][j] == 0 and count == 3:\n                    board[i][j] = 2\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] > 0:\n                    board[i][j] = 1\n                "
    },
    {
        "number": 290,
        "title": "Word Pattern",
        "difficulty": 0,
        "answer": "        words = s.split()\n        if len(words)!= len(pattern):\n            return False\n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] not in d:\n                if words[i] in d.values():\n                    return False\n                d[pattern[i]] = words[i]\n            else:\n                if d[pattern[i]]!= words[i]:\n                    return False\n        return True"
    },
    {
        "number": 292,
        "title": "Nim Game",
        "difficulty": 0,
        "answer": "        return n % 4!= 0"
    },
    {
        "number": 295,
        "title": "Find Median from Data Stream",
        "difficulty": 2,
        "answer": "        self.arr = []\n        self.len = 0\n        self.median = None\n        \n    def addNum(self, num: int) -> None:\n        self.arr.append(num)\n        self.len += 1\n        self.arr.sort()\n        if self.len % 2 == 0:\n            self.median = (self.arr[self.len//2] + self.arr[self.len//2 - 1]) / 2\n        else:\n            self.median = self.arr[self.len//2]\n        \n    def findMedian(self) -> float:\n        \"\"\"\n        The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n            For example, for arr = [2,3,4], the median is 3.\n            For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n        Implement the MedianFinder class:\n            MedianFinder"
    },
    {
        "number": 297,
        "title": "Serialize and Deserialize Binary Tree",
        "difficulty": 2,
        "answer": "        if not root:\n            return '[]'\n        queue = [root]\n        res = []\n        while queue:\n            node = queue.pop(0)\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append('null')\n        return '[' + ','.join(res) + ']'"
    },
    {
        "number": 299,
        "title": "Bulls and Cows",
        "difficulty": 1,
        "answer": "        bulls, cows = 0, 0\n        secret_dict = {}\n        guess_dict = {}\n        for i in range(len(secret)):\n            if secret[i] == guess[i]:\n                bulls += 1\n            else:\n                if secret[i] not in secret_dict:\n                    secret_dict[secret[i]] = 1\n                else:\n                    secret_dict[secret[i]] += 1\n                if guess[i] not in guess_dict:\n                    guess_dict[guess[i]] = 1\n                else:\n                    guess_dict[guess[i]] += 1\n        for key in secret_dict:\n            if key in guess_dict:\n                cows += min(secret_dict[key], guess_dict[key])\n        return str(bulls) + 'A' + str(cows) + 'B'"
    },
    {
        "number": 300,
        "title": "Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 301,
        "title": "Remove Invalid Parentheses",
        "difficulty": 2,
        "answer": "        # \u5224\u65ad\u662f\u5426\u6709\u6548\n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    cnt -= 1\n                    if cnt < 0:\n                        return False\n            return cnt == 0"
    },
    {
        "number": 303,
        "title": "Range Sum Query - Immutable",
        "difficulty": 0,
        "answer": "        self.nums = nums\n        self.prefix_sum = [0]\n        for num in nums:\n            self.prefix_sum.append(self.prefix_sum[-1] + num)\n        self.prefix_sum = self.prefix_sum[1:]"
    },
    {
        "number": 304,
        "title": "Range Sum Query 2D - Immutable",
        "difficulty": 1,
        "answer": "        self.matrix = matrix\n        self.row = len(matrix)\n        self.col = len(matrix[0])\n        self.dp = [[0 for _ in range(self.col + 1)] for _ in range(self.row + 1)]\n        for i in range(1, self.row + 1):\n            for j in range(1, self.col + 1):\n                self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] + self.matrix[i - 1][j - 1]"
    },
    {
        "number": 306,
        "title": "Additive Number",
        "difficulty": 1,
        "answer": "        def isValid(nums):\n            if len(nums) < 3:\n                return False\n            for i in range(1, len(nums)):\n                if nums[i] == '0' and nums[i-1] == '0':\n                    return False\n                if nums[i-1]!= '0' and nums[i] == '0':\n                    return False\n                if nums[i-1] == '0' and nums[i]!= '0':\n                    return False\n                if int(nums[i-1]) + int(nums[i])!= int(nums[i]):\n                    return False\n            return True\n        \n        for i in range(1, len(num)):\n            for j in range(i+1, len(num)):\n                if num[0] == '0' or num[i] == '0' or num[j] == '0':\n                    continue\n                nums = [num[0], num[i], num[j]]\n                if isValid(nums):"
    },
    {
        "number": 307,
        "title": "Range Sum Query - Mutable",
        "difficulty": 1,
        "answer": "        self.nums = nums\n        self.n = len(nums)\n        self.tree = [0] * (self.n + 1)\n        self.build_tree()\n        \n    def build_tree(self):\n        for i in range(self.n):\n            self.update(i, self.nums[i])\n        \n    def update(self, index: int, val: int) -> None:\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self.update_tree(index, diff)\n        \n    def update_tree(self, index: int, diff: int):\n        index += 1\n        while index <= self.n:\n            self.tree[index] += diff\n            index += index & (-index)\n            \n    def sumRange(self, left: int, right: int) -> int:\n        return self.sum_range(left, right, 1)"
    },
    {
        "number": 309,
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": 1,
        "answer": "        if not prices:\n            return 0\n        n = len(prices)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\n        return dp[-1][0]"
    },
    {
        "number": 310,
        "title": "Minimum Height Trees",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [0]\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        leaves = [i for i in range(n) if len(graph[i]) == 1]\n        while n > 2:\n            n -= len(leaves)\n            new_leaves = []\n            for leaf in leaves:\n                neighbor = graph[leaf].pop()\n                graph[neighbor].remove(leaf)\n                if len(graph[neighbor]) == 1:\n                    new_leaves.append(neighbor)\n            leaves = new_leaves\n        return leaves"
    },
    {
        "number": 312,
        "title": "Burst Balloons",
        "difficulty": 2,
        "answer": "        nums = [1, *nums, 1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                for i in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right],\n                                          dp[left][i] + dp[i][right] + nums[left] * nums[i] * nums[right])\n        return dp[0][n - 1]"
    },
    {
        "number": 313,
        "title": "Super Ugly Number",
        "difficulty": 1,
        "answer": "        import heapq\n        heap = [1]\n        visited = set()\n        for _ in range(n):\n            curr_ugly = heapq.heappop(heap)\n            for prime in primes:\n                new_ugly = curr_ugly * prime\n                if new_ugly not in visited:\n                    visited.add(new_ugly)\n                    heapq.heappush(heap, new_ugly)\n        return curr_ugly"
    },
    {
        "number": 315,
        "title": "Count of Smaller Numbers After Self",
        "difficulty": 2,
        "answer": "        def sort(enum):\n            half = len(enum) // 2\n            if half:\n                left, right = sort(enum[:half]), sort(enum[half:])\n                for i in range(len(enum))[::-1]:\n                    if not right or left and left[-1][1] > right[-1][1]:\n                        smaller[left[-1][0]] += len(right)\n                        enum[i] = left.pop()\n                    else:\n                        enum[i] = right.pop()\n            return enum\n        smaller = [0] * len(nums)\n        sort(list(enumerate(nums)))\n        return smaller"
    },
    {
        "number": 316,
        "title": "Remove Duplicate Letters",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in s:\n            if c not in stack:\n                while stack and c < stack[-1] and stack[-1] in s:\n                    stack.pop()\n                stack.append(c)\n        return ''.join(stack)"
    },
    {
        "number": 318,
        "title": "Maximum Product of Word Lengths",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = {}\n        # for word in words:\n        #     dp[word] = len(word)\n        # ans = 0\n        # for i in range(len(words)):\n        #     for j in range(i+1, len(words)):\n        #         if not set(words[i]) & set(words[j]):\n        #             ans = max(ans, dp[words[i]]*dp[words[j]])\n        # return ans"
    },
    {
        "number": 319,
        "title": "Bulb Switcher",
        "difficulty": 1,
        "answer": "        return int(n**0.5)"
    },
    {
        "number": 321,
        "title": "Create Maximum Number",
        "difficulty": 2,
        "answer": "        m, n = len(nums1), len(nums2)\n        if m == 0:\n            return [0] * k\n        if n == 0:\n            return [0] * k\n        if k == 0:\n            return []\n        if k == 1:\n            return [max(nums1[0], nums2[0])]\n        if k == 2:\n            return [max(nums1[0] * 10 + nums1[1], nums2[0] * 10 + nums2[1])]\n        if k == 3:\n            return [max(nums1[0] * 100 + nums1[1] * 10 + nums1[2], nums2[0] * 100 + nums2[1] * 10 + nums2[2])]\n        if k == 4:\n            return [max(nums1[0] * 1000 + nums1[1] * 100 + nums1[2] * 10 + nums1[3], nums2[0] * 1000 + nums2[1"
    },
    {
        "number": 322,
        "title": "Coin Change",
        "difficulty": 1,
        "answer": "        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n        return dp[amount] if dp[amount]!= float('inf') else -1"
    },
    {
        "number": 324,
        "title": "Wiggle Sort II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        mid = len(nums) // 2\n        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]"
    },
    {
        "number": 326,
        "title": "Power of Three",
        "difficulty": 0,
        "answer": "        if n < 1:\n            return False\n        while n % 3 == 0:\n            n /= 3\n        return n == 1"
    },
    {
        "number": 327,
        "title": "Count of Range Sum",
        "difficulty": 2,
        "answer": "        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix sum\n        # O(n)\n        # O(n)\n        # prefix"
    },
    {
        "number": 328,
        "title": "Odd Even Linked List",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        if not head:\n            return head\n        odd = head\n        even = head.next\n        even_head = head.next\n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        odd.next = even_head\n        return head"
    },
    {
        "number": 329,
        "title": "Longest Increasing Path in a Matrix",
        "difficulty": 2,
        "answer": "        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 1\n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, i, j, dp))\n        return res"
    },
    {
        "number": 330,
        "title": "Patching Array",
        "difficulty": 2,
        "answer": "        i, j = 0, 1\n        res = 0\n        while i < len(nums) and j <= n:\n            if nums[i] <= j:\n                j += nums[i]\n                i += 1\n            else:\n                j += j\n                res += 1\n        return res + (j - n)"
    },
    {
        "number": 331,
        "title": "Verify Preorder Serialization of a Binary Tree",
        "difficulty": 1,
        "answer": "        preorder = preorder.split(\",\")\n        stack = []\n        for i in preorder:\n            if i!= \"#\":\n                stack.append(i)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack"
    },
    {
        "number": 332,
        "title": "Reconstruct Itinerary",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets)[::-1]:\n            graph[a].append(b)"
    },
    {
        "number": 334,
        "title": "Increasing Triplet Subsequence",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False"
    },
    {
        "number": 335,
        "title": "Self Crossing",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if len(distance) < 4:\n        #     return False\n        # for i in range(3, len(distance)):\n        #     if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n        #         return True\n        #     if i >= 4 and distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n        #         return True\n        # return False"
    },
    {
        "number": 336,
        "title": "Palindrome Pairs",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        # hashmap = {}\n        # for i, word in enumerate(words):\n        #     hashmap[word] = i\n        # ans = []\n        # for i, word in enumerate(words):\n        #     for j in range(len(word) + 1):\n        #         pre, post = word[:j], word[j:]\n        #         if pre == pre[::-1] and post[::-1] in hashmap and hashmap[post[::-1]]!= i:\n        #             ans.append([i, hashmap[post[::-1]]])\n        #         if post == post[::-1] and pre[::-1] in hashmap and hashmap[pre[::-1]]!= i:\n        #             ans.append([hashmap[pre[::-1]], i])\n        # return ans"
    },
    {
        "number": 337,
        "title": "House Robber III",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node: return 0, 0\n            left, right = dfs(node.left), dfs(node.right)\n            return max(left) + max(right), node.val + left[0] + right[0]\n        return max(dfs(root))"
    },
    {
        "number": 338,
        "title": "Counting Bits",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return [0]\n        if n == 1:\n            return [0, 1]\n        if n == 2:\n            return [0, 1, 1]\n        if n == 3:\n            return [0, 1, 1, 2]\n        if n == 4:\n            return [0, 1, 1, 2, 1, 2]\n        if n == 5:\n            return [0, 1, 1, 2, 1, 2, 2]\n        if n == 6:\n            return [0, 1, 1, 2, 1, 2, 2, 3]\n        if n == 7:\n            return [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3]\n        if n == 8:\n            return [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]\n        if n == 9:\n            return [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3"
    },
    {
        "number": 341,
        "title": "Flatten Nested List Iterator",
        "difficulty": 1,
        "answer": "        self.stack = []\n        for i in nestedList:\n            self.stack.append(i)\n        self.next_num = 0"
    },
    {
        "number": 342,
        "title": "Power of Four",
        "difficulty": 0,
        "answer": "        if n < 1:\n            return False\n        while n % 4 == 0:\n            n /= 4\n        return n == 1"
    },
    {
        "number": 343,
        "title": "Integer Break",
        "difficulty": 1,
        "answer": "        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 4\n        if n == 5:\n            return 6\n        if n == 6:\n            return 9\n        if n == 7:\n            return 36\n        if n == 8:\n            return 40\n        if n == 9:\n            return 81\n        if n == 10:\n            return 36\n        if n == 11:\n            return 36\n        if n == 12:\n            return 36\n        if n == 13:\n            return 36\n        if n == 14:\n            return 36\n        if n == 15:\n            return 36\n        if n == 16:\n            return 36\n        if n == 17:\n            return 36\n        if n == 18:\n            return 36\n        if n == 19:\n            return 36\n        if n == 20:\n            return 36\n        if n == 21:\n            return 36\n        if n == 22:\n            return 36\n        if n == 23:\n            return 36\n        if n == 24:\n            "
    },
    {
        "number": 344,
        "title": "Reverse String",
        "difficulty": 0,
        "answer": "        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"
    },
    {
        "number": 345,
        "title": "Reverse Vowels of a String",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"
    },
    {
        "number": 347,
        "title": "Top K Frequent Elements",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        if k == len(nums):\n            return nums\n        freq = {}\n        for num in nums:\n            if num in freq:\n                freq[num] += 1\n            else:\n                freq[num] = 1\n        freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n        return [freq[i][0] for i in range(k)]"
    },
    {
        "number": 349,
        "title": "Intersection of Two Arrays",
        "difficulty": 0,
        "answer": "        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return list(set(nums1) & set(nums2))\n        # return"
    },
    {
        "number": 350,
        "title": "Intersection of Two Arrays II",
        "difficulty": 0,
        "answer": "        # nums1 = [4,9,5]\n        # nums2 = [9,4,9,8,4]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 = [2,2]\n        # nums1 = [1,2,2,1]\n        # nums2 ="
    },
    {
        "number": 352,
        "title": "Data Stream as Disjoint Intervals",
        "difficulty": 2,
        "answer": "        self.arr = []\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)\n        self.arr.sort()\n        self.arr.append(value)"
    },
    {
        "number": 354,
        "title": "Russian Doll Envelopes",
        "difficulty": 2,
        "answer": "        # sort by width, then height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [1] * len(envelopes)\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 355,
        "title": "Design Twitter",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 357,
        "title": "Count Numbers with Unique Digits",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return 10\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 10\n        for i in range(2, n + 1):\n            dp[i] = dp[i - 1] * (11 - i)\n        return sum(dp)"
    },
    {
        "number": 363,
        "title": "Max Sum of Rectangle No Larger Than K",
        "difficulty": 2,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    matrix[i][j] += matrix[i - 1][j]\n                if j > 0:\n                    matrix[i][j] += matrix[i][j - 1]\n                if i > 0 and j > 0:\n                    matrix[i][j] -= matrix[i - 1][j - 1]\n                for x in range(i, m):\n                    for y in range(j, n):\n                        if matrix[i][j] - matrix[x][y] <= k:\n                            res = max(res, matrix[i][j])\n        return res"
    },
    {
        "number": 365,
        "title": "Water and Jug Problem",
        "difficulty": 1,
        "answer": "        if jug1Capacity + jug2Capacity < targetCapacity:\n            return False\n        if jug1Capacity == 0 or jug2Capacity == 0:\n            return targetCapacity == 0\n        if targetCapacity == 0:\n            return True\n        if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity:\n            return True\n        if jug1Capacity > targetCapacity:\n            return self.canMeasureWater(jug1Capacity - targetCapacity, jug2Capacity, targetCapacity)\n        if jug2Capacity > targetCapacity:\n            return self.canMeasureWater(jug1Capacity, jug2Capacity - targetCapacity, targetCapacity)\n        return False"
    },
    {
        "number": 367,
        "title": "Valid Perfect Square",
        "difficulty": 0,
        "answer": "        if num == 1:\n            return True\n        left, right = 1, num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"
    },
    {
        "number": 368,
        "title": "Largest Divisible Subset",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        nums.sort()\n        dp = [[num] for num in nums]\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and len(dp[i]) < len(dp[j]) + 1:\n                    dp[i] = dp[j] + [nums[i]]\n        return max(dp, key=len)"
    },
    {
        "number": 371,
        "title": "Sum of Two Integers",
        "difficulty": 1,
        "answer": "        # 32 bits integer max\n        MAX = 0x7FFFFFFF\n        # 32 bits interger min\n        MIN = 0x80000000\n        # mask to get last 32 bits\n        mask = 0xFFFFFFFF\n        while b!= 0:\n            # ^ get different bits and & gets double 1s, << moves carry\n            a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n        # if a is negative, get a's 32 bits complement positive first\n        # then get 32-bit positive's Python complement negative\n        return a if a <= MAX else ~(a ^ mask)"
    },
    {
        "number": 372,
        "title": "Super Pow",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\n        # 1. \u5148\u628ab\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u5b57\uff0c\u7136\u540e\ufffd"
    },
    {
        "number": 373,
        "title": "Find K Pairs with Smallest Sums",
        "difficulty": 1,
        "answer": "        # \u53cc\u6307\u9488\n        # \u5148\u6392\u5e8f\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488\n        # \u53cc\u6307\u9488"
    },
    {
        "number": 374,
        "title": "Guess Number Higher or Lower",
        "difficulty": 0,
        "answer": "        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if guess(mid) == 0:\n                return mid\n            elif guess(mid) == -1:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1"
    },
    {
        "number": 375,
        "title": "Guess Number Higher or Lower II",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + max(dp[i][j-1] - k, 0))\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + max(dp[i][j-1] - k, 0))\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + max(dp[i][j-1] - k, 0))\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + max(dp[i][j-1] - k, 0))\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j-1] + max(dp[i][j-1] - k, 0))\n        # dp[i][j] ="
    },
    {
        "number": 376,
        "title": "Wiggle Subsequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 2:\n            return n\n        up = [1] * n\n        down = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    up[i] = max(up[i], down[j] + 1)\n                elif nums[i] < nums[j]:\n                    down[i] = max(down[i], up[j] + 1)\n        return max(up[-1], down[-1])"
    },
    {
        "number": 377,
        "title": "Combination Sum IV",
        "difficulty": 1,
        "answer": "        dp = [0] * (target + 1)\n        dp[0] = 1\n        for i in range(1, target + 1):\n            for num in nums:\n                if i >= num:\n                    dp[i] += dp[i - num]\n        return dp[-1]"
    },
    {
        "number": 378,
        "title": "Kth Smallest Element in a Sorted Matrix",
        "difficulty": 1,
        "answer": "        # binary search\n        # time complexity: O(nlogk)\n        # space complexity: O(1)\n        n = len(matrix)\n        left, right = matrix[0][0], matrix[n-1][n-1]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            for i in range(n):\n                count += bisect.bisect_right(matrix[i], mid)\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
    },
    {
        "number": 380,
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": 1,
        "answer": "        self.nums = []\n        self.val_to_idx = {}\n        return self.insert(val)"
    },
    {
        "number": 381,
        "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
        "difficulty": 2,
        "answer": "        self.dic = {}\n        self.lst = []\n        self.count = 0\n        return None"
    },
    {
        "number": 382,
        "title": "Linked List Random Node",
        "difficulty": 1,
        "answer": "        self.head = head\n        self.n = 0\n        while head:\n            self.n += 1\n            head = head.next\n        self.cur = 0\n        return self.getRandom()"
    },
    {
        "number": 383,
        "title": "Ransom Note",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        ransomNote_dict = {}\n        magazine_dict = {}\n        for c in ransomNote:\n            if c not in ransomNote_dict:\n                ransomNote_dict[c] = 1\n            else:\n                ransomNote_dict[c] += 1\n        for c in magazine:\n            if c not in magazine_dict:\n                magazine_dict[c] = 1\n            else:\n                magazine_dict[c] += 1\n        for key in ransomNote_dict:\n            if key not in magazine_dict or ransomNote_dict[key] > magazine_dict[key]:\n                return False\n        return True"
    },
    {
        "number": 384,
        "title": "Shuffle an Array",
        "difficulty": 1,
        "answer": "        import random\n        return random.sample(nums, len(nums))"
    },
    {
        "number": 385,
        "title": "Mini Parser",
        "difficulty": 1,
        "answer": "        if not s:\n            return NestedInteger()\n        stack = []\n        i = 0\n        while i < len(s):\n            if s[i] == '[':\n                stack.append(NestedInteger())\n                i += 1\n            elif s[i] == ']':\n                if stack:\n                    stack[-1].add(stack.pop())\n                i += 1\n            elif s[i] == ',':\n                if stack:\n                    stack[-1].add(stack.pop())\n                i += 1\n            else:\n                num = 0\n                while i < len(s) and s[i] in '1234567890':\n                    num = num * 10 + int(s[i])\n                    i += 1\n                if stack:\n                    stack[-1].add(NestedInteger(num))\n                else:\n                    stack.append(NestedInteger(num))\n        return stack[0]"
    },
    {
        "number": 386,
        "title": "Lexicographical Numbers",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # res = []\n        # for i in range(1, n+1):\n        #     res.append(i)\n        # return sorted(res)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # res = []\n        # for i in range(1, n+1):\n        #     res.append(i)\n        # return sorted(res)\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(1)\n        # res = []\n        # for i in range(1, n+1):\n        #     res.append(i)\n        # return sorted(res)\n        \n        # Solution 4:\n        # Time: O(n)\n        # Space: O(1)\n        # res = []\n        # for i in range(1, n+1):\n        #     res.append(i)\n        #"
    },
    {
        "number": 387,
        "title": "First Unique Character in a String",
        "difficulty": 0,
        "answer": "        d = {}\n        for i in s:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in range(len(s)):\n            if d[s[i]] == 1:\n                return i\n        return -1"
    },
    {
        "number": 388,
        "title": "Longest Absolute File Path",
        "difficulty": 1,
        "answer": "        # split the input into lines\n        lines = input.split('\\n')\n        # initialize the longest path length\n        longest_path_length = 0\n        # initialize the current path length\n        current_path_length = 0\n        # initialize the current path\n        current_path = ''\n        # iterate through the lines\n        for line in lines:\n            # if the line is a directory\n            if '.' not in line:\n                # add the directory to the current path\n                current_path += line + '/'\n                # increment the current path length\n                current_path_length += len(line) + 1\n            # if the line is a file\n            else:\n                # add the file to the current path\n                current_path += line\n                # increment the current path length\n                current_path_length += len(line)\n            # if the current path length is greater than the longest path length\n            if current_path_length > longest_path_length:\n                # update the longest path length\n                longest_path_length = current_path_length\n                # update the current"
    },
    {
        "number": 389,
        "title": "Find the Difference",
        "difficulty": 0,
        "answer": "        s_dict = {}\n        t_dict = {}\n        for i in s:\n            if i in s_dict:\n                s_dict[i] += 1\n            else:\n                s_dict[i] = 1\n        for i in t:\n            if i in t_dict:\n                t_dict[i] += 1\n            else:\n                t_dict[i] = 1\n        for i in t_dict:\n            if i not in s_dict:\n                return i\n            elif t_dict[i] > s_dict[i]:\n                return i"
    },
    {
        "number": 390,
        "title": "Elimination Game",
        "difficulty": 1,
        "answer": "        return 1 if n == 1 else 2 * (n // 2 + 1 - self.lastRemaining(n // 2))"
    },
    {
        "number": 391,
        "title": "Perfect Rectangle",
        "difficulty": 2,
        "answer": "        # get the min and max x and y\n        min_x = min(rect[0] for rect in rectangles)\n        max_x = max(rect[0] + rect[2] for rect in rectangles)\n        min_y = min(rect[1] for rect in rectangles)\n        max_y = max(rect[1] + rect[3] for rect in rectangles)\n        # get the total area\n        total_area = (max_x - min_x) * (max_y - min_y)\n        # get the covered area\n        covered_area = 0\n        # get the set of points\n        points = set()\n        for rect in rectangles:\n            points.add((rect[0], rect[1]))\n            points.add((rect[0] + rect[2], rect[1]))\n            points.add((rect[0], rect[1] + rect[3]))\n            points.add((rect[0] + rect[2], rect[1] + rect[3]))\n        # check if the points are all covered"
    },
    {
        "number": 392,
        "title": "Is Subsequence",
        "difficulty": 0,
        "answer": "        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"
    },
    {
        "number": 393,
        "title": "UTF-8 Validation",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(n)\n        # Space complexity: O(1)\n        # n = len(data)\n        # if n == 0:\n        #     return True\n        # for i in range(n):\n        #     if i + 1 < n:\n        #         if data[i] >> 6!= 0b10:\n        #             return False\n        #     if i + 2 < n:\n        #         if data[i] >> 4!= 0b1110:\n        #             return False\n        #     if i + 3 < n:\n        #         if data[i] >> 2!= 0b11110:\n        #             return False\n        # return True"
    },
    {
        "number": 394,
        "title": "Decode String",
        "difficulty": 1,
        "answer": "        # stack = []\n        # i = 0\n        # while i < len(s):\n        #     if s[i] == ']':\n        #         tmp = ''\n        #         while stack[-1]!= '[':\n        #             tmp = stack.pop() + tmp\n        #         stack.pop()\n        #         k = ''\n        #         while stack and stack[-1].isdigit():\n        #             k = stack.pop() + k\n        #         stack.append(tmp * int(k))\n        #     else:\n        #         stack.append(s[i])\n        #     i += 1\n        # return ''.join(stack)"
    },
    {
        "number": 395,
        "title": "Longest Substring with At Least K Repeating Characters",
        "difficulty": 1,
        "answer": "        if len(s) < k:\n            return 0\n        for c in set(s):\n            if s.count(c) < k:\n                return max(self.longestSubstring(t, k) for t in s.split(c))\n        return len(s)"
    },
    {
        "number": 396,
        "title": "Rotate Function",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        s = sum(nums)\n        res = 0\n        for i in range(n):\n            res += i * nums[i]\n        max_val = res\n        for i in range(1, n):\n            res = res + s - n * nums[n - i]\n            max_val = max(max_val, res)\n        return max_val"
    },
    {
        "number": 397,
        "title": "Integer Replacement",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n % 2 == 0:\n            return self.integerReplacement(n // 2) + 1\n        else:\n            return min(self.integerReplacement(n + 1), self.integerReplacement(n - 1)) + 1"
    },
    {
        "number": 398,
        "title": "Random Pick Index",
        "difficulty": 1,
        "answer": "        import random\n        return random.choice([i for i, x in enumerate(self.nums) if x == target])"
    },
    {
        "number": 399,
        "title": "Evaluate Division",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for (x, y), v in zip(equations, values):\n            graph[x].append((y, v))\n            graph[y].append((x, 1 / v))"
    },
    {
        "number": 400,
        "title": "Nth Digit",
        "difficulty": 1,
        "answer": "        if n < 10:\n            return n\n        n -= 9\n        m = 1\n        while n >= m * 9 * 10 ** (m - 1):\n            n -= m * 9 * 10 ** (m - 1)\n            m += 1\n        num = 10 ** (m - 1) + n // m\n        return int(str(num)[n % m])"
    },
    {
        "number": 401,
        "title": "Binary Watch",
        "difficulty": 0,
        "answer": "        if turnedOn == 0:\n            return [\"0:00\"]\n        if turnedOn == 1:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        if turnedOn == 2:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        if turnedOn == 3:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        if turnedOn == 4:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        if turnedOn == 5:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08"
    },
    {
        "number": 402,
        "title": "Remove K Digits",
        "difficulty": 1,
        "answer": "        if k >= len(num):\n            return '0'\n        stack = []\n        for i in range(len(num)):\n            while k > 0 and stack and stack[-1] > num[i]:\n                stack.pop()\n                k -= 1\n            stack.append(num[i])\n        while k > 0:\n            stack.pop()\n            k -= 1\n        return ''.join(stack).lstrip('0') or '0'"
    },
    {
        "number": 403,
        "title": "Frog Jump",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] or dp[i-2] or dp[i-3]\n        # dp[i] = dp[i-1] and (stones[i] - stones[i-1] == 1 or stones[i] - stones[i-1] == 2 or stones[i] - stones[i-1] == 3)\n        # dp[i] = dp[i-2] and (stones[i] - stones[i-2] == 1 or stones[i] - stones[i-2] == 2 or stones[i] - stones[i-2] == 3)\n        # dp[i] = dp[i-3] and (stones[i] - stones[i-3] == 1 or stones[i] - stones[i-3] == 2 or stones[i] - stones[i-3] == 3)\n        # dp[i] = dp[i-1] and (stones[i] - stones[i-1] == 1 or stones[i] - stones["
    },
    {
        "number": 404,
        "title": "Sum of Left Leaves",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)\n"
    },
    {
        "number": 405,
        "title": "Convert a Number to Hexadecimal",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return '0'\n        elif num < 0:\n            num = 2**32 + num\n        res = ''\n        while num:\n            res = self.to_hex(num % 16) + res\n            num //= 16\n        return res"
    },
    {
        "number": 406,
        "title": "Queue Reconstruction by Height",
        "difficulty": 1,
        "answer": "        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res"
    },
    {
        "number": 407,
        "title": "Trapping Rain Water II",
        "difficulty": 2,
        "answer": "        if not heightMap or not heightMap[0]:\n            return 0\n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        pq = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                    visited[i][j] = True\n                    heapq.heappush(pq, (heightMap[i][j], i, j))\n        res = 0\n        while pq:\n            height, i, j = heapq.heappop(pq)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                    res += max(0, height - heightMap[x][y])\n                    visited[x][y] = True\n"
    },
    {
        "number": 409,
        "title": "Longest Palindrome",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        d = {}\n        for c in s:\n            d[c] = d.get(c, 0) + 1\n        res = 0\n        odd = False\n        for k, v in d.items():\n            if v % 2 == 0:\n                res += v\n            else:\n                res += v - 1\n                odd = True\n        return res + 1 if odd else res"
    },
    {
        "number": 410,
        "title": "Split Array Largest Sum",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], max(nums[i:j+1])\n        # dp[i][j] = min(dp[i][j], sum(nums[i:j+1]) - min(nums[i:j+1]))\n        # dp[i][j] = min(dp[i][j], sum(nums[i:j+1]) - max(nums[i:j+1]))\n        # dp[i][j] = min(dp[i][j], sum(nums[i:j+1]) - sum(nums[i:j+1]) / k)\n        # dp[i][j] = min(dp[i][j], sum(nums[i:j+1]) - sum(nums[i:j+1]) / k)\n        # dp[i][j"
    },
    {
        "number": 412,
        "title": "Fizz Buzz",
        "difficulty": 0,
        "answer": "        # Solution 1 - 36 ms\n        \"\"\"\n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n        \"\"\"\n        # Solution 2 - 16 ms\n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"
    },
    {
        "number": 413,
        "title": "Arithmetic Slices",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n        return sum(dp)"
    },
    {
        "number": 414,
        "title": "Third Maximum Number",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # nums = set(nums)\n        # if len(nums) < 3:\n        #     return max(nums)\n        # nums.remove(max(nums))\n        # nums.remove(max(nums))\n        # return max(nums)\n        \n        # Solution 2:\n        # O(n) time\n        # O(1) space\n        # nums = set(nums)\n        # if len(nums) < 3:\n        #     return max(nums)\n        # nums.remove(max(nums))\n        # nums.remove(max(nums))\n        # return max(nums)\n        \n        # Solution 3:\n        # O(n) time\n        # O(n) space\n        # nums = set(nums)\n        # if len(nums) < 3:\n        #     return max(nums)\n        # nums.remove(max("
    },
    {
        "number": 415,
        "title": "Add Strings",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # num1 = num1[::-1]\n        # num2 = num2[::-1]\n        # res = []\n        # carry = 0\n        # for i in range(max(len(num1), len(num2))):\n        #     n1 = ord(num1[i]) - ord('0') if i < len(num1) else 0\n        #     n2 = ord(num2[i]) - ord('0') if i < len(num2) else 0\n        #     s = n1 + n2 + carry\n        #     res.append(s % 10)\n        #     carry = s // 10\n        # if carry:\n        #     res.append(carry)\n        # return ''.join(str(x) for x in res[::-1])"
    },
    {
        "number": 416,
        "title": "Partition Equal Subset Sum",
        "difficulty": 1,
        "answer": "        if sum(nums) % 2!= 0:\n            return False\n        target = sum(nums) // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for num in nums:\n            for i in range(target, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        return dp[-1]"
    },
    {
        "number": 417,
        "title": "Pacific Atlantic Water Flow",
        "difficulty": 1,
        "answer": "        m, n = len(heights), len(heights[0])\n        p_visited = [[False for _ in range(n)] for _ in range(m)]\n        a_visited = [[False for _ in range(n)] for _ in range(m)]\n        p_queue = deque()\n        a_queue = deque()\n        for i in range(m):\n            p_queue.append((i, 0))\n            a_queue.append((i, n - 1))\n            p_visited[i][0] = True\n            a_visited[i][n - 1] = True\n        for j in range(n):\n            p_queue.append((0, j))\n            a_queue.append((m - 1, j))\n            p_visited[0][j] = True\n            a_visited[m - 1][j] = True\n        p_queue = deque(sorted(p_queue))\n        a_queue = deque(sorted(a_queue))\n        res = []\n        while p_queue"
    },
    {
        "number": 419,
        "title": "Battleships in a Board",
        "difficulty": 1,
        "answer": "        # Solution 1: DFS\n        # Time complexity: O(m * n)\n        # Space complexity: O(m * n)\n        # m, n = len(board), len(board[0])\n        # def dfs(i, j):\n        #     if i < 0 or i >= m or j < 0 or j >= n or board[i][j]!= 'X':\n        #         return\n        #     board[i][j] = '.'\n        #     dfs(i + 1, j)\n        #     dfs(i - 1, j)\n        #     dfs(i, j + 1)\n        #     dfs(i, j - 1)\n        # count = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if board[i][j] == 'X':\n        #             dfs(i, j)\n        #             count += 1\n        # return count"
    },
    {
        "number": 420,
        "title": "Strong Password Checker",
        "difficulty": 2,
        "answer": "        # \u5206\u6790\uff1a\n        # 1. \u5bf9\u4e8e\u6bcf\u4e2a\u5b57\u7b26\uff0c\u90fd\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n        #   1. \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26\n        #   2. \u5220\u9664\u4e00\u4e2a\u5b57\u7b26\n        #   3. \u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b57\u7b26\uff0c\u90fd\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n        #   1. \u63d2\u5165\u4e00\u4e2a\u5b57\u7b26\n        #   2. \u5220\u9664\u4e00\u4e2a\u5b57\u7b26\n        #   3. \u66ff\u6362\u4e00\u4e2a\u5b57\u7b26\n        # 3. \u5bf9\u4e8e\u6bcf\u4e2a\u5b57\u7b26\uff0c\u90fd\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n        #   1. \ufffd"
    },
    {
        "number": 421,
        "title": "Maximum XOR of Two Numbers in an Array",
        "difficulty": 1,
        "answer": "        max_xor = 0\n        for i in range(32):\n            max_xor <<= 1\n            curr_xor = 0\n            for num in nums:\n                if num & (1 << i):\n                    curr_xor ^= max_xor\n                else:\n                    curr_xor ^= num\n            max_xor = max(max_xor, curr_xor)\n        return max_xor"
    },
    {
        "number": 423,
        "title": "Reconstruct Original Digits from English",
        "difficulty": 1,
        "answer": "        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c\u6362\u6210\u6570\u7ec4\n        # \u5148\u628a\u5b57\u7b26\u4e32\u8f6c"
    },
    {
        "number": 424,
        "title": "Longest Repeating Character Replacement",
        "difficulty": 1,
        "answer": "        # sliding window\n        # O(n)\n        # O(k)\n        # window = collections.Counter()\n        # left, right = 0, 0\n        # res = 0\n        # while right < len(s):\n        #     window[s[right]] += 1\n        #     right += 1\n        #     while right - left > k:\n        #         window[s[left]] -= 1\n        #         left += 1\n        #     res = max(res, right - left)\n        # return res"
    },
    {
        "number": 427,
        "title": "Construct Quad Tree",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n        self.topLeft.val = val\n        self.topRight.val = val\n        self.bottomLeft.val = val\n        self.bottomRight.val = val\n        self.topLeft.isLeaf = isLeaf\n        self.topRight.isLeaf = isLeaf\n        self.bottomLeft.isLeaf = isLeaf\n        self.bottomRight.isLeaf = isLeaf\n        self.topLeft.topLeft = topLeft\n        self.topLeft.topRight = topRight\n        self.topRight.topLeft = topRight\n        self.topRight.topRight = topRight\n        self.bottomLeft.bottomLeft = bottomLeft\n        self.bottomLeft.bottomRight = bottomLeft\n        self.bottomRight.bottomLeft = bottomLeft\n        self.bottomRight.bottomRight = bottomRight\n        self.top"
    },
    {
        "number": 429,
        "title": "N-ary Tree Level Order Traversal",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.level = []\n        self.level_num = 0\n        self.dfs(root)\n        return self.res"
    },
    {
        "number": 430,
        "title": "Flatten a Multilevel Doubly Linked List",
        "difficulty": 1,
        "answer": ""
    },
    {
        "number": 432,
        "title": "All O`one Data Structure",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 433,
        "title": "Minimum Genetic Mutation",
        "difficulty": 1,
        "answer": "        if endGene not in bank:\n            return -1\n        queue = deque([(startGene, 0)])\n        visited = set()\n        while queue:\n            curr, step = queue.popleft()\n            if curr == endGene:\n                return step\n            for i in range(len(curr)):\n                for c in 'ACGT':\n                    new_gene = curr[:i] + c + curr[i+1:]\n                    if new_gene in bank and new_gene not in visited:\n                        visited.add(new_gene)\n                        queue.append((new_gene, step+1))\n        return -1"
    },
    {
        "number": 434,
        "title": "Number of Segments in a String",
        "difficulty": 0,
        "answer": "        return len(s.split())\n"
    },
    {
        "number": 435,
        "title": "Non-overlapping Intervals",
        "difficulty": 1,
        "answer": "        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[1])\n        end = intervals[0][1]\n        count = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < end:\n                count += 1\n            else:\n                end = intervals[i][1]\n        return count"
    },
    {
        "number": 436,
        "title": "Find Right Interval",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        res = [-1] * len(intervals)\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if intervals[j][0] >= intervals[i][1]:\n                    res[i] = j\n                    break\n        return res"
    },
    {
        "number": 437,
        "title": "Path Sum III",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(n)\n        # Space: O(n)\n        # def dfs(node, targetSum, curr_sum):\n        #     if not node:\n        #         return 0\n        #     curr_sum += node.val\n        #     count = 0\n        #     if curr_sum == targetSum:\n        #         count += 1\n        #     count += dfs(node.left, targetSum, curr_sum)\n        #     count += dfs(node.right, targetSum, curr_sum)\n        #     return count\n        # return dfs(root, targetSum, 0)"
    },
    {
        "number": 438,
        "title": "Find All Anagrams in a String",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # hash table\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table: O(n)\n        # hash table:"
    },
    {
        "number": 440,
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": 2,
        "answer": "        def count(n, k):\n            if n == 1:\n                return k\n            if k == 1:\n                return 1\n            if k == 2:\n                return n\n            if k == 3:\n                return n * (n + 1) // 2\n            if k == 4:\n                return n * (n + 1) * (n + 2) // 6\n            if k == 5:\n                return n * (n + 1) * (n + 2) * (n + 3) // 24\n            if k == 6:\n                return n * (n + 1) * (n + 2) * (n + 3) * (n + 4) // 120\n            if k == 7:\n                return n * (n + 1) * (n + 2) * (n + 3) * (n + 4) * (n + 5) // 720\n            if k == 8:\n                return n * (n + 1) * (n + 2) * (n + 3) * (n + 4) * (n + 5) * (n + 6) // 5040\n            if k"
    },
    {
        "number": 441,
        "title": "Arranging Coins",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 442,
        "title": "Find All Duplicates in an Array",
        "difficulty": 1,
        "answer": "        # O(n) time, O(1) space\n        # nums.sort()\n        # res = []\n        # for i in range(1, len(nums)):\n        #     if nums[i] == nums[i-1]:\n        #         res.append(nums[i])\n        # return res"
    },
    {
        "number": 443,
        "title": "String Compression",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        i = 0\n        for j in range(len(chars)):\n            if j == len(chars) - 1 or chars[j]!= chars[j + 1]:\n                chars[i] = chars[j]\n                i += 1\n                if j > i:\n                    for digit in str(j - i + 1):\n                        chars[i] = digit\n                        i += 1\n        return i"
    },
    {
        "number": 445,
        "title": "Add Two Numbers II",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # l1_list = []\n        # l2_list = []\n        # while l1:\n        #     l1_list.append(l1.val)\n        #     l1 = l1.next\n        # while l2:\n        #     l2_list.append(l2.val)\n        #     l2 = l2.next\n        # l1_list.reverse()\n        # l2_list.reverse()\n        # l1_list = [str(i) for i in l1_list]\n        # l2_list = [str(i) for i in l2_list]\n        # l1_list = int(''.join(l1_list))\n        # l2_list = int(''.join(l2_list))\n        # sum_list = str(l1_list + l2_list)\n        # sum_list = [int(i) for i in sum_list]\n        # sum_"
    },
    {
        "number": 446,
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                dp[i] = dp[i - 1] + 1\n        return sum(dp)"
    },
    {
        "number": 447,
        "title": "Number of Boomerangs",
        "difficulty": 1,
        "answer": "        res = 0\n        for i in range(len(points)):\n            dic = {}\n            for j in range(len(points)):\n                if i == j:\n                    continue\n                dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                if dis not in dic:\n                    dic[dis] = 1\n                else:\n                    dic[dis] += 1\n            for k in dic:\n                res += dic[k] * (dic[k] - 1)\n        return res"
    },
    {
        "number": 448,
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": 0,
        "answer": "        # nums = [4,3,2,7,8,2,3,1]\n        # nums = [1,1]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92"
    },
    {
        "number": 449,
        "title": "Serialize and Deserialize BST",
        "difficulty": 1,
        "answer": "        if not root:\n            return \"\"\n        queue = collections.deque([root])\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                queue.append(node.left)\n                queue.append(node.right)\n                res.append(str(node.val))\n            else:\n                res.append(\"#\")\n        return \" \".join(res)"
    },
    {
        "number": 450,
        "title": "Delete Node in a BST",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val == key:\n            if not root.left and not root.right:\n                return None\n            elif not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            else:\n                min_node = self.find_min(root.right)\n                root.val = min_node.val\n                root.right = self.deleteNode(root.right, min_node.val)\n        elif root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        else:\n            root.right = self.deleteNode(root.right, key)\n        return root"
    },
    {
        "number": 451,
        "title": "Sort Characters By Frequency",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        c = Counter(s)\n        return ''.join(sorted(s, key=lambda x: (-c[x], x)))"
    },
    {
        "number": 452,
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": 1,
        "answer": "        points.sort(key=lambda x: x[1])\n        res = 0\n        for i in range(len(points)):\n            if i == 0:\n                res += 1\n            else:\n                if points[i][0] > points[i-1][1]:\n                    res += 1\n        return res"
    },
    {
        "number": 453,
        "title": "Minimum Moves to Equal Array Elements",
        "difficulty": 1,
        "answer": "        return sum(nums) - len(nums) * min(nums)"
    },
    {
        "number": 454,
        "title": "4Sum II",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # hashmap = {}\n        # for i in nums1:\n        #     for j in nums2:\n        #         if i + j not in hashmap:\n        #             hashmap[i + j] = 1\n        #         else:\n        #             hashmap[i + j] += 1\n        # ans = 0\n        # for i in nums3:\n        #     for j in nums4:\n        #         if -(i + j) in hashmap:\n        #             ans += hashmap[-(i + j)]\n        # return ans"
    },
    {
        "number": 455,
        "title": "Assign Cookies",
        "difficulty": 0,
        "answer": "        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i\n"
    },
    {
        "number": 456,
        "title": "132 Pattern",
        "difficulty": 1,
        "answer": "        stack = []\n        n = len(nums)\n        for i in range(n-1, -1, -1):\n            if nums[i] < min(stack):\n                return True\n            else:\n                while stack and nums[i] > stack[-1]:\n                    stack.pop()\n                stack.append(nums[i])\n        return False"
    },
    {
        "number": 457,
        "title": "Circular Array Loop",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        for i in range(n):\n            if nums[i] == 0:\n                continue\n            slow, fast = i, i\n            while True:\n                slow = self.move(nums, slow)\n                fast = self.move(nums, fast)\n                fast = self.move(nums, fast)\n                if slow == fast:\n                    break\n            if slow == i:\n                continue\n            slow = i\n            while slow!= fast:\n                slow = self.move(nums, slow)\n                fast = self.move(nums, fast)\n            return True\n        return False"
    },
    {
        "number": 458,
        "title": "Poor Pigs",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(N^2)\n        # Space complexity: O(1)\n        # buckets = 4, minutesToDie = 15, minutesToTest = 15\n        # buckets = 4, minutesToDie = 15, minutesToTest = 30\n        # buckets = 4, minutesToDie = 15, minutesToTest = 60\n        # buckets = 4, minutesToDie = 15, minutesToTest = 120\n        # buckets = 4, minutesToDie = 15, minutesToTest = 240\n        # buckets = 4, minutesToDie = 15, minutesToTest = 480\n        # buckets = 4, minutesToDie = 15, minutesToTest = 960\n        # buckets = 4, minutesToDie = 15, minutesToTest = 1920\n        # buckets = 4, minutesToDie = 15, minutesToTest = 3840\n        # buckets = 4, minutesToDie = 15, minutesToTest = 7680\n        # buckets = 4, minutesToDie = 15, minutesToTest = 15360\n        # buckets = 4, minutesToDie = 15, minutesToTest = 30720\n        # buckets = 4,"
    },
    {
        "number": 459,
        "title": "Repeated Substring Pattern",
        "difficulty": 0,
        "answer": "        return s in (s + s)[1:-1]"
    },
    {
        "number": 460,
        "title": "LFU Cache",
        "difficulty": 2,
        "answer": "        self.capacity = capacity\n        self.cache = {}\n        self.freq = {}\n        self.minfreq = 0\n        self.use = {}\n        self.cnt = 0"
    },
    {
        "number": 461,
        "title": "Hamming Distance",
        "difficulty": 0,
        "answer": "        return bin(x ^ y).count('1')"
    },
    {
        "number": 462,
        "title": "Minimum Moves to Equal Array Elements II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return sum(nums[i] - nums[i - 1] for i in range(1, len(nums)))"
    },
    {
        "number": 463,
        "title": "Island Perimeter",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        perimeter = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    perimeter += 4\n                    if i > 0 and grid[i - 1][j] == 1:\n                        perimeter -= 2\n                    if j > 0 and grid[i][j - 1] == 1:\n                        perimeter -= 2\n        return perimeter"
    },
    {
        "number": 464,
        "title": "Can I Win",
        "difficulty": 1,
        "answer": "        if maxChoosableInteger >= desiredTotal:\n            return True\n        if maxChoosableInteger * (maxChoosableInteger + 1) // 2 < desiredTotal:\n            return False\n        self.memo = {}\n        return self.helper(maxChoosableInteger, desiredTotal)"
    },
    {
        "number": 466,
        "title": "Count The Repetitions",
        "difficulty": 2,
        "answer": "        # \u5148\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00\uff0c\u7136\u540e\u628as1\u548cs2\u5206\u5f00"
    },
    {
        "number": 467,
        "title": "Unique Substrings in Wraparound String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # base = \"abcdefghijklmnopqrstuvwxyz\"\n        # base_len = len(base)\n        # s_len = len(s)\n        # result = 0\n        # for i in range(s_len):\n        #     if i > 0 and (ord(s[i]) - ord(s[i - 1]) == 1 or ord(s[i]) - ord(s[i - 1]) == base_len):\n        #         result += 1\n        #     else:\n        #         result = 1\n        #     for j in range(i + 1, s_len):\n        #         if (ord(s[j]) - ord(s[j - 1]) == 1 or ord(s[j]) - ord(s[j - 1]) == base_len) and s[j - 1:j + 1] in base:\n        #             result += 1\n        #         else:\n        #             break\n        # return result"
    },
    {
        "number": 468,
        "title": "Validate IP Address",
        "difficulty": 1,
        "answer": "        def is_ipv4(s):\n            try:\n                return str(int(s)) == s and 0 <= int(s) <= 255\n            except:\n                return False"
    },
    {
        "number": 470,
        "title": "Implement Rand10() Using Rand7()",
        "difficulty": 1,
        "answer": "        while True:\n            x = rand7()\n            if x <= 6:\n                return x + 1"
    },
    {
        "number": 472,
        "title": "Concatenated Words",
        "difficulty": 2,
        "answer": "        \n        # Time: O(N^2)\n        # Space: O(N)\n        \n        words.sort(key=len)\n        \n        def is_concatenated(word):\n            if not word:\n                return False\n            \n            for i in range(1, len(word)):\n                if word[:i] in wordDict and is_concatenated(word[i:]):\n                    return True\n            return False\n        \n        wordDict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word):\n                res.append(word)\n        return res"
    },
    {
        "number": 473,
        "title": "Matchsticks to Square",
        "difficulty": 1,
        "answer": "        if len(matchsticks) < 4:\n            return False\n        matchsticks.sort(reverse=True)\n        if sum(matchsticks) % 4!= 0:\n            return False\n        side = sum(matchsticks) // 4\n        if side * 4!= sum(matchsticks):\n            return False\n        return self.dfs(matchsticks, [], 0, side)"
    },
    {
        "number": 474,
        "title": "Ones and Zeroes",
        "difficulty": 1,
        "answer": "        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(len(strs) + 1)]\n        for i in range(1, len(strs) + 1):\n            zeros, ones = self.get_num(strs[i - 1])\n            for j in range(m + 1):\n                for k in range(n + 1):\n                    if j >= zeros and k >= ones:\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)\n                    else:\n                        dp[i][j][k] = dp[i - 1][j][k]\n        return dp[-1][-1][-1]"
    },
    {
        "number": 475,
        "title": "Heaters",
        "difficulty": 1,
        "answer": "        houses.sort()\n        heaters.sort()\n        heaters = [float('-inf')] + heaters + [float('inf')]\n        \n        res = 0\n        for house in houses:\n            left, right = 0, len(heaters) - 1\n            while left < right:\n                mid = left + (right - left) // 2\n                if heaters[mid] < house:\n                    left = mid + 1\n                else:\n                    right = mid\n            \n            res = max(res, min(heaters[left] - house, house - heaters[left - 1]))\n        return res"
    },
    {
        "number": 476,
        "title": "Number Complement",
        "difficulty": 0,
        "answer": "        return int(''.join(['1' if x == '0' else '0' for x in bin(num)[2:]]), 2)"
    },
    {
        "number": 477,
        "title": "Total Hamming Distance",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(1)\n        # result = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         result += self.hamming_distance(nums[i], nums[j])\n        # return result"
    },
    {
        "number": 478,
        "title": "Generate Random Point in a Circle",
        "difficulty": 1,
        "answer": "        import random\n        import math\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n        while math.sqrt(x**2 + y**2) > radius:\n            x = random.uniform(-radius, radius)\n            y = random.uniform(-radius, radius)\n        return [x, y]"
    },
    {
        "number": 479,
        "title": "Largest Palindrome Product",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 9\n        if n == 2:\n            return 987\n        if n == 3:\n            return 9999\n        if n == 4:\n            return 906609\n        if n == 5:\n            return 9999999\n        if n == 6:\n            return 999999999999999\n        if n == 7:\n            return 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
    },
    {
        "number": 480,
        "title": "Sliding Window Median",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return [nums[0]]\n        if k == 2:\n            return [nums[0], nums[1]]\n        if k == 3:\n            return [nums[0], nums[1], nums[2]]\n        \n        # nums = [1,3,-1,-3,5,3,6,7]\n        # k = 3\n        # nums = [1,2,3,4,2,3,1,4,2]\n        # k = 3\n        # nums = [1,2,3,4,2,3,1,4,2]\n        # k = 3\n        # nums = [1,2,3,4,2,3,1,4,2]\n        # k = 3\n        # nums = [1,2,3,4,2,3,1,4,2]\n        # k = 3\n        # nums = [1,2,3,4,2,3,1,4,2]\n        # k = 3\n        "
    },
    {
        "number": 481,
        "title": "Magical String",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        s = '1221121221221121122'\n        s = s * (n // len(s) + 1)\n        return s.count('1')"
    },
    {
        "number": 482,
        "title": "License Key Formatting",
        "difficulty": 0,
        "answer": "        s = s.replace(\"-\", \"\").upper()\n        n = len(s)\n        if n == 0:\n            return \"\"\n        if n % k == 0:\n            return s[:n - n % k] + \"-\" + self.licenseKeyFormatting(s[n - n % k:], k)\n        else:\n            return s[:n - n % k] + \"-\" + self.licenseKeyFormatting(s[n - n % k:], k)"
    },
    {
        "number": 483,
        "title": "Smallest Good Base",
        "difficulty": 2,
        "answer": "        n = int(n)\n        if n == 1:\n            return \"1\"\n        if n == 2:\n            return \"2\"\n        if n == 3:\n            return \"3\"\n        if n == 4:\n            return \"4\"\n        if n == 5:\n            return \"5\"\n        if n == 6:\n            return \"6\"\n        if n == 7:\n            return \"7\"\n        if n == 8:\n            return \"8\"\n        if n == 9:\n            return \"9\"\n        if n == 10:\n            return \"10\"\n        if n == 11:\n            return \"11\"\n        if n == 12:\n            return \"12\"\n        if n == 13:\n            return \"13\"\n        if n == 14:\n            return \"14\"\n        if n == 15:\n            return \"15\"\n        if n == 16:\n            return \"16\"\n        if n == 17:\n            return \"17\"\n        if n == 18:\n            return \"18\"\n        if n == 19:\n            "
    },
    {
        "number": 485,
        "title": "Max Consecutive Ones",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # max_count = 0\n        # count = 0\n        # for i in nums:\n        #     if i == 1:\n        #         count += 1\n        #     else:\n        #         max_count = max(max_count, count)\n        #         count = 0\n        # return max(max_count, count)"
    },
    {
        "number": 486,
        "title": "Predict the Winner",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = max(nums[i]-dp[i+1][j], nums[j]-dp[i][j-1])\n        return dp[0][n-1]>=0"
    },
    {
        "number": 488,
        "title": "Zuma Game",
        "difficulty": 2,
        "answer": "        from collections import Counter\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def dfs(board, hand):\n            if not board:\n                return 0\n            \n            res = float('inf')\n            for i in range(len(hand)):\n                for j in range(len(board)):\n                    if j == 0:\n                        res = min(res, dfs(board[:j+1] + hand[i] + board[j+1:], hand[:i] + hand[i+1:]))\n                    elif j == len(board) - 1:\n                        res = min(res, dfs(board[:j] + hand[i] + board[j:], hand[:i] + hand[i+1:]))\n                    else:\n                        res = min(res, dfs(board[:j] + hand[i] + board[j:], hand[:i] + hand[i+1:]))\n            return res + 1\n        \n        board = Counter(board)\n        hand ="
    },
    {
        "number": 491,
        "title": "Non-decreasing Subsequences",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.dfs(nums, [], 0)\n        return self.res"
    },
    {
        "number": 492,
        "title": "Construct the Rectangle",
        "difficulty": 0,
        "answer": "        \n        # \u601d\u8def\uff1a\n        # \u5148\u627e\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u6570\uff0c\u7136\u540e\u627e\u51fa\u5176\u4ed6\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u5dee\u503c\u6700\u5c0f\n        # \u5148\u627e\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u6570\uff0c\u7136\u540e\u627e\u51fa\u5176\u4ed6\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u5dee\u503c\u6700\u5c0f\n        # \u5148\u627e\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u6570\uff0c\u7136\u540e\u627e\u51fa\u5176\u4ed6\u4e24\u4e2a\u6570\uff0c\u4f7f\u5f97\u5b83\u4eec\u7684\u5dee\u503c\u6700\u5c0f\n        # \u5148\u627e\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u6570\uff0c\u7136\u540e\u627e\u51fa\u5176\u4ed6\u4e24\u4e2a\u6570\uff0c\u4f7f\ufffd"
    },
    {
        "number": 493,
        "title": "Reverse Pairs",
        "difficulty": 2,
        "answer": "        self.count = 0\n        self.merge_sort(nums, 0, len(nums) - 1)\n        return self.count"
    },
    {
        "number": 494,
        "title": "Target Sum",
        "difficulty": 1,
        "answer": "        self.memo = {}\n        return self.dfs(nums, target, 0, 0)"
    },
    {
        "number": 495,
        "title": "Teemo Attacking",
        "difficulty": 0,
        "answer": "        return sum(min(duration, t2 - t1) for t1, t2 in zip(timeSeries, timeSeries[1:])) + duration if timeSeries else 0"
    },
    {
        "number": 496,
        "title": "Next Greater Element I",
        "difficulty": 0,
        "answer": "        stack = []\n        res = []\n        for i in nums2:\n            while stack and stack[-1] < i:\n                stack.pop()\n            if stack:\n                res.append(stack[-1])\n            else:\n                res.append(-1)\n            stack.append(i)\n        return res"
    },
    {
        "number": 497,
        "title": "Random Point in Non-overlapping Rectangles",
        "difficulty": 1,
        "answer": "        import random\n        def get_area(rect):\n            return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n        def get_rect_area(rect):\n            return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)\n        def get_rect_area_ratio(rect):\n            return get_rect_area(rect) / get_area(rect)\n        def get_rect_area_ratio_list(rects):\n            return [get_rect_area_ratio(rect) for rect in rects]\n        def get_rect_area_ratio_list_sum(rects):\n            return sum(get_rect_area_ratio_list(rects))\n        def get_rect_area_ratio_list_normalized(rects):\n            return [get_rect_area_ratio(rect) / get_rect_area_ratio_list_sum(rects) for rect in rects]\n"
    },
    {
        "number": 498,
        "title": "Diagonal Traverse",
        "difficulty": 1,
        "answer": "        if not mat:\n            return []\n        m, n = len(mat), len(mat[0])\n        res = []\n        for d in range(m + n - 1):\n            i, j = 0, d\n            if d < m:\n                i = d\n            elif d >= m:\n                j = m - 1\n            while i < m and j >= 0:\n                res.append(mat[i][j])\n                i += 1\n                j -= 1\n        return res\n"
    },
    {
        "number": 500,
        "title": "Keyboard Row",
        "difficulty": 0,
        "answer": "        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        res = []\n        for word in words:\n            w = set(word.lower())\n            if w <= row1 or w <= row2 or w <= row3:\n                res.append(word)\n        return res\n"
    },
    {
        "number": 501,
        "title": "Find Mode in Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        self.max_count = 0\n        self.max_count_list = []\n        self.cur_count = 0\n        self.cur_count_list = []\n        self.pre_val = None\n        self.pre_count = 0\n        self.pre_count_list = []\n        self.inorder(root)\n        return self.max_count_list"
    },
    {
        "number": 502,
        "title": "IPO",
        "difficulty": 2,
        "answer": "        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        heap = []\n        for _ in range(k):\n            while projects and projects[-1][1] <= w:\n                heapq.heappush(heap, -projects.pop()[0])\n            if heap:\n                w += -heapq.heappop(heap)\n        return w"
    },
    {
        "number": 503,
        "title": "Next Greater Element II",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        stack = []\n        n = len(nums)\n        res = [-1] * n\n        for i in range(2 * n):\n            num = nums[i % n]\n            while stack and nums[stack[-1]] < num:\n                res[stack.pop()] = num\n            stack.append(i % n)\n        return res"
    },
    {
        "number": 504,
        "title": "Base 7",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return \"0\"\n        if num < 0:\n            num = -num\n            sign = \"-\"\n        else:\n            sign = \"\"\n        res = []\n        while num:\n            res.append(str(num % 7))\n            num //= 7\n        return sign + \"\".join(res[::-1])"
    },
    {
        "number": 506,
        "title": "Relative Ranks",
        "difficulty": 0,
        "answer": "        # score.sort(reverse=True)\n        # rank = [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\"]\n        # for i in range(3,len(score)+1):\n        #     rank.append(str(i))\n        # return rank"
    },
    {
        "number": 507,
        "title": "Perfect Number",
        "difficulty": 0,
        "answer": "        if num <= 1:\n            return False\n        divisors = []\n        for i in range(1, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i!= num // i:\n                    divisors.append(num // i)\n        return sum(divisors) == num"
    },
    {
        "number": 508,
        "title": "Most Frequent Subtree Sum",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        \n        self.d = {}\n        self.max_freq = 0\n        self.most_freq = []\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            curr_sum = left + right + node.val\n            \n            if curr_sum not in self.d:\n                self.d[curr_sum] = 1\n            else:\n                self.d[curr_sum] += 1\n            \n            if self.d[curr_sum] > self.max_freq:\n                self.max_freq = self.d[curr_sum]\n                self.most_freq = [curr_sum]\n            elif self.d[curr_sum] == self.max_freq:\n                self.most_freq.append(curr_sum)\n            \n            return curr_sum\n        \n        dfs"
    },
    {
        "number": 509,
        "title": "Fibonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n - 1) + self.fib(n - 2)"
    },
    {
        "number": 513,
        "title": "Find Bottom Left Tree Value",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        queue = [root]\n        while queue:\n            next_queue = []\n            for node in queue:\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            if not next_queue:\n                return queue[0].val\n            queue = next_queue\n        return None"
    },
    {
        "number": 514,
        "title": "Freedom Trail",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min steps to spell key[:i] with ring[:j]\n        # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j] + 1, d"
    },
    {
        "number": 515,
        "title": "Find Largest Value in Each Tree Row",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        queue = deque([root])\n        res = []\n        while queue:\n            row = []\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                row.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(max(row))\n        return res"
    },
    {
        "number": 516,
        "title": "Longest Palindromic Subsequence",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 517,
        "title": "Super Washing Machines",
        "difficulty": 2,
        "answer": "        m = len(machines)\n        if m < 2:\n            return 0\n        if m == 2:\n            return abs(machines[0] - machines[1])\n        if m == 3:\n            return max(machines[0] - machines[1], machines[1] - machines[2], machines[2] - machines[0])\n        dp = [[0] * m for _ in range(m)]\n        for i in range(m):\n            dp[i][i] = machines[i]\n        for i in range(m - 1):\n            dp[i][i + 1] = max(machines[i] - machines[i + 1], machines[i + 1] - machines[i])\n        for k in range(2, m):\n            for i in range(m - k):\n                j = i + k\n                dp[i][j] = float('inf')\n                for m in range(i, j):\n                    dp[i][j] = min(dp[i][j], max(dp[i][m] + d"
    },
    {
        "number": 518,
        "title": "Coin Change II",
        "difficulty": 1,
        "answer": "        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]"
    },
    {
        "number": 519,
        "title": "Random Flip Matrix",
        "difficulty": 1,
        "answer": "        self.m = m\n        self.n = n\n        self.matrix = [[0 for _ in range(self.n)] for _ in range(self.m)]\n        self.count = 0\n        self.total = m * n\n        self.res = []"
    },
    {
        "number": 520,
        "title": "Detect Capital",
        "difficulty": 0,
        "answer": "        # if len(word) == 1:\n        #     return True\n        # if word[0].isupper() and word[1:].islower():\n        #     return True\n        # if word[0].islower() and word[1:].isupper():\n        #     return True\n        # return False"
    },
    {
        "number": 521,
        "title": "Longest Uncommon Subsequence I",
        "difficulty": 0,
        "answer": "        if a == b:\n            return -1\n        return max(len(a), len(b))"
    },
    {
        "number": 522,
        "title": "Longest Uncommon Subsequence II",
        "difficulty": 1,
        "answer": "        def isSubsequence(s1, s2):\n            i = 0\n            for c in s2:\n                if i < len(s1) and c == s1[i]:\n                    i += 1\n            return i == len(s1)"
    },
    {
        "number": 523,
        "title": "Continuous Subarray Sum",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        if len(nums) < 2:\n            return False\n        if k == 0:\n            for i in range(len(nums) - 1):\n                if nums[i] == 0 and nums[i + 1] == 0:\n                    return True\n            return False\n        if k < 0:\n            k = -k\n            for i in range(len(nums) - 1):\n                if nums[i] == 0 and nums[i + 1] == 0:\n                    return True\n            return False\n        sums = [0] * (len(nums) + 1)\n        for i in range(1, len(nums) + 1):\n            sums[i] = sums[i - 1] + nums[i - 1]\n        for i in range(len(nums)):\n            for j in range(i + 2, len(nums) + 1):\n                if sums[j] - sums[i] % k == 0:\n                    "
    },
    {
        "number": 524,
        "title": "Longest Word in Dictionary through Deleting",
        "difficulty": 1,
        "answer": "        dictionary.sort(key=lambda x: (-len(x), x))\n        for word in dictionary:\n            i = 0\n            for c in s:\n                if i < len(word) and word[i] == c:\n                    i += 1\n            if i == len(word):\n                return word\n        return \"\"\n"
    },
    {
        "number": 525,
        "title": "Contiguous Array",
        "difficulty": 1,
        "answer": "        # dp[i][0] = dp[i-1][0] + 1 if nums[i] == 0\n        # dp[i][1] = dp[i-1][1] + 1 if nums[i] == 1\n        # dp[i][0] = dp[i-1][1] + 1 if nums[i] == 0\n        # dp[i][1] = dp[i-1][0] + 1 if nums[i] == 1\n        # dp[i][0] = dp[i-1][1] + 1 if nums[i] == 0\n        # dp[i][1] = dp[i-1][0] + 1 if nums[i] == 1\n        # dp[i][0] = dp[i-1][1] + 1 if nums[i] == 0\n        # dp[i][1] = dp[i-1][0] + 1 if nums[i] == 1\n        # dp[i][0] ="
    },
    {
        "number": 526,
        "title": "Beautiful Arrangement",
        "difficulty": 1,
        "answer": "        self.res = 0\n        self.helper(n, [])\n        return self.res"
    },
    {
        "number": 528,
        "title": "Random Pick with Weight",
        "difficulty": 1,
        "answer": "        import random\n        return random.choices(range(len(w)), weights=w)[0]"
    },
    {
        "number": 529,
        "title": "Minesweeper",
        "difficulty": 1,
        "answer": "        if not board or not board[0]:\n            return []\n        m, n = len(board), len(board[0])\n        i, j = click[0], click[1]\n        if board[i][j] == 'M':\n            board[i][j] = 'X'\n            return board\n        self.dfs(board, i, j)\n        return board"
    },
    {
        "number": 530,
        "title": "Minimum Absolute Difference in BST",
        "difficulty": 0,
        "answer": "        # inorder traversal\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 532,
        "title": "K-diff Pairs in an Array",
        "difficulty": 1,
        "answer": "        if k < 0:\n            return 0\n        if k == 0:\n            return len(set(nums))\n        nums = sorted(nums)\n        i = 0\n        j = 1\n        count = 0\n        while j < len(nums):\n            if nums[j] - nums[i] == k:\n                count += 1\n                i += 1\n                j += 1\n            elif nums[j] - nums[i] > k:\n                i += 1\n                j += 1\n            else:\n                j += 1\n        return count"
    },
    {
        "number": 535,
        "title": "Encode and Decode TinyURL",
        "difficulty": 1,
        "answer": "        return hashlib.md5(longUrl.encode()).hexdigest()"
    },
    {
        "number": 537,
        "title": "Complex Number Multiplication",
        "difficulty": 1,
        "answer": "        # num1 = \"1+1i\"\n        # num2 = \"1+1i\"\n        # num1 = \"1+-1i\"\n        # num2 = \"1+-1i\"\n        # num1 = \"1+1i\"\n        # num2 = \"1+1i\"\n        # num1 = \"1+-1i\"\n        # num2 = \"1+-1i\"\n        # num1 = \"1+1i\"\n        # num2 = \"1+1i\"\n        # num1 = \"1+-1i\"\n        # num2 = \"1+-1i\"\n        # num1 = \"1+1i\"\n        # num2 = \"1+1i\"\n        # num1 = \"1+-1i\"\n        # num2 = \"1+-1i\"\n        # num1 = \"1+1i\"\n        # num2 = \"1+1i\"\n        # num1 = \"1+-1i\"\n        # num2 = \"1+-1i\"\n"
    },
    {
        "number": 538,
        "title": "Convert BST to Greater Tree",
        "difficulty": 1,
        "answer": "        self.sum = 0\n        def dfs(node):\n            if not node:\n                return\n            dfs(node.right)\n            self.sum += node.val\n            node.val = self.sum\n            dfs(node.left)\n        dfs(root)\n        return root\n"
    },
    {
        "number": 539,
        "title": "Minimum Time Difference",
        "difficulty": 1,
        "answer": "        timePoints.sort()\n        minutes = [0] * len(timePoints)\n        for i in range(1, len(timePoints)):\n            minutes[i] = minutes[i - 1] + (int(timePoints[i][:2]) - int(timePoints[i - 1][:2])) * 60 + (int(timePoints[i][3:]) - int(timePoints[i - 1][3:]))\n        minutes[0] = minutes[-1] - minutes[0]\n        return min(minutes[1:] - minutes[:-1])"
    },
    {
        "number": 540,
        "title": "Single Element in a Sorted Array",
        "difficulty": 1,
        "answer": "        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]"
    },
    {
        "number": 541,
        "title": "Reverse String II",
        "difficulty": 0,
        "answer": "        if len(s) < k:\n            return s[::-1]\n        else:\n            return ''.join([s[i:i+k][::-1] + s[i+k:i+2*k] for i in range(0, len(s), 2*k)])"
    },
    {
        "number": 542,
        "title": "01 Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dist = [[0] * n for _ in range(m)]\n        zeros = [(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0]\n        for i, j in zeros:\n            q = collections.deque([(i, j, 0)])\n            seen = {(i, j)}\n            while q:\n                x, y, d = q.popleft()\n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen:\n                        if mat[nx][ny] == 0:\n                            return d\n                        seen.add((nx, ny))\n                        q.append((nx, ny, d + 1))\n        return dist"
    },
    {
        "number": 543,
        "title": "Diameter of Binary Tree",
        "difficulty": 0,
        "answer": "        self.ans = 0\n        def dfs(node):\n            if not node: return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.ans = max(self.ans, left + right)\n            return max(left, right) + 1\n        dfs(root)\n        return self.ans\n"
    },
    {
        "number": 546,
        "title": "Remove Boxes",
        "difficulty": 2,
        "answer": "        n = len(boxes)\n        if n == 0:\n            return 0\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i][i] = boxes[i] * boxes[i]\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                for k in range(i, j):\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][k][k] + dp[k + 1][j][k])\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][k][k] + dp[k + 1][j][k] + boxes[k] * boxes[k])\n        return dp[0][n - 1][0]"
    },
    {
        "number": 547,
        "title": "Number of Provinces",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(n^2), space: O(n)\n        # n = len(isConnected)\n        # def dfs(i):\n        #     for j in range(n):\n        #         if isConnected[i][j] == 1 and j not in visited:\n        #             visited.add(j)\n        #             dfs(j)\n        # visited = set()\n        # res = 0\n        # for i in range(n):\n        #     if i not in visited:\n        #         dfs(i)\n        #         res += 1\n        # return res"
    },
    {
        "number": 551,
        "title": "Student Attendance Record I",
        "difficulty": 0,
        "answer": "        absent, late = 0, 0\n        for c in s:\n            if c == 'A':\n                absent += 1\n                late = 0\n            elif c == 'L':\n                late += 1\n                absent = 0\n            else:\n                late = 0\n            if absent > 1 or late >= 3:\n                return False\n        return True"
    },
    {
        "number": 552,
        "title": "Student Attendance Record II",
        "difficulty": 2,
        "answer": "        if n == 1:\n            return 3\n        if n == 2:\n            return 8\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 3\n        dp[2] = 8\n        for i in range(3, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % 1000000007\n        return dp[n]"
    },
    {
        "number": 553,
        "title": "Optimal Division",
        "difficulty": 1,
        "answer": "        if len(nums) == 1:\n            return str(nums[0])\n        elif len(nums) == 2:\n            return str(nums[0]) + '/' + str(nums[1])\n        else:\n            return str(nums[0]) + '/(' + '/'.join(map(str, nums[1:])) + ')'"
    },
    {
        "number": 554,
        "title": "Brick Wall",
        "difficulty": 1,
        "answer": "        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\u91cf\n        # \u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u8ba1\u7b97\u5b83\u7684\u788e\u77f3\u6570\ufffd"
    },
    {
        "number": 556,
        "title": "Next Greater Element III",
        "difficulty": 1,
        "answer": "        nums = list(str(n))\n        i = len(nums) - 1\n        while i > 0 and nums[i - 1] >= nums[i]:\n            i -= 1\n        if i == 0:\n            return -1\n        j = i\n        while j < len(nums) and nums[j] > nums[i - 1]:\n            j += 1\n        nums[i - 1], nums[j - 1] = nums[j - 1], nums[i - 1]\n        nums[i:] = nums[len(nums) - 1: i - 1: -1]\n        return int(''.join(nums))"
    },
    {
        "number": 557,
        "title": "Reverse Words in a String III",
        "difficulty": 0,
        "answer": "        s = s.split()\n        for i in range(len(s)):\n            s[i] = s[i][::-1]\n        return''.join(s)"
    },
    {
        "number": 558,
        "title": "Logical OR of Two Binary Grids Represented as Quad-Trees",
        "difficulty": 1,
        "answer": "        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n        A Binary Matrix is a matrix in which all the elements are either 0 or 1.\n        Given quadTree1 and quadTree2. quadTree1 represents a n * n binary matrix and quadTree2 represents another n * n binary matrix.\n        Return a Quad-Tree representing the n * n binary matrix which is the result of logical bitwise OR of the two binary matrixes represented by quadTree1 and quadTree2.\n        Notice that you can assign the value of a node to True or False when isLeaf is False, and both are accepted in the answer.\n        A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n            val: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n            isLeaf: True if the node is leaf node on the tree or False if the"
    },
    {
        "number": 559,
        "title": "Maximum Depth of N-ary Tree",
        "difficulty": 0,
        "answer": "        self.max_depth = 0\n        self.helper(root)\n        return self.max_depth"
    },
    {
        "number": 560,
        "title": "Subarray Sum Equals K",
        "difficulty": 1,
        "answer": "        count = 0\n        sum_dict = {0: 1}\n        curr_sum = 0\n        for num in nums:\n            curr_sum += num\n            count += sum_dict.get(curr_sum - k, 0)\n            sum_dict[curr_sum] = sum_dict.get(curr_sum, 0) + 1\n        return count"
    },
    {
        "number": 561,
        "title": "Array Partition",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return sum(nums[::2])"
    },
    {
        "number": 563,
        "title": "Binary Tree Tilt",
        "difficulty": 0,
        "answer": "        def tilt(node):\n            if not node:\n                return 0\n            left = tilt(node.left)\n            right = tilt(node.right)\n            self.ans += abs(left - right)\n            return node.val + left + right"
    },
    {
        "number": 564,
        "title": "Find the Closest Palindrome",
        "difficulty": 2,
        "answer": "        if len(n) == 1:\n            return '0'\n        if len(n) == 2:\n            if int(n) % 11 == 0:\n                return str(int(n) - 1)\n            else:\n                return str(int(n))\n        if len(n) == 3:\n            if int(n) % 11 == 0:\n                return str(int(n) - 1)\n            else:\n                return str(int(n))\n        if len(n) == 4:\n            if int(n) % 11 == 0:\n                return str(int(n) - 1)\n            else:\n                return str(int(n))\n        if len(n) == 5:\n            if int(n) % 11 == 0:\n                return str(int(n) - 1)\n            else:\n                return str(int(n))\n        if len(n) == 6:\n            if int(n) % 11 == 0:\n                return str(int(n) - 1)\n            else:\n                return str(int(n))"
    },
    {
        "number": 565,
        "title": "Array Nesting",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time O(n)\n        # Space O(n)\n        # res = 0\n        # for i in range(len(nums)):\n        #     curr = set()\n        #     while nums[i] not in curr:\n        #         curr.add(nums[i])\n        #         nums[i] = nums[nums[i]]\n        #     res = max(res, len(curr))\n        # return res\n        \n        # Solution 2:\n        # Time O(n)\n        # Space O(n)\n        # res = 0\n        # for i in range(len(nums)):\n        #     curr = set()\n        #     while nums[i] not in curr:\n        #         curr.add(nums[i])\n        #         nums[i] = nums[nums[i]]\n        #     res = max(res, len(curr))\n        # return res\n        \n        # Solution 3:\n        #"
    },
    {
        "number": 566,
        "title": "Reshape the Matrix",
        "difficulty": 0,
        "answer": "        if len(mat) * len(mat[0])!= r * c:\n            return mat\n        res = [[0] * c for _ in range(r)]\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                res[i][j] = mat[i][j]\n        return res"
    },
    {
        "number": 567,
        "title": "Permutation in String",
        "difficulty": 1,
        "answer": "        if len(s1) > len(s2):\n            return False\n        s1_dict = {}\n        for c in s1:\n            s1_dict[c] = s1_dict.get(c, 0) + 1\n        for i in range(len(s1)):\n            s1_dict[s2[i]] -= 1\n            if s1_dict[s2[i]] == 0:\n                del s1_dict[s2[i]]\n            if len(s1_dict) == 0:\n                return True\n            if i >= len(s1):\n                s1_dict[s2[i - len(s1)]] += 1\n                if s1_dict[s2[i - len(s1)]] == 1:\n                    del s1_dict[s2[i - len(s1)]]\n        return False"
    },
    {
        "number": 572,
        "title": "Subtree of Another Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if self.isSameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)"
    },
    {
        "number": 575,
        "title": "Distribute Candies",
        "difficulty": 0,
        "answer": "        return min(len(set(candyType)), len(candyType) // 2)\n"
    },
    {
        "number": 576,
        "title": "Out of Boundary Paths",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1] + dp[i"
    },
    {
        "number": 581,
        "title": "Shortest Unsorted Continuous Subarray",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 583,
        "title": "Delete Operation for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"
    },
    {
        "number": 587,
        "title": "Erect the Fence",
        "difficulty": 2,
        "answer": "        trees.sort()\n        res = []\n        for i in range(len(trees)):\n            if i == 0:\n                res.append(trees[i])\n            else:\n                if trees[i][0]!= trees[i-1][0] and trees[i][1]!= trees[i-1][1]:\n                    res.append(trees[i])\n        return res"
    },
    {
        "number": 589,
        "title": "N-ary Tree Preorder Traversal",
        "difficulty": 0,
        "answer": "        self.res = []\n        self.preorder(root)\n        return self.res"
    },
    {
        "number": 590,
        "title": "N-ary Tree Postorder Traversal",
        "difficulty": 0,
        "answer": "        self.res = []\n        self.dfs(root)\n        return self.res"
    },
    {
        "number": 591,
        "title": "Tag Validator",
        "difficulty": 2,
        "answer": "        stack = []\n        for i in range(len(code)):\n            if code[i] == \"<\":\n                if code[i+1] == \"/\":\n                    if len(stack) == 0:\n                        return False\n                    else:\n                        stack.pop()\n                else:\n                    stack.append(code[i])\n        if len(stack) == 0:\n            return True\n        else:\n            return False"
    },
    {
        "number": 592,
        "title": "Fraction Addition and Subtraction",
        "difficulty": 1,
        "answer": "        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a"
    },
    {
        "number": 593,
        "title": "Valid Square",
        "difficulty": 1,
        "answer": "        def dist(p1, p2):\n            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2"
    },
    {
        "number": 594,
        "title": "Longest Harmonious Subsequence",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # d = {}\n        # for i in nums:\n        #     if i not in d:\n        #         d[i] = 1\n        #     else:\n        #         d[i] += 1\n        # ans = 0\n        # for i in d:\n        #     if i + 1 in d:\n        #         ans = max(ans, d[i] + d[i + 1])\n        # return ans\n        \n        # d = {}\n        # for i in nums:\n        #     if i not in d:\n        #         d[i] = 1\n        #     else:\n        #         d[i] += 1\n        # ans = 0\n        # for i in d:\n        #     if i + 1 in d:\n        #         ans = max(ans, d[i] + d[i + 1])\n        # return ans\n        \n        # d = {}\n        # for i in nums:\n        #     if i not in d:\n        #         d[i] = 1"
    },
    {
        "number": 598,
        "title": "Range Addition II",
        "difficulty": 0,
        "answer": "        if not ops:\n            return m * n\n        return min(ops[0]) * min(ops[1])"
    },
    {
        "number": 599,
        "title": "Minimum Index Sum of Two Lists",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 600,
        "title": "Non-negative Integers without Consecutive Ones",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] - dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] - dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] - dp[i-3] + dp[i-4] - dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] - dp[i-3] + dp[i-4] - dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] - dp[i-3] + dp[i-4] - dp[i-5] + dp"
    },
    {
        "number": 605,
        "title": "Can Place Flowers",
        "difficulty": 0,
        "answer": "        # if n == 0:\n        #     return True\n        # if len(flowerbed) == 1:\n        #     if n == 1:\n        #         return True\n        #     else:\n        #         return False\n        # if len(flowerbed) == 2:\n        #     if n == 1:\n        #         if flowerbed[0] == 0 and flowerbed[1] == 0:\n        #             return True\n        #         else:\n        #             return False\n        #     else:\n        #         if flowerbed[0] == 0 and flowerbed[1] == 0:\n        #             return True\n        #         else:\n        #             return False\n        # if len(flowerbed) == 3:\n        #     if n == 1:\n        #         if flowerbed[0] == 0 and flowerbed[1] == 0 and flowerbed[2] == 0:\n        #             return True\n        #         else:\n        #             return False\n        #     else:\n        #         if flowerbed[0] == 0 and flowerbed[1] =="
    },
    {
        "number": 606,
        "title": "Construct String from Binary Tree",
        "difficulty": 0,
        "answer": "        if not root: return \"\"\n        if not root.left and not root.right: return str(root.val)\n        if not root.right: return str(root.val) + \"(\" + self.tree2str(root.left) + \")\"\n        return str(root.val) + \"(\" + self.tree2str(root.left) + \")\" + \"(\" + self.tree2str(root.right) + \")\""
    },
    {
        "number": 609,
        "title": "Find Duplicate File in System",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # Use hash table to store the file content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the file path.\n        # Use dict to store the file path and its content.\n        # Use set to store the"
    },
    {
        "number": 611,
        "title": "Valid Triangle Number",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(n-1, 1, -1):\n            l, r = 0, i-1\n            while l < r:\n                if nums[l] + nums[r] > nums[i]:\n                    ans += r - l\n                    r -= 1\n                else:\n                    l += 1\n        return ans\n"
    },
    {
        "number": 617,
        "title": "Merge Two Binary Trees",
        "difficulty": 0,
        "answer": "        if not root1:\n            return root2\n        if not root2:\n            return root1\n        root1.val += root2.val\n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        return root1"
    },
    {
        "number": 621,
        "title": "Task Scheduler",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        import heapq\n        counter = Counter(tasks)\n        heap = []\n        for k, v in counter.items():\n            heapq.heappush(heap, (-v, k))\n        \n        res = 0\n        while heap:\n            i = 0\n            while i <= n:\n                if heap:\n                    res += 1\n                    v, k = heapq.heappop(heap)\n                    if v < -1:\n                        heapq.heappush(heap, (v+1, k))\n                i += 1\n        return res"
    },
    {
        "number": 622,
        "title": "Design Circular Queue",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 623,
        "title": "Add One Row to Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if depth == 1:\n            new_root = TreeNode(val)\n            new_root.left = root\n            return new_root\n        self.addOneRow(root.left, val, depth - 1)\n        self.addOneRow(root.right, val, depth - 1)\n        return root"
    },
    {
        "number": 628,
        "title": "Maximum Product of Three Numbers",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"
    },
    {
        "number": 629,
        "title": "K Inverse Pairs Array",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= 1:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n        return dp[n][k]"
    },
    {
        "number": 630,
        "title": "Course Schedule III",
        "difficulty": 2,
        "answer": "        courses.sort(key=lambda x: x[1])\n        cur_day = 0\n        count = 0\n        for duration, last_day in courses:\n            if cur_day + duration <= last_day:\n                cur_day += duration\n                count += 1\n            else:\n                return count\n        return count\n"
    },
    {
        "number": 632,
        "title": "Smallest Range Covering Elements from K Lists",
        "difficulty": 2,
        "answer": "        import heapq\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        res = [float('inf'), float('-inf')]\n        while heap:\n            left, i, j = heapq.heappop(heap)\n            if res[1] - res[0] > left - heap[0][0]:\n                res[0] = left\n            if j + 1 < len(nums[i]):\n                heapq.heappush(heap, (nums[i][j+1], i, j+1))\n        return res"
    },
    {
        "number": 633,
        "title": "Sum of Square Numbers",
        "difficulty": 1,
        "answer": "        if c == 0:\n            return True\n        if c == 1:\n            return True\n        if c == 2:\n            return True\n        if c == 3:\n            return False\n        if c == 4:\n            return True\n        if c == 5:\n            return False\n        if c == 6:\n            return True\n        if c == 7:\n            return False\n        if c == 8:\n            return True\n        if c == 9:\n            return False\n        if c == 10:\n            return True\n        if c == 11:\n            return False\n        if c == 12:\n            return True\n        if c == 13:\n            return False\n        if c == 14:\n            return True\n        if c == 15:\n            return False\n        if c == 16:\n            return True\n        if c == 17:\n            return False\n        if c == 18:\n            return True\n        if c == 19:\n            return False\n        if c == 20:\n            return True\n        if c == 21:\n            return False\n        if c == 22:\n            "
    },
    {
        "number": 636,
        "title": "Exclusive Time of Functions",
        "difficulty": 1,
        "answer": "        res = [0] * n\n        stack = []\n        prev = 0\n        for log in logs:\n            fid, typ, time = log.split(':')\n            fid, time = int(fid), int(time)\n            if typ =='start':\n                if stack:\n                    res[stack[-1]] += time - prev\n                stack.append(fid)\n                prev = time\n            else:\n                res[stack.pop()] += time - prev + 1\n                prev = time + 1\n        return res"
    },
    {
        "number": 637,
        "title": "Average of Levels in Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return []\n        queue = [root]\n        res = []\n        while queue:\n            level_sum = 0\n            level_count = 0\n            next_queue = []\n            for node in queue:\n                level_sum += node.val\n                level_count += 1\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            res.append(level_sum / level_count)\n            queue = next_queue\n        return res\n"
    },
    {
        "number": 638,
        "title": "Shopping Offers",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]] + price[i-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]] + price[i-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]] + price[i-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]] + price[i-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]] + price[i-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-needs[i-1]]"
    },
    {
        "number": 639,
        "title": "Decode Ways II",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] if s[i]!= '*'\n        # dp[i] = dp[i-2] if s[i] == '*' and s[i-1]!= '*'\n        # dp[i] = dp[i-2] if s[i] == '*' and s[i-1] == '*'\n        # dp[i] = 0 if s[i] == '0'\n        # dp[i] = 0 if i == 0\n        # dp[i] = 0 if i == 1 and s[0] == '0'\n        # dp[i] = 0 if i == 2 and s[0] == '0' and s[1] == '0'\n        # dp[i] = 0 if i == 3 and s[0] == '0' and s[1] == '0' and s[2] == '0'\n"
    },
    {
        "number": 640,
        "title": "Solve the Equation",
        "difficulty": 1,
        "answer": "        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x = 6 + x - 2\n        # x + 5 - 3 + x ="
    },
    {
        "number": 641,
        "title": "Design Circular Deque",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 643,
        "title": "Maximum Average Subarray I",
        "difficulty": 0,
        "answer": "        # \u601d\u8def\uff1a\n        # \u5148\u6c42\u51fa\u6bcf\u4e2a\u7a97\u53e3\u7684\u5e73\u5747\u503c\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684\u5e73\u5747\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # \u601d\u8def\uff1a\n        # \u5148\u6c42\u51fa\u6bcf\u4e2a\u7a97\u53e3\u7684\u5e73\u5747\u503c\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684\u5e73\u5747\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # \u601d\u8def\uff1a\n        # \u5148\u6c42\u51fa\u6bcf\u4e2a\u7a97\u53e3\u7684\u5e73\u5747\u503c\uff0c\u7136"
    },
    {
        "number": 645,
        "title": "Set Mismatch",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # for i in range(len(nums) - 1):\n        #     if nums[i] == nums[i + 1]:\n        #         return [nums[i], nums[i] + 1]\n        # return [nums[-1] + 1, nums[0]]\n        \n        # nums.sort()\n        # for i in range(len(nums) - 1):\n        #     if nums[i] == nums[i + 1]:\n        #         return [nums[i], nums[i] + 1]\n        # return [nums[-1] + 1, nums[0]]\n        \n        # nums.sort()\n        # for i in range(len(nums) - 1):\n        #     if nums[i] == nums[i + 1]:\n        #         return [nums[i], nums[i] + 1]\n        # return [nums[-1] + 1, nums[0]]\n        \n        # nums"
    },
    {
        "number": 646,
        "title": "Maximum Length of Pair Chain",
        "difficulty": 1,
        "answer": "        pairs.sort(key=lambda x: x[1])\n        dp = [1] * len(pairs)\n        for i in range(1, len(pairs)):\n            for j in range(i):\n                if pairs[j][1] < pairs[i][0]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 647,
        "title": "Palindromic Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n^2)\n        # n = len(s)\n        # ans = 0\n        # for i in range(n):\n        #     for j in range(i, n):\n        #         if s[i:j+1] == s[i:j+1][::-1]:\n        #             ans += 1\n        # return ans"
    },
    {
        "number": 648,
        "title": "Replace Words",
        "difficulty": 1,
        "answer": "        dictionary = set(dictionary)\n        sentence = sentence.split()\n        for i in range(len(sentence)):\n            for j in range(1, len(sentence[i])):\n                if sentence[i][:j] in dictionary:\n                    sentence[i] = sentence[i][:j]\n                    break\n        return''.join(sentence)"
    },
    {
        "number": 649,
        "title": "Dota2 Senate",
        "difficulty": 1,
        "answer": "        radiant, dire = [], []\n        for i, c in enumerate(senate):\n            if c == 'R':\n                radiant.append(i)\n            else:\n                dire.append(i)\n        while radiant and dire:\n            if radiant[0] < dire[0]:\n                radiant.append(radiant[0] + len(senate))\n            else:\n                dire.append(dire[0] + len(senate))\n            radiant.pop(0)\n            dire.pop(0)\n        return 'Radiant' if radiant else 'Dire'"
    },
    {
        "number": 650,
        "title": "2 Keys Keyboard",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 2\n        dp = [0] * (n + 1)\n        dp[1] = 0\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + 1\n            for j in range(1, i // 2 + 1):\n                if i % j == 0:\n                    dp[i] = min(dp[i], dp[j] + i // j)\n        return dp[n]"
    },
    {
        "number": 652,
        "title": "Find Duplicate Subtrees",
        "difficulty": 1,
        "answer": "        self.res = []\n        self.preorder(root)\n        return self.res"
    },
    {
        "number": 653,
        "title": "Two Sum IV - Input is a BST",
        "difficulty": 0,
        "answer": "        # inorder traversal\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 654,
        "title": "Maximum Binary Tree",
        "difficulty": 1,
        "answer": "        if not nums:\n            return None\n        max_val = max(nums)\n        max_idx = nums.index(max_val)\n        root = TreeNode(max_val)\n        root.left = self.constructMaximumBinaryTree(nums[:max_idx])\n        root.right = self.constructMaximumBinaryTree(nums[max_idx+1:])\n        return root"
    },
    {
        "number": 655,
        "title": "Print Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return []\n        res = [[''] * (2 ** self.get_height(root) - 1) for _ in range(self.get_height(root) + 1)]\n        self.fill_tree(root, 0, 0, res)\n        return res"
    },
    {
        "number": 657,
        "title": "Robot Return to Origin",
        "difficulty": 0,
        "answer": "        return moves.count('U') == moves.count('D') and moves.count('L') == moves.count('R')"
    },
    {
        "number": 658,
        "title": "Find K Closest Elements",
        "difficulty": 1,
        "answer": "        left, right = 0, len(arr) - k\n        while left < right:\n            mid = left + (right - left) // 2\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]"
    },
    {
        "number": 659,
        "title": "Split Array into Consecutive Subsequences",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n < 3:\n            return False\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                dp[i] = dp[i - 1]\n            elif nums[i] == nums[i - 1]:\n                dp[i] = dp[i - 1]\n            elif nums[i] == nums[i - 1] + 2:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = dp[i - 1] + 2\n        return dp[-1] >= 3"
    },
    {
        "number": 661,
        "title": "Image Smoother",
        "difficulty": 0,
        "answer": "        m, n = len(img), len(img[0])\n        ans = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                count = 0\n                total = 0\n                for x in range(i - 1, i + 2):\n                    for y in range(j - 1, j + 2):\n                        if 0 <= x < m and 0 <= y < n:\n                            total += img[x][y]\n                            count += 1\n                ans[i][j] = total // count\n        return ans"
    },
    {
        "number": 662,
        "title": "Maximum Width of Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        queue = deque([(root, 1)])\n        max_width = 0\n        while queue:\n            max_width = max(max_width, queue[-1][1] - queue[0][1] + 1)\n            for _ in range(len(queue)):\n                node, depth = queue.popleft()\n                if node.left:\n                    queue.append((node.left, depth + 1))\n                if node.right:\n                    queue.append((node.right, depth + 1))\n        return max_width"
    },
    {
        "number": 664,
        "title": "Strange Printer",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+"
    },
    {
        "number": 665,
        "title": "Non-decreasing Array",
        "difficulty": 1,
        "answer": "        # 1. check if the array is non-decreasing\n        # 2. check if the array is non-decreasing by modifying at most one element\n        # 3. check if the array is non-decreasing by modifying at most two elements\n        # 4. check if the array is non-decreasing by modifying at most three elements\n        # 5. check if the array is non-decreasing by modifying at most four elements\n        # 6. check if the array is non-decreasing by modifying at most five elements\n        # 7. check if the array is non-decreasing by modifying at most six elements\n        # 8. check if the array is non-decreasing by modifying at most seven elements\n        # 9. check if the array is non-decreasing by modifying at most eight elements\n        # 10. check if the array is non-decreasing by modifying at most nine elements\n        # 11. check if the array is non-decreasing by modifying at most ten elements\n        # 12. check if the array is non-decreasing by modifying at most eleven elements\n        # 13."
    },
    {
        "number": 667,
        "title": "Beautiful Arrangement II",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return list(range(1, n+1))\n        if k == 2:\n            return [i for i in range(1, n+1) if i % 2 == 1] + [i for i in range(1, n+1) if i % 2 == 0]\n        if k == 3:\n            return [i for i in range(1, n+1) if i % 3 == 1] + [i for i in range(1, n+1) if i % 3 == 2] + [i for i in range(1, n+1) if i % 3 == 0]\n        if k == 4:\n            return [i for i in range(1, n+1) if i % 4 == 1] + [i for i in range(1, n+1) if i % 4 == 3] + [i for i in range(1, n+1) if i % 4 == 2] + [i for i in range(1, n+1) if i % 4 == 0]\n        if k == 5:\n            return [i for i in"
    },
    {
        "number": 668,
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": 2,
        "answer": "        def count(m, n, k):\n            if m == 1:\n                return k\n            if n == 1:\n                return k\n            if k == 1:\n                return m * n\n            if k == m * n:\n                return m * n\n            if k == m * n - 1:\n                return m * n - 1\n            if k == m * n - m + 1:\n                return m * n - m + 1\n            if k == m * n - m + 1 + m - 1:\n                return m * n - m + 1 + m - 1\n            if k == m * n - m + 1 + m - 1 + m - 2:\n                return m * n - m + 1 + m - 1 + m - 2\n            if k == m * n - m + 1 + m - 1 + m - 2 + m - 3:\n                return m * n - m + 1 + m - 1 + m - 2 + m - 3\n            if k == m * n - m + 1 + m - 1 + m - 2 + m - 3 + m - 4:\n                "
    },
    {
        "number": 669,
        "title": "Trim a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        if root.val < low:\n            return self.trimBST(root.right, low, high)\n        elif root.val > high:\n            return self.trimBST(root.left, low, high)\n        else:\n            root.left = self.trimBST(root.left, low, high)\n            root.right = self.trimBST(root.right, low, high)\n            return root\n"
    },
    {
        "number": 670,
        "title": "Maximum Swap",
        "difficulty": 1,
        "answer": "        s = str(num)\n        n = len(s)\n        max_num = num\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                s1 = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]\n                if int(s1) > max_num:\n                    max_num = int(s1)\n        return max_num"
    },
    {
        "number": 671,
        "title": "Second Minimum Node In a Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return -1\n        if not root.left and not root.right:\n            return -1\n        if not root.left:\n            return min(root.right.val, root.val)\n        if not root.right:\n            return min(root.left.val, root.val)\n        return min(root.right.val, root.left.val, root.val)\n"
    },
    {
        "number": 672,
        "title": "Bulb Switcher II",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 2\n        elif n == 2:\n            return 3\n        elif n == 3:\n            return 4\n        else:\n            return 2 ** n"
    },
    {
        "number": 673,
        "title": "Number of Longest Increasing Subsequence",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [1] * n\n        count = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if dp[j] + 1 > dp[i]:\n                        dp[i] = dp[j] + 1\n                        count[i] = count[j]\n                    elif dp[j] + 1 == dp[i]:\n                        count[i] += count[j]\n        longest = max(dp)\n        return sum(c for i, c in enumerate(count) if dp[i] == longest)"
    },
    {
        "number": 674,
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            if nums[i] > nums[i - 1]:\n                dp[i] = dp[i - 1] + 1\n        return max(dp)"
    },
    {
        "number": 675,
        "title": "Cut Off Trees for Golf Event",
        "difficulty": 2,
        "answer": "        m, n = len(forest), len(forest[0])\n        trees = sorted([(h, i, j) for i, row in enumerate(forest) for j, h in enumerate(row) if h > 1])\n        if not trees:\n            return -1\n        x, y = 0, 0\n        steps = 0\n        for h, i, j in trees:\n            if not self.can_reach(forest, x, y, i, j):\n                return -1\n            for _ in range(h - 1):\n                if not self.can_reach(forest, x, y, i, j):\n                    return -1\n                steps += 1\n                x, y = i, j\n            x, y = i, j\n            steps += 1\n        return steps"
    },
    {
        "number": 676,
        "title": "Implement Magic Dictionary",
        "difficulty": 1,
        "answer": "        self.d = set(dictionary)\n        self.m = {}\n        for word in self.d:\n            for i in range(len(word)):\n                self.m[word[:i] + '*' + word[i+1:]] = word\n        return self.search_helper(searchWord)"
    },
    {
        "number": 677,
        "title": "Map Sum Pairs",
        "difficulty": 1,
        "answer": "        self.d = {}\n        self.prefix = prefix\n        self.val = val\n        self.d[prefix] = val\n        \n    def sum(self, prefix):\n        return sum(self.d[prefix])\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 678,
        "title": "Valid Parenthesis String",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for i in s:\n        #     if i == '(':\n        #         stack.append(i)\n        #     elif i == ')':\n        #         if stack:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     elif i == '*':\n        #         if stack:\n        #             stack.pop()\n        #         else:\n        #             stack.append(i)\n        # if stack:\n        #     return False\n        # return True"
    },
    {
        "number": 679,
        "title": "24 Game",
        "difficulty": 2,
        "answer": "        if len(cards) == 1:\n            return abs(cards[0] - 24) < 1e-6\n        for i in range(len(cards)):\n            for j in range(len(cards)):\n                if i!= j:\n                    cards1 = cards[:i] + cards[i + 1:j] + cards[j + 1:]\n                    for op1 in [\"+\", \"-\", \"*\", \"/\"]:\n                        for op2 in [\"+\", \"-\", \"*\", \"/\"]:\n                            if op1 == \"/\" and op2 == \"/\":\n                                continue\n                            if self.judgePoint24(cards1 + [eval(\"{}{}{}\".format(cards[i], op1, cards[j]))]):\n                                return True\n        return False"
    },
    {
        "number": 680,
        "title": "Valid Palindrome II",
        "difficulty": 0,
        "answer": "        left, right = 0, len(s) - 1\n        while left < right:\n            if s[left] == s[right]:\n                left += 1\n                right -= 1\n            else:\n                return self.is_palindrome(s, left + 1, right) or self.is_palindrome(s, left, right - 1)\n        return True"
    },
    {
        "number": 682,
        "title": "Baseball Game",
        "difficulty": 0,
        "answer": "        stack = []\n        for op in operations:\n            if op == 'C':\n                stack.pop()\n            elif op == 'D':\n                stack.append(stack[-1] * 2)\n            elif op == '+':\n                stack.append(stack[-1] + stack[-2])\n            else:\n                stack.append(int(op))\n        return sum(stack)"
    },
    {
        "number": 684,
        "title": "Redundant Connection",
        "difficulty": 1,
        "answer": "        # build the graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 685,
        "title": "Redundant Connection II",
        "difficulty": 2,
        "answer": "        n = len(edges)\n        parent = [0] * n\n        child = [0] * n\n        for u, v in edges:\n            if parent[u - 1] == 0:\n                parent[u - 1] = v\n            else:\n                child[u - 1] = v\n        for i in range(n):\n            if parent[i] == 0 and child[i]!= 0:\n                parent[i] = child[i]\n        for u, v in edges:\n            if parent[u - 1] == v:\n                return [u, v]\n        return []"
    },
    {
        "number": 686,
        "title": "Repeated String Match",
        "difficulty": 1,
        "answer": "        if len(a) == 1 and len(b) == 1:\n            return 1 if a == b else -1\n        if len(a) == 1 and len(b) > 1:\n            return 1 if a == b[:len(b)] else -1\n        if len(a) > 1 and len(b) == 1:\n            return 1 if a[:len(b)] == b else -1\n        if len(a) > 1 and len(b) > 1:\n            if b in a:\n                return 1\n            elif b in a + a:\n                return 2\n            else:\n                return -1"
    },
    {
        "number": 687,
        "title": "Longest Univalue Path",
        "difficulty": 1,
        "answer": "        if not root:\n            return 0\n        self.max_len = 0\n        self.dfs(root)\n        return self.max_len"
    },
    {
        "number": 688,
        "title": "Knight Probability in Chessboard",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 0.0625\n        if n == 3:\n            return 0.0625\n        if n == 4:\n            return 0.0625\n        if n == 5:\n            return 0.0625\n        if n == 6:\n            return 0.0625\n        if n == 7:\n            return 0.0625\n        if n == 8:\n            return 0.0625\n        if n == 9:\n            return 0.0625\n        if n == 10:\n            return 0.0625\n        if n == 11:\n            return 0.0625\n        if n == 12:\n            return 0.0625\n        if n == 13:\n            return 0.0625\n        if n == 14:\n            return 0.0625\n        if n == 15:\n            return 0.0625\n        if n == 16:\n            return 0.0625\n        if n == 17:\n            return 0.0625\n        if n =="
    },
    {
        "number": 689,
        "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        res = []\n        for i in range(n - k + 1):\n            for j in range(i + k, n + 1):\n                s1 = prefix[j] - prefix[i]\n                s2 = prefix[j + k] - prefix[j]\n                s3 = prefix[j + 2 * k] - prefix[j + k]\n                if s1 >= s2 and s1 >= s3:\n                    res.append([i, j])\n                elif s2 >= s1 and s2 >= s3:\n                    res.append([i, j + k])\n                elif s3 >= s1 and s3 >= s2:\n                    res.append([i, j + 2 * k])\n        return res"
    },
    {
        "number": 690,
        "title": "Employee Importance",
        "difficulty": 1,
        "answer": ""
    },
    {
        "number": 691,
        "title": "Stickers to Spell Word",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min number of stickers to form target[:i]\n        # dp[i][j] = min(dp[i][j], dp[i - len(stickers[k])][j - set(stickers[k])] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j - set(stickers[k])] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j - set(stickers[k])] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j - set(stickers[k])] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j - set(stickers[k])] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j - set(stickers[k])] + 1"
    },
    {
        "number": 692,
        "title": "Top K Frequent Words",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 693,
        "title": "Binary Number with Alternating Bits",
        "difficulty": 0,
        "answer": "        return bin(n)[2:].count('0') == bin(n)[2:].count('1')"
    },
    {
        "number": 695,
        "title": "Max Area of Island",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return 0\n            grid[i][j] = 0\n            return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    res = max(res, dfs(i, j))\n        return res"
    },
    {
        "number": 696,
        "title": "Count Binary Substrings",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # count = 0\n        # prev = None\n        # curr = 0\n        # for i in range(len(s)):\n        #     if s[i] == prev:\n        #         curr += 1\n        #     else:\n        #         count += min(curr, 1)\n        #         curr = 1\n        #         prev = s[i]\n        # count += min(curr, 1)\n        # return count"
    },
    {
        "number": 697,
        "title": "Degree of an Array",
        "difficulty": 0,
        "answer": "        # 1. \u627e\u51fa\u6240\u6709\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\n        # 2. \u627e\u51fa\u6240\u6709\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u7d22\u5f15\n        # 3. \u627e\u51fa\u6240\u6709\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u7d22\u5f15\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\n        # 4. \u627e\u51fa\u6240\u6709\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u7d22\u5f15\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u7684\u5dee\u503c\n        # 5. \u627e\u51fa\u6240\u6709\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u7d22\u5f15\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c"
    },
    {
        "number": 698,
        "title": "Partition to K Equal Sum Subsets",
        "difficulty": 1,
        "answer": "        if len(nums) < k:\n            return False\n        if sum(nums) % k!= 0:\n            return False\n        target = sum(nums) // k\n        nums.sort(reverse=True)\n        if nums[0] > target:\n            return False\n        return self.dfs(nums, k, 0, 0, target)"
    },
    {
        "number": 699,
        "title": "Falling Squares",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # N = len(positions)\n        # ans = [0] * N\n        # for i in range(N):\n        #     left, side = positions[i]\n        #     for j in range(i, -1, -1):\n        #         right = left + side\n        #         if right >= ans[j]:\n        #             break\n        #     ans[i] = max(ans[i], side)\n        # return ans"
    },
    {
        "number": 700,
        "title": "Search in a Binary Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return None\n        if root.val == val:\n            return root\n        elif root.val > val:\n            return self.searchBST(root.left, val)\n        else:\n            return self.searchBST(root.right, val)\n"
    },
    {
        "number": 701,
        "title": "Insert into a Binary Search Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return TreeNode(val)\n        if val < root.val:\n            root.left = self.insertIntoBST(root.left, val)\n        else:\n            root.right = self.insertIntoBST(root.right, val)\n        return root"
    },
    {
        "number": 703,
        "title": "Kth Largest Element in a Stream",
        "difficulty": 0,
        "answer": "        self.nums = nums\n        self.k = k\n        self.nums.sort()\n        self.nums = self.nums[::-1]\n        return self.nums[k-1]"
    },
    {
        "number": 704,
        "title": "Binary Search",
        "difficulty": 0,
        "answer": "        if not nums:\n            return -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"
    },
    {
        "number": 705,
        "title": "Design HashSet",
        "difficulty": 0,
        "answer": "        \"\"\"\n        Runtime: O(1)\n        Space: O(n)\n        \"\"\"\n        self.set = set()\n        \n    def add(self, key: int) -> None:\n        self.set.add(key)\n        \n    def remove(self, key: int) -> None:\n        if key in self.set:\n            self.set.remove(key)\n        \n    def contains(self, key: int) -> bool:\n        return key in self.set\n        \n        \"\"\"\n        Runtime: O(1)\n        Space: O(n)\n        \"\"\"\n        self.set = set()\n        \n    def add(self, key: int) -> None:\n        self.set.add(key)\n        \n    def remove(self, key: int) -> None:\n        if key in self.set:\n            self.set.remove(key)\n        \n    def contains(self, key: int) -> bool:\n        return key in self.set\n        \n        \"\"\"\n        Runtime: O(n)\n        Space: O("
    },
    {
        "number": 706,
        "title": "Design HashMap",
        "difficulty": 0,
        "answer": "        self.hash_map = {}\n        self.hash_map[key] = value"
    },
    {
        "number": 707,
        "title": "Design Linked List",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 709,
        "title": "To Lower Case",
        "difficulty": 0,
        "answer": "        return s.lower()"
    },
    {
        "number": 710,
        "title": "Random Pick with Blacklist",
        "difficulty": 2,
        "answer": "        import random\n        import bisect\n        self.n = n\n        self.blacklist = blacklist\n        self.blacklist.sort()\n        self.blacklist_set = set(self.blacklist)\n        self.blacklist_len = len(self.blacklist)\n        self.blacklist_set_len = len(self.blacklist_set)\n        self.blacklist_set_len_half = self.blacklist_set_len // 2\n        self.blacklist_set_len_half_plus_one = self.blacklist_set_len // 2 + 1\n        self.blacklist_set_len_half_plus_one_minus_one = self.blacklist_set_len // 2 + 1 - 1\n        self.blacklist_set_len_half_plus_one_minus_one_half = self.blacklist_set_len // 2 + 1 - 1 // 2\n        self.blacklist_set_len_half_plus_one_minus_one_half_plus_one = self.blacklist_set_len // 2 + 1 -"
    },
    {
        "number": 712,
        "title": "Minimum ASCII Delete Sum for Two Strings",
        "difficulty": 1,
        "answer": "        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m - 1, -1, -1):\n            dp[i][n] = dp[i + 1][n] + ord(s1[i])\n        for j in range(n - 1, -1, -1):\n            dp[m][j] = dp[m][j + 1] + ord(s2[j])\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if s1[i] == s2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = min(dp[i + 1][j] + ord(s1[i]), dp[i][j + 1] + ord(s2[j]))\n        return dp[0][0]"
    },
    {
        "number": 713,
        "title": "Subarray Product Less Than K",
        "difficulty": 1,
        "answer": "        if k <= 1:\n            return 0\n        prod = 1\n        ans = left = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k:\n                prod /= nums[left]\n                left += 1\n            ans += right - left + 1\n        return ans"
    },
    {
        "number": 714,
        "title": "Best Time to Buy and Sell Stock with Transaction Fee",
        "difficulty": 1,
        "answer": "        # dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)\n        # dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n        n = len(prices)\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = 0\n        dp[0][1] = -prices[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i] - fee)\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n        return dp[n-1][0]"
    },
    {
        "number": 715,
        "title": "Range Module",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 717,
        "title": "1-bit and 2-bit Characters",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        i = 0\n        while i < len(bits) - 1:\n            i += bits[i] + 1\n        return i == len(bits) - 1"
    },
    {
        "number": 718,
        "title": "Maximum Length of Repeated Subarray",
        "difficulty": 1,
        "answer": "        n, m = len(nums1), len(nums2)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n        return max(max(row) for row in dp)"
    },
    {
        "number": 719,
        "title": "Find K-th Smallest Pair Distance",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = left + (right - left) // 2\n            count = 0\n            i, j = 0, 1\n            while j < n:\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n                i += 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
    },
    {
        "number": 720,
        "title": "Longest Word in Dictionary",
        "difficulty": 1,
        "answer": "        words.sort()\n        words.sort(key=len)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        words.sort(key=lambda x: len(x), reverse=True)\n        words.sort(key=lambda x: x[::-1])\n        "
    },
    {
        "number": 721,
        "title": "Accounts Merge",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(set)\n        for account in accounts:\n            name = account[0]\n            for email in account[1:]:\n                graph[account[1]].add(email)\n                graph[email].add(account[1])\n        # dfs\n        visited = set()\n        ans = []\n        for account in accounts:\n            name, emails = account[0], set(account[1:])\n            if name in visited:\n                continue\n            visited.add(name)\n            stack = [name]\n            emails = set(stack)\n            while stack:\n                node = stack.pop()\n                for nei in graph[node]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        stack.append(nei)\n                        emails.add(nei)\n            ans.append([name] + sorted(emails))\n        return ans"
    },
    {
        "number": 722,
        "title": "Remove Comments",
        "difficulty": 1,
        "answer": "        \n        # stack of comments\n        # stack of lines\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        # stack of comments\n        # stack of blocks\n        #"
    },
    {
        "number": 724,
        "title": "Find Pivot Index",
        "difficulty": 0,
        "answer": "        left_sum = 0\n        right_sum = sum(nums)\n        for i in range(len(nums)):\n            if left_sum == right_sum - nums[i]:\n                return i\n            left_sum += nums[i]\n        return -1"
    },
    {
        "number": 725,
        "title": "Split Linked List in Parts",
        "difficulty": 1,
        "answer": "        if not head:\n            return [None] * k\n        n = 0\n        cur = head\n        while cur:\n            n += 1\n            cur = cur.next\n        n = n // k\n        if n == 0:\n            return [head] + [None] * (k - 1)\n        res = []\n        cur = head\n        for i in range(k):\n            res.append(cur)\n            for j in range(n):\n                if cur:\n                    cur = cur.next\n            if cur:\n                cur = cur.next\n                n -= 1\n        return res"
    },
    {
        "number": 726,
        "title": "Number of Atoms",
        "difficulty": 2,
        "answer": "        # Solution 1: stack\n        # O(n) time\n        # O(n) space\n        # stack = []\n        # i = 0\n        # while i < len(formula):\n        #     if formula[i] == '(':\n        #         stack.append(formula[i])\n        #     elif formula[i].isupper():\n        #         stack.append(formula[i])\n        #     elif formula[i].islower():\n        #         j = i + 1\n        #         while j < len(formula) and formula[j].islower():\n        #             j += 1\n        #         count = int(formula[i + 1:j])\n        #         stack.append(formula[i:j + 1])\n        #         stack.append(count)\n        #         i = j\n        #     elif formula[i].isdigit():\n        #         j = i + 1\n        #         while j < len(formula) and formula[j].isdigit():\n        #             j += 1\n        #"
    },
    {
        "number": 728,
        "title": "Self Dividing Numbers",
        "difficulty": 0,
        "answer": "        res = []\n        for i in range(left, right + 1):\n            if self.is_self_dividing(i):\n                res.append(i)\n        return res"
    },
    {
        "number": 729,
        "title": "My Calendar I",
        "difficulty": 1,
        "answer": "        for i in range(start, end):\n            if self.is_booked(i):\n                return False\n        self.events.append([start, end])\n        return True"
    },
    {
        "number": 730,
        "title": "Count Different Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 731,
        "title": "My Calendar II",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 732,
        "title": "My Calendar III",
        "difficulty": 2,
        "answer": "        events = []\n        for start, end in zip(startTime, endTime):\n            events.append((start, 1))\n            events.append((end, -1))\n        events.sort()\n        ans = 0\n        count = 0\n        for time, delta in events:\n            count += delta\n            ans = max(ans, count)\n        return ans"
    },
    {
        "number": 733,
        "title": "Flood Fill",
        "difficulty": 0,
        "answer": "        if not image:\n            return image\n        m, n = len(image), len(image[0])\n        visited = set()\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or image[i][j]!= image[sr][sc]:\n                return\n            visited.add((i, j))\n            image[i][j] = color\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        dfs(sr, sc)\n        return image"
    },
    {
        "number": 735,
        "title": "Asteroid Collision",
        "difficulty": 1,
        "answer": "        stack = []\n        for asteroid in asteroids:\n            while stack and asteroid < 0 < stack[-1]:\n                if stack[-1] < -asteroid:\n                    stack.pop()\n                    continue\n                elif stack[-1] == -asteroid:\n                    stack.pop()\n                break\n            else:\n                stack.append(asteroid)\n        return stack"
    },
    {
        "number": 736,
        "title": "Parse Lisp Expression",
        "difficulty": 2,
        "answer": "        # stack = []\n        # curr_num = 0\n        # curr_op = '+'\n        # for c in expression:\n        #     if c.isdigit():\n        #         curr_num = curr_num * 10 + int(c)\n        #     elif c == '(':\n        #         stack.append(curr_num)\n        #         stack.append(curr_op)\n        #         curr_num = 0\n        #         curr_op = '+'\n        #     elif c == ')':\n        #         num = stack.pop()\n        #         op = stack.pop()\n        #         if op == '+':\n        #             curr_num += num\n        #         elif op == '*':\n        #             curr_num *= num\n        #     elif c in '+*':\n        #         curr_op = c\n        # return curr_num"
    },
    {
        "number": 738,
        "title": "Monotone Increasing Digits",
        "difficulty": 1,
        "answer": "        nums = list(str(n))\n        i = 1\n        while i < len(nums):\n            if nums[i] < nums[i - 1]:\n                break\n            i += 1\n        if i == len(nums):\n            return n\n        else:\n            nums[i - 1] = str(int(nums[i - 1]) - 1)\n            for j in range(i, len(nums)):\n                nums[j] = '9'\n            return int(''.join(nums))"
    },
    {
        "number": 739,
        "title": "Daily Temperatures",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # stack = []\n        # result = [0] * len(temperatures)\n        # for i in range(len(temperatures)):\n        #     while stack and temperatures[stack[-1]] < temperatures[i]:\n        #         result[stack.pop()] = i - stack[-1]\n        #     stack.append(i)\n        # return result"
    },
    {
        "number": 740,
        "title": "Delete and Earn",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max("
    },
    {
        "number": 741,
        "title": "Cherry Pickup",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][n - 1] = grid[0][0]\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if i == j == k == n - 1:\n                        continue\n                    if grid[i][j] == -1 or grid[i][k] == -1:\n                        continue\n                    if i > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k] + grid[i][j])\n                    if j > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k] + grid[i][j])\n                    if k > 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]"
    },
    {
        "number": 743,
        "title": "Network Delay Time",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v, w in times:\n            graph[u].append((v, w))\n        dist = {i: float('inf') for i in range(1, n+1)}\n        dist[k] = 0\n        heap = [(0, k)]\n        while heap:\n            time, node = heapq.heappop(heap)\n            if dist[node] < time:\n                continue\n            for v, w in graph[node]:\n                alt = time + w\n                if alt < dist[v]:\n                    dist[v] = alt\n                    heapq.heappush(heap, (alt, v))\n        if len(dist) == n:\n            return max(dist.values())\n        return -1"
    },
    {
        "number": 744,
        "title": "Find Smallest Letter Greater Than Target",
        "difficulty": 0,
        "answer": "        # binary search\n        # time complexity: O(logN)\n        # space complexity: O(1)\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]"
    },
    {
        "number": 745,
        "title": "Prefix and Suffix Search",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 746,
        "title": "Min Cost Climbing Stairs",
        "difficulty": 0,
        "answer": "        n = len(cost)\n        dp = [0] * n\n        dp[0] = cost[0]\n        dp[1] = cost[1]\n        for i in range(2, n):\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n        return min(dp[-1], dp[-2])"
    },
    {
        "number": 747,
        "title": "Largest Number At Least Twice of Others",
        "difficulty": 0,
        "answer": "        max_num = max(nums)\n        if max_num < 2 * min(nums):\n            return nums.index(max_num)\n        else:\n            return -1"
    },
    {
        "number": 748,
        "title": "Shortest Completing Word",
        "difficulty": 0,
        "answer": "        # licensePlate = \"1s3 456\"\n        # words = [\"looks\",\"pest\",\"stew\",\"show\"]\n        # licensePlate = \"1s3 456\"\n        # words = [\"looks\",\"pest\",\"stew\",\"show\"]\n        # licensePlate = \"Ah71752\"\n        # words = [\"suggest\",\"letter\",\"of\",\"husband\",\"easy\",\"education\",\"drug\",\"prevent\",\"writer\",\"old\"]\n        # licensePlate = \"Ah71752\"\n        # words = [\"suggest\",\"letter\",\"of\",\"husband\",\"easy\",\"education\",\"drug\",\"prevent\",\"writer\",\"old\"]\n        # licensePlate = \"Ah71752\"\n        # words = [\"suggest\",\"letter\",\"of\",\"husband\",\"easy\",\"education\",\"drug\",\"prevent\",\"writer\",\"old\"]\n        # licensePlate = \"Ah71752\"\n        # words = [\"suggest\",\"letter\",\"of\",\"husband\",\"easy\",\"education\",\"drug\",\"prevent\",\"writer\",\"old\"]\n        # licensePlate = \"Ah71752\"\n        # words = [\"suggest\",\"letter\",\"of\",\"husband\",\"easy\",\""
    },
    {
        "number": 749,
        "title": "Contain Virus",
        "difficulty": 2,
        "answer": "        def dfs(i, j, visited):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0 or (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, visited)\n            dfs(i - 1, j, visited)\n            dfs(i, j + 1, visited)\n            dfs(i, j - 1, visited)"
    },
    {
        "number": 752,
        "title": "Open the Lock",
        "difficulty": 1,
        "answer": "        deadends = set(deadends)\n        if \"0000\" in deadends:\n            return -1\n        if target == \"0000\":\n            return 0\n        q = deque([(\"0000\", 0)])\n        visited = set(\"0000\")\n        while q:\n            cur, step = q.popleft()\n            if cur == target:\n                return step\n            for i in range(4):\n                for d in (-1, 1):\n                    new_code = cur[:i] + str((int(cur[i]) + d) % 10) + cur[i+1:]\n                    if new_code not in visited and new_code not in deadends:\n                        q.append((new_code, step + 1))\n                        visited.add(new_code)\n        return -1"
    },
    {
        "number": 753,
        "title": "Cracking the Safe",
        "difficulty": 2,
        "answer": "        self.k = k\n        self.n = n\n        self.ans = []\n        self.visited = set()\n        self.dfs(0, \"\")\n        return \"\".join(self.ans)"
    },
    {
        "number": 754,
        "title": "Reach a Number",
        "difficulty": 1,
        "answer": "        target = abs(target)\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target % 2 == 0:\n            return target // 2 + 1\n        else:\n            return target // 2 + 2"
    },
    {
        "number": 756,
        "title": "Pyramid Transition Matrix",
        "difficulty": 1,
        "answer": "        if not bottom:\n            return True\n        if not allowed:\n            return False\n        self.memo = {}\n        return self.dfs(bottom, allowed)"
    },
    {
        "number": 757,
        "title": "Set Intersection Size At Least Two",
        "difficulty": 2,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        n = len(intervals)\n        res = 0\n        for i in range(n):\n            j = i + 1\n            while j < n and intervals[j][0] <= intervals[i][1]:\n                j += 1\n            res = max(res, j - i)\n        return res"
    },
    {
        "number": 761,
        "title": "Special Binary String",
        "difficulty": 2,
        "answer": "        res = []\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n            else:\n                count -= 1\n            if count == 0:\n                res.append(s[i:])\n        res.sort()\n        return ''.join(res)"
    },
    {
        "number": 762,
        "title": "Prime Number of Set Bits in Binary Representation",
        "difficulty": 0,
        "answer": "        def is_prime(n):\n            if n < 2:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True"
    },
    {
        "number": 763,
        "title": "Partition Labels",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # dic = {}\n        # for i, c in enumerate(s):\n        #     dic[c] = i\n        # res = []\n        # start = 0\n        # end = 0\n        # for i, c in enumerate(s):\n        #     end = max(end, dic[c])\n        #     if i == end:\n        #         res.append(end - start + 1)\n        #         start = end + 1\n        # return res"
    },
    {
        "number": 764,
        "title": "Largest Plus Sign",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i+1][j], dp[i][j+1]) + 1\n"
    },
    {
        "number": 765,
        "title": "Couples Holding Hands",
        "difficulty": 2,
        "answer": "        # n = len(row) // 2\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     for j in range(n):\n        #         if i == j:\n        #             dp[i][j] = 0\n        #         elif abs(row[2 * i] - row[2 * j]) == 1:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = float('inf')\n        # for k in range(n):\n        #     for i in range(n):\n        #         for j in range(n):\n        #             if dp[i][k] + dp[k][j] < dp[i][j]:\n        #                 dp[i][j] = dp[i][k] + dp[k][j]\n        # return sum(dp[i][j] for i in range(n) for j in range(n) if i!= j) // 2"
    },
    {
        "number": 766,
        "title": "Toeplitz Matrix",
        "difficulty": 0,
        "answer": "        m = len(matrix)\n        n = len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if i > 0 and j > 0:\n                    if matrix[i][j]!= matrix[i-1][j-1]:\n                        return False\n        return True"
    },
    {
        "number": 767,
        "title": "Reorganize String",
        "difficulty": 1,
        "answer": "        if len(s) < 2:\n            return s\n        s_dict = {}\n        for c in s:\n            if c in s_dict:\n                s_dict[c] += 1\n            else:\n                s_dict[c] = 1\n        s_list = []\n        for c in s_dict:\n            s_list.append((c, s_dict[c]))\n        s_list.sort(key=lambda x: x[1], reverse=True)\n        if s_list[0][1] > (len(s) + 1) // 2:\n            return \"\"\n        s_list_new = []\n        for c, n in s_list:\n            s_list_new.append((c, n))\n        s_list_new.sort(key=lambda x: x[0])\n        s_list_new.sort(key=lambda x: x[1], reverse=True)\n        s_list_new_new = []\n        for c, n in s_list_new:\n            s_list_new_new"
    },
    {
        "number": 768,
        "title": "Max Chunks To Make Sorted II",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 769,
        "title": "Max Chunks To Make Sorted",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n == 1:\n            return 1\n        max_chunks = 1\n        for i in range(1, n):\n            if arr[i] > arr[i - 1]:\n                max_chunks += 1\n        return max_chunks"
    },
    {
        "number": 770,
        "title": "Basic Calculator IV",
        "difficulty": 2,
        "answer": "        # evalvars = [\"e\", \"temperature\"]\n        # evalints = [1, 12]\n        # expression = \"(e + 8) * (e - 8)\"\n        # evalvars = [\"e\"]\n        # evalints = [1]\n        # expression = \"e + 8 - a + 5\"\n        # evalvars = [\"e\"]\n        # evalints = [1]\n        # expression = \"e - 8 + temperature - pressure\"\n        # evalvars = [\"e\", \"temperature\"]\n        # evalints = [1, 12]\n        # expression = \"(e + 8) * (e - 8)\"\n        # evalvars = []\n        # evalints = []\n        # expression = \"1 + 1\"\n        # evalvars = [\"e\"]\n        # evalints = [1]\n        # expression = \"e - 8 + temperature - pressure\"\n        # evalvars = [\"e\", \"temperature\"]\n        # evalints = [1, 12]\n        # expression = \"(e + 8) * (e - 8)\"\n        # eval"
    },
    {
        "number": 771,
        "title": "Jewels and Stones",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in stones:\n            if i in jewels:\n                count += 1\n        return count"
    },
    {
        "number": 773,
        "title": "Sliding Puzzle",
        "difficulty": 2,
        "answer": "        # BFS\n        # queue = collections.deque([(board, 0)])\n        # seen = set()\n        # while queue:\n        #     board, step = queue.popleft()\n        #     if tuple(board) in seen:\n        #         continue\n        #     seen.add(tuple(board))\n        #     if board == [[1,2,3],[4,5,0]]:\n        #         return step\n        #     for i in range(len(board)):\n        #         for j in range(len(board[0])):\n        #             if board[i][j] == 0:\n        #                 for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n        #                     if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y]!= 0:\n        #                         new_board = copy.deepcopy(board)\n        #                         new_board[i][j], new_board"
    },
    {
        "number": 775,
        "title": "Global and Local Inversions",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        # global_inversions = 0\n        # local_inversions = 0\n        # for i in range(len(nums) - 1):\n        #     if nums[i] > nums[i + 1]:\n        #         global_inversions += 1\n        #         local_inversions += 1\n        #     elif nums[i] < nums[i + 1]:\n        #         local_inversions += 1\n        # return global_inversions == local_inversions"
    },
    {
        "number": 777,
        "title": "Swap Adjacent in LR String",
        "difficulty": 1,
        "answer": "        if len(start)!= len(end):\n            return False\n        i = 0\n        while i < len(start):\n            if start[i] == 'X' and end[i] == 'L':\n                i += 1\n                continue\n            if start[i] == 'L' and end[i] == 'X':\n                i += 1\n                continue\n            if start[i]!= end[i]:\n                return False\n            i += 1\n        return True"
    },
    {
        "number": 778,
        "title": "Swim in Rising Water",
        "difficulty": 2,
        "answer": "        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        visited = set()\n        while heap:\n            t, x, y = heapq.heappop(heap)\n            if x == n - 1 and y == n - 1:\n                return t\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    heapq.heappush(heap, (max(t, grid[nx][ny]), nx, ny))\n        return -1"
    },
    {
        "number": 779,
        "title": "K-th Symbol in Grammar",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return 0\n        # if k == 1:\n        #     return 0\n        # if k == 2:\n        #     return 1\n        # if k == 3:\n        #     return 1\n        # if k == 4:\n        #     return 0\n        # if k == 5:\n        #     return 1\n        # if k == 6:\n        #     return 0\n        # if k == 7:\n        #     return 1\n        # if k == 8:\n        #     return 0\n        # if k == 9:\n        #     return 1\n        # if k == 10:\n        #     return 0\n        # if k == 11:\n        #     return 1\n        # if k == 12:\n        #     return 0\n        # if k == 13:\n        #     return 1\n        # if k == 14:\n        #     return 0\n        # if k == 15:\n        #     return 1\n        # if k == 16:\n        #     return 0\n        # if k == 17:\n        #     return"
    },
    {
        "number": 780,
        "title": "Reaching Points",
        "difficulty": 2,
        "answer": "        while tx >= sx and ty >= sy:\n            if tx == ty:\n                return True\n            elif tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    return (tx - sx) % ty == 0\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    return (ty - sy) % tx == 0\n        return False"
    },
    {
        "number": 781,
        "title": "Rabbits in Forest",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n), space: O(n)\n        # dp[i] = the minimum number of rabbits that could be in the forest if the ith rabbit answered \"yes\"\n        # dp[i] = dp[i-1] + answers[i] - 1\n        # dp[0] = answers[0]\n        # dp[1] = dp[0] + answers[1] - 1\n        # dp[2] = dp[1] + answers[2] - 1\n        # dp[3] = dp[2] + answers[3] - 1\n        # dp[4] = dp[3] + answers[4] - 1\n        # dp[5] = dp[4] + answers[5] - 1\n        # dp[6] = dp[5] + answers[6] - 1\n        # dp[7] = dp[6] + answers[7] - 1\n        # dp[8] = dp[7] + answers[8] - 1\n"
    },
    {
        "number": 782,
        "title": "Transform to Chessboard",
        "difficulty": 2,
        "answer": "        n = len(board)\n        if n < 2:\n            return 0\n        if n % 2 == 1:\n            return -1\n        # check if the board is valid\n        # check if the rows are valid\n        row_count = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    row_count[i] += 1\n        if any(row_count[i] % 2!= 0 for i in range(n)):\n            return -1\n        # check if the columns are valid\n        col_count = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if board[j][i] == 1:\n                    col_count[i] += 1\n        if any(col_count[i] % 2!= 0 for i in range(n)):\n            return -1\n        # check if the diagonals are valid\n        # check the left diagonal\n        left_diag_count = 0\n        for i in"
    },
    {
        "number": 783,
        "title": "Minimum Distance Between BST Nodes",
        "difficulty": 0,
        "answer": "        self.min_diff = float('inf')\n        self.pre_order(root)\n        return self.min_diff"
    },
    {
        "number": 784,
        "title": "Letter Case Permutation",
        "difficulty": 1,
        "answer": "        if not s:\n            return []\n        res = []\n        self.dfs(s, 0, res, '')\n        return res"
    },
    {
        "number": 785,
        "title": "Is Graph Bipartite?",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(graph)\n        # color = [0] * n\n        # def dfs(node, color):\n        #     if color[node]!= 0:\n        #         return color[node] == 1\n        #     color[node] = 1\n        #     for neighbor in graph[node]:\n        #         if not dfs(neighbor, color):\n        #             return False\n        #     color[node] = 2\n        #     return True\n        # for node in range(n):\n        #     if not dfs(node, color):\n        #         return False\n        # return True"
    },
    {
        "number": 786,
        "title": "K-th Smallest Prime Fraction",
        "difficulty": 1,
        "answer": "        def gcd(a, b):\n            if a == 0:\n                return b\n            return gcd(b % a, a)"
    },
    {
        "number": 787,
        "title": "Cheapest Flights Within K Stops",
        "difficulty": 1,
        "answer": "        import heapq\n        graph = collections.defaultdict(list)\n        for u, v, w in flights:\n            graph[u].append((v, w))\n        heap = [(0, src, k)]\n        while heap:\n            cost, node, k = heapq.heappop(heap)\n            if node == dst:\n                return cost\n            if k >= 0:\n                for v, w in graph[node]:\n                    heapq.heappush(heap, (cost + w, v, k - 1))\n        return -1"
    },
    {
        "number": 788,
        "title": "Rotated Digits",
        "difficulty": 1,
        "answer": "        # 1. \u66b4\u529b\u6cd5\n        # 2. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\n        # 3. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 4. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 5. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 6. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 7. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 8. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 9. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        # 10. \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\u6570\u7684\u7b80\u5316\u7248\n        #"
    },
    {
        "number": 789,
        "title": "Escape The Ghosts",
        "difficulty": 1,
        "answer": "        def manhattan(p1, p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])"
    },
    {
        "number": 790,
        "title": "Domino and Tromino Tiling",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD\n        return dp[n]"
    },
    {
        "number": 791,
        "title": "Custom Sort String",
        "difficulty": 1,
        "answer": "        # order = \"cba\"\n        # s = \"abcd\"\n        # order = \"cbafg\"\n        # s = \"abcd\"\n        # order = \"zabc\"\n        # s = \"abcd\"\n        # order = \"zyxwvutsrqponmlkjihgfedcba\"\n        # s = \"fedcba\"\n        # order = \"abcdefghijklmnopqrstuvwxyz\"\n        # s = \"leetcode\"\n        # order = \"zabcdefghijklmnopqrstuvwxy\"\n        # s = \"codeleet\"\n        # order = \"abcdefghijklmnopqrstuvwxyz\"\n        # s = \"abcdefghijklmnopqrstuvwxyz\"\n        # order = \"zyxwvutsrqponmlkjihgfedcba\"\n        # s = \"fedcba\"\n        # order = \"zyxwvutsrqponmlkjihgfedcba\"\n        #"
    },
    {
        "number": 792,
        "title": "Number of Matching Subsequences",
        "difficulty": 1,
        "answer": "        # M1. \u66b4\u529b\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n^2*m)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # n\u4e3as\u7684\u957f\u5ea6\uff0cm\u4e3awords\u7684\u957f\u5ea6\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684s\u662f\u5b57\u7b26\u4e32\uff0c\u800c\u4e0d\u662f\u6570\u7ec4\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684words\u662f\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u800c\u4e0d\u662f\u5b57\u7b26\u4e32\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684words\u662f\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u800c\u4e0d\u662f\u5b57\u7b26\u4e32\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684words\u662f\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u800c\u4e0d\u662f\u5b57\u7b26\u4e32\n        #"
    },
    {
        "number": 793,
        "title": "Preimage Size of Factorial Zeroes Function",
        "difficulty": 2,
        "answer": "        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! / (x - k)!\n        # f(x) = x! /"
    },
    {
        "number": 794,
        "title": "Valid Tic-Tac-Toe State",
        "difficulty": 1,
        "answer": "        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is valid\n        # check if the board is"
    },
    {
        "number": 795,
        "title": "Number of Subarrays with Bounded Maximum",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # left_bound = -1\n        # right_bound = -1\n        # res = 0\n        # for i in range(len(nums)):\n        #     if nums[i] >= left:\n        #         left_bound = i\n        #     if nums[i] <= right:\n        #         right_bound = i\n        #     if left_bound!= -1 and right_bound!= -1:\n        #         res += right_bound - left_bound + 1\n        #         left_bound = -1\n        #         right_bound = -1\n        # return res"
    },
    {
        "number": 796,
        "title": "Rotate String",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return True\n        for i in range(len(s)):\n            if s[i:] + s[:i] == goal:\n                return True\n        return False"
    },
    {
        "number": 797,
        "title": "All Paths From Source to Target",
        "difficulty": 1,
        "answer": "        # dfs\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        self.res = []\n        self.dfs(graph, 0, [0])\n        return self.res"
    },
    {
        "number": 798,
        "title": "Smallest Rotation with Highest Score",
        "difficulty": 2,
        "answer": "        \n        # [2,3,1,4,0]\n        # [3,1,4,0,2]\n        # [1,4,0,2,3]\n        # [4,0,2,3,1]\n        # [0,2,3,1,4]\n        \n        # [2,3,1,4,0]\n        # [3,1,4,0,2]\n        # [1,4,0,2,3]\n        # [4,0,2,3,1]\n        # [0,2,3,1,4]\n        \n        # [2,3,1,4,0]\n        # [3,1,4,0,2]\n        # [1,4,0,2,3]\n        # [4,0,2,3,1]\n        # [0,2,3,1,4]\n        \n        # [2,3,1,4,0]\n        # [3,1,4,0,2]\n        # [1"
    },
    {
        "number": 799,
        "title": "Champagne Tower",
        "difficulty": 1,
        "answer": "        # \u521d\u59cb\u5316dp\u6570\u7ec4\n        dp = [0] * 100\n        dp[0] = poured\n        # \u521d\u59cb\u5316\u7b2c\u4e00\u884c\n        for i in range(1, query_row + 1):\n            dp[i] = dp[i - 1] / 2\n            if dp[i] > 1:\n                dp[i] = 1\n            for j in range(i - 1, 0, -1):\n                dp[j] = (dp[j] + dp[j - 1]) / 2\n                if dp[j] > 1:\n                    dp[j] = 1\n        return dp[query_glass]"
    },
    {
        "number": 801,
        "title": "Minimum Swaps To Make Sequences Increasing",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i]["
    },
    {
        "number": 802,
        "title": "Find Eventual Safe States",
        "difficulty": 1,
        "answer": "        # bfs\n        # time complexity: O(n + m), n is the number of nodes, m is the number of edges\n        # space complexity: O(n)\n        # graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n        # graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]"
    },
    {
        "number": 803,
        "title": "Bricks Falling When Hit",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        def dfs(i, j):\n            if not (0 <= i < m and 0 <= j < n) or grid[i][j] == 0:\n                return 0\n            grid[i][j] = 0\n            return 1 + sum(dfs(i + x, j + y) for x, y in ((0, 1), (0, -1), (1, 0), (-1, 0)))"
    },
    {
        "number": 804,
        "title": "Unique Morse Code Words",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # morse = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n        # res = set()\n        # for word in words:\n        #     tmp = ''\n        #     for c in word:\n        #         tmp += morse[ord(c) - ord('a')]\n        #     res.add(tmp)\n        # return len(res)"
    },
    {
        "number": 805,
        "title": "Split Array With Same Average",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        if n < 2:\n            return False\n        if n == 2:\n            return abs(nums[0] - nums[1]) / 2.0 == 0.0\n        for i in range(1, n - 1):\n            if abs(nums[i] - nums[i - 1]) / 2.0 == abs(nums[i + 1] - nums[i]) / 2.0:\n                return True\n        return False"
    },
    {
        "number": 806,
        "title": "Number of Lines To Write String",
        "difficulty": 0,
        "answer": "        # Time: O(n), n is the length of s\n        # Space: O(1)\n        # widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\n        # s = \"bbbcccdddaa\"\n        # widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\n        # s = \"abcdefghijklmnopqrstuvwxyz\"\n        # widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\n        # s = \"bbbcccdddaa\"\n"
    },
    {
        "number": 807,
        "title": "Max Increase to Keep City Skyline",
        "difficulty": 1,
        "answer": "        # Solution 1: O(n^2)\n        # max_row = [max(row) for row in grid]\n        # max_col = [max(col) for col in zip(*grid)]\n        # return sum(min(max_row[i], max_col[i]) - grid[i][j] for i in range(len(grid)) for j in range(len(grid[0])))"
    },
    {
        "number": 808,
        "title": "Soup Servings",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 1\n        if n == 1:\n            return 0.5\n        if n == 2:\n            return 0.75\n        if n == 3:\n            return 0.875\n        if n == 4:\n            return 0.9375\n        if n == 5:\n            return 0.96875\n        if n == 6:\n            return 0.984375\n        if n == 7:\n            return 0.9921875\n        if n == 8:\n            return 0.99609375\n        if n == 9:\n            return 0.998046875\n        if n == 10:\n            return 0.999609375\n        if n == 11:\n            return 0.99984375\n        if n == 12:\n            return 0.999921875\n        if n == 13:\n            return 0.9999609375\n        if n == 14:\n            return 0.99998046875\n        if n == 15:\n            return 0.99999921875\n        if n == 16:\n            return 0.9999996093"
    },
    {
        "number": 809,
        "title": "Expressive Words",
        "difficulty": 1,
        "answer": "        def is_stretchy(s, word):\n            i, j = 0, 0\n            while i < len(s) and j < len(word):\n                if s[i] == word[j]:\n                    i += 1\n                    j += 1\n                else:\n                    if s[i]!= word[j] and s[i]!= word[j-1] and s[i]!= word[j+1]:\n                        return False\n                    if s[i] == word[j-1] and s[i]!= word[j] and s[i]!= word[j+1]:\n                        return False\n                    if s[i] == word[j+1] and s[i]!= word[j] and s[i]!= word[j-1]:\n                        return False\n                    if s[i] == word[j-1] and s[i] == word[j+1] and s[i]!= word[j]:\n                        return False\n                    if s[i] == word[j-1] and s[i] == word[j+1] and"
    },
    {
        "number": 810,
        "title": "Chalkboard XOR Game",
        "difficulty": 2,
        "answer": "        return len(nums) % 2 == 0 or sum(nums) % 3 == 0\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 811,
        "title": "Subdomain Visit Count",
        "difficulty": 1,
        "answer": "        from collections import defaultdict\n        d = defaultdict(int)\n        for cpdomain in cpdomains:\n            count, domain = cpdomain.split()\n            count = int(count)\n            subdomains = domain.split('.')\n            for i in range(len(subdomains)):\n                d[\".\".join(subdomains[i:])] += count\n        return [str(v) + \" \" + k for k, v in d.items()]"
    },
    {
        "number": 812,
        "title": "Largest Triangle Area",
        "difficulty": 0,
        "answer": "        # sort by x\n        points.sort(key=lambda x: x[0])\n        # print(points)\n        # for i in range(len(points)):\n        #     print(points[i])\n        # print(points[0][0])\n        # print(points[0][1])\n        # print(points[1][0])\n        # print(points[1][1])\n        # print(points[2][0])\n        # print(points[2][1])\n        # print(points[3][0])\n        # print(points[3][1])\n        # print(points[4][0])\n        # print(points[4][1])\n        # print(points[5][0])\n        # print(points[5][1])\n        # print(points[6][0])\n        # print(points[6][1])\n        # print(points[7][0])\n        # print(points[7][1])\n        # print(points[8][0])\n        # print(points[8][1])\n        "
    },
    {
        "number": 813,
        "title": "Largest Sum of Averages",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][1] = sum(nums[:i]) / i\n        for i in range(2, n + 1):\n            for j in range(2, k + 1):\n                for x in range(i - 1, 0, -1):\n                    dp[i][j] = max(dp[i][j], dp[x][j - 1] + (dp[i][j - 1] - dp[x][j - 1]) / (i - x))\n        return dp[n][k]"
    },
    {
        "number": 814,
        "title": "Binary Tree Pruning",
        "difficulty": 1,
        "answer": "        \n        def dfs(node):\n            if not node:\n                return None\n            \n            node.left = dfs(node.left)\n            node.right = dfs(node.right)\n            \n            if not node.left and not node.right and node.val == 0:\n                return None\n            \n            return node\n        \n        return dfs(root)\n"
    },
    {
        "number": 815,
        "title": "Bus Routes",
        "difficulty": 2,
        "answer": "        if source == target:\n            return 0\n        routes = [set(route) for route in routes]\n        graph = collections.defaultdict(set)\n        for i, route in enumerate(routes):\n            for stop in route:\n                graph[stop].add(i)\n        queue = collections.deque([(source, 0)])\n        visited = set()\n        while queue:\n            stop, step = queue.popleft()\n            if stop == target:\n                return step\n            for i in graph[stop]:\n                if i not in visited:\n                    visited.add(i)\n                    queue.append((list(routes[i])[0], step + 1))\n        return -1"
    },
    {
        "number": 816,
        "title": "Ambiguous Coordinates",
        "difficulty": 1,
        "answer": "        def helper(s):\n            if not s:\n                return ['']\n            if len(s) == 1:\n                return [s]\n            res = []\n            for i in range(1, len(s)):\n                left = helper(s[:i])\n                right = helper(s[i:])\n                for l in left:\n                    for r in right:\n                        res.append('({}, {})'.format(l, r))\n            return res\n        return helper(s)"
    },
    {
        "number": 817,
        "title": "Linked List Components",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(n) space\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset\n        # hashset"
    },
    {
        "number": 818,
        "title": "Race Car",
        "difficulty": 2,
        "answer": "        # \u52a8\u6001\u89c4\u5212\n        # dp[i] = min(dp[i], dp[i - speed] + 1)\n        # dp[i] = min(dp[i], dp[i - speed] + 1 + dp[i - 2 * speed])\n        # dp[i] = min(dp[i], dp[i - speed] + 1 + dp[i - 2 * speed] + 1)\n        # dp[i] = min(dp[i], dp[i - speed] + 1 + dp[i - 2 * speed] + 1 + dp[i - 3 * speed])\n        # dp[i] = min(dp[i], dp[i - speed] + 1 + dp[i - 2 * speed] + 1 + dp[i - 3 * speed] + 1)\n        # dp[i] = min(dp[i], dp[i - speed] + 1 + dp[i - 2 * speed] + 1 + dp[i - 3 * speed] +"
    },
    {
        "number": 819,
        "title": "Most Common Word",
        "difficulty": 0,
        "answer": "        # 1. split the paragraph into words\n        # 2. remove the punctuation\n        # 3. remove the banned words\n        # 4. return the most common word\n        \n        # 1. split the paragraph into words\n        words = [word.lower() for word in re.findall(r'\\w+', paragraph)]\n        \n        # 2. remove the punctuation\n        words = [word for word in words if word not in string.punctuation]\n        \n        # 3. remove the banned words\n        words = [word for word in words if word not in banned]\n        \n        # 4. return the most common word\n        return collections.Counter(words).most_common(1)[0][0]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 820,
        "title": "Short Encoding of Words",
        "difficulty": 1,
        "answer": "        words.sort(key=lambda x: len(x), reverse=True)\n        res = []\n        for word in words:\n            if word not in res:\n                res.append(word)\n            else:\n                res.remove(word)\n        return sum(len(word) + 1 for word in res)"
    },
    {
        "number": 821,
        "title": "Shortest Distance to a Character",
        "difficulty": 0,
        "answer": "        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                res.append(0)\n            else:\n                res.append(min(res[i - 1] if i > 0 else float('inf'), abs(i - s.index(c))))\n        return res"
    },
    {
        "number": 822,
        "title": "Card Flipping Game",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 2)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 3)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 4)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 5)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 6)\n        # dp[i][j"
    },
    {
        "number": 823,
        "title": "Binary Trees With Factors",
        "difficulty": 1,
        "answer": "        arr.sort()\n        mod = 10**9 + 7\n        dp = {}\n        for num in arr:\n            dp[num] = 1\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    dp[num] += dp[i] * dp[num // i]\n                    dp[num] %= mod\n        return sum(dp.values()) % mod"
    },
    {
        "number": 824,
        "title": "Goat Latin",
        "difficulty": 0,
        "answer": "        vowels = set('aeiouAEIOU')\n        words = sentence.split()\n        for i, word in enumerate(words):\n            if word[0] in vowels:\n                words[i] = word +'ma'\n            else:\n                words[i] = word[1:] + word[0] +'ma'\n        return''.join(words) + 'a' * (i + 1)"
    },
    {
        "number": 825,
        "title": "Friends Of Appropriate Ages",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # count = 0\n        # for i in range(len(ages)):\n        #     for j in range(i+1, len(ages)):\n        #         if (ages[i] <= 0.5 * ages[j] + 7) or (ages[i] > ages[j]) or (ages[i] > 100 and ages[j] < 100):\n        #             continue\n        #         else:\n        #             count += 1\n        # return count"
    },
    {
        "number": 826,
        "title": "Most Profit Assigning Work",
        "difficulty": 1,
        "answer": "        jobs = sorted(zip(difficulty, profit), key=lambda x: x[0])\n        workers = sorted(zip(worker, range(len(worker))), key=lambda x: x[0])\n        jobs = [j for j in jobs if j[0] <= workers[0][0]]\n        workers = [w for w in workers if w[0] <= jobs[0][0]]\n        jobs = [j for j in jobs if j[0] <= workers[0][0]]\n        workers = [w for w in workers if w[0] <= jobs[0][0]]\n        jobs = [j for j in jobs if j[0] <= workers[0][0]]\n        workers = [w for w in workers if w[0] <= jobs[0][0]]\n        jobs = [j for j in jobs if j[0] <= workers[0][0]]\n        workers = [w for w in workers if w[0] <= jobs[0][0]]\n        jobs = [j for j in jobs if j[0] <= workers[0][0]]\n        workers = ["
    },
    {
        "number": 827,
        "title": "Making A Large Island",
        "difficulty": 2,
        "answer": "        if not grid:\n            return 0\n        \n        n = len(grid)\n        uf = UnionFind(n * n)\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i > 0 and grid[i - 1][j] == 1:\n                        uf.union(i * n + j, (i - 1) * n + j)\n                    if j > 0 and grid[i][j - 1] == 1:\n                        uf.union(i * n + j, i * n + j - 1)\n        \n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    res = max(res, uf.size(i * n + j))\n        return res"
    },
    {
        "number": 828,
        "title": "Count Unique Characters of All Substrings of a Given String",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        # n = len(s)\n        # res = 0\n        # for i in range(n):\n        #     left = i\n        #     right = i\n        #     while left >= 0 and right < n and s[left] == s[right]:\n        #         res += left - right\n        #         left -= 1\n        #         right += 1\n        #     left = i\n        #     right = i + 1\n        #     while left >= 0 and right < n and s[left] == s[right]:\n        #         res += left - right\n        #         left -= 1\n        #         right += 1\n        # return res"
    },
    {
        "number": 829,
        "title": "Consecutive Numbers Sum",
        "difficulty": 2,
        "answer": "        # \u52a8\u6001\u89c4\u5212\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-k]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-k] + dp[i-k-1]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-k] + dp[i-k-1] + dp[i-k-2]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-k] + dp[i-k-1] + dp[i-k-2] + dp[i-k-3]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-k] + dp[i-k-"
    },
    {
        "number": 830,
        "title": "Positions of Large Groups",
        "difficulty": 0,
        "answer": "        res = []\n        start = 0\n        for i in range(len(s)):\n            if i == len(s) - 1 or s[i]!= s[i + 1]:\n                if i - start + 1 >= 3:\n                    res.append([start, i + 1])\n                start = i + 1\n        return res"
    },
    {
        "number": 831,
        "title": "Masking Personal Information",
        "difficulty": 1,
        "answer": "        if '@' in s:\n            s = s.lower()\n            s = s.split('@')\n            s[0] = s[0].replace('.', '*')\n            s[0] = s[0].replace(' ', '*')\n            s[0] = s[0][0] + '*' * (len(s[0]) - 2) + s[0][-1]\n            return '@'.join(s)\n        else:\n            s = s.replace('(', '').replace(')', '').replace(' ', '')\n            s = s[-10:]\n            if len(s) == 10:\n                return '+*-***-***-' + s\n            elif len(s) == 11:\n                return '+**-***-***-' + s\n            elif len(s) == 12:\n                return '+***-***-***-' + s\n            elif len(s) == 13:\n                return '+***-***-***-' + s\n            else:\n                return '+***-***"
    },
    {
        "number": 832,
        "title": "Flipping an Image",
        "difficulty": 0,
        "answer": "        return [[1 - i for i in row[::-1]] for row in image]"
    },
    {
        "number": 833,
        "title": "Find And Replace in String",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        # n = len(s)\n        # if n == 0:\n        #     return s\n        # indices.sort()\n        # sources.sort()\n        # targets.sort()\n        # res = list(s)\n        # for i in range(len(indices)):\n        #     if indices[i] < len(s) and s[indices[i]] == sources[i][0]:\n        #         for j in range(len(sources[i])):\n        #             if indices[i] + j < len(s) and s[indices[i] + j] == sources[i][j]:\n        #                 res[indices[i] + j] = targets[i][j]\n        # return \"\".join(res)"
    },
    {
        "number": 834,
        "title": "Sum of Distances in Tree",
        "difficulty": 2,
        "answer": "        # dfs\n        # time O(n)\n        # space O(n)\n        graph = collections.defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)"
    },
    {
        "number": 835,
        "title": "Image Overlap",
        "difficulty": 1,
        "answer": "        # \u5148\u628aimg1\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg2\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg1\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg2\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\n        # \u7136\u540e\u628aimg1\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg2\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg1\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\uff0c\u7136\u540e\u628aimg2\u7684\u6bcf\u4e00\u884c\u90fd\u53d8\u6210\u4e00\u4e2alist\n        # \u7136\u540e\u628aimg1\u7684\u6bcf\u4e00\ufffd"
    },
    {
        "number": 836,
        "title": "Rectangle Overlap",
        "difficulty": 0,
        "answer": "        # \u5224\u65ad\u4e24\u4e2a\u77e9\u5f62\u662f\u5426\u76f8\u4ea4\n        # \u5982\u679c\u4e24\u4e2a\u77e9\u5f62\u6709\u4ea4\u96c6\uff0c\u90a3\u4e48\u4e24\u4e2a\u77e9\u5f62\u7684\u5de6\u4e0b\u89d2\u5750\u6807\u5fc5\u7136\u5728\u53f3\u4e0a\u89d2\u5750\u6807\u4e4b\u4e0a\n        # \u5982\u679c\u4e24\u4e2a\u77e9\u5f62\u6ca1\u6709\u4ea4\u96c6\uff0c\u90a3\u4e48\u4e24\u4e2a\u77e9\u5f62\u7684\u5de6\u4e0b\u89d2\u5750\u6807\u5fc5\u7136\u5728\u53f3\u4e0a\u89d2\u5750\u6807\u4e4b\u4e0b\n        # \u5982\u679c\u4e24\u4e2a\u77e9\u5f62\u6709\u4ea4\u96c6\uff0c\u90a3\u4e48\u4e24\u4e2a\u77e9\u5f62\u7684\u53f3\u4e0b\u89d2\u5750\u6807\u5fc5\u7136\u5728\u5de6\u4e0a\u89d2\u5750\u6807\u4e4b\u4e0a\n        # \ufffd"
    },
    {
        "number": 837,
        "title": "New 21 Game",
        "difficulty": 1,
        "answer": "        if n >= k:\n            return 1\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(k, 0, -1):\n                dp[j] = dp[j] + dp[j - 1] / maxPts\n        return dp[k]"
    },
    {
        "number": 838,
        "title": "Push Dominoes",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        n = len(dominoes)\n        force = [0] * n\n        force[0] = 1 if dominoes[0] == 'R' else -1\n        for i in range(1, n):\n            if dominoes[i] == 'R':\n                force[i] = force[i - 1] + 1\n            elif dominoes[i] == 'L':\n                force[i] = force[i - 1] - 1\n            else:\n                force[i] = 0"
    },
    {
        "number": 839,
        "title": "Similar String Groups",
        "difficulty": 2,
        "answer": "        \n        def similar(a, b):\n            count = 0\n            for i in range(len(a)):\n                if a[i]!= b[i]:\n                    count += 1\n                    if count > 2:\n                        return False\n            return True\n        \n        def dfs(i, visited, graph):\n            visited[i] = True\n            for j in graph[i]:\n                if not visited[j]:\n                    dfs(j, visited, graph)\n        \n        graph = collections.defaultdict(list)\n        for i in range(len(strs)):\n            for j in range(len(strs)):\n                if i!= j and similar(strs[i], strs[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n        \n        visited = [False] * len(strs)\n        res = 0\n        for i in range(len(strs)):\n            if not visited[i]:\n                dfs(i, visited, graph)\n                res += 1\n        return"
    },
    {
        "number": 840,
        "title": "Magic Squares In Grid",
        "difficulty": 1,
        "answer": "        def isMagicSquare(grid):\n            if len(grid)!= 3:\n                return False\n            if len(grid[0])!= 3:\n                return False\n            if sum(grid[0])!= 15:\n                return False\n            if sum(grid[1])!= 15:\n                return False\n            if sum(grid[2])!= 15:\n                return False\n            if sum(grid[0][0:3])!= 15:\n                return False\n            if sum(grid[1][0:3])!= 15:\n                return False\n            if sum(grid[2][0:3])!= 15:\n                return False\n            if sum(grid[0][0:3])!= sum(grid[1][0:3]):\n                return False\n            if sum(grid[0][0:3])!= sum(grid[2][0:3]):\n                return False\n            if sum(grid[0][0:3])!= sum(grid[2][0:3]):\n                return False\n            return True\n        \n        def isMagicSquare(grid):\n            "
    },
    {
        "number": 841,
        "title": "Keys and Rooms",
        "difficulty": 1,
        "answer": "        # BFS\n        # queue = [0]\n        # visited = set()\n        # visited.add(0)\n        # while queue:\n        #     curr = queue.pop(0)\n        #     for key in rooms[curr]:\n        #         if key not in visited:\n        #             queue.append(key)\n        #             visited.add(key)\n        # return len(visited) == len(rooms)\n        \n        # DFS\n        # def dfs(curr):\n        #     for key in rooms[curr]:\n        #         if key not in visited:\n        #             visited.add(key)\n        #             dfs(key)\n        # visited = set()\n        # dfs(0)\n        # return len(visited) == len(rooms)\n        \n        # DFS + memo\n        # def dfs(curr, memo):\n        #     for key in rooms[curr]:\n        #         if key not in memo:\n        #             memo[key] = True\n        #             "
    },
    {
        "number": 842,
        "title": "Split Array into Fibonacci Sequence",
        "difficulty": 1,
        "answer": "        n = len(num)\n        if n < 3:\n            return []\n        for i in range(1, n):\n            if num[0] == '0' and i > 1:\n                return []\n            a = int(num[:i])\n            if a >= 2 ** 31:\n                return []\n            if num[i:] and num[i] == '0':\n                return []\n            b = int(num[i:])\n            if b >= 2 ** 31:\n                return []\n            if a + b == int(num[i:]):\n                return [a, b]\n        return []"
    },
    {
        "number": 843,
        "title": "Guess the Word",
        "difficulty": 2,
        "answer": "        self.secret = secret\n        self.words = words\n        self.allowedGuesses = allowedGuesses\n        self.guesses = 0\n        self.matches = 0\n        self.guessed = set()\n        self.master = Master(self.words)"
    },
    {
        "number": 844,
        "title": "Backspace String Compare",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # stack1 = []\n        # stack2 = []\n        # for i in s:\n        #     if i!= \"#\":\n        #         stack1.append(i)\n        #     else:\n        #         if stack1:\n        #             stack1.pop()\n        #\n        # for j in t:\n        #     if j!= \"#\":\n        #         stack2.append(j)\n        #     else:\n        #         if stack2:\n        #             stack2.pop()\n        #\n        # return stack1 == stack2"
    },
    {
        "number": 845,
        "title": "Longest Mountain in Array",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the longest mountain\n        # Find the"
    },
    {
        "number": 846,
        "title": "Hand of Straights",
        "difficulty": 1,
        "answer": "        if len(hand) % groupSize!= 0:\n            return False\n        hand.sort()\n        hand_dict = {}\n        for i in hand:\n            if i not in hand_dict:\n                hand_dict[i] = 1\n            else:\n                hand_dict[i] += 1\n        for i in hand_dict:\n            if hand_dict[i] > groupSize:\n                return False\n        return True"
    },
    {
        "number": 847,
        "title": "Shortest Path Visiting All Nodes",
        "difficulty": 2,
        "answer": "        n = len(graph)\n        queue = deque([(i, 1 << i) for i in range(n)])\n        seen = {(i, 1 << i) for i in range(n)}\n        while queue:\n            node, state = queue.popleft()\n            if state == (1 << n) - 1:\n                return graph[node].count(1)\n            for nei in graph[node]:\n                if (nei, state | 1 << nei) not in seen:\n                    queue.append((nei, state | 1 << nei))\n                    seen.add((nei, state | 1 << nei))\n        return -1"
    },
    {
        "number": 848,
        "title": "Shifting Letters",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(len(shifts)):\n            res.append(self.shift(s, shifts[i]))\n        return ''.join(res)"
    },
    {
        "number": 849,
        "title": "Maximize Distance to Closest Person",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # seats = [1,0,0,0,1,0,1]\n        # seats = [1,0,0,0]\n        # seats = [0,1]\n        # seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
    },
    {
        "number": 850,
        "title": "Rectangle Area II",
        "difficulty": 2,
        "answer": "        # O(n^2)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O"
    },
    {
        "number": 851,
        "title": "Loud and Rich",
        "difficulty": 1,
        "answer": "        # \u5148\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\u6bcd\u653e\u5230\u5b57\u5178\u91cc\uff0c\u7136\u540e\u628a\u6bcf\u4e2a\u4eba\u7684\u7236\ufffd"
    },
    {
        "number": 852,
        "title": "Peak Index in a Mountain Array",
        "difficulty": 1,
        "answer": "        # binary search\n        left, right = 0, len(arr) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if arr[mid] < arr[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
    },
    {
        "number": 853,
        "title": "Car Fleet",
        "difficulty": 1,
        "answer": "        cars = sorted(zip(position, speed))\n        times = [0] * len(cars)\n        for i, (pos, spd) in enumerate(cars):\n            times[i] = (target - pos) / spd\n        return sum(times[i] < times[i - 1] for i in range(1, len(cars)))"
    },
    {
        "number": 854,
        "title": "K-Similar Strings",
        "difficulty": 2,
        "answer": "        if s1 == s2:\n            return 0\n        if len(s1)!= len(s2):\n            return -1\n        if len(s1) == 1:\n            return 1\n        if len(s1) == 2:\n            if s1[0] == s2[1] or s1[1] == s2[0]:\n                return 1\n            else:\n                return -1\n        if len(s1) == 3:\n            if s1[0] == s2[2] or s1[1] == s2[1] or s1[2] == s2[0]:\n                return 1\n            else:\n                return -1\n        if len(s1) == 4:\n            if s1[0] == s2[3] or s1[1] == s2[2] or s1[2] == s2[1] or s1[3] == s2[0]:\n                return 1\n            else:\n                return -1\n        if len(s1) == 5:\n            if s1[0"
    },
    {
        "number": 855,
        "title": "Exam Room",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 856,
        "title": "Score of Parentheses",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            else:\n                if stack:\n                    stack.pop()\n                else:\n                    stack.append(c)\n        return sum(2 ** i for i, c in enumerate(stack) if c == '(')"
    },
    {
        "number": 857,
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": 2,
        "answer": "        workers = sorted(zip(wage, quality), key=lambda x: x[1]/x[0], reverse=True)\n        res = float('inf')\n        qsum = 0\n        for w, q in workers[:k]:\n            qsum += q\n            res = min(res, qsum * w)\n        return res"
    },
    {
        "number": 858,
        "title": "Mirror Reflection",
        "difficulty": 1,
        "answer": "        # if p == q:\n        #     return 0\n        # if p % 2 == 0:\n        #     return 2\n        # if q % 2 == 0:\n        #     return 1\n        # if p % 4 == 0:\n        #     return 2\n        # if q % 4 == 0:\n        #     return 1\n        # if p % 2 == 0 and q % 2 == 0:\n        #     return 0\n        # if p % 4 == 0 and q % 4 == 0:\n        #     return 2\n        # if p % 2 == 0 and q % 4 == 0:\n        #     return 1\n        # if p % 4 == 0 and q % 2 == 0:\n        #     return 1\n        # if p % 2 == 0 and q % 2 == 0:\n        #     return 0\n        # if p % 4 == 0 and q % 2 == 0:\n        #     return 1\n        # if p % 2 == 0 and q % 4 == 0:\n        #     return 1\n        # if p % 4 == 0 and q % 2 == 0:\n        #"
    },
    {
        "number": 859,
        "title": "Buddy Strings",
        "difficulty": 0,
        "answer": "        if len(s)!= len(goal):\n            return False\n        if s == goal:\n            return len(set(s)) < len(s)\n        diffs = []\n        for i in range(len(s)):\n            if s[i]!= goal[i]:\n                diffs.append(i)\n        if len(diffs)!= 2:\n            return False\n        return s[diffs[0]] == goal[diffs[1]] and s[diffs[1]] == goal[diffs[0]]"
    },
    {
        "number": 860,
        "title": "Lemonade Change",
        "difficulty": 0,
        "answer": "        # Time: O(n), space: O(1)\n        cash = {5: 0, 10: 0, 20: 0}\n        for bill in bills:\n            if bill == 5:\n                cash[5] += 1\n            elif bill == 10:\n                if cash[5] > 0:\n                    cash[5] -= 1\n                    cash[10] += 1\n                else:\n                    return False\n            else:\n                if cash[10] > 0 and cash[5] > 0:\n                    cash[10] -= 1\n                    cash[5] -= 1\n                elif cash[5] > 2:\n                    cash[5] -= 3\n                else:\n                    return False\n        return True"
    },
    {
        "number": 861,
        "title": "Score After Flipping Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            if grid[i][0] == 0:\n                for j in range(n):\n                    grid[i][j] = 1 - grid[i][j]\n        for j in range(n):\n            if grid[0][j] == 0:\n                for i in range(m):\n                    grid[i][j] = 1 - grid[i][j]\n        res = 0\n        for i in range(m):\n            res += int(''.join(map(str, grid[i])), 2)\n        return res"
    },
    {
        "number": 862,
        "title": "Shortest Subarray with Sum at Least K",
        "difficulty": 2,
        "answer": "        # sliding window\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n"
    },
    {
        "number": 863,
        "title": "All Nodes Distance K in Binary Tree",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = collections.deque([(root, 0)])\n        # visited = set()\n        # while queue:\n        #     node, level = queue.popleft()\n        #     if node:\n        #         if node.val == target.val:\n        #             visited.add(node)\n        #         if level == k:\n        #             return [node.val for node in visited]\n        #         queue.append((node.left, level+1))\n        #         queue.append((node.right, level+1))\n        # return []"
    },
    {
        "number": 864,
        "title": "Shortest Path to Get All Keys",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        keys = set()\n        locks = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '@':\n                    start = (i, j)\n                elif 'a' <= grid[i][j] <= 'z':\n                    keys.add(grid[i][j])\n                elif 'A' <= grid[i][j] <= 'Z':\n                    locks.add(grid[i][j])\n        # print(start, keys, locks)\n        # print(self.bfs(start, keys, locks))\n        return self.bfs(start, keys, locks)"
    },
    {
        "number": 865,
        "title": "Smallest Subtree with all the Deepest Nodes",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0, None\n            l, l_node = dfs(node.left)\n            r, r_node = dfs(node.right)\n            if l > r:\n                return l + 1, l_node\n            elif l < r:\n                return r + 1, r_node\n            else:\n                return l + 1, node"
    },
    {
        "number": 866,
        "title": "Prime Palindrome",
        "difficulty": 1,
        "answer": "        # if n == 1:\n        #     return 2\n        # if n == 2:\n        #     return 3\n        # if n == 3:\n        #     return 5\n        # if n == 4:\n        #     return 7\n        # if n == 5:\n        #     return 11\n        # if n == 6:\n        #     return 13\n        # if n == 7:\n        #     return 17\n        # if n == 8:\n        #     return 19\n        # if n == 9:\n        #     return 23\n        # if n == 10:\n        #     return 29\n        # if n == 11:\n        #     return 31\n        # if n == 12:\n        #     return 37\n        # if n == 13:\n        #     return 41\n        # if n == 14:\n        #     return 43\n        # if n == 15:\n        #     return 47\n        # if n == 16:\n        #     return 53\n        # if n == 17:\n        #     return 59\n        # if n == 18:\n        #     return"
    },
    {
        "number": 867,
        "title": "Transpose Matrix",
        "difficulty": 0,
        "answer": "        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = [[0] * m for _ in range(n)]\n        \n        for i in range(m):\n            for j in range(n):\n                res[j][i] = matrix[i][j]\n        \n        return res\n"
    },
    {
        "number": 868,
        "title": "Binary Gap",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # return max([len(bin(n)[2:].split('1')[i]) - 1 for i in range(len(bin(n)[2:])) if bin(n)[2:].split('1')[i]!= ''])"
    },
    {
        "number": 869,
        "title": "Reordered Power of 2",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return False\n        if n == 1:\n            return True\n        nums = [int(i) for i in str(n)]\n        nums.sort()\n        if nums[0] == 0:\n            return False\n        for i in range(1, len(nums)):\n            if nums[i]!= nums[i - 1] * 2:\n                return False\n        return True"
    },
    {
        "number": 870,
        "title": "Advantage Shuffle",
        "difficulty": 1,
        "answer": "        # nums1.sort()\n        # nums2.sort()\n        # res = []\n        # for i in range(len(nums1)):\n        #     if nums1[i] > nums2[i]:\n        #         res.append(nums1[i])\n        #     else:\n        #         res.append(nums2[i])\n        # return res\n        \"\"\"\n        nums1.sort()\n        nums2.sort()\n        res = []\n        for i in range(len(nums1)):\n            if nums1[i] > nums2[i]:\n                res.append(nums1[i])\n            else:\n                res.append(nums2[i])\n        return res\n        \"\"\"\n        # nums1.sort()\n        # nums2.sort()\n        # res = []\n        # for i in range(len(nums1)):\n        #     if nums1[i] > nums2[i]:\n        #         res.append(n"
    },
    {
        "number": 871,
        "title": "Minimum Number of Refueling Stops",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        stations.append([target, float('inf')])\n        stations.insert(0, [0, 0])\n        pq = []\n        stations.sort(key=lambda x: x[0])\n        ans = prev = 0\n        for pos, fuel in stations:\n            tank = fuel - (pos - prev)\n            while pq and tank < 0:\n                tank += -heapq.heappop(pq)\n                ans += 1\n            if tank < 0:\n                return -1\n            heapq.heappush(pq, -tank)\n            prev = pos\n        return ans"
    },
    {
        "number": 872,
        "title": "Leaf-Similar Trees",
        "difficulty": 0,
        "answer": "        def dfs(node):\n            if not node:\n                return []\n            if not node.left and not node.right:\n                return [node.val]\n            return dfs(node.left) + dfs(node.right)\n        return dfs(root1) == dfs(root2)"
    },
    {
        "number": 873,
        "title": "Length of Longest Fibonacci Subsequence",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # dp = {}\n        # for i in range(len(arr)):\n        #     for j in range(i+1, len(arr)):\n        #         if arr[j] - arr[i] in dp:\n        #             dp[arr[j] - arr[i]] = dp[arr[j] - arr[i]] + 1\n        #         else:\n        #             dp[arr[j] - arr[i]] = 2\n        # return max(dp.values()) if dp else 0"
    },
    {
        "number": 874,
        "title": "Walking Robot Simulation",
        "difficulty": 1,
        "answer": "        x, y = 0, 0\n        dx, dy = 0, 1\n        max_distance = 0\n        for command in commands:\n            if command == -2:\n                dx, dy = -dy, dx\n            elif command == -1:\n                dx, dy = dy, -dx\n            else:\n                for _ in range(command):\n                    if (x + dx, y + dy) in obstacles:\n                        break\n                    x, y = x + dx, y + dy\n                    max_distance = max(max_distance, x * x + y * y)\n        return max_distance"
    },
    {
        "number": 875,
        "title": "Koko Eating Bananas",
        "difficulty": 1,
        "answer": "        # binary search\n        # time complexity: O(nlogn)\n        # space complexity: O(1)\n        left, right = 1, max(piles)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.canFinish(piles, h, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 876,
        "title": "Middle of the Linked List",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(1) space\n        # slow, fast = head, head\n        # while fast and fast.next:\n        #     slow = slow.next\n        #     fast = fast.next.next\n        # return slow"
    },
    {
        "number": 877,
        "title": "Stone Game",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])\n        # dp[i][j] = max(piles[i] - dp[i-1][j], piles[j] - dp[i][j-1])\n        # dp[i][j] = max(piles[i] - dp[i-1][j], piles[j] - dp[i][j-1])\n        # dp[i][j] = max(piles[i] - dp[i-1][j], piles[j] - dp[i][j-1])\n        # dp[i][j] = max(piles[i] - dp[i-1][j], piles[j] - dp[i][j-1])\n        # dp[i][j] = max(piles[i] - dp[i-1][j], piles[j] - dp[i][j-1])\n        # dp[i][j"
    },
    {
        "number": 878,
        "title": "Nth Magical Number",
        "difficulty": 2,
        "answer": "        def gcd(a, b):\n            if a < b:\n                a, b = b, a\n            while b!= 0:\n                a, b = b, a % b\n            return a"
    },
    {
        "number": 879,
        "title": "Profitable Schemes",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        m = len(group)\n        dp = [[0] * (minProfit + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n, group[i] - 1, -1):\n                for k in range(minProfit, -1, -1):\n                    dp[j][k] = (dp[j][k] + dp[j - group[i]][max(0, k - profit[i])]) % MOD\n        return sum(dp[n]) % MOD"
    },
    {
        "number": 880,
        "title": "Decoded String at Index",
        "difficulty": 1,
        "answer": "        if not s:\n            return ''\n        if k == 0:\n            return ''\n        if k == 1:\n            return s[0]\n        if k == 2:\n            return s[0] + s[1]\n        if k == 3:\n            return s[0] + s[1] + s[2]\n        if k == 4:\n            return s[0] + s[1] + s[2] + s[3]\n        if k == 5:\n            return s[0] + s[1] + s[2] + s[3] + s[4]\n        if k == 6:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5]\n        if k == 7:\n            return s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6]\n        if k == 8:\n            return s[0] + s[1] + s[2] + s["
    },
    {
        "number": 881,
        "title": "Boats to Save People",
        "difficulty": 1,
        "answer": "        people.sort()\n        l = 0\n        r = len(people) - 1\n        res = 0\n        while l <= r:\n            if people[l] + people[r] <= limit:\n                l += 1\n            r -= 1\n            res += 1\n        return res"
    },
    {
        "number": 882,
        "title": "Reachable Nodes In Subdivided Graph",
        "difficulty": 2,
        "answer": "        # dfs\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v, cnt in edges:\n        #     graph[u].append((v, cnt))\n        #     graph[v].append((u, cnt))\n        #\n        # def dfs(node, dist):\n        #     if dist > maxMoves:\n        #         return 0\n        #     if node == 0:\n        #         return 1\n        #     res = 0\n        #     for v, cnt in graph[node]:\n        #         res += dfs(v, dist + cnt)\n        #     return res\n        #\n        # return dfs(0, 0)"
    },
    {
        "number": 883,
        "title": "Projection Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(grid)\n        # x_area = 0\n        # y_area = 0\n        # z_area = 0\n        # for i in range(n):\n        #     for j in range(n):\n        #         if grid[i][j] > 0:\n        #             x_area += 1\n        #             y_area += 1\n        #             z_area += 1\n        #         if grid[i][j] > 0 and i > 0:\n        #             x_area += min(grid[i][j], grid[i-1][j])\n        #         if grid[i][j] > 0 and j > 0:\n        #             y_area += min(grid[i][j], grid[i][j-1])\n        #         if grid[i][j] > 0 and i > 0 and j > 0:\n        #             z_area += min(grid[i][j], grid[i-1][j], grid[i][j-"
    },
    {
        "number": 884,
        "title": "Uncommon Words from Two Sentences",
        "difficulty": 0,
        "answer": "        s1 = s1.split()\n        s2 = s2.split()\n        s1_set = set(s1)\n        s2_set = set(s2)\n        s1_set.difference_update(s2_set)\n        s2_set.difference_update(s1_set)\n        return list(s1_set.union(s2_set))"
    },
    {
        "number": 885,
        "title": "Spiral Matrix III",
        "difficulty": 1,
        "answer": "        # \u521d\u59cb\u5316\u8fb9\u754c\n        if rows == 1 and cols == 1:\n            return [[rStart, cStart]]\n        if rows == 1:\n            return [[rStart, cStart], [rStart, cStart + 1]]\n        if cols == 1:\n            return [[rStart, cStart], [rStart + 1, cStart]]\n        # \u521d\u59cb\u5316\u8fb9\u754c\n        if rows == 1 and cols == 1:\n            return [[rStart, cStart]]\n        if rows == 1:\n            return [[rStart, cStart], [rStart, cStart + 1]]\n        if cols == 1:\n            return [[rStart, cStart], [rStart + 1, cStart]]\n        # \u521d\u59cb\u5316\u8fb9\u754c\n        if rows == 1 and cols == 1:\n            return [[rStart, cStart]]\n        if rows == 1:\n            return [[rStart, cStart], [rStart, cStart + 1]]\n        if cols == 1:"
    },
    {
        "number": 886,
        "title": "Possible Bipartition",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for u, v in dislikes:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 887,
        "title": "Super Egg Drop",
        "difficulty": 2,
        "answer": "        memo = {}\n        def dp(k, n):\n            if k == 1:\n                return n\n            if n == 0:\n                return 0\n            if (k, n) in memo:\n                return memo[(k, n)]\n            res = float('inf')\n            for i in range(1, n+1):\n                res = min(res, max(dp(k-1, i-1), dp(k, n-i)) + 1)\n            memo[(k, n)] = res\n            return res\n        return dp(k, n)"
    },
    {
        "number": 888,
        "title": "Fair Candy Swap",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        alice_total = sum(aliceSizes)\n        bob_total = sum(bobSizes)\n        diff = alice_total - bob_total\n        alice_set = set(aliceSizes)\n        for candy in bobSizes:\n            if candy - diff in alice_set:\n                return [candy - diff, candy]"
    },
    {
        "number": 889,
        "title": "Construct Binary Tree from Preorder and Postorder Traversal",
        "difficulty": 1,
        "answer": "        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1]\n        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1]\n        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1]\n        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1]\n        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1]\n        # preorder = [1,2,4,5,3,6,7]\n        # postorder = [4,5,2,6,7,3,1"
    },
    {
        "number": 890,
        "title": "Find and Replace Pattern",
        "difficulty": 1,
        "answer": "        def match(word, pattern):\n            m, n = len(word), len(pattern)\n            if m!= n: return False\n            d = {}\n            for i in range(n):\n                if word[i] not in d:\n                    if pattern[i] in d.values(): return False\n                    d[word[i]] = pattern[i]\n                else:\n                    if d[word[i]]!= pattern[i]: return False\n            return True\n        return [word for word in words if match(word, pattern)]"
    },
    {
        "number": 891,
        "title": "Sum of Subsequence Widths",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 892,
        "title": "Surface Area of 3D Shapes",
        "difficulty": 0,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] > 0:\n                    res += grid[i][j] * 4 + 2\n                    if i > 0:\n                        res -= min(grid[i][j], grid[i - 1][j]) * 2\n                    if j > 0:\n                        res -= min(grid[i][j], grid[i][j - 1]) * 2\n        return res"
    },
    {
        "number": 893,
        "title": "Groups of Special-Equivalent Strings",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 894,
        "title": "All Possible Full Binary Trees",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [TreeNode(0)]\n        if n % 2 == 0:\n            return []\n        res = []\n        for i in range(1, n, 2):\n            left = self.allPossibleFBT(i)\n            right = self.allPossibleFBT(n - i - 1)\n            for l in left:\n                for r in right:\n                    root = TreeNode(0)\n                    root.left = l\n                    root.right = r\n                    res.append(root)\n        return res"
    },
    {
        "number": 895,
        "title": "Maximum Frequency Stack",
        "difficulty": 2,
        "answer": "        self.freq = {}\n        self.stack = []\n        self.count = 0\n        self.freq[val] = self.count\n        self.stack.append(val)\n        self.count += 1"
    },
    {
        "number": 896,
        "title": "Monotonic Array",
        "difficulty": 0,
        "answer": "        # monotone increasing\n        if len(nums) <= 2:\n            return True\n        \n        inc = True\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                inc = False\n                break\n        \n        # monotone decreasing\n        dec = True\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                dec = False\n                break\n        \n        return inc or dec\n"
    },
    {
        "number": 897,
        "title": "Increasing Order Search Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return root\n        stack = []\n        curr = root\n        prev = None\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            if prev:\n                prev.right = curr\n            curr.left = None\n            prev = curr\n            curr = curr.right\n        return root"
    },
    {
        "number": 898,
        "title": "Bitwise ORs of Subarrays",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 899,
        "title": "Orderly Queue",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return min(s[i:] + s[:i] for i in range(len(s)))\n        return ''.join(sorted(s))\n"
    },
    {
        "number": 900,
        "title": "RLE Iterator",
        "difficulty": 1,
        "answer": "        self.encoding = encoding\n        self.index = 0\n        self.n = n\n        self.count = 0\n        self.val = 0\n        self.max = 0\n        self.max_index = 0\n        self.max_count = 0\n        self.max_val = 0\n        self.max_count_index = 0\n        self.max_count_val = 0\n        self.max_count_count = 0\n        self.max_count_index_count = 0\n        self.max_count_val_count = 0\n        self.max_count_count_count = 0\n        self.max_count_index_count_count = 0\n        self.max_count_val_count_count = 0\n        self.max_count_index_count_val_count = 0\n        self.max_count_val_count_val_count = 0\n        self.max_count_index_count_val_count_count = 0\n        self.max_count_val_count_val_count_count = 0\n        self.max_count"
    },
    {
        "number": 901,
        "title": "Online Stock Span",
        "difficulty": 1,
        "answer": "        self.stack = []\n        self.stack.append((price, 1))\n        return self.stack[-1][1]"
    },
    {
        "number": 902,
        "title": "Numbers At Most N Given Digit Set",
        "difficulty": 2,
        "answer": "        # digits = [\"1\",\"3\",\"5\",\"7\"]\n        # n = 100\n        # digits = [\"1\",\"4\",\"9\"]\n        # n = 1000000000\n        # digits = [\"7\"]\n        # n = 8\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n        # n = 234\n        # digits = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\""
    },
    {
        "number": 903,
        "title": "Valid Permutations for DI Sequence",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == 'D':\n                    dp[i][j] = dp[i + 1][j] + dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = dp[i + 1][j] - dp[i + 1][j - 1]\n        return dp[0][n - 1] % (10 ** 9 + 7)"
    },
    {
        "number": 904,
        "title": "Fruit Into Baskets",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(fruits)\n        # if n < 2:\n        #     return n\n        # dp = [0] * n\n        # dp[0] = 1\n        # max_fruits = 1\n        # for i in range(1, n):\n        #     if fruits[i]!= fruits[i - 1]:\n        #         dp[i] = dp[i - 1] + 1\n        #         max_fruits = max(max_fruits, dp[i])\n        #     else:\n        #         dp[i] = dp[i - 1]\n        # return max_fruits"
    },
    {
        "number": 905,
        "title": "Sort Array By Parity",
        "difficulty": 0,
        "answer": "        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] % 2 == 0:\n                i += 1\n            else:\n                nums[i], nums[j] = nums[j], nums[i]\n                j -= 1\n        return nums"
    },
    {
        "number": 906,
        "title": "Super Palindromes",
        "difficulty": 2,
        "answer": "        left, right = int(left), int(right)\n        left_sqrt = int(math.sqrt(left))\n        right_sqrt = int(math.sqrt(right))\n        res = 0\n        for i in range(left_sqrt, right_sqrt + 1):\n            if self.is_palindrome(i):\n                res += 1\n                res += self.is_palindrome(i * i)\n        return res"
    },
    {
        "number": 907,
        "title": "Sum of Subarray Minimums",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # arr = [11,81,94,43,3]\n        # dp = [0] * len(arr)\n        # dp[0] = arr[0]\n        # for i in range(1, len(arr)):\n        #     dp[i] = min(dp[i-1] + arr[i], arr[i])\n        # return sum(dp) % (10**9 + 7)\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = [0] * len(arr)\n        # dp[0] = arr[0]\n        # for i in range(1, len(arr)):\n        #     dp[i] = min(dp[i-1] + arr[i], arr[i])\n        # return sum(dp) % (10**9 + 7)\n        \n        # Time: O(n)\n        # Space: O(n)\n        # dp = [0]"
    },
    {
        "number": 908,
        "title": "Smallest Range I",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return max(nums[-1] - nums[0] - k, 0)"
    },
    {
        "number": 909,
        "title": "Snakes and Ladders",
        "difficulty": 1,
        "answer": "        # bfs\n        # time complexity: O(n^2)\n        # space complexity: O(n^2)\n        n = len(board)\n        queue = collections.deque([(1, 0)])\n        visited = set()\n        while queue:\n            curr, step = queue.popleft()\n            if curr == n * n:\n                return step\n            for i in range(curr + 1, min(curr + 6, n * n) + 1):\n                if i in visited:\n                    continue\n                r, c = self.get_row_col(i, n)\n                if board[r][c]!= -1:\n                    i = board[r][c]\n                queue.append((i, step + 1))\n                visited.add(i)\n        return -1"
    },
    {
        "number": 910,
        "title": "Smallest Range II",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return min(nums[-1] - nums[0] - 2 * k, nums[-1] - nums[0] + 2 * k)"
    },
    {
        "number": 911,
        "title": "Online Election",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(persons)\n        # d = {}\n        # for i in range(n):\n        #     if persons[i] not in d:\n        #         d[persons[i]] = times[i]\n        #     else:\n        #         d[persons[i]] = max(d[persons[i]], times[i])\n        # ans = []\n        # for t in times:\n        #     if t in d:\n        #         ans.append(d[t])\n        #     else:\n        #         ans.append(0)\n        # return ans"
    },
    {
        "number": 912,
        "title": "Sort an Array",
        "difficulty": 1,
        "answer": "        self.quick_sort(nums, 0, len(nums) - 1)\n        return nums"
    },
    {
        "number": 913,
        "title": "Cat and Mouse",
        "difficulty": 2,
        "answer": "        # Time: O(V + E)\n        # Space: O(V + E)\n        # graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n        # graph = [[1,3],[0],[3],[0,2]]\n        # graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\n        # graph = [[1,2,3],[0,2],[1,3],[0,2]]\n        # graph = [[1,2,3,4],[0,2],[1,3,4],[0,1,2,3,4],[2,3,4],[1,2,3,4],[0,1,2,3,4]]\n        # graph = [[1,2,3,4],[0,2],[1,3,4],[0,1,2,3,4],[2,3,4],[1,2,3,4],[0,1,2,3,4]]\n        #"
    },
    {
        "number": 914,
        "title": "X of a Kind in a Deck of Cards",
        "difficulty": 0,
        "answer": "        from collections import Counter\n        from functools import reduce\n        c = Counter(deck)\n        return reduce(lambda x, y: x * y, c.values()) > len(c) and len(c) > 1"
    },
    {
        "number": 915,
        "title": "Partition Array into Disjoint Intervals",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # left_max = [0] * len(nums)\n        # right_min = [0] * len(nums)\n        # left_max[0] = nums[0]\n        # for i in range(1, len(nums)):\n        #     left_max[i] = max(left_max[i-1], nums[i])\n        # right_min[-1] = nums[-1]\n        # for i in range(len(nums)-2, -1, -1):\n        #     right_min[i] = min(right_min[i+1], nums[i])\n        # for i in range(1, len(nums)):\n        #     if left_max[i-1] <= right_min[i]:\n        #         return i\n        # return 0"
    },
    {
        "number": 916,
        "title": "Word Subsets",
        "difficulty": 1,
        "answer": "        # get the frequency of each character in words2\n        # get the frequency of each character in words1\n        # compare the frequency of each character in words2 to the frequency of each character in words1\n        # if the frequency of each character in words2 is greater than the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is less than the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is equal to the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is greater than the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is less than the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is equal to the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is greater than the frequency of each character in words1, return the word\n        # if the frequency of each character in words2 is less than the frequency"
    },
    {
        "number": 917,
        "title": "Reverse Only Letters",
        "difficulty": 0,
        "answer": "        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            if not s[l].isalpha():\n                l += 1\n            elif not s[r].isalpha():\n                r -= 1\n            else:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n        return ''.join(s)"
    },
    {
        "number": 918,
        "title": "Maximum Sum Circular Subarray",
        "difficulty": 1,
        "answer": "        \n        # O(n) time\n        # O(1) space\n        # max_sum = float('-inf')\n        # curr_sum = 0\n        # for num in nums:\n        #     curr_sum = max(curr_sum + num, num)\n        #     max_sum = max(max_sum, curr_sum)\n        # return max_sum\n        \n        # O(n) time\n        # O(1) space\n        # max_sum = float('-inf')\n        # curr_sum = 0\n        # for num in nums:\n        #     curr_sum = max(curr_sum + num, num)\n        #     max_sum = max(max_sum, curr_sum)\n        # return max_sum\n        \n        # O(n) time\n        # O(1) space\n        # max_sum = float('-inf')\n        # curr_sum = 0\n        # for num in nums:\n        #     curr_sum = max(curr_sum"
    },
    {
        "number": 919,
        "title": "Complete Binary Tree Inserter",
        "difficulty": 1,
        "answer": "        self.root = root\n        self.queue = []\n        self.queue.append(root)\n        while self.queue:\n            node = self.queue.pop(0)\n            if node.left:\n                self.queue.append(node.left)\n            if node.right:\n                self.queue.append(node.right)\n        return self.root"
    },
    {
        "number": 920,
        "title": "Number of Music Playlists",
        "difficulty": 2,
        "answer": "        mod = 10 ** 9 + 7\n        dp = [[0] * (goal + 1) for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(goal + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j - i >= 0:\n                    dp[i][j] += dp[i][j - i]\n                dp[i][j] %= mod\n        return dp[k][goal]"
    },
    {
        "number": 921,
        "title": "Minimum Add to Make Parentheses Valid",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(s[i])\n            else:\n                if len(stack) == 0:\n                    stack.append(s[i])\n                else:\n                    stack.pop()\n        return len(stack)"
    },
    {
        "number": 922,
        "title": "Sort Array By Parity II",
        "difficulty": 0,
        "answer": "        odd_nums = []\n        even_nums = []\n        for num in nums:\n            if num % 2 == 0:\n                even_nums.append(num)\n            else:\n                odd_nums.append(num)\n        return [even_nums[i] if i % 2 == 0 else odd_nums[i] for i in range(len(nums))]"
    },
    {
        "number": 923,
        "title": "3Sum With Multiplicity",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        count = collections.Counter(arr)\n        res = 0\n        for i in count:\n            for j in count:\n                k = target - i - j\n                if k in count:\n                    if i < j < k:\n                        res += count[i] * count[j] * count[k]\n                    elif i < k < j:\n                        res += count[i] * count[k] * count[j]\n                    elif j < i < k:\n                        res += count[j] * count[i] * count[k]\n                    elif j < k < i:\n                        res += count[j] * count[k] * count[i]\n                    elif k < i < j:\n                        res += count[k] * count[i] * count[j]\n                    elif k < j < i:\n                        res += count[k] * count[j] * count[i]\n        return res % (10**9 + 7)\n        \n"
    },
    {
        "number": 924,
        "title": "Minimize Malware Spread",
        "difficulty": 2,
        "answer": "        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(graph)\n        # initial = set(initial)\n        # q = collections.deque(initial)\n        # seen = set(initial)\n        # while q:\n        #     size = len(q)\n        #     for _ in range(size):\n        #         node = q.popleft()\n        #         for neighbor in range(n):\n        #             if graph[node][neighbor] == 1 and neighbor not in seen:\n        #                 seen.add(neighbor)\n        #                 q.append(neighbor)\n        # return min(initial)"
    },
    {
        "number": 925,
        "title": "Long Pressed Name",
        "difficulty": 0,
        "answer": "        if len(typed) < len(name):\n            return False\n        if len(typed) == len(name):\n            return name == typed\n        i = 0\n        j = 0\n        while i < len(name) and j < len(typed):\n            if name[i] == typed[j]:\n                i += 1\n                j += 1\n            elif j == 0 or typed[j]!= typed[j - 1]:\n                return False\n            else:\n                j += 1\n        return i == len(name)"
    },
    {
        "number": 926,
        "title": "Flip String to Monotone Increasing",
        "difficulty": 1,
        "answer": "        n = len(s)\n        flip = 0\n        for i in range(n):\n            if s[i] == '1':\n                flip += 1\n        if flip % 2 == 0:\n            return flip // 2\n        else:\n            return flip // 2 + 1"
    },
    {
        "number": 927,
        "title": "Three Equal Parts",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # arr = [1,0,1,0,1]\n        # arr = [1,1,0,1,1]\n        # arr = [1,1,0,0,1]\n        # arr = [1,1,0,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1"
    },
    {
        "number": 928,
        "title": "Minimize Malware Spread II",
        "difficulty": 2,
        "answer": "        # BFS\n        # Time: O(V + E)\n        # Space: O(V + E)\n        # n = len(graph)\n        # initial = set(initial)\n        # q = collections.deque(initial)\n        # seen = set(initial)\n        # while q:\n        #     size = len(q)\n        #     for _ in range(size):\n        #         node = q.popleft()\n        #         for nei in range(n):\n        #             if graph[node][nei] == 1 and nei not in seen:\n        #                 q.append(nei)\n        #                 seen.add(nei)\n        # return list(initial)[0]"
    },
    {
        "number": 929,
        "title": "Unique Email Addresses",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # emails_set = set()\n        # for email in emails:\n        #     local_name, domain_name = email.split('@')\n        #     local_name = local_name.split('+')[0]\n        #     local_name = local_name.replace('.', '')\n        #     emails_set.add(local_name + '@' + domain_name)\n        # return len(emails_set)"
    },
    {
        "number": 930,
        "title": "Binary Subarrays With Sum",
        "difficulty": 1,
        "answer": "        # prefix sum\n        # prefix[i] = prefix[i-1] + nums[i]\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1])\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1]) - sum(nums[j:i])\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1]) - sum(nums[j:i])\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1]) - sum(nums[j:i])\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1]) - sum(nums[j:i])\n        # prefix[i] - prefix[j] = sum(nums[j+1:i+1]) - sum(nums[j:i])\n        # prefix[i] - prefix[j] = sum(nums[j+"
    },
    {
        "number": 931,
        "title": "Minimum Falling Path Sum",
        "difficulty": 1,
        "answer": "        n = len(matrix)\n        dp = [[0] * n for _ in range(n)]\n        dp[0] = matrix[0]\n        for i in range(1, n):\n            for j in range(n):\n                if j == 0:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j]\n                elif j == n - 1:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]) + matrix[i][j]\n        return min(dp[-1])"
    },
    {
        "number": 932,
        "title": "Beautiful Array",
        "difficulty": 1,
        "answer": "        def dfs(nums, i, j, k):\n            if i >= j:\n                return nums\n            if k == 0:\n                return dfs(nums, i + 1, j, k + 1)\n            if k == 1:\n                return dfs(nums, i, j - 1, k + 1)\n            if nums[i] * 2 == nums[j] + 1:\n                return dfs(nums, i + 1, j, k + 1)\n            if nums[i] * 2 == nums[j] - 1:\n                return dfs(nums, i, j - 1, k + 1)\n            if nums[i] * 2 > nums[j] + 1:\n                return dfs(nums, i, j - 1, k + 1)\n            if nums[i] * 2 < nums[j] - 1:\n                return dfs(nums, i + 1, j, k + 1)"
    },
    {
        "number": 933,
        "title": "Number of Recent Calls",
        "difficulty": 0,
        "answer": "        self.t = t\n        self.requests = []\n        self.requests.append(t)\n        return len(self.requests)"
    },
    {
        "number": 934,
        "title": "Shortest Bridge",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j]!= 1:\n                return\n            grid[i][j] = 2\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)"
    },
    {
        "number": 935,
        "title": "Knight Dialer",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j-2] + dp[i-1][j-1] + dp[i-1][j+1] + dp[i-1][j+2]\n        # dp[i][j] = dp[i-2][j-1] + dp[i-2][j+1] + dp[i-1][j-2] + dp[i-1][j+2]\n        # dp[i][j] = dp[i-2][j-2] + dp[i-2][j+2] + dp[i-1][j-1] + dp[i-1][j+1]\n        # dp[i][j] = dp[i-3][j-3] + dp[i-3][j+3] + dp[i-2][j-2] + dp[i-2][j+2] + dp[i-1][j-1] + dp[i-1"
    },
    {
        "number": 936,
        "title": "Stamping The Sequence",
        "difficulty": 2,
        "answer": "        n, m = len(stamp), len(target)\n        if n > m:\n            return []\n        stamp = list(stamp)\n        target = list(target)\n        res = []\n        for i in range(m - n + 1):\n            if target[i:i + n] == stamp:\n                res.append(i)\n                for j in range(i, i + n):\n                    target[j] = '?'\n        return res if target == ['?'] * m else []"
    },
    {
        "number": 937,
        "title": "Reorder Data in Log Files",
        "difficulty": 1,
        "answer": "        # split the logs into two parts: letter logs and digit logs\n        letter_logs = []\n        digit_logs = []\n        for log in logs:\n            if log.split()[1].isdigit():\n                digit_logs.append(log)\n            else:\n                letter_logs.append(log)"
    },
    {
        "number": 938,
        "title": "Range Sum of BST",
        "difficulty": 0,
        "answer": "        if not root:\n            return 0\n        if root.val < low:\n            return self.rangeSumBST(root.right, low, high)\n        elif root.val > high:\n            return self.rangeSumBST(root.left, low, high)\n        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)"
    },
    {
        "number": 939,
        "title": "Minimum Area Rectangle",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # n = len(points)\n        # if n < 4:\n        #     return 0\n        # res = float('inf')\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         for k in range(j+1, n):\n        #             x1, y1 = points[i]\n        #             x2, y2 = points[j]\n        #             x3, y3 = points[k]\n        #             if x1 == x2 or x1 == x3 or x2 == x3:\n        #                 continue\n        #             if y1 == y2 or y1 == y3 or y2 == y3:\n        #                 continue\n        #             if x1 == x2 == x3 or y1 == y2 == y3:\n        #                 res = min(res, abs(x1 - x3) * abs(y1 - y2))\n        # return res if res!= float('inf') else 0"
    },
    {
        "number": 940,
        "title": "Distinct Subsequences II",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [1] * n\n        for i in range(1, n):\n            dp[i] = (dp[i - 1] * 2) % (10 ** 9 + 7)\n            if s[i] == s[i - 1]:\n                dp[i] = (dp[i] - dp[i - 2]) % (10 ** 9 + 7)\n        return dp[-1]"
    },
    {
        "number": 941,
        "title": "Valid Mountain Array",
        "difficulty": 0,
        "answer": "        if len(arr) < 3:\n            return False\n        \n        i = 1\n        while i < len(arr) and arr[i] > arr[i-1]:\n            i += 1\n        \n        if i == 1 or i == len(arr):\n            return False\n        \n        while i < len(arr) and arr[i] < arr[i-1]:\n            i += 1\n        \n        return i == len(arr)\n"
    },
    {
        "number": 942,
        "title": "DI String Match",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # n = len(s)\n        # res = [0] * (n + 1)\n        # for i in range(n):\n        #     if s[i] == 'I':\n        #         res[i + 1] = res[i] + 1\n        #     else:\n        #         res[i + 1] = res[i] - 1\n        # return res[1:]"
    },
    {
        "number": 943,
        "title": "Find the Shortest Superstring",
        "difficulty": 2,
        "answer": "        # dp[i][j] = shortest superstring of words[i:j+1]\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])\n        # dp[i][j] = min(dp[i][k] + dp[k+1][j] + word[i:j+1])"
    },
    {
        "number": 944,
        "title": "Delete Columns to Make Sorted",
        "difficulty": 0,
        "answer": "        # Time: O(n^2), space: O(1)\n        # n = len(strs)\n        # if n == 1:\n        #     return 0\n        # res = 0\n        # for i in range(n):\n        #     for j in range(i+1, n):\n        #         if strs[i] > strs[j]:\n        #             res += 1\n        #             break\n        # return res"
    },
    {
        "number": 945,
        "title": "Minimum Increment to Make Array Unique",
        "difficulty": 1,
        "answer": "        # nums.sort()\n        # res = 0\n        # for i in range(1, len(nums)):\n        #     if nums[i] <= nums[i-1]:\n        #         res += nums[i-1] - nums[i] + 1\n        #         nums[i] = nums[i-1] + 1\n        # return res"
    },
    {
        "number": 946,
        "title": "Validate Stack Sequences",
        "difficulty": 1,
        "answer": "        # stack = []\n        # i = 0\n        # for num in pushed:\n        #     stack.append(num)\n        #     while stack and stack[-1] == popped[i]:\n        #         stack.pop()\n        #         i += 1\n        # return not stack"
    },
    {
        "number": 947,
        "title": "Most Stones Removed with Same Row or Column",
        "difficulty": 1,
        "answer": "        # Time: O(n^2), space: O(n^2)\n        # dp[i][j] = the max stones can be removed if we remove stones[i] and stones[j]\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i"
    },
    {
        "number": 948,
        "title": "Bag of Tokens",
        "difficulty": 1,
        "answer": "        tokens.sort()\n        i, j = 0, len(tokens) - 1\n        score = 0\n        while i <= j:\n            if power >= tokens[i]:\n                power -= tokens[i]\n                score += 1\n                i += 1\n            elif score > 0:\n                power += tokens[j]\n                score -= 1\n                j -= 1\n            else:\n                break\n        return score"
    },
    {
        "number": 949,
        "title": "Largest Time for Given Digits",
        "difficulty": 1,
        "answer": "        # Time: O(1)\n        # Space: O(1)\n        # arr.sort()\n        # for i in range(len(arr) - 1, -1, -1):\n        #     if arr[i] > 2:\n        #         arr[i] = 0\n        #     else:\n        #         break\n        # for i in range(len(arr) - 1, -1, -1):\n        #     if arr[i] > 3:\n        #         arr[i] = 0\n        #     else:\n        #         break\n        # for i in range(len(arr) - 1, -1, -1):\n        #     if arr[i] > 4:\n        #         arr[i] = 0\n        #     else:\n        #         break\n        # if arr[0] == 0 or arr[1] == 0 or arr[2] == 0 or arr[3] == 0:\n        #     return \"\"\n        # else:\n        #     return \"{:02d}:{:02d}\".format(arr[0"
    },
    {
        "number": 950,
        "title": "Reveal Cards In Increasing Order",
        "difficulty": 1,
        "answer": "        deck.sort()\n        ans = [0] * len(deck)\n        for i in range(len(deck)):\n            ans[i] = deck[len(deck) - 1 - i]\n        return ans"
    },
    {
        "number": 951,
        "title": "Flip Equivalent Binary Trees",
        "difficulty": 1,
        "answer": "        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        if root1.val!= root2.val:\n            return False\n        return self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or \\\n               self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)"
    },
    {
        "number": 952,
        "title": "Largest Component Size by Common Factor",
        "difficulty": 2,
        "answer": "        def find(x):\n            if x!= p[x]:\n                p[x] = find(p[x])\n            return p[x]"
    },
    {
        "number": 953,
        "title": "Verifying an Alien Dictionary",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # order_dict = {}\n        # for i, c in enumerate(order):\n        #     order_dict[c] = i\n        # for i in range(len(words) - 1):\n        #     word1 = words[i]\n        #     word2 = words[i + 1]\n        #     for j in range(min(len(word1), len(word2))):\n        #         if word1[j]!= word2[j]:\n        #             if order_dict[word1[j]] > order_dict[word2[j]]:\n        #                 return False\n        #             break\n        #     else:\n        #         if len(word1) > len(word2):\n        #             return False\n        # return True"
    },
    {
        "number": 954,
        "title": "Array of Doubled Pairs",
        "difficulty": 1,
        "answer": "        arr.sort()\n        for i in range(len(arr) // 2):\n            if arr[2 * i] * 2!= arr[2 * i + 1]:\n                return False\n        return True"
    },
    {
        "number": 955,
        "title": "Delete Columns to Make Sorted II",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        # n = len(strs)\n        # m = len(strs[0])\n        # dp = [[0] * m for _ in range(n)]\n        # for j in range(m):\n        #     for i in range(n):\n        #         if j == 0:\n        #             dp[i][j] = 1\n        #         else:\n        #             dp[i][j] = dp[i][j - 1] + 1 if strs[i][j] < strs[i][j - 1] else dp[i][j - 1]\n        # return m - dp[n - 1][m - 1]"
    },
    {
        "number": 956,
        "title": "Tallest Billboard",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n        # dp[i] = max(dp[i], dp[i-j] + k)\n"
    },
    {
        "number": 957,
        "title": "Prison Cells After N Days",
        "difficulty": 1,
        "answer": "        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number of occupied cells.\n        # The state of the prison is defined as the number"
    },
    {
        "number": 958,
        "title": "Check Completeness of a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return True\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node.left:\n                if node.right:\n                    queue.append(node.right)\n                else:\n                    return False\n            else:\n                if node.right:\n                    return False\n            if node.left:\n                queue.append(node.left)\n        return True\n"
    },
    {
        "number": 959,
        "title": "Regions Cut By Slashes",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        self.parent = list(range(4 * n * n))\n        self.size = [1] * 4 * n * n"
    },
    {
        "number": 960,
        "title": "Delete Columns to Make Sorted III",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        # n = len(strs)\n        # ans = 0\n        # for i in range(n):\n        #     for j in range(i + 1, n):\n        #         if all(strs[i][k] <= strs[j][k] for k in range(len(strs[i]))):\n        #             ans += 1\n        # return ans"
    },
    {
        "number": 961,
        "title": "N-Repeated Element in Size 2N Array",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        n = len(nums) // 2\n        for i in range(n):\n            if nums[i] == nums[i + n]:\n                return nums[i]"
    },
    {
        "number": 962,
        "title": "Maximum Width Ramp",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 963,
        "title": "Minimum Area Rectangle II",
        "difficulty": 1,
        "answer": "        points.sort()\n        n = len(points)\n        res = float('inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                if x1 == x2 or y1 == y2:\n                    continue\n                x3, y3 = points[(i+j)//2]\n                x4, y4 = points[(i+j)//2 + 1]\n                if x3 == x4 or y3 == y4:\n                    continue\n                res = min(res, abs(x1-x2)*abs(y1-y2))\n        return res if res!= float('inf') else 0"
    },
    {
        "number": 964,
        "title": "Least Operators to Express Number",
        "difficulty": 2,
        "answer": "        def dfs(x, target, cur, count):\n            if x == 0:\n                return count\n            if x < 0:\n                return float('inf')\n            if x == 1:\n                return float('inf')\n            if x == target:\n                return count\n            if cur == 0:\n                return min(dfs(x // 2, target, 1, count + 1), dfs(x * 2, target, 0, count + 1), dfs(x - 1, target, 1, count + 1))\n            if cur == 1:\n                return min(dfs(x // 2, target, 1, count + 1), dfs(x * 2, target, 0, count + 1), dfs(x - 1, target, 1, count + 1))\n            if cur == 2:\n                return min(dfs(x // 2, target, 1, count + 1), dfs(x * 2, target, 0, count + 1), dfs(x - 1, target, 1, count + 1))\n            if cur == 3:\n                return min(dfs(x"
    },
    {
        "number": 965,
        "title": "Univalued Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return True\n        if root.left:\n            if root.val!= root.left.val:\n                return False\n        if root.right:\n            if root.val!= root.right.val:\n                return False\n        return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)\n"
    },
    {
        "number": 966,
        "title": "Vowel Spellchecker",
        "difficulty": 1,
        "answer": "        # build a dict of words in wordlist\n        wordlist_dict = {}\n        for word in wordlist:\n            wordlist_dict[word] = word\n        # build a dict of words in wordlist with capitalization\n        wordlist_dict_cap = {}\n        for word in wordlist:\n            wordlist_dict_cap[word.lower()] = word\n        # build a dict of words in wordlist with vowel errors\n        wordlist_dict_vowel = {}\n        for word in wordlist:\n            wordlist_dict_vowel[self.vowel_error(word)] = word\n        # build a dict of words in wordlist with capitalization and vowel errors\n        wordlist_dict_cap_vowel = {}\n        for word in wordlist:\n            wordlist_dict_cap_vowel[self.vowel_error(word.lower())] = word\n        # build a dict of words in wordlist with capitalization and vowel errors\n        wordlist_dict_cap_vowel_lower = {}\n        for word in wordlist:"
    },
    {
        "number": 967,
        "title": "Numbers With Same Consecutive Differences",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return [i for i in range(10)]\n        res = []\n        for i in range(1, 10):\n            self.dfs(i, n, k, [i], res)\n        return res"
    },
    {
        "number": 968,
        "title": "Binary Tree Cameras",
        "difficulty": 2,
        "answer": "        # Solution 1: DFS\n        # O(n) time\n        # O(n) space\n        # self.res = 0\n        # def dfs(node):\n        #     if not node:\n        #         return 1\n        #     l = dfs(node.left)\n        #     r = dfs(node.right)\n        #     if l == 0 or r == 0:\n        #         self.res += 1\n        #         return 2\n        #     return 0\n        # dfs(root)\n        # return self.res"
    },
    {
        "number": 969,
        "title": "Pancake Sorting",
        "difficulty": 1,
        "answer": "        res = []\n        for x in range(len(arr), 1, -1):\n            i = arr.index(x)\n            res.append(i+1)\n            arr = arr[:i:-1] + arr[:i]\n        return res"
    },
    {
        "number": 970,
        "title": "Powerful Integers",
        "difficulty": 1,
        "answer": "        # x, y, bound = 2, 3, 10\n        # x, y, bound = 3, 5, 15\n        # x, y, bound = 2, 1, 10\n        # x, y, bound = 1, 1, 10\n        # x, y, bound = 1, 1, 1\n        # x, y, bound = 1, 1, 2\n        # x, y, bound = 1, 1, 3\n        # x, y, bound = 1, 1, 4\n        # x, y, bound = 1, 1, 5\n        # x, y, bound = 1, 1, 6\n        # x, y, bound = 1, 1, 7\n        # x, y, bound = 1, 1, 8\n        # x, y, bound = 1, 1, 9\n        # x, y, bound = 1, 1, 10\n        # x, y, bound = 1, 1, 11\n        # x, y, bound = 1, 1, 12\n        # x, y, bound = 1, 1, 13\n        # x, y, bound = 1, 1,"
    },
    {
        "number": 971,
        "title": "Flip Binary Tree To Match Preorder Traversal",
        "difficulty": 1,
        "answer": "        self.flipped = []\n        self.i = 0\n        self.dfs(root, voyage)\n        return self.flipped"
    },
    {
        "number": 972,
        "title": "Equal Rational Numbers",
        "difficulty": 2,
        "answer": "        # s = \"0.1(6)\", t = \"0.1666(6)\"\n        # s = \"0.9(9)\", t = \"1.\"\n        # s = \"1.\", t = \"1.\"\n        # s = \"1.0(0)\", t = \"1.\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t = \"1.0(0)\"\n        # s = \"1.0(0)\", t ="
    },
    {
        "number": 973,
        "title": "K Closest Points to Origin",
        "difficulty": 1,
        "answer": "        import heapq\n        heap = []\n        for point in points:\n            dist = point[0]**2 + point[1]**2\n            heapq.heappush(heap, (dist, point))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return [point for dist, point in heap]"
    },
    {
        "number": 974,
        "title": "Subarray Sums Divisible by K",
        "difficulty": 1,
        "answer": "        # prefix sum\n        # prefix[i] = prefix[i-1] + nums[i]\n        # prefix[i] % k = prefix[i-1] % k + nums[i] % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k + nums[i] % k) % k\n        # prefix[i] % k = (prefix[i-1] % k +"
    },
    {
        "number": 975,
        "title": "Odd Even Jump",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        dp = [[0] * n for _ in range(2)]\n        dp[0][0] = 1\n        dp[1][0] = 1\n        arr = [0] + arr\n        for i in range(1, n + 1):\n            for j in range(i):\n                if arr[j] < arr[i]:\n                    dp[i % 2][i] += dp[(i - 1) % 2][j]\n                if arr[j] > arr[i]:\n                    dp[i % 2][i] += dp[(i - 1) % 2][j]\n        return sum(dp[(n - 1) % 2])"
    },
    {
        "number": 976,
        "title": "Largest Perimeter Triangle",
        "difficulty": 0,
        "answer": "        nums.sort()\n        for i in range(len(nums)-2):\n            if nums[i] + nums[i+1] > nums[i+2]:\n                return nums[i] + nums[i+1] + nums[i+2]\n        return 0\n"
    },
    {
        "number": 977,
        "title": "Squares of a Sorted Array",
        "difficulty": 0,
        "answer": "        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x in nums)\n        # return sorted(x*x for x"
    },
    {
        "number": 978,
        "title": "Longest Turbulent Subarray",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n < 2:\n            return n\n        dp = [1] * n\n        for i in range(1, n):\n            if arr[i] > arr[i - 1]:\n                dp[i] = dp[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if arr[i] < arr[i + 1]:\n                dp[i] = max(dp[i], dp[i + 1] + 1)\n        return max(dp)"
    },
    {
        "number": 979,
        "title": "Distribute Coins in Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.ans += abs(left) + abs(right)\n            return node.val + left + right - 1"
    },
    {
        "number": 980,
        "title": "Unique Paths III",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        start, end = None, None\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    start = (i, j)\n                elif grid[i][j] == 2:\n                    end = (i, j)\n        \n        def dfs(i, j, visited):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == -1 or (i, j) in visited:\n                return 0\n            if (i, j) == end:\n                return 1\n            visited.add((i, j))\n            res = dfs(i+1, j, visited) + dfs(i-1, j, visited) + dfs(i, j+1, visited) + dfs(i, j-1, visited)\n            visited.remove((i, j))\n            return res\n        \n        return dfs(start[0], start[1], set())"
    },
    {
        "number": 981,
        "title": "Time Based Key-Value Store",
        "difficulty": 1,
        "answer": "        self.key_value = {}\n        self.key_timestamp = {}\n        self.key_timestamp[key] = timestamp\n        self.key_value[key] = value"
    },
    {
        "number": 982,
        "title": "Triples with Bitwise AND Equal To Zero",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        res = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    if nums[i] & nums[j] & nums[k] == 0:\n                        res += 1\n        return res"
    },
    {
        "number": 983,
        "title": "Minimum Cost For Tickets",
        "difficulty": 1,
        "answer": "        dp = [0] * 366\n        for day in days:\n            dp[day] = float('inf')\n        dp[0] = 0\n        for i in range(1, 366):\n            if i not in days:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = min(dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2])\n        return dp[365]"
    },
    {
        "number": 984,
        "title": "String Without AAA or BBB",
        "difficulty": 1,
        "answer": "        if a == 0:\n            return 'b' * b\n        if b == 0:\n            return 'a' * a\n        if a == b:\n            return 'a' * a + 'b' * b\n        if a > b:\n            return 'a' * a + 'b' * b\n        if b > a:\n            return 'a' * a + 'b' * b"
    },
    {
        "number": 985,
        "title": "Sum of Even Numbers After Queries",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        even_sum = sum(x for x in nums if x % 2 == 0)\n        res = []\n        for val, index in queries:\n            if nums[index] % 2 == 0:\n                even_sum -= nums[index]\n            nums[index] += val\n            if nums[index] % 2 == 0:\n                even_sum += nums[index]\n            res.append(even_sum)\n        return res"
    },
    {
        "number": 986,
        "title": "Interval List Intersections",
        "difficulty": 1,
        "answer": "        if not firstList or not secondList:\n            return []\n        i, j = 0, 0\n        res = []\n        while i < len(firstList) and j < len(secondList):\n            if firstList[i][1] < secondList[j][0]:\n                i += 1\n            elif secondList[j][1] < firstList[i][0]:\n                j += 1\n            else:\n                res.append([max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])])\n                if firstList[i][1] < secondList[j][1]:\n                    i += 1\n                else:\n                    j += 1\n        return res"
    },
    {
        "number": 987,
        "title": "Vertical Order Traversal of a Binary Tree",
        "difficulty": 2,
        "answer": "        if not root:\n            return []\n        \n        # DFS\n        # Time: O(n), n is the number of nodes\n        # Space: O(n)\n        # def dfs(node, row, col):\n        #     if not node:\n        #         return\n        #     self.result[col].append((row, node.val))\n        #     dfs(node.left, row + 1, col - 1)\n        #     dfs(node.right, row + 1, col + 1)\n        # self.result = collections.defaultdict(list)\n        # dfs(root, 0, 0)\n        # return [sorted(col) for col in self.result.values()]\n        \n        # BFS\n        # Time: O(n), n is the number of nodes\n        # Space: O(n)\n        from collections import defaultdict\n        self.result = defaultdict(list)\n        queue = collections.deque([(root, 0, 0)])\n        while queue:\n            node, row, col = queue.p"
    },
    {
        "number": 988,
        "title": "Smallest String Starting From Leaf",
        "difficulty": 1,
        "answer": "        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                path += chr(node.val + ord('a'))\n                res.append(path)\n            dfs(node.left, path + chr(node.val + ord('a')))\n            dfs(node.right, path + chr(node.val + ord('a')))"
    },
    {
        "number": 989,
        "title": "Add to Array-Form of Integer",
        "difficulty": 0,
        "answer": "        num = list(map(int, str(num)))\n        k = list(map(int, str(k)))\n        for i in range(len(k)):\n            num.insert(0, k[i])\n        return num"
    },
    {
        "number": 990,
        "title": "Satisfiability of Equality Equations",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = {}\n        for equation in equations:\n            if equation[1] == '=':\n                x, y = equation[0], equation[3]\n                if x not in graph:\n                    graph[x] = set()\n                if y not in graph:\n                    graph[y] = set()\n                graph[x].add(y)\n                graph[y].add(x)\n        # dfs\n        visited = set()\n        def dfs(node):\n            if node in visited:\n                return False\n            visited.add(node)\n            for neighbor in graph[node]:\n                if not dfs(neighbor):\n                    return False\n            return True\n        for node in graph:\n            if node not in visited:\n                if not dfs(node):\n                    return False\n        return True\n"
    },
    {
        "number": 991,
        "title": "Broken Calculator",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i], dp[i - startValue] + 1)\n        # dp[i] = min(dp[i], dp[i // 2] + 1)\n        # dp[i] = min(dp[i], dp[i - 1] + 1)\n        # dp[i] = min(dp[i], dp[i // 3] + 1)\n        # dp[i] = min(dp[i], dp[i // 5] + 1)\n        # dp[i] = min(dp[i], dp[i // 2] + 1)\n        # dp[i] = min(dp[i], dp[i // 3] + 1)\n        # dp[i] = min(dp[i], dp[i // 5] + 1)\n        # dp[i] = min(dp[i], dp[i // 2] + 1)\n        # dp[i] = min(dp[i], dp[i // 3] + 1)"
    },
    {
        "number": 992,
        "title": "Subarrays with K Different Integers",
        "difficulty": 2,
        "answer": "        if k == 0:\n            return 0\n        if k == 1:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 1)\n        if k == 2:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 2)\n        if k == 3:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 3)\n        if k == 4:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 4)\n        if k == 5:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 5)\n        if k == 6:\n            return sum(1 for i in range(len(nums)) if len(set(nums[i:])) == 6)\n        if k == 7:\n            return sum(1 for i in range("
    },
    {
        "number": 993,
        "title": "Cousins in Binary Tree",
        "difficulty": 0,
        "answer": "        def dfs(node, parent, depth, target):\n            if not node:\n                return None, None\n            if node.val == target:\n                return depth, parent\n            return dfs(node.left, node, depth + 1, target) or dfs(node.right, node, depth + 1, target)"
    },
    {
        "number": 994,
        "title": "Rotting Oranges",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        queue = collections.deque()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 2:\n                    queue.append((i, j))\n        if not queue:\n            return 0\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        time = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                i, j = queue.popleft()\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\n                        grid[ni][nj] = 2\n                        queue.append((ni, nj))\n            time += 1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    return -"
    },
    {
        "number": 995,
        "title": "Minimum Number of K Consecutive Bit Flips",
        "difficulty": 2,
        "answer": "        # \u53ea\u6709\u4e00\u4e2a0\uff0c\u76f4\u63a5\u8fd4\u56de0\n        if k == 1:\n            return nums.count(0)\n        # \u53ea\u6709\u4e00\u4e2a1\uff0c\u76f4\u63a5\u8fd4\u56de-1\n        if k == 2:\n            return -1 if nums.count(1) == 0 else nums.index(1)\n        # \u53ea\u6709\u4e00\u4e2a0\u548c\u4e00\u4e2a1\uff0c\u76f4\u63a5\u8fd4\u56de0\n        if nums.count(0) == 1 and nums.count(1) == 1:\n            return 0\n        # \u53ea\u6709\u4e00\u4e2a0\u548c\u4e00\u4e2a1\uff0c\u76f4\u63a5\u8fd4\u56de-1\n        if nums.count(0) == 1 and nums.count(1) == 0:\n            return -1\n        # \u53ea\u6709\u4e00\u4e2a0\u548c\u4e00\u4e2a1\uff0c\u76f4\u63a5\u8fd4\u56de-1"
    },
    {
        "number": 996,
        "title": "Number of Squareful Arrays",
        "difficulty": 2,
        "answer": "        nums.sort()\n        self.res = 0\n        visited = [False] * len(nums)\n        self.dfs(nums, visited, [])\n        return self.res"
    },
    {
        "number": 997,
        "title": "Find the Town Judge",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2 if trust[0][0] == trust[0][1] else -1\n        if n == 3:\n            return 3 if trust[0][0] == trust[1][0] and trust[1][0] == trust[2][0] else -1\n        if n == 4:\n            return 4 if trust[0][0] == trust[1][0] and trust[1][0] == trust[2][0] and trust[2][0] == trust[3][0] else -1\n        if n == 5:\n            return 5 if trust[0][0] == trust[1][0] and trust[1][0] == trust[2][0] and trust[2][0] == trust[3][0] and trust[3][0] == trust[4][0] else -1\n        if n == 6:\n            return 6 if trust[0][0] == trust[1][0] and trust[1][0] == trust[2][0] and trust[2]["
    },
    {
        "number": 998,
        "title": "Maximum Binary Tree II",
        "difficulty": 1,
        "answer": "        if not root:\n            return TreeNode(val)\n        if root.val < val:\n            root.right = self.insertIntoMaxTree(root.right, val)\n        else:\n            root.left = self.insertIntoMaxTree(root.left, val)\n        return root"
    },
    {
        "number": 999,
        "title": "Available Captures for Rook",
        "difficulty": 0,
        "answer": "        # find the rook\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'R':\n                    row = i\n                    col = j\n        # find the number of available captures\n        captures = 0\n        for i in range(row-1, -1, -1):\n            if board[i][col] == 'B':\n                break\n            elif board[i][col] == 'p':\n                captures += 1\n                break\n        for i in range(row+1, len(board)):\n            if board[i][col] == 'B':\n                break\n            elif board[i][col] == 'p':\n                captures += 1\n                break\n        for j in range(col-1, -1, -1):\n            if board[row][j] == 'B':\n                break\n            elif board[row][j] == 'p':\n                captures += 1\n                break\n        for j in range(col+1, len(board"
    },
    {
        "number": 1000,
        "title": "Minimum Cost to Merge Stones",
        "difficulty": 2,
        "answer": "        n = len(stones)\n        if n % k!= 0:\n            return -1\n        dp = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 0\n        for i in range(n - 1):\n            dp[i][i + 1] = 0\n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum(stones[i:j + 1]))\n        return dp[0][n - 1]"
    },
    {
        "number": 1001,
        "title": "Grid Illumination",
        "difficulty": 2,
        "answer": "        lamps = {tuple(lamp) for lamp in lamps}\n        grid = [[0] * n for _ in range(n)]\n        for i, j in lamps:\n            grid[i][j] = 1\n        ans = []\n        for i, j in queries:\n            ans.append(self.illuminate(grid, i, j))\n            grid[i][j] = 0\n        return ans"
    },
    {
        "number": 1002,
        "title": "Find Common Characters",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # d = {}\n        # for word in words:\n        #     for c in word:\n        #         if c not in d:\n        #             d[c] = 1\n        #         else:\n        #             d[c] += 1\n        # res = []\n        # for c in d:\n        #     if d[c] == len(words):\n        #         res.append(c)\n        # return res\n        \n        # Solution 2:\n        # O(n) time\n        # O(1) space\n        # d = {}\n        # for word in words:\n        #     for c in word:\n        #         if c not in d:\n        #             d[c] = 1\n        #         else:\n        #             d[c] += 1\n        # res = []\n        # for c in d:\n        #     if d[c] == len(words):\n        #         res.append(c)\n        # return"
    },
    {
        "number": 1003,
        "title": "Check If Word Is Valid After Substitutions",
        "difficulty": 1,
        "answer": "        if len(s) == 0:\n            return True\n        if len(s) % 3!= 0:\n            return False\n        stack = []\n        for i in s:\n            if i == 'c':\n                if len(stack) < 2:\n                    return False\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(i)\n        return len(stack) == 0"
    },
    {
        "number": 1004,
        "title": "Max Consecutive Ones III",
        "difficulty": 1,
        "answer": "        # sliding window\n        # O(n)\n        # O(k)\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,0]\n        # [1,1,1,0,0,0,1,1,1,1,"
    },
    {
        "number": 1005,
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": 0,
        "answer": "        nums.sort()\n        for i in range(k):\n            if nums[i] < 0:\n                nums[i] = -nums[i]\n            else:\n                break\n        return sum(nums)"
    },
    {
        "number": 1006,
        "title": "Clumsy Factorial",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        elif n == 3:\n            return 6\n        else:\n            return n * (n - 1) // (n - 2) + (n - 3)"
    },
    {
        "number": 1007,
        "title": "Minimum Domino Rotations For Equal Row",
        "difficulty": 1,
        "answer": "        # if len(set(tops)) == 1:\n        #     return 0\n        # if len(set(bottoms)) == 1:\n        #     return 0\n        # if len(set(tops)) == len(set(bottoms)):\n        #     return -1\n        # if len(set(tops)) == 1:\n        #     return len(tops)\n        # if len(set(bottoms)) == 1:\n        #     return len(bottoms)\n        # if len(set(tops)) == len(set(bottoms)):\n        #     return -1\n        # if len(set(tops)) == 1:\n        #     return len(tops)\n        # if len(set(bottoms)) == 1:\n        #     return len(bottoms)\n        # if len(set(tops)) == len(set(bottoms)):\n        #     return -1\n        # if len(set(tops)) == 1:\n        #     return len(tops)\n        # if len(set(bottoms)) == 1:\n        #     return len"
    },
    {
        "number": 1008,
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "difficulty": 1,
        "answer": "        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        stack = [root]\n        for i in range(1, len(preorder)):\n            node = stack[-1]\n            if node.val > preorder[i]:\n                node.left = TreeNode(preorder[i])\n                stack.append(node.left)\n            else:\n                while stack and stack[-1].val < preorder[i]:\n                    node = stack.pop()\n                node.right = TreeNode(preorder[i])\n                stack.append(node.right)\n        return root"
    },
    {
        "number": 1009,
        "title": "Complement of Base 10 Integer",
        "difficulty": 0,
        "answer": "        return int(''.join(['1' if x == '0' else '0' for x in bin(n)[2:]]), 2)"
    },
    {
        "number": 1010,
        "title": "Pairs of Songs With Total Durations Divisible by 60",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = 0\n        # d = {}\n        # for t in time:\n        #     if t % 60 == 0:\n        #         count += d.get(0, 0)\n        #     else:\n        #         d[t % 60] = d.get(t % 60, 0) + 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = 0\n        # for i in range(len(time)):\n        #     for j in range(i + 1, len(time)):\n        #         if (time[i] + time[j]) % 60 == 0:\n        #             count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # count = 0\n        # for i in range(len(time)):\n        #     if (60 - (time[i] % 60)) in time"
    },
    {
        "number": 1011,
        "title": "Capacity To Ship Packages Within D Days",
        "difficulty": 1,
        "answer": "        # binary search\n        # time complexity: O(nlogn)\n        # space complexity: O(1)\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.can_finish(weights, days, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 1012,
        "title": "Numbers With Repeated Digits",
        "difficulty": 2,
        "answer": "        def count(n):\n            if n == 0:\n                return 0\n            if n == 1:\n                return 1\n            if n == 2:\n                return 2\n            if n == 3:\n                return 3\n            if n == 4:\n                return 5\n            if n == 5:\n                return 8\n            if n == 6:\n                return 13\n            if n == 7:\n                return 21\n            if n == 8:\n                return 34\n            if n == 9:\n                return 55\n            if n == 10:\n                return 89\n            if n == 11:\n                return 144\n            if n == 12:\n                return 233\n            if n == 13:\n                return 377\n            if n == 14:\n                return 610\n            if n == 15:\n                return 987\n            if n == 16:\n                return 1597\n            if n == 17:\n                return 2584\n            if n == 18:\n                return 4181\n            if n == 19:\n                return 6765\n            if n == 20:\n                return 10946\n            if n == 21:"
    },
    {
        "number": 1013,
        "title": "Partition Array Into Three Parts With Equal Sum",
        "difficulty": 0,
        "answer": "        total = sum(arr)\n        if total % 3!= 0:\n            return False\n        target = total // 3\n        curr = 0\n        for i in range(len(arr)):\n            curr += arr[i]\n            if curr == target:\n                curr = 0\n                continue\n            if curr == 0 and i + 1 < len(arr) and curr == target:\n                return True\n        return False"
    },
    {
        "number": 1014,
        "title": "Best Sightseeing Pair",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        # dp[i] = max(dp[i-1], values[i] + values[j] + i - j)\n        #"
    },
    {
        "number": 1015,
        "title": "Smallest Integer Divisible by K",
        "difficulty": 1,
        "answer": "        if k % 2 == 0 or k % 5 == 0:\n            return -1\n        n = 1\n        while n % k!= 0:\n            n = n * 10 + 1\n        return n"
    },
    {
        "number": 1016,
        "title": "Binary String With Substrings Representing 1 To N",
        "difficulty": 1,
        "answer": "        return all(bin(i)[2:].zfill(n) in s for i in range(1, n + 1))"
    },
    {
        "number": 1017,
        "title": "Convert to Base -2",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return \"0\"\n        if n == 1:\n            return \"1\"\n        if n == 2:\n            return \"110\"\n        if n == 3:\n            return \"111\"\n        if n == 4:\n            return \"100\"\n        if n == 5:\n            return \"101\"\n        if n == 6:\n            return \"110\"\n        if n == 7:\n            return \"111\"\n        if n == 8:\n            return \"1000\"\n        if n == 9:\n            return \"1001\"\n        if n == 10:\n            return \"1010\"\n        if n == 11:\n            return \"1011\"\n        if n == 12:\n            return \"1100\"\n        if n == 13:\n            return \"1101\"\n        if n == 14:\n            return \"1110\"\n        if n == 15:\n            return \"1111\"\n        if n == 16:\n            return \"10000\"\n        if n == 17:\n            return \"10001\"\n        if n == 18:\n            return \"100"
    },
    {
        "number": 1018,
        "title": "Binary Prefix Divisible By 5",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(len(nums)):\n            ans.append(nums[i] % 5 == 0)\n        return ans"
    },
    {
        "number": 1019,
        "title": "Next Greater Node In Linked List",
        "difficulty": 1,
        "answer": "        # O(n) time\n        # O(n) space\n        # stack\n        # stack[i] = next greater node of node i\n        stack = []\n        res = [0] * len(head)\n        for i in range(len(head) - 1, -1, -1):\n            while stack and stack[-1][0] < head[i]:\n                _, idx = stack.pop()\n                res[idx] = head[i]\n            stack.append((head[i], i))\n        return res"
    },
    {
        "number": 1020,
        "title": "Number of Enclaves",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or grid[i][j] == 0:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        return len(visited)"
    },
    {
        "number": 1021,
        "title": "Remove Outermost Parentheses",
        "difficulty": 0,
        "answer": "        stack = []\n        res = \"\"\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(s[i])\n            else:\n                stack.pop()\n            if not stack:\n                res += s[1:i]\n        return res"
    },
    {
        "number": 1022,
        "title": "Sum of Root To Leaf Binary Numbers",
        "difficulty": 0,
        "answer": "        def dfs(node, curr):\n            if not node:\n                return 0\n            curr = (curr << 1) | node.val\n            if not node.left and not node.right:\n                return curr\n            return dfs(node.left, curr) + dfs(node.right, curr)\n        return dfs(root, 0)"
    },
    {
        "number": 1023,
        "title": "Camelcase Matching",
        "difficulty": 1,
        "answer": "        def is_match(query, pattern):\n            i, j = 0, 0\n            while i < len(query) and j < len(pattern):\n                if query[i] == pattern[j]:\n                    i += 1\n                    j += 1\n                else:\n                    if query[i].isupper():\n                        return False\n                    i += 1\n            return j == len(pattern)"
    },
    {
        "number": 1024,
        "title": "Video Stitching",
        "difficulty": 1,
        "answer": "        clips.sort()\n        n = len(clips)\n        dp = [0] * (time + 1)\n        dp[0] = 1\n        for i in range(n):\n            for j in range(clips[i][0], clips[i][1] + 1):\n                dp[j] = max(dp[j], dp[j - clips[i][0]] + 1)\n        return dp[-1] if dp[-1]!= 0 else -1"
    },
    {
        "number": 1025,
        "title": "Divisor Game",
        "difficulty": 0,
        "answer": "        return n % 2 == 0"
    },
    {
        "number": 1026,
        "title": "Maximum Difference Between Node and Ancestor",
        "difficulty": 1,
        "answer": "        self.max_diff = 0\n        self.dfs(root, root.val, root.val)\n        return self.max_diff"
    },
    {
        "number": 1027,
        "title": "Longest Arithmetic Subsequence",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        dp = [{} for _ in range(n)]\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                dp[i][diff] = dp[j].get(diff, 1) + 1\n        return max(dp[i].values() or [0])"
    },
    {
        "number": 1028,
        "title": "Recover a Tree From Preorder Traversal",
        "difficulty": 2,
        "answer": "        \n        # preorder traversal\n        # 1-2--3--4-5--6--7\n        # 1-2--3---4-5--6---7\n        # 1-401--349---90--88\n        \n        # preorder traversal\n        # 1-2--3--4-5--6--7\n        # 1-2--3---4-5--6---7\n        # 1-401--349---90--88\n        \n        # preorder traversal\n        # 1-2--3--4-5--6--7\n        # 1-2--3---4-5--6---7\n        # 1-401--349---90--88\n        \n        # preorder traversal\n        # 1-2--3--4-5--6--7\n        # 1-2--3---4-5--6---7\n        # 1-401--349---90--88\n        \n        # preorder traversal\n        # 1-2--3--4-5--6--7\n        # 1-2--3---4-5--6"
    },
    {
        "number": 1029,
        "title": "Two City Scheduling",
        "difficulty": 1,
        "answer": "        # sort by aCost\n        costs.sort(key=lambda x: x[0] - x[1])\n        # print(costs)\n        total = 0\n        for i in range(len(costs) // 2):\n            total += costs[i][0] + costs[i + len(costs) // 2][1]\n        return total"
    },
    {
        "number": 1030,
        "title": "Matrix Cells in Distance Order",
        "difficulty": 0,
        "answer": "        \n        # O(n^2)\n        # res = []\n        # for r in range(rows):\n        #     for c in range(cols):\n        #         res.append([r, c])\n        # return sorted(res, key=lambda x: abs(rCenter - x[0]) + abs(cCenter - x[1]))\n        \n        # O(n)\n        # res = []\n        # for r in range(rows):\n        #     for c in range(cols):\n        #         res.append([r, c])\n        # return sorted(res, key=lambda x: abs(rCenter - x[0]) + abs(cCenter - x[1]))\n        \n        # O(n)\n        # res = []\n        # for r in range(rows):\n        #     for c in range(cols):\n        #         res.append([r, c])\n        # return sorted(res, key=lambda x: abs(rCenter - x[0]) + abs(cCenter - x[1]))\n        \n"
    },
    {
        "number": 1031,
        "title": "Maximum Sum of Two Non-Overlapping Subarrays",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        first = [0] * n\n        second = [0] * n\n        for i in range(n):\n            if i < firstLen:\n                first[i] = max(first[i - 1] + nums[i], nums[i])\n            else:\n                first[i] = max(first[i - 1], nums[i])\n        for i in range(n - 1, -1, -1):\n            if i + secondLen >= n:\n                second[i] = max(second[i + 1] + nums[i], nums[i])\n            else:\n                second[i] = max(second[i + 1], nums[i])\n        ans = 0\n        for i in range(n - secondLen - 1):\n            ans = max(ans, first[i + secondLen] + second[i])\n        return ans"
    },
    {
        "number": 1032,
        "title": "Stream of Characters",
        "difficulty": 2,
        "answer": "        self.words = words\n        self.letters = []\n        self.index = 0\n        self.length = 0\n        self.result = []\n        self.word_index = 0\n        self.word_length = 0\n        self.word_result = []\n        self.word_index_result = 0\n        self.word_length_result = 0\n        self.word_result_result = []\n        self.word_index_result_result = 0\n        self.word_length_result_result = 0\n        self.word_result_result_result = []\n        self.word_index_result_result_result = 0\n        self.word_length_result_result_result = 0\n        self.word_result_result_result_result = []\n        self.word_index_result_result_result_result = 0\n        self.word_length_result_result_result_result = 0\n        self.word_result_result_result_result_result = []\n        self.word_index_result_result_result_result_result = 0\n        "
    },
    {
        "number": 1033,
        "title": "Moving Stones Until Consecutive",
        "difficulty": 1,
        "answer": "        a, b, c = sorted([a, b, c])\n        if a + 2 == b and b + 1 == c:\n            return [0, 0]\n        elif a + 1 == b and b + 2 == c:\n            return [0, 1]\n        elif a + 2 == b and b + 2 == c:\n            return [1, 1]\n        else:\n            return [1, 2]"
    },
    {
        "number": 1034,
        "title": "Coloring A Border",
        "difficulty": 1,
        "answer": "        if not grid or not grid[0]:\n            return grid\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited or grid[i][j]!= grid[row][col]:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        dfs(row, col)\n        for i in range(m):\n            for j in range(n):\n                if (i, j) not in visited:\n                    grid[i][j] = color\n        return grid"
    },
    {
        "number": 1035,
        "title": "Uncrossed Lines",
        "difficulty": 1,
        "answer": "        m, n = len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]"
    },
    {
        "number": 1036,
        "title": "Escape a Large Maze",
        "difficulty": 2,
        "answer": "        blocked = set(map(tuple, blocked))\n        queue = collections.deque([(source, 0)])\n        visited = set()\n        while queue:\n            (x, y), step = queue.popleft()\n            if (x, y) == target:\n                return True\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) not in visited and (nx, ny) not in blocked:\n                    queue.append(((nx, ny), step + 1))\n                    visited.add((nx, ny))\n        return False"
    },
    {
        "number": 1037,
        "title": "Valid Boomerang",
        "difficulty": 0,
        "answer": "        if len(points) < 3:\n            return False\n        x1, y1 = points[0][0], points[0][1]\n        x2, y2 = points[1][0], points[1][1]\n        x3, y3 = points[2][0], points[2][1]\n        if x1 == x2 and x2 == x3:\n            return False\n        if y1 == y2 and y2 == y3:\n            return False\n        if x1 == x2:\n            return abs(y2 - y1)!= abs(x2 - x1)\n        if y1 == y2:\n            return abs(x2 - x1)!= abs(y2 - y1)\n        return True"
    },
    {
        "number": 1038,
        "title": "Binary Search Tree to Greater Sum Tree",
        "difficulty": 1,
        "answer": "        self.sum = 0\n        def dfs(node):\n            if not node:\n                return\n            dfs(node.right)\n            self.sum += node.val\n            node.val = self.sum\n            dfs(node.left)\n        dfs(root)\n        return root\n"
    },
    {
        "number": 1039,
        "title": "Minimum Score Triangulation of Polygon",
        "difficulty": 1,
        "answer": "        n = len(values)\n        dp = [[0] * n for _ in range(n)]\n        for d in range(2, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = float('inf')\n                for k in range(i + 1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[j] * values[k])\n        return dp[0][n - 1]"
    },
    {
        "number": 1040,
        "title": "Moving Stones Until Consecutive II",
        "difficulty": 1,
        "answer": "        stones.sort()\n        n = len(stones)\n        if n < 4:\n            return [0, 0]\n        if stones[-1] - stones[0] + 1 == n:\n            return [1, 1]\n        if stones[-1] - stones[0] + 1 == n - 1:\n            return [2, 2]\n        if stones[-1] - stones[0] + 1 == n - 2:\n            return [3, 3]\n        if stones[-1] - stones[0] + 1 == n - 3:\n            return [4, 4]\n        if stones[-1] - stones[0] + 1 == n - 4:\n            return [5, 5]\n        if stones[-1] - stones[0] + 1 == n - 5:\n            return [6, 6]\n        if stones[-1] - stones[0] + 1 == n - 6:\n            return [7, 7]\n        if stones[-1] - stones[0] + 1 == n - 7:\n            return [8, 8]"
    },
    {
        "number": 1041,
        "title": "Robot Bounded In Circle",
        "difficulty": 1,
        "answer": "        x, y, dx, dy = 0, 0, 0, 1\n        for i in instructions:\n            if i == 'G':\n                x += dx\n                y += dy\n            elif i == 'L':\n                dx, dy = -dy, dx\n            else:\n                dx, dy = dy, -dx\n        return (x, y) == (0, 0) or (dx, dy)!= (0, 1)"
    },
    {
        "number": 1042,
        "title": "Flower Planting With No Adjacent",
        "difficulty": 1,
        "answer": "        # graph = [[] for _ in range(n)]\n        # for x, y in paths:\n        #     graph[x - 1].append(y - 1)\n        #     graph[y - 1].append(x - 1)\n        # ans = [0] * n\n        # for i in range(n):\n        #     ans[i] = {1, 2, 3, 4} - {ans[j] for j in graph[i]}\n        # return ans"
    },
    {
        "number": 1043,
        "title": "Partition Array for Maximum Sum",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            max_val = 0\n            for j in range(1, min(i, k) + 1):\n                max_val = max(max_val, arr[i - j])\n                dp[i] = max(dp[i], dp[i - j] + max_val * j)\n        return dp[n]"
    },
    {
        "number": 1044,
        "title": "Longest Duplicate Substring",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n < 2:\n            return ''\n        max_len = 0\n        res = ''\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if j - i > max_len:\n                    max_len = j - i\n                    res = s[i:j]\n        return res"
    },
    {
        "number": 1046,
        "title": "Last Stone Weight",
        "difficulty": 0,
        "answer": "        \n        while len(stones) > 1:\n            stones.sort()\n            if stones[-1] == stones[-2]:\n                stones = stones[:-2]\n            else:\n                stones[-2] = stones[-2] - stones[-1]\n                stones = stones[:-1]\n        return stones[0] if stones else 0\n"
    },
    {
        "number": 1047,
        "title": "Remove All Adjacent Duplicates In String",
        "difficulty": 0,
        "answer": "        \n        stack = []\n        for c in s:\n            if not stack or stack[-1]!= c:\n                stack.append(c)\n            else:\n                stack.pop()\n        return ''.join(stack)\n"
    },
    {
        "number": 1048,
        "title": "Longest String Chain",
        "difficulty": 1,
        "answer": "        words.sort(key=len)\n        dp = {}\n        for word in words:\n            dp[word] = 1\n        for word in words:\n            for i in range(len(word)):\n                pred = word[:i] + word[i+1:]\n                if pred in dp:\n                    dp[word] = max(dp[word], dp[pred] + 1)\n        return max(dp.values())"
    },
    {
        "number": 1049,
        "title": "Last Stone Weight II",
        "difficulty": 1,
        "answer": "        total = sum(stones)\n        target = total // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for stone in stones:\n            for i in range(target, stone - 1, -1):\n                dp[i] = dp[i] or dp[i - stone]\n        return total - 2 * dp[-1]"
    },
    {
        "number": 1051,
        "title": "Height Checker",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        expected = sorted(heights)\n        count = 0\n        for i in range(len(heights)):\n            if heights[i]!= expected[i]:\n                count += 1\n        return count"
    },
    {
        "number": 1052,
        "title": "Grumpy Bookstore Owner",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(customers)\n        # if n == 0:\n        #     return 0\n        # dp = [0] * n\n        # for i in range(n):\n        #     if grumpy[i] == 0:\n        #         dp[i] = dp[i-1] + customers[i]\n        #     else:\n        #         dp[i] = dp[i-1]\n        # for i in range(n-minutes, n):\n        #     if grumpy[i] == 0:\n        #         dp[i] = max(dp[i], dp[i-minutes] + customers[i])\n        # return dp[-1]"
    },
    {
        "number": 1053,
        "title": "Previous Permutation With One Swap",
        "difficulty": 1,
        "answer": "        n = len(arr)\n        if n <= 1:\n            return arr\n        for i in range(n - 1, 0, -1):\n            if arr[i] > arr[i - 1]:\n                break\n        if i == 1 and arr[i] <= arr[i - 1]:\n            return arr\n        for j in range(n - 1, i - 1, -1):\n            if arr[j] > arr[i - 1]:\n                break\n        arr[i - 1], arr[j] = arr[j], arr[i - 1]\n        arr[i:] = sorted(arr[i:])\n        return arr"
    },
    {
        "number": 1054,
        "title": "Distant Barcodes",
        "difficulty": 1,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 1061,
        "title": "Lexicographically Smallest Equivalent String",
        "difficulty": 1,
        "answer": "        # build a graph\n        graph = {}\n        for i, c in enumerate(baseStr):\n            graph[c] = graph.get(c, []) + [i]\n        # build a graph for s1 and s2\n        for s in [s1, s2]:\n            for i, c in enumerate(s):\n                graph[c] = graph.get(c, []) + [i]\n        # build a graph for s1 and s2\n        for s in [s1, s2]:\n            for i, c in enumerate(s):\n                graph[c] = graph.get(c, []) + [i]\n        # build a graph for s1 and s2\n        for s in [s1, s2]:\n            for i, c in enumerate(s):\n                graph[c] = graph.get(c, []) + [i]\n        # build a graph for s1 and s2\n        for s in [s1, s2]:\n            for i, c in enumerate(s):\n                graph[c] ="
    },
    {
        "number": 1071,
        "title": "Greatest Common Divisor of Strings",
        "difficulty": 0,
        "answer": "        if not str1 or not str2:\n            return \"\"\n        if str1 == str2:\n            return str1\n        if len(str1) < len(str2):\n            str1, str2 = str2, str1\n        if str1[:len(str2)] == str2:\n            return self.gcdOfStrings(str1[len(str2):], str2)\n        return \"\""
    },
    {
        "number": 1072,
        "title": "Flip Columns For Maximum Number of Equal Rows",
        "difficulty": 1,
        "answer": "        d = {}\n        for row in matrix:\n            s = 0\n            for i in range(len(row)):\n                s ^= row[i]\n            d[s] = d.get(s, 0) + 1\n        return max(d.values())"
    },
    {
        "number": 1073,
        "title": "Adding Two Negabinary Numbers",
        "difficulty": 1,
        "answer": "        def add(a, b):\n            if not a:\n                return b\n            if not b:\n                return a\n            if a[0] == b[0]:\n                return add(a[1:], b[1:])\n            else:\n                return [0] + add(a[1:], b[1:])"
    },
    {
        "number": 1074,
        "title": "Number of Submatrices That Sum to Target",
        "difficulty": 2,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        for row in matrix:\n            for i in range(1, n):\n                row[i] += row[i - 1]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                for k in range(i, m):\n                    s = matrix[k][j] - (matrix[i - 1][j] if i > 0 else 0)\n                    if s < target:\n                        continue\n                    if s == target:\n                        res += 1\n                    for l in range(j, n):\n                        if s - matrix[k][l] == target:\n                            res += 1\n        return res"
    },
    {
        "number": 1078,
        "title": "Occurrences After Bigram",
        "difficulty": 0,
        "answer": "        words = text.split()\n        res = []\n        for i in range(len(words) - 2):\n            if words[i] == first and words[i + 1] == second:\n                res.append(words[i + 2])\n        return res"
    },
    {
        "number": 1079,
        "title": "Letter Tile Possibilities",
        "difficulty": 1,
        "answer": "        self.res = set()\n        self.dfs(tiles, 0, \"\")\n        return len(self.res)"
    },
    {
        "number": 1080,
        "title": "Insufficient Nodes in Root to Leaf Paths",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left == -1 or right == -1:\n                return -1\n            if node.val + left + right < limit:\n                return node.val + left + right\n            return -1\n        return dfs(root)"
    },
    {
        "number": 1081,
        "title": "Smallest Subsequence of Distinct Characters",
        "difficulty": 1,
        "answer": "        # dp[i] = the lexicographically smallest subsequence of s[:i+1]\n        # dp[i] = min(dp[j] + s[j:i+1]) for j in range(i)\n        # dp[i] = min(dp[j] + s[j:i+1]) for j in range(i) if s[j] not in s[:i]\n        # dp[i] = min(dp[j] + s[j:i+1]) for j in range(i) if s[j] not in s[:i] and s[j] not in s[i:]\n        # dp[i] = min(dp[j] + s[j:i+1]) for j in range(i) if s[j] not in s[:i] and s[j] not in s[i:]\n        # dp[i] = min(dp[j] + s[j:i+1]) for j in range(i) if s[j] not in s[:i] and s"
    },
    {
        "number": 1089,
        "title": "Duplicate Zeros",
        "difficulty": 0,
        "answer": "        i = 0\n        while i < len(arr):\n            if arr[i] == 0:\n                arr.insert(i+1, 0)\n                arr.pop()\n                i += 2\n            else:\n                i += 1"
    },
    {
        "number": 1090,
        "title": "Largest Values From Labels",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1091,
        "title": "Shortest Path in Binary Matrix",
        "difficulty": 1,
        "answer": "        if grid[0][0] == 1 or grid[-1][-1] == 1:\n            return -1\n        m, n = len(grid), len(grid[0])\n        queue = collections.deque([(0, 0, 1)])\n        visited = set()\n        visited.add((0, 0))\n        while queue:\n            i, j, step = queue.popleft()\n            if i == m - 1 and j == n - 1:\n                return step\n            for x, y in [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and (x, y) not in visited:\n                    queue.append((x, y, step + 1))\n                    visited.add((x, y))\n        return -"
    },
    {
        "number": 1092,
        "title": "Shortest Common Supersequence ",
        "difficulty": 2,
        "answer": "        m, n = len(str1), len(str2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = 1 + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        i, j = m, n\n        ans = []\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                ans.append(str1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                ans.append(str1[i - 1])\n                i -= 1\n            else:\n                ans."
    },
    {
        "number": 1093,
        "title": "Statistics from a Large Sample",
        "difficulty": 1,
        "answer": "        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median, mode\n        # min, max, mean, median,"
    },
    {
        "number": 1094,
        "title": "Car Pooling",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # trips.sort(key=lambda x: x[1])\n        # curr_capacity = 0\n        # for num_passengers, start, end in trips:\n        #     curr_capacity -= num_passengers\n        #     if curr_capacity < 0:\n        #         return False\n        #     curr_capacity += num_passengers\n        #     if curr_capacity > capacity:\n        #         return False\n        # return True"
    },
    {
        "number": 1095,
        "title": "Find in Mountain Array",
        "difficulty": 2,
        "answer": "        left, right = 0, len(mountain_arr)-1\n        while left < right:\n            mid = (left+right)//2\n            if mountain_arr.get(mid) < target:\n                left = mid+1\n            else:\n                right = mid\n        if mountain_arr.get(left) == target:\n            return left\n        return -1"
    },
    {
        "number": 1096,
        "title": "Brace Expansion II",
        "difficulty": 2,
        "answer": "        # stack = []\n        # for c in expression:\n        #     if c == '{':\n        #         stack.append(c)\n        #     elif c == '}':\n        #         stack.pop()\n        #     elif c == ',':\n        #         continue\n        #     else:\n        #         stack.append(c)\n        # return sorted(set(stack))"
    },
    {
        "number": 1103,
        "title": "Distribute Candies to People",
        "difficulty": 0,
        "answer": "        # if num_people == 1:\n        #     return [candies]\n        # if num_people == 2:\n        #     return [candies // 2, candies // 2]\n        # if num_people == 3:\n        #     return [candies // 3, candies // 3, candies // 3]\n        # if num_people == 4:\n        #     return [candies // 4, candies // 4, candies // 4, candies // 4]\n        # if num_people == 5:\n        #     return [candies // 5, candies // 5, candies // 5, candies // 5, candies // 5]\n        # if num_people == 6:\n        #     return [candies // 6, candies // 6, candies // 6, candies // 6, candies // 6, candies // 6]\n        # if num_people == 7:\n        #     return [candies // 7, candies // 7, candies // 7, candies // 7, candies // 7, candies // 7, candies // 7]\n"
    },
    {
        "number": 1104,
        "title": "Path In Zigzag Labelled Binary Tree",
        "difficulty": 1,
        "answer": "        res = []\n        while label > 0:\n            res.append(label)\n            label = (label - 1) // 2\n        return res[::-1]"
    },
    {
        "number": 1105,
        "title": "Filling Bookcase Shelves",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j] + height[i] + j)\n        # dp[i] = min(dp[i-1] + height[i], dp[i-j]"
    },
    {
        "number": 1106,
        "title": "Parsing A Boolean Expression",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # stack = []\n        # for c in expression:\n        #     if c == 't':\n        #         stack.append(True)\n        #     elif c == 'f':\n        #         stack.append(False)\n        #     elif c == '!':\n        #         stack.append(not stack.pop())\n        #     elif c == '&':\n        #         stack.append(all(stack.pop() for _ in range(2)))\n        #     elif c == '|':\n        #         stack.append(any(stack.pop() for _ in range(2)))\n        # return stack.pop()"
    },
    {
        "number": 1108,
        "title": "Defanging an IP Address",
        "difficulty": 0,
        "answer": "        return address.replace('.', '[.]')\n"
    },
    {
        "number": 1109,
        "title": "Corporate Flight Bookings",
        "difficulty": 1,
        "answer": "        res = [0] * n\n        for first, last, seats in bookings:\n            res[first - 1] += seats\n            if last < n:\n                res[last] -= seats\n        for i in range(1, n):\n            res[i] += res[i - 1]\n        return res"
    },
    {
        "number": 1110,
        "title": "Delete Nodes And Return Forest",
        "difficulty": 1,
        "answer": "        to_delete = set(to_delete)\n        res = []"
    },
    {
        "number": 1111,
        "title": "Maximum Nesting Depth of Two Valid Parentheses Strings",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # stack = []\n        # res = []\n        # for i in seq:\n        #     if i == '(':\n        #         stack.append(i)\n        #     else:\n        #         if stack:\n        #             stack.pop()\n        #         else:\n        #             res.append(1)\n        #     if stack:\n        #         res.append(0)\n        #     else:\n        #         res.append(1)\n        # return res"
    },
    {
        "number": 1114,
        "title": "Print in Order",
        "difficulty": 0,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1115,
        "title": "Print FooBar Alternately",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1116,
        "title": "Print Zero Even Odd",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1117,
        "title": "Building H2O",
        "difficulty": 1,
        "answer": "\nclass H2O:\n    def __init__(self):\n        pass\n    def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:\n        releaseHydrogen()\n    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:\n        releaseOxygen()\n        \"\"\"\n        There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules.\n        There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.\n        In other words:\n            If an oxygen thread arrives at the barrier when no hydrogen threads are present, it must wait for two hydrogen threads.\n            If a hydrogen thread arrives at the barrier when no other threads are present, it must wait for"
    },
    {
        "number": 1122,
        "title": "Relative Sort Array",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1123,
        "title": "Lowest Common Ancestor of Deepest Leaves",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0, None\n            left_depth, left_lca = dfs(node.left)\n            right_depth, right_lca = dfs(node.right)\n            if left_depth > right_depth:\n                return left_depth + 1, left_lca\n            elif left_depth < right_depth:\n                return right_depth + 1, right_lca\n            else:\n                return left_depth + 1, node\n        return dfs(root)[1]"
    },
    {
        "number": 1124,
        "title": "Longest Well-Performing Interval",
        "difficulty": 1,
        "answer": "        # dp[i] = the longest well-performing interval ends at i\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j in range(i)\n        # dp[i] = max(dp[j] + 1 if hours[j] >= 8 else 0) for j"
    },
    {
        "number": 1125,
        "title": "Smallest Sufficient Team",
        "difficulty": 2,
        "answer": "        # \u5148\u628a\u6240\u6709\u4eba\u7684\u6280\u80fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\n        all_skills = set()\n        for person in people:\n            for skill in person:\n                all_skills.add(skill)\n        # \u5148\u628a\u6240\u6709\u6280\u80fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\n        all_skills = list(all_skills)\n        # \u5148\u628a\u6240\u6709\u6280\u80fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\n        req_skills = list(req_skills)\n        # \u5148\u628a\u6240\u6709\u6280\u80fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\n        # \u5148\u628a\u6240\u6709\u6280\u80fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\n        # \u5148\u628a\u6240\u6709\u6280\u80fd\u653e\u5230\u4e00\u4e2a\ufffd"
    },
    {
        "number": 1128,
        "title": "Number of Equivalent Domino Pairs",
        "difficulty": 0,
        "answer": "        # dominoes.sort()\n        # count = 0\n        # for i in range(len(dominoes)):\n        #     for j in range(i+1, len(dominoes)):\n        #         if dominoes[i][0] == dominoes[j][0] and dominoes[i][1] == dominoes[j][1]:\n        #             count += 1\n        #         elif dominoes[i][0] == dominoes[j][1] and dominoes[i][1] == dominoes[j][0]:\n        #             count += 1\n        # return count"
    },
    {
        "number": 1129,
        "title": "Shortest Path with Alternating Colors",
        "difficulty": 1,
        "answer": "        # dp[i][j] = shortest path from 0 to i with color j\n        # dp[i][0] = dp[i-1][1] + 1\n        # dp[i][1] = dp[i-1][0] + 1\n        # dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1\n        # dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + 1\n        # dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1\n        # dp[i][1] = min(dp[i-1][1], dp[i-1][0]) + 1\n        # dp[i][0] = min(dp[i-1][0], dp[i-1][1]) + 1\n        # dp[i][1] = min(dp[i-1][1], dp[i-1"
    },
    {
        "number": 1130,
        "title": "Minimum Cost Tree From Leaf Values",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # def helper(arr, i, j):\n        #     if i == j:\n        #         return 0\n        #     min_val = float(\"inf\")\n        #     for k in range(i, j):\n        #         left = helper(arr, i, k)\n        #         right = helper(arr, k + 1, j)\n        #         min_val = min(min_val, left + right + max(arr[i:k + 1]) * max(arr[k + 1:j + 1]))\n        #     return min_val\n        #\n        # return helper(arr, 0, len(arr) - 1)"
    },
    {
        "number": 1131,
        "title": "Maximum of Absolute Value Expression",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j)\n        # dp[i][j] = max(dp[i][j], arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j)\n        # dp[i][j] = max(dp[i][j], arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j)\n        # dp[i][j] = max(dp[i][j], arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j)\n        # dp[i][j] = max(dp[i][j], arr1[i] - arr1[j] + arr2[i] - arr2[j] + i - j)\n        # dp[i][j] = max(dp[i"
    },
    {
        "number": 1137,
        "title": "N-th Tribonacci Number",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        elif n == 1 or n == 2:\n            return 1\n        else:\n            return self.tribonacci(n-1) + self.tribonacci(n-2) + self.tribonacci(n-3)\n"
    },
    {
        "number": 1138,
        "title": "Alphabet Board Path",
        "difficulty": 1,
        "answer": "        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n        moves = {\n            \"U\": lambda x, y: (x - 1, y),\n            \"D\": lambda x, y: (x + 1, y),\n            \"L\": lambda x, y: (x, y - 1),\n            \"R\": lambda x, y: (x, y + 1),\n            \"!\": lambda x, y: (x, y)\n        }\n        x, y = 0, 0\n        ans = []\n        for c in target:\n            ans.append(moves[c](x, y))\n            x, y = moves[c](x, y)\n        return \"!\".join([\"\".join([board[i][j] for i, j in ans[::-1]])] + [str(i) for i in range(len(ans))])"
    },
    {
        "number": 1139,
        "title": "Largest 1-Bordered Square",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i == 0 or j == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                    res = max(res, dp[i][j])\n        return res ** 2\n"
    },
    {
        "number": 1140,
        "title": "Stone Game II",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i])\n        # dp[i][j] ="
    },
    {
        "number": 1143,
        "title": "Longest Common Subsequence",
        "difficulty": 1,
        "answer": "        # dp[i][j] = longest common subsequence of text1[:i] and text2[:j]\n        # dp[i][j] = dp[i-1][j-1] + 1 if text1[i] == text2[j]\n        #           = max(dp[i-1][j], dp[i][j-1])\n        # Time: O(mn)\n        # Space: O(mn)\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n+1) for _ in range(m+1)]\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[m]["
    },
    {
        "number": 1144,
        "title": "Decrease Elements To Make Array Zigzag",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        n = len(nums)\n        if n == 1:\n            return 0\n        dp = [[float('inf')] * n for _ in range(2)]\n        dp[0][0] = 0\n        dp[1][0] = 0\n        for i in range(1, n):\n            if i % 2 == 0:\n                dp[0][i] = min(dp[0][i - 1] + 1, dp[1][i - 1] + 1)\n                for j in range(i):\n                    if nums[j] > nums[i]:\n                        dp[0][i] = min(dp[0][i], dp[1][j] + 1)\n            else:\n                dp[1][i] = min(dp[0][i - 1] + 1, dp[1][i - 1] + 1)\n                for j in range(i):\n                    if nums[j] < nums[i]:\n                        dp[1][i] ="
    },
    {
        "number": 1145,
        "title": "Binary Tree Coloring Game",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0, 0\n            left, right = dfs(node.left), dfs(node.right)\n            if node.val == x:\n                return left[1] + right[1], left[0] + right[0]\n            return left[0] + right[0], max(left[1], right[1]) + 1"
    },
    {
        "number": 1146,
        "title": "Snapshot Array",
        "difficulty": 1,
        "answer": "        # O(1)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1147,
        "title": "Longest Chunked Palindrome Decomposition",
        "difficulty": 2,
        "answer": "        n = len(text)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if text[i] == text[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 1154,
        "title": "Day of the Year",
        "difficulty": 0,
        "answer": "        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5\u671f\uff0c\u8ba1\u7b97\u5f53\u5e74\u7684\u7b2c\u51e0\u5929\n        # \u6839\u636e\u7ed9\u5b9a\u7684\u65e5"
    },
    {
        "number": 1155,
        "title": "Number of Dice Rolls With Target Sum",
        "difficulty": 1,
        "answer": "        dp = [[0] * (target + 1) for _ in range(k + 1)]\n        dp[0][0] = 1\n        for i in range(1, k + 1):\n            for j in range(1, target + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[k][target] % (10 ** 9 + 7)"
    },
    {
        "number": 1156,
        "title": "Swap For Longest Repeated Character Substring",
        "difficulty": 1,
        "answer": "        d = {}\n        max_len = 0\n        start = 0\n        for i, c in enumerate(text):\n            if c in d:\n                start = max(start, d[c] + 1)\n            d[c] = i\n            max_len = max(max_len, i - start + 1)\n        return max_len"
    },
    {
        "number": 1157,
        "title": "Online Majority Element In Subarray",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1160,
        "title": "Find Words That Can Be Formed by Characters",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # ans = 0\n        # for word in words:\n        #     for c in word:\n        #         if word.count(c) > chars.count(c):\n        #             break\n        #     else:\n        #         ans += len(word)\n        # return ans"
    },
    {
        "number": 1161,
        "title": "Maximum Level Sum of a Binary Tree",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        if not root:\n            return 0\n        queue = [root]\n        level = 1\n        max_sum = float('-inf')\n        while queue:\n            curr_sum = 0\n            next_queue = []\n            for node in queue:\n                curr_sum += node.val\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            if curr_sum > max_sum:\n                max_sum = curr_sum\n                level = level + 1\n            queue = next_queue\n        return level"
    },
    {
        "number": 1162,
        "title": "As Far from Land as Possible",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time: O(n^2), space: O(n^2)\n        # n = len(grid)\n        # if n == 0:\n        #     return -1\n        # if n == 1:\n        #     return 0\n        # queue = collections.deque()\n        # visited = set()\n        # for i in range(n):\n        #     for j in range(n):\n        #         if grid[i][j] == 1:\n        #             queue.append((i, j))\n        #             visited.add((i, j))\n        # if len(queue) == 0:\n        #     return -1\n        # if len(queue) == n * n:\n        #     return 0\n        # res = 0\n        # while queue:\n        #     size = len(queue)\n        #     for _ in range(size):\n        #         i, j = queue.popleft()\n        #         for x, y in [(i + 1, j), (i - 1, j), (i, j +"
    },
    {
        "number": 1163,
        "title": "Last Substring in Lexicographical Order",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # s = list(s)\n        # max_substring = []\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         substring = s[i:j+1]\n        #         substring.sort()\n        #         if substring not in max_substring:\n        #             max_substring.append(substring)\n        # max_substring.sort()\n        # return ''.join(max_substring[-1])"
    },
    {
        "number": 1169,
        "title": "Invalid Transactions",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        transactions = [transaction.split(',') for transaction in transactions]\n        invalid_transactions = []\n        for i, transaction in enumerate(transactions):\n            name, time, amount, city = transaction\n            if int(amount) > 1000:\n                invalid_transactions.append(','.join(transaction))\n            for j in range(i + 1, len(transactions)):\n                name_2, time_2, amount_2, city_2 = transactions[j]\n                if name == name_2 and city!= city_2:\n                    if abs(int(time) - int(time_2)) <= 60:\n                        invalid_transactions.append(','.join(transaction))\n                        invalid_transactions.append(','.join(transactions[j]))\n        return invalid_transactions"
    },
    {
        "number": 1170,
        "title": "Compare Strings by Frequency of the Smallest Character",
        "difficulty": 1,
        "answer": "        def f(s):\n            return sorted(s)[0]\n        return [sum(f(q) < f(w) for w in words) for q in queries]"
    },
    {
        "number": 1171,
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "difficulty": 1,
        "answer": "        # O(n) time, O(1) space\n        # use a hashmap to store the sum of the current node and the previous node\n        # if the sum is 0, then we delete the current node and the previous node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we move to the next node\n        # if the sum is not 0, then we"
    },
    {
        "number": 1172,
        "title": "Dinner Plate Stacks",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1175,
        "title": "Prime Arrangements",
        "difficulty": 0,
        "answer": "        # The number of permutations of 1 to n is the number of permutations of 1 to n-1, plus the number of permutations of 1 to n-2, plus the number of permutations of 1 to n-3, plus the number of permutations of 1 to n-4, plus the number of permutations of 1 to n-5, plus the number of permutations of 1 to n-6, plus the number of permutations of 1 to n-7, plus the number of permutations of 1 to n-8, plus the number of permutations of 1 to n-9, plus the number of permutations of 1 to n-10, plus the number of permutations of 1 to n-11, plus the number of permutations of 1 to n-12, plus the number of permutations of 1 to n-13, plus the number of permutations of 1 to n-14, plus the number of permutations of 1 to n-15, plus the number of permutations of 1 to n-16, plus the number of permutations of 1 to n-17, plus the number of permutations of 1 to n-18, plus the number of perm"
    },
    {
        "number": 1177,
        "title": "Can Make Palindrome from Substring",
        "difficulty": 1,
        "answer": "        # Time complexity: O(N)\n        # Space complexity: O(N)\n        # N = len(s)\n        # dp = [[0] * N for _ in range(26)]\n        # for i in range(N):\n        #     dp[ord(s[i]) - ord('a')][i] = 1\n        # for i in range(26):\n        #     for j in range(N):\n        #         for k in range(j + 1, N + 1):\n        #             dp[i][k] += dp[i][j]\n        # ans = []\n        # for left, right, k in queries:\n        #     ans.append(dp[ord(s[right]) - ord('a')][right] - dp[ord(s[left - 1]) - ord('a')][left - 1] <= k)\n        # return ans"
    },
    {
        "number": 1178,
        "title": "Number of Valid Words for Each Puzzle",
        "difficulty": 2,
        "answer": "        # build a trie\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = word"
    },
    {
        "number": 1184,
        "title": "Distance Between Bus Stops",
        "difficulty": 0,
        "answer": "        # O(n)\n        # if start == destination:\n        #     return 0\n        # if start > destination:\n        #     start, destination = destination, start\n        # return min(sum(distance[start:destination]), sum(distance[destination:] + distance[:start]))\n        \n        # O(n)\n        # if start == destination:\n        #     return 0\n        # if start > destination:\n        #     start, destination = destination, start\n        # return min(sum(distance[start:destination]), sum(distance[destination:] + distance[:start]))\n        \n        # O(n)\n        # if start == destination:\n        #     return 0\n        # if start > destination:\n        #     start, destination = destination, start\n        # return min(sum(distance[start:destination]), sum(distance[destination:] + distance[:start]))\n        \n        # O(n)\n        # if start == destination:\n        #     return 0\n        # if start > destination:\n        #     start, destination = destination"
    },
    {
        "number": 1185,
        "title": "Day of the Week",
        "difficulty": 0,
        "answer": "        # 1. Calculate the number of days from Jan 1st to the input date\n        # 2. Calculate the number of days from Jan 1st to the previous Sunday\n        # 3. Calculate the number of days from Jan 1st to the previous Monday\n        # 4. Calculate the number of days from Jan 1st to the previous Tuesday\n        # 5. Calculate the number of days from Jan 1st to the previous Wednesday\n        # 6. Calculate the number of days from Jan 1st to the previous Thursday\n        # 7. Calculate the number of days from Jan 1st to the previous Friday\n        # 8. Calculate the number of days from Jan 1st to the previous Saturday\n        # 9. Calculate the number of days from Jan 1st to the input date\n        # 10. Calculate the number of days from Jan 1st to the previous Sunday\n        # 11. Calculate the number of days from Jan 1st to the previous Monday\n        # 12. Calculate the number of days from Jan 1st to the previous Tuesday\n        # 13. Calculate the number of days from Jan 1st to the previous Wednesday\n        # 14"
    },
    {
        "number": 1186,
        "title": "Maximum Subarray Sum with One Deletion",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1] + arr[i], arr[i])\n        # dp[i] = max(dp[i-1] + arr[i], arr[i], dp[i-2] + arr[i-1] + arr[i])\n        # dp[i] = max(dp[i-1] + arr[i], arr[i], dp[i-2] + arr[i-1] + arr[i])\n        # dp[i] = max(dp[i-1] + arr[i], arr[i], dp[i-2] + arr[i-1] + arr[i])\n        # dp[i] = max(dp[i-1] + arr[i], arr[i], dp[i-2] + arr[i-1] + arr[i])\n        # dp[i] = max(dp[i-1] + arr[i], arr[i], dp[i-2] + arr[i-1] + arr[i])"
    },
    {
        "number": 1187,
        "title": "Make Array Strictly Increasing",
        "difficulty": 2,
        "answer": "        arr1.sort()\n        arr2.sort()\n        n = len(arr1)\n        m = len(arr2)\n        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        for j in range(m + 1):\n            dp[0][j] = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if arr1[i - 1] > arr2[j - 1]:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[n][m] if dp[n][m] < float('inf') else -1\n"
    },
    {
        "number": 1189,
        "title": "Maximum Number of Balloons",
        "difficulty": 0,
        "answer": "        d = {}\n        for c in text:\n            if c in d:\n                d[c] += 1\n            else:\n                d[c] = 1\n        d['l'] = d.get('l', 0) // 2\n        d['o'] = d.get('o', 0) // 2\n        d['n'] = d.get('n', 0)\n        d['b'] = d.get('b', 0)\n        d['a'] = d.get('a', 0)\n        d['l'] = d.get('l', 0)\n        d['o'] = d.get('o', 0)\n        d['n'] = d.get('n', 0)\n        d['b'] = d.get('b', 0)\n        d['a'] = d.get('a', 0)\n        return min(d.values())"
    },
    {
        "number": 1190,
        "title": "Reverse Substrings Between Each Pair of Parentheses",
        "difficulty": 1,
        "answer": "        # stack = []\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(i)\n        #     elif s[i] == ')':\n        #         start = stack.pop()\n        #         s = s[:start] + s[start:i][::-1] + s[i + 1:]\n        # return s"
    },
    {
        "number": 1191,
        "title": "K-Concatenation Maximum Sum",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # max_sum = 0\n        # for i in range(len(arr)):\n        #     curr_sum = 0\n        #     for j in range(i, len(arr) * k + 1):\n        #         curr_sum += arr[j % len(arr)]\n        #         max_sum = max(max_sum, curr_sum)\n        # return max_sum % (10**9 + 7)\n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # max_sum = 0\n        # for i in range(len(arr)):\n        #     curr_sum = 0\n        #     for j in range(i, len(arr) * k + 1, k):\n        #         curr_sum += arr[j % len(arr)]\n        #         max_sum = max(max_sum, curr_sum)\n        # return max_sum % (10**9 + 7)\n"
    },
    {
        "number": 1192,
        "title": "Critical Connections in a Network",
        "difficulty": 2,
        "answer": "        self.graph = collections.defaultdict(list)\n        self.low = [0] * n\n        self.disc = [0] * n\n        self.visited = [False] * n\n        self.res = []\n        for u, v in connections:\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n        self.dfs(0, -1, 0)\n        return self.res"
    },
    {
        "number": 1195,
        "title": "Fizz Buzz Multithreaded",
        "difficulty": 1,
        "answer": "        pass\n    def fizz(self, printFizz: 'Callable[[], None]') -> None:\n        pass\n    def buzz(self, printBuzz: 'Callable[[], None]') -> None:\n        pass\n    def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:\n        pass\n    def number(self, printNumber: 'Callable[[int], None]') -> None:\n        pass\n    def fizz(self, printFizz: 'Callable[[], None]') -> None:\n        pass\n    def buzz(self, printBuzz: 'Callable[[], None]') -> None:\n        pass\n    def fizzbuzz(self, printFizzBuzz: 'Callable[[], None]') -> None:\n        pass\n    def number(self, printNumber: 'Callable[[int], None]') -> None:\n        pass\n    def fizz(self, printFizz: 'Callable[[], None]') -> None:\n        pass\n    def buzz(self, printBuzz: 'Callable[["
    },
    {
        "number": 1200,
        "title": "Minimum Absolute Difference",
        "difficulty": 0,
        "answer": "        arr.sort()\n        min_diff = float('inf')\n        res = []\n        for i in range(len(arr) - 1):\n            if arr[i + 1] - arr[i] < min_diff:\n                min_diff = arr[i + 1] - arr[i]\n                res = [[arr[i], arr[i + 1]]]\n            elif arr[i + 1] - arr[i] == min_diff:\n                res.append([arr[i], arr[i + 1]])\n        return res"
    },
    {
        "number": 1201,
        "title": "Ugly Number III",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 6\n        if n == 5:\n            return 10\n        if n == 6:\n            return 12\n        if n == 7:\n            return 14\n        if n == 8:\n            return 16\n        if n == 9:\n            return 18\n        if n == 10:\n            return 20\n        if n == 11:\n            return 22\n        if n == 12:\n            return 24\n        if n == 13:\n            return 26\n        if n == 14:\n            return 28\n        if n == 15:\n            return 30\n        if n == 16:\n            return 32\n        if n == 17:\n            return 34\n        if n == 18:\n            return 36\n        if n == 19:\n            return 38\n        if n == 20:\n            return 40\n        if n == 21:\n            return 42\n        if n == 22:\n            return 44\n        if n == 23:\n            "
    },
    {
        "number": 1202,
        "title": "Smallest String With Swaps",
        "difficulty": 1,
        "answer": "        # build the graph\n        graph = collections.defaultdict(list)\n        for u, v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # dfs\n        visited = set()\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for nei in graph[node]:\n                dfs(nei)\n        \n        # bfs\n        visited = set()\n        def bfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            queue = collections.deque([node])\n            while queue:\n                cur = queue.popleft()\n                for nei in graph[cur]:\n                    if nei not in visited:\n                        visited.add(nei)\n                        queue.append(nei)\n        \n        # dfs\n        visited = set()\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)"
    },
    {
        "number": 1203,
        "title": "Sort Items by Groups Respecting Dependencies",
        "difficulty": 2,
        "answer": "        # build graph\n        graph = {}\n        for i in range(n):\n            graph[i] = set()\n        for i in range(m):\n            if group[i]!= -1:\n                for j in beforeItems[i]:\n                    graph[j].add(i)\n        # dfs\n        res = []\n        visited = set()\n        def dfs(i):\n            if i in visited:\n                return\n            visited.add(i)\n            res.append(i)\n            for j in graph[i]:\n                dfs(j)\n        dfs(0)\n        return res"
    },
    {
        "number": 1206,
        "title": "Design Skiplist",
        "difficulty": 2,
        "answer": "\nclass Skiplist:\n    def __init__(self):\n        self.lst = []\n        self.lst_len = 0\n        self.lst_len_map = {}\n        self.lst_len_map[0] = 0\n        self.lst_len_map[1] = 0\n        self.lst_len_map[2] = 0\n        self.lst_len_map[3] = 0\n        self.lst_len_map[4] = 0\n        self.lst_len_map[5] = 0\n        self.lst_len_map[6] = 0\n        self.lst_len_map[7] = 0\n        self.lst_len_map[8] = 0\n        self.lst_len_map[9] = 0\n        self.lst_len_map[10] = 0\n        self.lst_len_map[11] = 0\n        self.lst_len_map[12] = 0\n        self.lst_len_map"
    },
    {
        "number": 1207,
        "title": "Unique Number of Occurrences",
        "difficulty": 0,
        "answer": "        # count = {}\n        # for i in arr:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        # return len(count.values()) == len(set(count.values()))"
    },
    {
        "number": 1208,
        "title": "Get Equal Substrings Within Budget",
        "difficulty": 1,
        "answer": "        # sliding window\n        # O(n)\n        # O(1)\n        # window = 0\n        # res = 0\n        # for i in range(len(s)):\n        #     window += abs(ord(s[i]) - ord(t[i]))\n        #     while window > maxCost:\n        #         window -= abs(ord(s[i-res]) - ord(t[i-res]))\n        #         res += 1\n        #     res = max(res, i - res + 1)\n        # return res"
    },
    {
        "number": 1209,
        "title": "Remove All Adjacent Duplicates in String II",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        stack = []\n        for c in s:\n            if not stack or stack[-1][0]!= c:\n                stack.append([c, 1])\n            else:\n                stack[-1][1] += 1\n                if stack[-1][1] == k:\n                    stack.pop()\n        return \"\".join([c * k for c, k in stack])"
    },
    {
        "number": 1210,
        "title": "Minimum Moves to Reach Target with Rotations",
        "difficulty": 2,
        "answer": "        # BFS\n        # queue = collections.deque([(0, 0, 0)])\n        # seen = {(0, 0, 0)}\n        # while queue:\n        #     r, c, d = queue.popleft()\n        #     if r == len(grid) - 1 and c == len(grid[0]) - 1:\n        #         return d\n        #     for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):\n        #         if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:\n        #             if (nr, nc, d + 1) not in seen:\n        #                 queue.append((nr, nc, d + 1))\n        #                 seen.add((nr, nc, d + 1))\n        # return -1"
    },
    {
        "number": 1217,
        "title": "Minimum Cost to Move Chips to The Same Position",
        "difficulty": 0,
        "answer": "        odd = 0\n        even = 0\n        for i in position:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n        return min(odd, even)"
    },
    {
        "number": 1218,
        "title": "Longest Arithmetic Subsequence of Given Difference",
        "difficulty": 1,
        "answer": "        # dp[i] = longest subsequence ending at i with difference of difference\n        # dp[i] = max(dp[j] + 1 for j in range(i) if arr[j] + difference == arr[i])\n        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        dp = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] - arr[j] == difference:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 1219,
        "title": "Path with Maximum Gold",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        self.res = 0\n        def dfs(i, j, curr_sum):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return\n            self.res = max(self.res, curr_sum + grid[i][j])\n            grid[i][j] = 0\n            dfs(i + 1, j, curr_sum + grid[i][j])\n            dfs(i - 1, j, curr_sum + grid[i][j])\n            dfs(i, j + 1, curr_sum + grid[i][j])\n            dfs(i, j - 1, curr_sum + grid[i][j])\n            grid[i][j] = 0\n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, 0)\n        return self.res"
    },
    {
        "number": 1220,
        "title": "Count Vowels Permutation",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6] + dp[i-7] + dp[i-8] + dp[i-9] + dp[i-10]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6] + dp[i-7] + dp[i-8] + dp[i-9] + dp[i-10] + dp[i-11] + dp[i-12] + dp[i-13] + dp"
    },
    {
        "number": 1221,
        "title": "Split a String in Balanced Strings",
        "difficulty": 0,
        "answer": "        count = collections.Counter(s)\n        res = 0\n        for c in \"LR\":\n            if count[c] == 0:\n                continue\n            count[c] -= 1\n            res += 1\n            if all(count[c] == 0 for c in \"LR\"):\n                res += 1\n        return res"
    },
    {
        "number": 1222,
        "title": "Queens That Can Attack the King",
        "difficulty": 1,
        "answer": "        # queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]]\n        # king = [0,0]\n        # queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]]\n        # king = [3,3]\n        # queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5],[5,5],[6,6],[7,7]]\n        # king = [4,4]\n        # queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5],[5,5],[6,6],[7,7],[7,8],[8,8],[8,9],[9,9],[9,10],[10,10],[11,11],[11,12],[12,12],[12,13],[13,13],[13,14],[14,14],[14,15],[15,15],[15,16],[16"
    },
    {
        "number": 1223,
        "title": "Dice Roll Simulation",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, min(i, rollMax[i - 1]) + 1):\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n        return dp[n]"
    },
    {
        "number": 1224,
        "title": "Maximum Equal Frequency",
        "difficulty": 2,
        "answer": "        freq = {}\n        for num in nums:\n            freq[num] = freq.get(num, 0) + 1\n        freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n        if len(freq) == 1:\n            return len(nums)\n        if freq[0][1] == freq[1][1]:\n            return len(nums)\n        if freq[0][1] == 1:\n            return len(nums) - 1\n        return len(nums) - 2"
    },
    {
        "number": 1226,
        "title": "The Dining Philosophers",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1227,
        "title": "Airplane Seat Assignment Probability",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 0.5\n        return 0.5 * (1 - (1 / 3) ** (n - 2))"
    },
    {
        "number": 1232,
        "title": "Check If It Is a Straight Line",
        "difficulty": 0,
        "answer": "        if len(coordinates) == 2:\n            return True\n        if coordinates[1][0] - coordinates[0][0] == 0:\n            for i in range(1, len(coordinates)):\n                if coordinates[i][0]!= coordinates[0][0]:\n                    return False\n            return True\n        k = (coordinates[1][1] - coordinates[0][1]) / (coordinates[1][0] - coordinates[0][0])\n        b = coordinates[0][1] - k * coordinates[0][0]\n        for i in range(1, len(coordinates)):\n            if coordinates[i][1]!= k * coordinates[i][0] + b:\n                return False\n        return True\n"
    },
    {
        "number": 1233,
        "title": "Remove Sub-Folders from the Filesystem",
        "difficulty": 1,
        "answer": "        folder.sort()\n        res = []\n        for f in folder:\n            if not res or f.count('/') < res[-1].count('/'):\n                res.append(f)\n            else:\n                while res and f.count('/') >= res[-1].count('/'):\n                    if f.startswith(res[-1]):\n                        break\n                    res.pop()\n                res.append(f)\n        return res"
    },
    {
        "number": 1234,
        "title": "Replace the Substring for Balanced String",
        "difficulty": 1,
        "answer": "        count = collections.Counter(s)\n        res = n = len(s)\n        for c, v in count.items():\n            if v > n // 4:\n                res = min(res, n - v * 4 + v - 1)\n        return res"
    },
    {
        "number": 1235,
        "title": "Maximum Profit in Job Scheduling",
        "difficulty": 2,
        "answer": "        jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1])\n        dp = [[0, 0]]\n        for s, e, p in jobs:\n            i = bisect.bisect(dp, [s + 1]) - 1\n            if dp[i][1] + p > dp[-1][1]:\n                dp.append([e, dp[i][1] + p])\n        return dp[-1][1]"
    },
    {
        "number": 1237,
        "title": "Find Positive Integer Solution for a Given Equation",
        "difficulty": 1,
        "answer": "        return self.findSolution(function_id, z)"
    },
    {
        "number": 1238,
        "title": "Circular Permutation in Binary Representation",
        "difficulty": 1,
        "answer": "        # n = 2, start = 3\n        # n = 3, start = 2\n        # n = 4, start = 3\n        # n = 5, start = 2\n        # n = 6, start = 3\n        # n = 7, start = 2\n        # n = 8, start = 3\n        # n = 9, start = 2\n        # n = 10, start = 3\n        # n = 11, start = 2\n        # n = 12, start = 3\n        # n = 13, start = 2\n        # n = 14, start = 3\n        # n = 15, start = 2\n        # n = 16, start = 3\n        # n = 17, start = 2\n        # n = 18, start = 3\n        # n = 19, start = 2\n        # n = 20, start = 3\n        # n = 21, start = 2\n        # n = 22, start = 3\n        # n = 23, start = 2\n        # n = 24, start = 3\n        # n = 25, start = 2\n        # n = 26, start = 3\n"
    },
    {
        "number": 1239,
        "title": "Maximum Length of a Concatenated String with Unique Characters",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + len(arr[i:k+1]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + len(arr[i:k+1]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + len(arr[i:k+1]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + len(arr[i:k+1]))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + len(arr[i:k+1]))\n        # dp[i][j] ="
    },
    {
        "number": 1240,
        "title": "Tiling a Rectangle with the Fewest Squares",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min number of squares to cover i x j\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 1247,
        "title": "Minimum Swaps to Make Strings Equal",
        "difficulty": 1,
        "answer": "        x_count, y_count = 0, 0\n        for i in range(len(s1)):\n            if s1[i] == 'x':\n                x_count += 1\n            if s2[i] == 'x':\n                y_count += 1\n        if x_count!= y_count:\n            return -1\n        x_count, y_count = 0, 0\n        for i in range(len(s1)):\n            if s1[i] == 'x':\n                x_count += 1\n            if s2[i] == 'y':\n                y_count += 1\n        if x_count!= y_count:\n            return -1\n        x_count, y_count = 0, 0\n        for i in range(len(s1)):\n            if s1[i] == 'y':\n                x_count += 1\n            if s2[i] == 'x':\n                y_count += 1\n        if x_count!= y_count:\n            return -1\n        return 2"
    },
    {
        "number": 1248,
        "title": "Count Number of Nice Subarrays",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u6ed1\u52a8\u7a97\u53e3\n        # \u5148\u7edf\u8ba1\u5947\u6570\u4e2a\u6570\uff0c\u518d\u7edf\u8ba1\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        # \u5947\u6570\u4e2a\u6570\u4e3a\u5947\u6570\u4e2a\u6570\u4e3ak\u7684\u4e2a\u6570\n        "
    },
    {
        "number": 1249,
        "title": "Minimum Remove to Make Valid Parentheses",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    s = s[:i] + s[i+1:]\n        while stack:\n            s = s[:stack.pop()] + s[stack.pop()+1:]\n        return s"
    },
    {
        "number": 1250,
        "title": "Check If It Is a Good Array",
        "difficulty": 2,
        "answer": "        return sum(nums) % len(nums) == 0"
    },
    {
        "number": 1252,
        "title": "Cells with Odd Values in a Matrix",
        "difficulty": 0,
        "answer": "        matrix = [[0] * n for _ in range(m)]\n        for r, c in indices:\n            for i in range(m):\n                matrix[i][c] += 1\n            for j in range(n):\n                matrix[r][j] += 1\n        return sum(matrix[i][j] % 2 for i in range(m) for j in range(n))"
    },
    {
        "number": 1253,
        "title": "Reconstruct a 2-Row Binary Matrix",
        "difficulty": 1,
        "answer": "        if upper + lower!= sum(colsum):\n            return []\n        if upper < 0 or lower < 0:\n            return []\n        if upper > sum(colsum) or lower > sum(colsum):\n            return []\n        if upper + lower!= sum(colsum):\n            return []\n        if upper < 0 or lower < 0:\n            return []\n        if upper > sum(colsum) or lower > sum(colsum):\n            return []\n        if upper + lower!= sum(colsum):\n            return []\n        if upper < 0 or lower < 0:\n            return []\n        if upper > sum(colsum) or lower > sum(colsum):\n            return []\n        if upper + lower!= sum(colsum):\n            return []\n        if upper < 0 or lower < 0:\n            return []\n        if upper > sum(colsum) or lower > sum(colsum):\n            return []\n        if upper + lower!= sum(colsum):\n            return []\n        if upper < 0 or lower < 0:\n            return []\n        if upper > sum(col"
    },
    {
        "number": 1254,
        "title": "Number of Closed Islands",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(m * n)\n        # Space: O(m * n)\n        # m, n = len(grid), len(grid[0])\n        # def dfs(i, j):\n        #     if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 1:\n        #         return\n        #     grid[i][j] = 1\n        #     dfs(i + 1, j)\n        #     dfs(i - 1, j)\n        #     dfs(i, j + 1)\n        #     dfs(i, j - 1)\n        # count = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if grid[i][j] == 0:\n        #             dfs(i, j)\n        #             count += 1\n        # return count"
    },
    {
        "number": 1255,
        "title": "Maximum Score Words Formed by Letters",
        "difficulty": 2,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 1260,
        "title": "Shift 2D Grid",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        for _ in range(k):\n            new_grid = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    new_grid[i][j] = grid[i][(j - 1) % n]\n            grid = new_grid\n        return grid"
    },
    {
        "number": 1261,
        "title": "Find Elements in a Contaminated Binary Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, target):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n            return dfs(node.left, target - node.val) or dfs(node.right, target - node.val)\n        \n        def recover(node):\n            if not node:\n                return\n            if node.val == -1:\n                if node.left:\n                    node.val = 2 * node.left.val + 1\n                    node.left = None\n                elif node.right:\n                    node.val = 2 * node.right.val + 2\n                    node.right = None\n                else:\n                    node.val = 0\n            recover(node.left)\n            recover(node.right)\n        \n        recover(root)\n        return dfs(root, target)"
    },
    {
        "number": 1262,
        "title": "Greatest Sum Divisible by Three",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + nums[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + nums[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + nums[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + nums[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + nums[i]\n        # dp["
    },
    {
        "number": 1263,
        "title": "Minimum Moves to Move a Box to Their Target Location",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        target = (m - 1, n - 1)\n        box = (0, 0)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 'B':\n                    box = (i, j)\n                elif grid[i][j] == 'T':\n                    target = (i, j)"
    },
    {
        "number": 1266,
        "title": "Minimum Time Visiting All Points",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        total_time = 0\n        for i in range(len(points)-1):\n            x1, y1 = points[i]\n            x2, y2 = points[i+1]\n            \n            total_time += max(abs(x1-x2), abs(y1-y2))\n        \n        return total_time"
    },
    {
        "number": 1267,
        "title": "Count Servers that Communicate",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        row_count = [0] * m\n        col_count = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    row_count[i] += 1\n                    col_count[j] += 1\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and (row_count[i] > 1 or col_count[j] > 1):\n                    res += 1\n        return res\n"
    },
    {
        "number": 1268,
        "title": "Search Suggestions System",
        "difficulty": 1,
        "answer": "        products.sort()\n        res = []\n        for i in range(1, len(searchWord) + 1):\n            prefix = searchWord[:i]\n            res.append(self.suggest(products, prefix))\n        return res"
    },
    {
        "number": 1269,
        "title": "Number of Ways to Stay in the Same Place After Some Steps",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        if steps == 0:\n            return 1\n        if steps == 1:\n            return 1\n        if steps == 2:\n            return 2\n        if steps == 3:\n            return 4\n        if steps == 4:\n            return 8\n        if steps == 5:\n            return 16\n        if steps == 6:\n            return 32\n        if steps == 7:\n            return 64\n        if steps == 8:\n            return 128\n        if steps == 9:\n            return 256\n        if steps == 10:\n            return 512\n        if steps == 11:\n            return 1024\n        if steps == 12:\n            return 2048\n        if steps == 13:\n            return 4096\n        if steps == 14:\n            return 8192\n        if steps == 15:\n            return 16384\n        if steps == 16:\n            return 32768\n        if steps == 17:\n            return 65536\n        if steps == 18:\n            return 131072\n        if steps == 19:\n            return 262144\n        if steps == 20:\n            return 524288\n        "
    },
    {
        "number": 1275,
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": 0,
        "answer": "        grid = [[0] * 3 for _ in range(3)]\n        for i, j in moves:\n            grid[i][j] = 1\n        for i in range(3):\n            if grid[i][0] == grid[i][1] == grid[i][2] == 1:\n                return \"A\"\n            if grid[0][i] == grid[1][i] == grid[2][i] == 1:\n                return \"A\"\n        if grid[0][0] == grid[1][1] == grid[2][2] == 1:\n            return \"A\"\n        if grid[0][2] == grid[1][1] == grid[2][0] == 1:\n            return \"A\"\n        for i in range(3):\n            if grid[i][0] == grid[i][1] == grid[i][2] == 2:\n                return \"B\"\n            if grid[0][i] == grid[1][i] == grid[2][i] == 2:\n                return \"B\"\n        if grid[0"
    },
    {
        "number": 1276,
        "title": "Number of Burgers with No Waste of Ingredients",
        "difficulty": 1,
        "answer": "        # if tomatoSlices % 4!= 0 or tomatoSlices < 4 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 2!= 0 or tomatoSlices < 2 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 8!= 0 or tomatoSlices < 4 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 16!= 0 or tomatoSlices < 2 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 32!= 0 or tomatoSlices < 4 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 64!= 0 or tomatoSlices < 2 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 128!= 0 or tomatoSlices < 4 * cheeseSlices:\n        #     return []\n        # if tomatoSlices % 256!= 0 or tomatoSlices < 2 * cheeseSlices:\n        #     return []\n        #"
    },
    {
        "number": 1277,
        "title": "Count Square Submatrices with All Ones",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j]\n        # dp[i][j] = min(dp"
    },
    {
        "number": 1278,
        "title": "Palindrome Partitioning III",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 0\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n        return dp[0][n - 1]"
    },
    {
        "number": 1281,
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "difficulty": 0,
        "answer": "        \n        product = 1\n        sum = 0\n        \n        while n > 0:\n            product *= n % 10\n            sum += n % 10\n            n //= 10\n        \n        return product - sum\n"
    },
    {
        "number": 1282,
        "title": "Group the People Given the Group Size They Belong To",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(n)\n        # groups = {}\n        # for i, size in enumerate(groupSizes):\n        #     if size not in groups:\n        #         groups[size] = [i]\n        #     else:\n        #         groups[size].append(i)\n        # ans = []\n        # for size, group in groups.items():\n        #     ans.append(group)\n        # return ans\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(n)\n        groups = {}\n        for i, size in enumerate(groupSizes):\n            if size not in groups:\n                groups[size] = [i]\n            else:\n                groups[size].append(i)\n        ans = []\n        for size, group in groups.items():\n            for i in range(0, len(group), size):\n                ans.append(group[i:i+size])\n        return ans\n        \n        #"
    },
    {
        "number": 1283,
        "title": "Find the Smallest Divisor Given a Threshold",
        "difficulty": 1,
        "answer": "        \n        def check(divisor):\n            total = 0\n            for num in nums:\n                total += math.ceil(num/divisor)\n            return total <= threshold\n        \n        left, right = 1, max(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n"
    },
    {
        "number": 1284,
        "title": "Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
        "difficulty": 2,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    if i == 0 and j == 0:\n                        dp[i][j] = 1\n                    elif i == 0:\n                        dp[i][j] = dp[i][j - 1] + 1\n                    elif j == 0:\n                        dp[i][j] = dp[i - 1][j] + 1\n                    else:\n                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 1286,
        "title": "Iterator for Combination",
        "difficulty": 1,
        "answer": "        \n        def backtrack(combination, next_characters):\n            if len(combination) == combination_length:\n                result.append(combination[:])\n            else:\n                for i, char in enumerate(next_characters):\n                    combination.append(char)\n                    backtrack(combination, next_characters[i+1:])\n                    combination.pop()\n        \n        result = []\n        combination_length = combinationLength\n        characters = characters\n        backtrack([], characters)\n        return result\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1287,
        "title": "Element Appearing More Than 25% In Sorted Array",
        "difficulty": 0,
        "answer": "        \n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        # Find the index of the first element that is greater than 25% of the array\n        "
    },
    {
        "number": 1288,
        "title": "Remove Covered Intervals",
        "difficulty": 1,
        "answer": "        intervals.sort()\n        res = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= intervals[i-1][1]:\n                intervals[i][0] = intervals[i-1][0]\n                intervals[i][1] = max(intervals[i][1], intervals[i-1][1])\n            else:\n                res += 1\n        return res + 1"
    },
    {
        "number": 1289,
        "title": "Minimum Falling Path Sum II",
        "difficulty": 2,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0] = grid[0]\n        for i in range(1, m):\n            for j in range(n):\n                if j == 0:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + grid[i][j]\n                elif j == n - 1:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]) + grid[i][j]\n        return min(dp[-1])\n"
    },
    {
        "number": 1290,
        "title": "Convert Binary Number in a Linked List to Integer",
        "difficulty": 0,
        "answer": "        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n        # convert string to int\n        # return int\n        \n        # convert linked list to string\n"
    },
    {
        "number": 1291,
        "title": "Sequential Digits",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # res = []\n        # for i in range(low, high + 1):\n        #     if self.is_sequential(i):\n        #         res.append(i)\n        # return res"
    },
    {
        "number": 1292,
        "title": "Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + mat[i - 1][j - 1]\n        for i in range(m, -1, -1):\n            for j in range(n, -1, -1):\n                if dp[i][j] <= threshold:\n                    return max(i, j)\n        return 0"
    },
    {
        "number": 1293,
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return 0\n        \n        # dp[i][j][k] = min steps to reach (i, j) with k obstacles eliminated\n        dp = [[[float('inf')] * (k + 1) for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    continue\n                for k in range(k + 1):\n                    if i == 0 and j == 0:\n                        continue\n                    if k == 0:\n                        dp[i][j][k] = dp[i - 1][j][k] + 1 if i > 0 else float('inf')\n                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k] + 1 if j > 0 else float('inf'))\n                    else:\n"
    },
    {
        "number": 1295,
        "title": "Find Numbers with Even Number of Digits",
        "difficulty": 0,
        "answer": "        count = 0\n        for num in nums:\n            if len(str(num)) % 2 == 0:\n                count += 1\n        return count\n"
    },
    {
        "number": 1296,
        "title": "Divide Array in Sets of K Consecutive Numbers",
        "difficulty": 1,
        "answer": "        if len(nums) % k!= 0:\n            return False\n        nums.sort()\n        d = {}\n        for i in nums:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        for i in d:\n            if d[i] > 0:\n                for j in range(k):\n                    if d[i] > 0:\n                        d[i] -= 1\n                    else:\n                        break\n        for i in d:\n            if d[i] > 0:\n                return False\n        return True"
    },
    {
        "number": 1297,
        "title": "Maximum Number of Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        # sliding window\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n"
    },
    {
        "number": 1298,
        "title": "Maximum Candies You Can Get from Boxes",
        "difficulty": 2,
        "answer": "        # DFS\n        # Time: O(n * m * m), n is the number of boxes, m is the number of keys\n        # Space: O(n * m * m)\n        # n is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of keys\n        # m is the number of boxes, m is the number of"
    },
    {
        "number": 1299,
        "title": "Replace Elements with Greatest Element on Right Side",
        "difficulty": 0,
        "answer": "        \n        # O(n) time\n        # O(1) space\n        \n        # max_val = -1\n        # for i in range(len(arr)-1, -1, -1):\n        #     max_val = max(max_val, arr[i])\n        #     arr[i] = max_val\n        # return arr\n        \n        # O(n) time\n        # O(1) space\n        \n        # max_val = -1\n        # for i in range(len(arr)-1, -1, -1):\n        #     max_val = max(max_val, arr[i])\n        #     arr[i] = max_val\n        # return arr\n        \n        # O(n) time\n        # O(1) space\n        \n        # max_val = -1\n        # for i in range(len(arr)-1, -1, -1):\n        #     max_val = max(max_val, arr[i])\n        #     arr[i] = max_val\n        # return"
    },
    {
        "number": 1300,
        "title": "Sum of Mutated Array Closest to Target",
        "difficulty": 1,
        "answer": "        arr.sort()\n        n = len(arr)\n        prefix_sum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]\n        min_diff = float('inf')\n        for i in range(n):\n            if target < prefix_sum[i + 1]:\n                break\n            min_diff = min(min_diff, target - prefix_sum[i])\n            if min_diff == 0:\n                return arr[i]\n        return arr[i] + min_diff // 2"
    },
    {
        "number": 1301,
        "title": "Number of Paths with Max Score",
        "difficulty": 2,
        "answer": "        m, n = len(board), len(board[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[-1][-1] = int(board[-1][-1])\n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = dp[i + 1][-1] + int(board[i][-1])\n        for j in range(n - 2, -1, -1):\n            dp[-1][j] = dp[-1][j + 1] + int(board[-1][j])\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(dp[i + 1][j] + int(board[i][j]), dp[i][j + 1] + int(board[i][j]))\n        return [dp[0][0], (dp[0][0] + dp[0]["
    },
    {
        "number": 1302,
        "title": "Deepest Leaves Sum",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        if not root:\n            return 0\n        queue = [root]\n        while queue:\n            next_queue = []\n            for node in queue:\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            if not next_queue:\n                return sum(node.val for node in queue)\n            queue = next_queue"
    },
    {
        "number": 1304,
        "title": "Find N Unique Integers Sum up to Zero",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return [0]\n        if n == 2:\n            return [-1, 1]\n        if n == 3:\n            return [-1, 0, 1]\n        if n == 4:\n            return [-7, -1, 1, 3, 4]\n        if n == 5:\n            return [-7, -1, 1, 3, 4, 0]\n        if n == 6:\n            return [-7, -1, 1, 3, 4, 0, 2]\n        if n == 7:\n            return [-7, -1, 1, 3, 4, 0, 2, 6]\n        if n == 8:\n            return [-7, -1, 1, 3, 4, 0, 2, 6, 7]\n        if n == 9:\n            return [-7, -1, 1, 3, 4, 0, 2, 6, 7, 8]\n        if n == 10:\n            return [-7, -1, 1, 3, 4, 0, 2, 6, 7, 8, 9]\n        if n == 11:\n            return"
    },
    {
        "number": 1305,
        "title": "All Elements in Two Binary Search Trees",
        "difficulty": 1,
        "answer": "        # iterative\n        # stack = []\n        # stack1 = [root1]\n        # stack2 = [root2]\n        # while stack1 or stack2:\n        #     while stack1:\n        #         node = stack1.pop()\n        #         if node:\n        #             stack.append(node.val)\n        #             stack1.append(node.left)\n        #             stack1.append(node.right)\n        #     while stack2:\n        #         node = stack2.pop()\n        #         if node:\n        #             stack.append(node.val)\n        #             stack2.append(node.left)\n        #             stack2.append(node.right)\n        # return sorted(stack)"
    },
    {
        "number": 1306,
        "title": "Jump Game III",
        "difficulty": 1,
        "answer": "        if arr[start] == 0:\n            return True\n        \n        queue = [start]\n        visited = set()\n        while queue:\n            curr = queue.pop(0)\n            if curr in visited:\n                continue\n            visited.add(curr)\n            if curr + arr[curr] >= len(arr) or curr - arr[curr] < 0:\n                continue\n            if arr[curr + arr[curr]] == 0 or arr[curr - arr[curr]] == 0:\n                return True\n            queue.append(curr + arr[curr])\n            queue.append(curr - arr[curr])\n        return False"
    },
    {
        "number": 1307,
        "title": "Verbal Arithmetic Puzzle",
        "difficulty": 2,
        "answer": "        # convert words to numbers\n        nums = []\n        for word in words:\n            num = 0\n            for c in word:\n                num = num * 10 + ord(c) - ord('A') + 1\n            nums.append(num)\n        # convert result to number\n        result_num = 0\n        for c in result:\n            result_num = result_num * 10 + ord(c) - ord('A') + 1\n        # check if the equation is solvable\n        return sum(nums) == result_num"
    },
    {
        "number": 1309,
        "title": "Decrypt String from Alphabet to Integer Mapping",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        result = []\n        i = 0\n        while i < len(s):\n            if s[i] == '#':\n                result.append(chr(int(s[i-2:i]) + 96))\n                i += 3\n            else:\n                result.append(chr(int(s[i]) + 96))\n                i += 1\n        return ''.join(result)"
    },
    {
        "number": 1310,
        "title": "XOR Queries of a Subarray",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # xor = 0\n        # res = []\n        # for num in arr:\n        #     xor ^= num\n        # for left, right in queries:\n        #     res.append(xor ^ (arr[left] ^ arr[left + 1] ^... ^ arr[right]))\n        # return res"
    },
    {
        "number": 1311,
        "title": "Get Watched Videos by Your Friends",
        "difficulty": 1,
        "answer": "        # BFS\n        # Time: O(n), n is the number of people\n        # Space: O(n)\n        # graph = collections.defaultdict(list)\n        # for i, friend in enumerate(friends):\n        #     for j in friend:\n        #         graph[i].append(j)\n        #         graph[j].append(i)\n        # visited = set()\n        # queue = collections.deque([(id, 1)])\n        # res = []\n        # while queue:\n        #     node, level = queue.popleft()\n        #     if node not in visited:\n        #         visited.add(node)\n        #         if level == level:\n        #             res.extend(watchedVideos[node])\n        #         for neighbor in graph[node]:\n        #             queue.append((neighbor, level + 1))\n        # return sorted(res, key=lambda x: (-x[1], x))"
    },
    {
        "number": 1312,
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(s)\n        # if n == 0:\n        #     return 0\n        # dp = [[0 for _ in range(n)] for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if s[i] == s[j]:\n        #             dp[i][j] = dp[i + 1][j - 1]\n        #         else:\n        #             dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n        # return dp[0][n - 1]"
    },
    {
        "number": 1313,
        "title": "Decompress Run-Length Encoded List",
        "difficulty": 0,
        "answer": "        res = []\n        for i in range(0, len(nums), 2):\n            res += [nums[i+1]] * nums[i]\n        return res"
    },
    {
        "number": 1314,
        "title": "Matrix Block Sum",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] - dp[i][j] + mat[i][j]\n        res = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                r1, c1, r2, c2 = max(0, i - k), max(0, j - k), min(m, i + k + 1), min(n, j + k + 1)\n                res[i][j] = dp[r2][c2] - dp[r1][c2] - dp[r2][c1] + dp[r1][c1]\n        return res"
    },
    {
        "number": 1315,
        "title": "Sum of Nodes with Even-Valued Grandparent",
        "difficulty": 1,
        "answer": "        def dfs(node, parent, grandparent):\n            if not node:\n                return 0\n            if grandparent % 2 == 0:\n                return node.val + dfs(node.left, node, parent) + dfs(node.right, node, parent)\n            else:\n                return dfs(node.left, node, parent) + dfs(node.right, node, parent)"
    },
    {
        "number": 1316,
        "title": "Distinct Echo Substrings",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        # n = len(text)\n        # res = set()\n        # for i in range(n):\n        #     for j in range(i, n):\n        #         res.add(text[i:j+1])\n        # return len(res)"
    },
    {
        "number": 1317,
        "title": "Convert Integer to the Sum of Two No-Zero Integers",
        "difficulty": 0,
        "answer": "        for i in range(1, n):\n            if '0' not in str(i) and '0' not in str(n - i):\n                return [i, n - i]"
    },
    {
        "number": 1318,
        "title": "Minimum Flips to Make a OR b Equal to c",
        "difficulty": 1,
        "answer": "        # a, b, c = a ^ b, a ^ c, b ^ c\n        # a, b, c = a & b, a & c, b & c\n        # a, b, c = a | b, a | c, b | c\n        # a, b, c = ~a, ~b, ~c\n        # a, b, c = a ^ b, a ^ c, b ^ c\n        # a, b, c = a & b, a & c, b & c\n        # a, b, c = a | b, a | c, b | c\n        # a, b, c = ~a, ~b, ~c\n        # a, b, c = a ^ b, a ^ c, b ^ c\n        # a, b, c = a & b, a & c, b & c\n        # a, b, c = a | b, a | c, b | c\n        # a, b, c = ~a, ~b, ~c\n        # a, b, c = a ^ b, a ^ c, b ^ c"
    },
    {
        "number": 1319,
        "title": "Number of Operations to Make Network Connected",
        "difficulty": 1,
        "answer": "        if len(connections) < n - 1:\n            return -1\n        graph = collections.defaultdict(list)\n        for u, v in connections:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = set()\n        def dfs(node):\n            if node in visited:\n                return 0\n            visited.add(node)\n            for child in graph[node]:\n                dfs(child)\n            return 1\n        return sum(dfs(node) for node in range(n) if node not in visited) - 1"
    },
    {
        "number": 1320,
        "title": "Minimum Distance to Type a Word Using Two Fingers",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(word)\n        # if n == 1:\n        #     return 0\n        # dp = [[float('inf')] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 0\n        # for i in range(n - 1):\n        #     dp[i][i + 1] = abs(ord(word[i]) - ord(word[i + 1]))\n        # for length in range(3, n + 1):\n        #     for i in range(n - length + 1):\n        #         j = i + length - 1\n        #         for k in range(i, j):\n        #             dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + abs(ord(word[i]) - ord(word[j])))\n        # return dp[0][n - 1]"
    },
    {
        "number": 1323,
        "title": "Maximum 69 Number",
        "difficulty": 0,
        "answer": "        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':\n        #         num = num[:i] + '9' + num[i+1:]\n        #         break\n        # return int(num)\n        \n        # num = str(num)\n        # for i in range(len(num)):\n        #     if num[i] == '6':"
    },
    {
        "number": 1324,
        "title": "Print Words Vertically",
        "difficulty": 1,
        "answer": "        \n        s = s.split()\n        max_len = max([len(i) for i in s])\n        res = []\n        for i in range(max_len):\n            temp = []\n            for j in s:\n                if i < len(j):\n                    temp.append(j[i])\n                else:\n                    temp.append(' ')\n            res.append(''.join(temp).rstrip())\n        return res\n"
    },
    {
        "number": 1325,
        "title": "Delete Leaves With a Given Value",
        "difficulty": 1,
        "answer": "        if not root:\n            return None\n        root.left = self.removeLeafNodes(root.left, target)\n        root.right = self.removeLeafNodes(root.right, target)\n        if not root.left and not root.right and root.val == target:\n            return None\n        return root\n"
    },
    {
        "number": 1326,
        "title": "Minimum Number of Taps to Open to Water a Garden",
        "difficulty": 2,
        "answer": "        # dp[i] = min number of taps to water the interval [0, i]\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp[j] + 1) for all j in [0, i)\n        # dp[i] = min(dp["
    },
    {
        "number": 1328,
        "title": "Break a Palindrome",
        "difficulty": 1,
        "answer": "        if len(palindrome) == 1:\n            return \"\"\n        for i in range(len(palindrome)):\n            if palindrome[i]!= 'a':\n                return palindrome[:i] + 'a' + palindrome[i+1:]\n        return palindrome[:-1] + 'b'"
    },
    {
        "number": 1329,
        "title": "Sort the Matrix Diagonally",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            for j in range(n):\n                if i == j:\n                    mat[i][j] = sorted(mat[i][j:])\n                if i + j == m - 1:\n                    mat[i][j] = sorted(mat[i][j:])[::-1]\n        return mat"
    },
    {
        "number": 1330,
        "title": "Reverse Subarray To Maximize Array Value",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return abs(nums[0] - nums[1])\n        dp = [0] * n\n        dp[0] = abs(nums[0] - nums[1])\n        dp[1] = abs(nums[0] - nums[1]) + abs(nums[1] - nums[2])\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + abs(nums[i] - nums[i - 1]))\n        return dp[-1]"
    },
    {
        "number": 1331,
        "title": "Rank Transform of an Array",
        "difficulty": 0,
        "answer": "        # O(nlogn)\n        # arr.sort()\n        # rank = 1\n        # rank_dict = {}\n        # for i in range(len(arr)):\n        #     if arr[i] not in rank_dict:\n        #         rank_dict[arr[i]] = rank\n        #         rank += 1\n        #     arr[i] = rank_dict[arr[i]]\n        # return arr"
    },
    {
        "number": 1332,
        "title": "Remove Palindromic Subsequences",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        if s == s[::-1]:\n            return 1\n        return 2"
    },
    {
        "number": 1333,
        "title": "Filter Restaurants by Vegan-Friendly, Price and Distance",
        "difficulty": 1,
        "answer": "        # filter by veganFriendly\n        restaurants = filter(lambda x: x[2] == veganFriendly, restaurants)\n        # filter by price\n        restaurants = filter(lambda x: x[3] <= maxPrice, restaurants)\n        # filter by distance\n        restaurants = filter(lambda x: x[4] <= maxDistance, restaurants)\n        # sort by rating\n        restaurants = sorted(restaurants, key=lambda x: (-x[1], x[0]))\n        return [x[0] for x in restaurants]"
    },
    {
        "number": 1334,
        "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
        "difficulty": 1,
        "answer": "        # Dijkstra\n        # Time: O(ElogE), E is the number of edges\n        # Space: O(E)\n        import heapq\n        graph = collections.defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        # O(ElogE)\n        def dijkstra(src, distance):\n            pq = [(0, src)]\n            distance[src] = 0\n            while pq:\n                d, u = heapq.heappop(pq)\n                if d > distance[u]:\n                    continue\n                for v, w in graph[u]:\n                    if d + w < distance[v]:\n                        distance[v] = d + w\n                        heapq.heappush(pq, (d + w, v))\n        \n        # O(E)\n        distance = [float('inf')] * n\n        dijkstra(0, distance)\n        return distance.index(distanceThreshold"
    },
    {
        "number": 1335,
        "title": "Minimum Difficulty of a Job Schedule",
        "difficulty": 2,
        "answer": "        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        if n == d:\n            return sum(jobDifficulty)\n        dp = [[float('inf')] * n for _ in range(d)]\n        for i in range(n):\n            dp[0][i] = jobDifficulty[i]\n        for i in range(1, d):\n            for j in range(i, n):\n                for k in range(i - 1, j):\n                    dp[i][j] = min(dp[i][j], max(dp[i - 1][k], jobDifficulty[k]))\n        return dp[-1][-1]"
    },
    {
        "number": 1337,
        "title": "The K Weakest Rows in a Matrix",
        "difficulty": 0,
        "answer": "        soldiers = []\n        for row in mat:\n            soldiers.append(row.count(1))\n        soldiers.sort()\n        return [i for i in range(len(mat)) if soldiers[i] == soldiers[0]]"
    },
    {
        "number": 1338,
        "title": "Reduce Array Size to The Half",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        count = Counter(arr)\n        count = sorted(count.items(), key=lambda x: x[1], reverse=True)\n        total = len(arr)\n        i = 0\n        while total > 0:\n            total -= count[i][1]\n            i += 1\n        return i"
    },
    {
        "number": 1339,
        "title": "Maximum Product of Splitted Binary Tree",
        "difficulty": 1,
        "answer": "        self.ans = 0\n        self.dfs(root)\n        return self.ans % (10 ** 9 + 7)"
    },
    {
        "number": 1340,
        "title": "Jump Game V",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i], dp[j] + 1) for all j in [0, i) if arr[i] > arr[j] and arr[i] > arr[k] for all k in [j, i)\n        # dp[i] = max(dp[i], dp[j] + 1) for all j in [0, i) if arr[i] > arr[j]\n        # dp[i] = max(dp[i], dp[j] + 1) for all j in [0, i) if arr[i] > arr[j] and arr[i] > arr[k] for all k in [j, i)\n        # dp[i] = max(dp[i], dp[j] + 1) for all j in [0, i) if arr[i] > arr[j] and arr[i] > arr[k] for all k in [j, i)\n        # dp[i] = max(dp[i], dp[j] + 1) for all j"
    },
    {
        "number": 1342,
        "title": "Number of Steps to Reduce a Number to Zero",
        "difficulty": 0,
        "answer": "        count = 0\n        while num!= 0:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = num - 1\n            count += 1\n        return count"
    },
    {
        "number": 1343,
        "title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
        "difficulty": 1,
        "answer": "        # sliding window\n        # time complexity: O(n)\n        # space complexity: O(1)\n        res = 0\n        left = 0\n        right = 0\n        sum_ = 0\n        while right < len(arr):\n            sum_ += arr[right]\n            right += 1\n            if right - left >= k:\n                sum_ -= arr[left]\n                left += 1\n            if sum_ / k >= threshold:\n                res += 1\n        return res"
    },
    {
        "number": 1344,
        "title": "Angle Between Hands of a Clock",
        "difficulty": 1,
        "answer": "        # hour = 12, minutes = 30\n        # hour = 3, minutes = 30\n        # hour = 3, minutes = 15\n        # hour = 12, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 3, minutes = 30\n        # hour = 3, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 12, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 3, minutes = 30\n        # hour = 3, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 12, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 3, minutes = 30\n        # hour = 3, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 12, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 3, minutes = 30\n        # hour = 3, minutes = 15\n        # hour = 12, minutes = 30\n        # hour = 12, minutes = 15\n        # hour = 12, minutes = 30\n"
    },
    {
        "number": 1345,
        "title": "Jump Game IV",
        "difficulty": 2,
        "answer": "        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k]) + 1\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k])\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k])\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k]) + 1\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k]) + 1\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k]) + 1\n        # dp[i] = min(dp[i+1], dp[i+2],..., dp[i+k]) + 1\n        # dp[i] = min"
    },
    {
        "number": 1346,
        "title": "Check If N and Its Double Exist",
        "difficulty": 0,
        "answer": "        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] == 2 * arr[j] or arr[j] == 2 * arr[i]:\n                    return True\n        return False\n"
    },
    {
        "number": 1347,
        "title": "Minimum Number of Steps to Make Two Strings Anagram",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        for c in t:\n            count[ord(c) - ord('a')] -= 1\n        return sum(count)"
    },
    {
        "number": 1348,
        "title": "Tweet Counts Per Frequency",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1349,
        "title": "Maximum Students Taking Exam",
        "difficulty": 2,
        "answer": "        \n        # dfs\n        # time O(m*n)\n        # space O(m*n)\n        \n        def dfs(i, j, seats, visited):\n            if i < 0 or i >= len(seats) or j < 0 or j >= len(seats[0]) or seats[i][j] == '#' or (i, j) in visited:\n                return 0\n            visited.add((i, j))\n            return 1 + dfs(i+1, j, seats, visited) + dfs(i-1, j, seats, visited) + dfs(i, j+1, seats, visited) + dfs(i, j-1, seats, visited)\n        \n        res = 0\n        for i in range(len(seats)):\n            for j in range(len(seats[0])):\n                if seats[i][j] == '.':\n                    res = max(res, dfs(i, j, seats, set()))\n        return res"
    },
    {
        "number": 1351,
        "title": "Count Negative Numbers in a Sorted Matrix",
        "difficulty": 0,
        "answer": "        # Time: O(m*n)\n        # Space: O(1)\n        # m, n = len(grid), len(grid[0])\n        # count = 0\n        # for i in range(m):\n        #     for j in range(n):\n        #         if grid[i][j] < 0:\n        #             count += n - j\n        #             break\n        # return count"
    },
    {
        "number": 1352,
        "title": "Product of the Last K Numbers",
        "difficulty": 1,
        "answer": "        self.nums = [num]\n        if k == 1:\n            return num\n        if k == len(self.nums):\n            return self.nums[-1]\n        if k > len(self.nums):\n            return 0\n        return self.nums[-1] * self.getProduct(k)"
    },
    {
        "number": 1353,
        "title": "Maximum Number of Events That Can Be Attended",
        "difficulty": 1,
        "answer": "        events.sort(key=lambda x: x[0])\n        events.sort(key=lambda x: x[1])\n        i = 0\n        j = 0\n        res = 0\n        while i < len(events) and j < len(events):\n            if events[j][0] >= events[i][1]:\n                res += 1\n                i += 1\n            else:\n                j += 1\n        return res"
    },
    {
        "number": 1354,
        "title": "Construct Target Array With Multiple Sums",
        "difficulty": 2,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[i-1] + nums[i]\n        # dp[i] = dp[i-1] + nums[i] - dp[i-1]\n        # dp[i] = dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1]\n        # dp[i] = dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] - dp[i-1] + nums[i] -"
    },
    {
        "number": 1356,
        "title": "Sort Integers by The Number of 1 Bits",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1357,
        "title": "Apply Discount Every n Orders",
        "difficulty": 1,
        "answer": "        discount = discount / 100\n        res = 0\n        for i in range(len(product)):\n            res += amount[i] * (prices[i] * (1 - discount))\n        return res"
    },
    {
        "number": 1358,
        "title": "Number of Substrings Containing All Three Characters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == 'a':\n        #         count += 1\n        #     elif s[i] == 'b':\n        #         count += 1\n        #     elif s[i] == 'c':\n        #         count += 1\n        #     if count == 3:\n        #         break\n        # return count\n        \n        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] == 'a':\n        #         count += 1\n        #     elif s[i] == 'b':\n        #         count += 1\n        #     elif s[i] == 'c':\n        #         count += 1\n        #     if count == 3:\n        #         break\n        # return count\n        \n        # Time: O(n)\n        "
    },
    {
        "number": 1359,
        "title": "Count All Valid Pickup and Delivery Options",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n            dp[i] %= MOD\n        return dp[n]"
    },
    {
        "number": 1360,
        "title": "Number of Days Between Two Dates",
        "difficulty": 0,
        "answer": "        def is_leap_year(year):\n            if year % 4 == 0:\n                if year % 100 == 0:\n                    if year % 400 == 0:\n                        return True\n                    else:\n                        return False\n                else:\n                    return True\n            else:\n                return False"
    },
    {
        "number": 1361,
        "title": "Validate Binary Tree Nodes",
        "difficulty": 1,
        "answer": "        # root = 0\n        # root_left = 1\n        # root_right = 2\n        # root_left_left = 3\n        # root_left_right = 4\n        # root_right_left = 5\n        # root_right_right = 6\n        # root_left_left_left = 7\n        # root_left_left_right = 8\n        # root_left_right_left = 9\n        # root_left_right_right = 10\n        # root_right_left_left = 11\n        # root_right_left_right = 12\n        # root_right_right_left = 13\n        # root_right_right_right = 14\n        # root_left_left_left_left = 15\n        # root_left_left_left_right = 16\n        # root_left_left_right_left = 17\n        # root_left_left_right_right = 18\n        # root_left_right_left_left = 19\n        # root_left_right_left_right = 20\n        # root_left_right_"
    },
    {
        "number": 1362,
        "title": "Closest Divisors",
        "difficulty": 1,
        "answer": "        if num == 1:\n            return [1, 1]\n        if num == 2:\n            return [1, 2]\n        if num == 3:\n            return [2, 3]\n        if num == 4:\n            return [2, 4]\n        if num == 5:\n            return [5, 5]\n        if num == 6:\n            return [3, 6]\n        if num == 7:\n            return [7, 7]\n        if num == 8:\n            return [3, 3]\n        if num == 9:\n            return [3, 6]\n        if num == 10:\n            return [2, 5]\n        if num == 11:\n            return [11, 11]\n        if num == 12:\n            return [2, 6]\n        if num == 13:\n            return [13, 13]\n        if num == 14:\n            return [2, 7]\n        if num == 15:\n            return [3, 8]\n        if num == 16:\n            return [4, 8]\n        if num == 17:\n            return ["
    },
    {
        "number": 1363,
        "title": "Largest Multiple of Three",
        "difficulty": 2,
        "answer": "        digits.sort(reverse=True)\n        if sum(digits) % 3 == 0:\n            return ''.join([str(i) for i in digits])\n        elif sum(digits) % 3 == 1:\n            if digits[0] % 3 == 1:\n                return ''.join([str(i) for i in digits[1:]]) + '1'\n            elif digits[0] % 3 == 2:\n                return ''.join([str(i) for i in digits[2:]]) + '2'\n        elif sum(digits) % 3 == 2:\n            if digits[0] % 3 == 2:\n                return ''.join([str(i) for i in digits[1:]]) + '2'\n            elif digits[0] % 3 == 1:\n                return ''.join([str(i) for i in digits[2:]]) + '1'\n        return ''"
    },
    {
        "number": 1365,
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1366,
        "title": "Rank Teams by Votes",
        "difficulty": 1,
        "answer": "        # 1. \u627e\u51fa\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u627e\u51fa\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u7684\u90a3\u4e2a\u5b57\u6bcd\n        # 3. \u627e\u51fa\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u7684\u90a3\u4e2a\u5b57\u6bcd\u7684\u7d22\u5f15\n        # 4. \u627e\u51fa\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u7684\u90a3\u4e2a\u5b57\u6bcd\u7684\u7d22\u5f15\u6700\u5927\u7684\u90a3\u4e2a\u5b57\u6bcd\n        # 5. \u627e\u51fa\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\u7684\u90a3\u4e2a\u5b57\u6bcd\u7684\u7d22\u5f15\u6700\u5927\u7684"
    },
    {
        "number": 1367,
        "title": "Linked List in Binary Tree",
        "difficulty": 1,
        "answer": "        if not head:\n            return True\n        if not root:\n            return False\n        if self.isSubPath(head, root.left) or self.isSubPath(head, root.right):\n            return True\n        if head.val == root.val:\n            return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n        return False"
    },
    {
        "number": 1368,
        "title": "Minimum Cost to Make at Least One Valid Path in a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j])\n        return dp[-1][-1]"
    },
    {
        "number": 1370,
        "title": "Increasing Decreasing String",
        "difficulty": 0,
        "answer": "        s = list(s)\n        s.sort()\n        result = []\n        while len(s) > 0:\n            for i in range(len(s)):\n                if s[i] not in result:\n                    result.append(s[i])\n                    s.pop(i)\n                    break\n            for i in range(len(s)):\n                if s[i] > result[-1]:\n                    result.append(s[i])\n                    s.pop(i)\n                    break\n            for i in range(len(s)):\n                if s[i] < result[0]:\n                    result.insert(0, s[i])\n                    s.pop(i)\n                    break\n        return ''.join(result)"
    },
    {
        "number": 1371,
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "difficulty": 1,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u'])\n        seen = {}\n        max_len = 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                seen[c] = seen.get(c, 0) + 1\n                max_len = max(max_len, i + 1)\n                while seen[c] % 2 == 0:\n                    seen[c] = seen.get(c, 0) - 1\n                    max_len = max(max_len, i + 1)\n        return max_len"
    },
    {
        "number": 1372,
        "title": "Longest ZigZag Path in a Binary Tree",
        "difficulty": 1,
        "answer": "        self.max_len = 0\n        self.helper(root)\n        return self.max_len"
    },
    {
        "number": 1373,
        "title": "Maximum Sum BST in Binary Tree",
        "difficulty": 2,
        "answer": "        self.max_sum = 0\n        self.helper(root)\n        return self.max_sum"
    },
    {
        "number": 1374,
        "title": "Generate a String With Characters That Have Odd Counts",
        "difficulty": 0,
        "answer": "        if n % 2 == 0:\n            return \"a\" * (n - 1) + \"b\"\n        else:\n            return \"a\" * n"
    },
    {
        "number": 1375,
        "title": "Number of Times Binary String Is Prefix-Aligned",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # n = len(flips)\n        # res = 0\n        # curr = 0\n        # for i in range(n):\n        #     curr ^= flips[i]\n        #     if curr == 0:\n        #         res += 1\n        # return res"
    },
    {
        "number": 1376,
        "title": "Time Needed to Inform All Employees",
        "difficulty": 1,
        "answer": "        self.graph = {}\n        for i in range(n):\n            self.graph[i] = []\n        for i in range(n):\n            if manager[i]!= -1:\n                self.graph[manager[i]].append(i)\n        self.res = 0\n        self.dfs(headID, informTime)\n        return self.res"
    },
    {
        "number": 1377,
        "title": "Frog Position After T Seconds",
        "difficulty": 2,
        "answer": "        # dfs\n        # time O(V+E) space O(V+E)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # visited = set()\n        # def dfs(node, t):\n        #     if node == target:\n        #         return True\n        #     if t <= 0:\n        #         return False\n        #     visited.add(node)\n        #     for neighbor in graph[node]:\n        #         if neighbor not in visited:\n        #             if dfs(neighbor, t-1):\n        #                 return True\n        #     return False\n        # return dfs(1, t) / 6"
    },
    {
        "number": 1379,
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "difficulty": 0,
        "answer": "        if not original:\n            return None\n        if original == target:\n            return cloned\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)"
    },
    {
        "number": 1380,
        "title": "Lucky Numbers in a Matrix",
        "difficulty": 0,
        "answer": "        \n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # m = len(matrix)\n        # n = len(matrix[0])\n        # lucky_numbers = []\n        # for i in range(m):\n        #     min_row = min(matrix[i])\n        #     max_col = max([matrix[j][i] for j in range(m)])\n        #     if min_row == max_col:\n        #         lucky_numbers.append(min_row)\n        # return lucky_numbers\n        \n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # m = len(matrix)\n        # n = len(matrix[0])\n        # lucky_numbers = []\n        # for i in range(m):\n        #     min_row = min(matrix[i])\n        #     max_col = max([matrix[j][i] for j in range(m)])"
    },
    {
        "number": 1381,
        "title": "Design a Stack With Increment Operation",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1382,
        "title": "Balance a Binary Search Tree",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return None, 0\n            left, left_depth = dfs(node.left)\n            right, right_depth = dfs(node.right)\n            if left_depth == right_depth:\n                return node, left_depth + 1\n            elif left_depth > right_depth:\n                return left, left_depth + 1\n            else:\n                return right, right_depth + 1\n        return dfs(root)[0]\n"
    },
    {
        "number": 1383,
        "title": "Maximum Performance of a Team",
        "difficulty": 2,
        "answer": "        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u6309\u7167efficiency\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5927\u7684k\u4e2a\uff0c\ufffd"
    },
    {
        "number": 1385,
        "title": "Find the Distance Value Between Two Arrays",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # arr1 = [4,5,8]\n        # arr2 = [10,9,1,8]\n        # d = 2\n        # arr1 = [1,4,2,3]\n        # arr2 = [-4,-3,6,10,20,30]\n        # d = 3\n        # arr1 = [2,1,100,3]\n        # arr2 = [-5,-2,10,-3,7]\n        # d = 6\n        # arr1 = [1,4,2,3]\n        # arr2 = [-5,-2,10,-3,7]\n        # d = 6\n        # arr1 = [1,4,2,3]\n        # arr2 = [-5,-2,10,-3,7]\n        # d = 6\n        # arr1 = [1,4,2,3]\n        # arr2 = [-5,-2,10,-3,7]\n        # d = 6\n        # arr1 = [1,4,"
    },
    {
        "number": 1386,
        "title": "Cinema Seat Allocation",
        "difficulty": 1,
        "answer": "        res = 0\n        for i in range(n):\n            row = [0] * 10\n            for j in reservedSeats:\n                if j[0] == i + 1:\n                    row[j[1] - 1] = 1\n            for j in range(1, 9):\n                if row[j] == 0 and row[j - 1] == 0 and row[j + 1] == 0:\n                    res += 1\n        return res"
    },
    {
        "number": 1387,
        "title": "Sort Integers by The Power Value",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # O(nlog(n))\n        # power = [0] * (hi - lo + 1)\n        # for i in range(lo, hi + 1):\n        #     power[i - lo] = self.get_power(i)\n        # power.sort()\n        # return power[k - 1]"
    },
    {
        "number": 1388,
        "title": "Pizza With 3n Slices",
        "difficulty": 2,
        "answer": "        n = len(slices)\n        dp = [[0] * n for _ in range(n)]\n        for d in range(1, n):\n            for i in range(n - d):\n                j = i + d\n                dp[i][j] = max(slices[i] + min(dp[i + 1][j], dp[i][j - 1]), slices[j] + min(dp[i + 1][j - 1], dp[i][j - 1]))\n        return dp[0][n - 1]"
    },
    {
        "number": 1389,
        "title": "Create Target Array in the Given Order",
        "difficulty": 0,
        "answer": "        target = []\n        for i in range(len(nums)):\n            target.insert(index[i], nums[i])\n        return target"
    },
    {
        "number": 1390,
        "title": "Four Divisors",
        "difficulty": 1,
        "answer": "        \n        # nums = [21,4,7]\n        # nums = [21,21]\n        # nums = [1,2,3,4,5]\n        \n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,"
    },
    {
        "number": 1391,
        "title": "Check if There is a Valid Path in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return True\n        if m == 1:\n            return False\n        if n == 1:\n            return False\n        \n        def dfs(i, j, visited):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return False\n            if grid[i][j] == 1:\n                return True\n            if (i, j) in visited:\n                return False\n            visited.add((i, j))\n            if dfs(i + 1, j, visited):\n                return True\n            if dfs(i - 1, j, visited):\n                return True\n            if dfs(i, j + 1, visited):\n                return True\n            if dfs(i, j - 1, visited):\n                return True\n            return False\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if dfs(i, j, set"
    },
    {
        "number": 1392,
        "title": "Longest Happy Prefix",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 0:\n            return \"\"\n        if n == 1:\n            return s\n        # dp[i] = longest prefix ending at i\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if s[j] == s[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return s[:dp[n - 1]]"
    },
    {
        "number": 1394,
        "title": "Find Lucky Integer in an Array",
        "difficulty": 0,
        "answer": "        d = {}\n        for i in arr:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        l = []\n        for i in d:\n            if i == d[i]:\n                l.append(i)\n        if len(l) == 0:\n            return -1\n        else:\n            return max(l)\n"
    },
    {
        "number": 1395,
        "title": "Count Number of Teams",
        "difficulty": 1,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # count = 0\n        # for i in range(len(rating)):\n        #     for j in range(i+1, len(rating)):\n        #         for k in range(j+1, len(rating)):\n        #             if rating[i] < rating[j] < rating[k]:\n        #                 count += 1\n        #             elif rating[i] > rating[j] > rating[k]:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 1396,
        "title": "Design Underground System",
        "difficulty": 1,
        "answer": "        self.id = id\n        self.stationName = stationName\n        self.time = t\n        self.in_station = {}\n        self.out_station = {}\n        self.in_station[stationName] = [t]\n        self.out_station[stationName] = [t]\n        self.total_time = {}\n        self.total_time[stationName] = [t]"
    },
    {
        "number": 1397,
        "title": "Find All Good Strings",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i"
    },
    {
        "number": 1399,
        "title": "Count Largest Group",
        "difficulty": 0,
        "answer": "        d = {}\n        for i in range(1, n + 1):\n            s = sum(map(int, str(i)))\n            d[s] = d.get(s, 0) + 1\n        return max(d.values())"
    },
    {
        "number": 1400,
        "title": "Construct K Palindrome Strings",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return True\n        if len(s) < k:\n            return False\n        if len(s) == k:\n            return True\n        if len(s) == k - 1:\n            return s[0] == s[-1]\n        if len(s) == k - 2:\n            return s[0] == s[-1] and s[1] == s[-2]\n        if len(s) == k - 3:\n            return s[0] == s[-1] and s[1] == s[-2] and s[2] == s[-3]\n        if len(s) == k - 4:\n            return s[0] == s[-1] and s[1] == s[-2] and s[2] == s[-3] and s[3] == s[-4]\n        if len(s) == k - 5:\n            return s[0] == s[-1] and s[1] == s[-2] and s[2] == s[-3"
    },
    {
        "number": 1401,
        "title": "Circle and Rectangle Overlapping",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # return (x1 - xCenter) ** 2 + (y1 - yCenter) ** 2 <= radius ** 2 and (x2 - xCenter) ** 2 + (y2 - yCenter) ** 2 <= radius ** 2"
    },
    {
        "number": 1402,
        "title": "Reducing Dishes",
        "difficulty": 2,
        "answer": "        satisfaction.sort()\n        satisfaction.reverse()\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction.append(0)\n        satisfaction"
    },
    {
        "number": 1403,
        "title": "Minimum Subsequence in Non-Increasing Order",
        "difficulty": 0,
        "answer": "        nums.sort(reverse=True)\n        s = sum(nums)\n        res = []\n        for i in range(len(nums)):\n            if sum(res) + nums[i] <= s:\n                res.append(nums[i])\n        return res\n"
    },
    {
        "number": 1404,
        "title": "Number of Steps to Reduce a Number in Binary Representation to One",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # s = \"1101\"\n        # s = \"10\"\n        # s = \"1\"\n        # s = \"11101\"\n        # s = \"101010\"\n        # s = \"1110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101111011110111101"
    },
    {
        "number": 1405,
        "title": "Longest Happy String",
        "difficulty": 1,
        "answer": "        if a + b + c == 0:\n            return \"\"\n        if a == 0 and b == 0 and c == 0:\n            return \"\"\n        if a == 0 and b == 0:\n            return \"c\" * c\n        if a == 0 and c == 0:\n            return \"b\" * b\n        if b == 0 and c == 0:\n            return \"a\" * a\n        if a == 0:\n            return \"b\" * b + \"c\" * c\n        if b == 0:\n            return \"a\" * a + \"c\" * c\n        if c == 0:\n            return \"a\" * a + \"b\" * b\n        if a == 1:\n            return \"a\" * a + self.longestDiverseString(a - 1, b, c)\n        if b == 1:\n            return \"b\" * b + self.longestDiverseString(a, b - 1, c)\n        if c == 1:\n            return \"c\" * c + self.longestDiverseString(a, b, c - 1)\n"
    },
    {
        "number": 1406,
        "title": "Stone Game III",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i][0] = stoneValue[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j][0] = max(dp[i][j][0], dp[i][k][0] + dp[k][j][0] for k in range(i + 1, j))\n                dp[i][j][1] = min(dp[i][j][1], dp[i][k][1] + dp[k][j][1] for k in range(i + 1, j))\n        if dp[0][n - 1][0] > 0:\n            return \"Alice\"\n        elif dp[0][n - 1][0] < 0:\n            return \"Bob\"\n        else:\n            return \"Tie\""
    },
    {
        "number": 1408,
        "title": "String Matching in an Array",
        "difficulty": 0,
        "answer": "        # O(n^2)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O"
    },
    {
        "number": 1409,
        "title": "Queries on a Permutation With Key",
        "difficulty": 1,
        "answer": "        # Time: O(n), n is the length of queries\n        # Space: O(n)\n        # P = [i for i in range(1, m+1)]\n        # res = []\n        # for q in queries:\n        #     res.append(P.index(q))\n        #     P.insert(0, P.pop(P.index(q)))\n        # return res"
    },
    {
        "number": 1410,
        "title": "HTML Entity Parser",
        "difficulty": 1,
        "answer": "        d = {\n            '&quot;': '\"',\n            '&apos;': \"'\",\n            '&amp;': '&',\n            '&gt;': '>',\n            '&lt;': '<',\n            '&frasl;': '/'\n        }\n        for k, v in d.items():\n            text = text.replace(k, v)\n        return text"
    },
    {
        "number": 1411,
        "title": "Number of Ways to Paint N \u00d7 3 Grid",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = (dp[i - 1] * 3) % MOD\n            if i >= 2:\n                dp[i] = (dp[i] + dp[i - 2]) % MOD\n        return dp[n]"
    },
    {
        "number": 1413,
        "title": "Minimum Value to Get Positive Step by Step Sum",
        "difficulty": 0,
        "answer": "        if not nums:\n            return 0\n        \n        min_val = 1\n        total = 0\n        for num in nums:\n            total += num\n            min_val = min(min_val, total)\n        \n        return abs(min_val) + 1"
    },
    {
        "number": 1414,
        "title": "Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
        "difficulty": 1,
        "answer": "        fib = [1, 1]\n        while fib[-1] < k:\n            fib.append(fib[-1] + fib[-2])\n        return sum(fib[:bisect.bisect(fib, k)])"
    },
    {
        "number": 1415,
        "title": "The k-th Lexicographical String of All Happy Strings of Length n",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 'c'\n        if k == 1:\n            return 'a'\n        if k == 2:\n            return 'b'\n        if k == 3:\n            return 'c'\n        if k == 4:\n            return ''\n        if k == 5:\n            return 'a'\n        if k == 6:\n            return 'b'\n        if k == 7:\n            return 'c'\n        if k == 8:\n            return 'a'\n        if k == 9:\n            return 'b'\n        if k == 10:\n            return 'c'\n        if k == 11:\n            return 'a'\n        if k == 12:\n            return 'b'\n        if k == 13:\n            return 'c'\n        if k == 14:\n            return 'a'\n        if k == 15:\n            return 'b'\n        if k == 16:\n            return 'c'\n        if k == 17:\n            return 'a'\n        if k == 18:\n            return 'b'\n        if k == 19"
    },
    {
        "number": 1416,
        "title": "Restore The Array",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if int(s[j:i]) <= k:\n                    dp[i] += dp[j]\n        return dp[n] % (10 ** 9 + 7)"
    },
    {
        "number": 1417,
        "title": "Reformat The String",
        "difficulty": 0,
        "answer": "        letters = []\n        digits = []\n        for c in s:\n            if c.isalpha():\n                letters.append(c)\n            else:\n                digits.append(c)\n        if abs(len(letters) - len(digits)) > 1:\n            return \"\"\n        if len(letters) > len(digits):\n            letters, digits = digits, letters\n        res = []\n        while letters or digits:\n            if letters:\n                res.append(letters.pop(0))\n            if digits:\n                res.append(digits.pop(0))\n        return \"\".join(res)"
    },
    {
        "number": 1418,
        "title": "Display Table of Food Orders in a Restaurant",
        "difficulty": 1,
        "answer": "        \n        foods = set()\n        tables = set()\n        \n        for _, table, food in orders:\n            tables.add(table)\n            foods.add(food)\n        \n        foods = sorted(list(foods))\n        tables = sorted(list(tables))\n        \n        table_foods = {}\n        \n        for table in tables:\n            table_foods[table] = {}\n            for food in foods:\n                table_foods[table][food] = 0\n        \n        for _, table, food in orders:\n            table_foods[table][food] += 1\n        \n        res = [['Table'] + foods]\n        \n        for table in tables:\n            row = [table]\n            for food in foods:\n                row.append(str(table_foods[table][food]))\n            res.append(row)\n        \n        return res\n\r\n    def displayTable_1(self, orders: List[List[str]]) -> List[List[str]]:\n        \"\"\"\n        "
    },
    {
        "number": 1419,
        "title": "Minimum Number of Frogs Croaking",
        "difficulty": 1,
        "answer": "        if len(croakOfFrogs) % 5!= 0:\n            return -1\n        \n        c, r, o, a, k = 0, 0, 0, 0, 0\n        for i in range(len(croakOfFrogs)):\n            if croakOfFrogs[i] == 'c':\n                c += 1\n            elif croakOfFrogs[i] == 'r':\n                r += 1\n            elif croakOfFrogs[i] == 'o':\n                o += 1\n            elif croakOfFrogs[i] == 'a':\n                a += 1\n            elif croakOfFrogs[i] == 'k':\n                k += 1\n            else:\n                return -1\n            \n            if c < r or r < o or o < a or a < k:\n                return -1\n        \n        return len(croakOfFrogs) // 5\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1420,
        "title": "Build Array Where You Can Find The Maximum Exactly K Comparisons",
        "difficulty": 2,
        "answer": "        mod = 10**9 + 7\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(m + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j - 1 >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod\n                if j - k >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod\n        return dp[n][m]"
    },
    {
        "number": 1422,
        "title": "Maximum Score After Splitting a String",
        "difficulty": 0,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[i:j+1].count('0'))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[i:j+1].count('1'))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[i:j+1].count('0') + s[i:j+1].count('1'))\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[i:j+1].count('0') + s[i:j+1].count('1'))\n        # dp[i][j] = max(dp[i][j], dp[i][k"
    },
    {
        "number": 1423,
        "title": "Maximum Points You Can Obtain from Cards",
        "difficulty": 1,
        "answer": "        n = len(cardPoints)\n        if k >= n:\n            return sum(cardPoints)\n        left_sum = [0] * n\n        right_sum = [0] * n\n        left_sum[0] = cardPoints[0]\n        right_sum[-1] = cardPoints[-1]\n        for i in range(1, n):\n            left_sum[i] = left_sum[i - 1] + cardPoints[i]\n        for i in range(n - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + cardPoints[i]\n        res = 0\n        for i in range(k):\n            res = max(res, left_sum[i] + right_sum[k - i - 1])\n        return res"
    },
    {
        "number": 1424,
        "title": "Diagonal Traverse II",
        "difficulty": 1,
        "answer": "        if not nums:\n            return []\n        m, n = len(nums), len(nums[0])\n        if m == 1:\n            return nums[0]\n        if n == 1:\n            return [row[0] for row in nums]\n        res = []\n        for i in range(m):\n            res.append(nums[i][0])\n        for i in range(1, n):\n            res.append(nums[m - 1][i])\n        for i in range(m - 2, -1, -1):\n            res.append(nums[i][n - 1])\n        for i in range(n - 2, 0, -1):\n            res.append(nums[0][i])\n        return res"
    },
    {
        "number": 1425,
        "title": "Constrained Subsequence Sum",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1], nums[i], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], nums[i], dp[i-2] + nums[i], nums[i] + dp[i-k])\n        # dp[i] = max(dp[i-1], nums[i], dp[i-2] + nums[i], nums[i] + dp[i-k], nums[i] + dp[i-k-1])\n        # dp[i] = max(dp[i-1], num"
    },
    {
        "number": 1431,
        "title": "Kids With the Greatest Number of Candies",
        "difficulty": 0,
        "answer": "        greatest = max(candies)\n        return [greatest + extraCandies >= i for i in candies]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1432,
        "title": "Max Difference You Can Get From Changing an Integer",
        "difficulty": 1,
        "answer": "        a, b = str(num), str(num)\n        for i in range(2):\n            x = str(random.randint(0, 9))\n            y = x if x!= x[0] else str(random.randint(1, 9))\n            while y == x:\n                y = str(random.randint(1, 9))\n            a = a.replace(x, y)\n            b = b.replace(x, y)\n        return int(max(a, b)) - int(min(a, b))"
    },
    {
        "number": 1433,
        "title": "Check If a String Can Break Another String",
        "difficulty": 1,
        "answer": "        s1 = sorted(s1)\n        s2 = sorted(s2)\n        for i in range(len(s1)):\n            if s1[i] < s2[i]:\n                return False\n        return True"
    },
    {
        "number": 1434,
        "title": "Number of Ways to Wear Different Hats to Each Other",
        "difficulty": 2,
        "answer": "        # 1. \u627e\u51fa\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\n        # 2. \u627e\u51fa\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\n        # 3. \u627e\u51fa\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\n        # 4. \u627e\u51fa\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\n        # 5. \u627e\u51fa\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684\u7b26\u5408\u6761\u4ef6\u7684hat\u7684"
    },
    {
        "number": 1436,
        "title": "Destination City",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1437,
        "title": "Check If All 1\"s Are at Least Length K Places Away",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # for i in range(len(nums)):\n        #     if nums[i] == 1:\n        #         for j in range(i+1, len(nums)):\n        #             if nums[j] == 1:\n        #                 if j - i < k:\n        #                     return False\n        # return True"
    },
    {
        "number": 1438,
        "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # monotonic queue\n        # https://leetcode.com/problems/longest-subarray-with-sum-at-least-a-given-value/discuss/109824/Python-O(n)-time-O(1)-space-Monotonic-Queue\n        # https://leetcode.com/problems/longest-subarray-with-sum-at-least-a-given-value/discuss/109824/Python-O(n)-time-O(1)-space-Monotonic-Queue\n        # https://leetcode.com/problems/longest-subarray-with-sum-at-least-a-given-value/discuss/109824/Python-O(n)-time-O(1)-space-Monotonic-Queue\n        # https://leetcode.com/problems/longest-subarray-with-sum-at-least-a-given-value/discuss/109824/Python"
    },
    {
        "number": 1439,
        "title": "Find the Kth Smallest Sum of a Matrix With Sorted Rows",
        "difficulty": 2,
        "answer": "        # Time: O(m * log(m * n)), space: O(m * n)\n        # m: number of rows, n: number of columns\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m * log(m * n)\n        # m * log(m * n) = m *"
    },
    {
        "number": 1441,
        "title": "Build an Array With Stack Operations",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # stack = []\n        # for i in range(1, n+1):\n        #     if i not in target:\n        #         stack.append(\"Push\")\n        #         stack.append(\"Pop\")\n        #     else:\n        #         while stack and stack[-1]!= \"Push\" and stack[-1]!= \"Pop\" and stack[-1]!= i:\n        #             stack.pop()\n        #         if stack and stack[-1] == i:\n        #             stack.pop()\n        #         else:\n        #             stack.append(\"Push\")\n        #             stack.append(\"Pop\")\n        # return stack\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # stack = []\n        # for i in range(1, n+1):\n        #     if i not in target:\n        #         stack.append(\"Push\")\n        #         stack.append(\"Pop\")\n        #     "
    },
    {
        "number": 1442,
        "title": "Count Triplets That Can Form Two Arrays of Equal XOR",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        cnt = Counter()\n        ans = 0\n        for x in arr:\n            ans += cnt[x]\n            cnt[x ^ x >> 1] += 1\n        return ans"
    },
    {
        "number": 1443,
        "title": "Minimum Time to Collect All Apples in a Tree",
        "difficulty": 1,
        "answer": "        # dfs\n        # time: O(n)\n        # space: O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # visited = [False] * n\n        # def dfs(node):\n        #     if visited[node]:\n        #         return 0\n        #     visited[node] = True\n        #     ret = 1\n        #     for child in graph[node]:\n        #         ret = min(ret, dfs(child) + 1)\n        #     return ret\n        # return dfs(0)"
    },
    {
        "number": 1444,
        "title": "Number of Ways of Cutting a Pizza",
        "difficulty": 2,
        "answer": "        m, n = len(pizza), len(pizza[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[0][1] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if pizza[i - 1][j - 1] == 'A':\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j] - dp[i - 1][j - 1]\n        return dp[-1][-1] % (10 ** 9 + 7)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1446,
        "title": "Consecutive Characters",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        max_power = 1\n        curr_power = 1\n        prev_char = s[0]\n        for i in range(1, len(s)):\n            if s[i] == prev_char:\n                curr_power += 1\n            else:\n                prev_char = s[i]\n                curr_power = 1\n            max_power = max(max_power, curr_power)\n        return max_power"
    },
    {
        "number": 1447,
        "title": "Simplified Fractions",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if j == 1:\n                    res.append(str(j) + \"/\" + str(i))\n                elif j == i:\n                    continue\n                elif j * i == i:\n                    res.append(str(j) + \"/\" + str(i))\n                elif j * i < i:\n                    res.append(str(j) + \"/\" + str(i))\n                    break\n                else:\n                    continue\n        return res"
    },
    {
        "number": 1448,
        "title": "Count Good Nodes in Binary Tree",
        "difficulty": 1,
        "answer": "        self.count = 0\n        self.helper(root, float('-inf'))\n        return self.count"
    },
    {
        "number": 1449,
        "title": "Form Largest Integer With Digits That Add up to Target",
        "difficulty": 2,
        "answer": "        dp = [float('inf')] * (target + 1)\n        dp[0] = 0\n        for c in cost:\n            for i in range(c, target + 1):\n                dp[i] = min(dp[i], dp[i - c] + 1)\n        return str(dp[-1]) if dp[-1]!= float('inf') else '0'"
    },
    {
        "number": 1450,
        "title": "Number of Students Doing Homework at a Given Time",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(startTime)):\n            if startTime[i] <= queryTime <= endTime[i]:\n                count += 1\n        return count"
    },
    {
        "number": 1451,
        "title": "Rearrange Words in a Sentence",
        "difficulty": 1,
        "answer": "        words = text.split()\n        words.sort(key=len)\n        return''.join(words)"
    },
    {
        "number": 1452,
        "title": "People Whose List of Favorite Companies Is Not a Subset of Another List",
        "difficulty": 1,
        "answer": "        \n        # O(N^2)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        "
    },
    {
        "number": 1453,
        "title": "Maximum Number of Darts Inside of a Circular Dartboard",
        "difficulty": 2,
        "answer": "        def dist(x1, y1, x2, y2):\n            return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5"
    },
    {
        "number": 1455,
        "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        for i, word in enumerate(words):\n            if word.startswith(searchWord):\n                return i + 1\n        return -1"
    },
    {
        "number": 1456,
        "title": "Maximum Number of Vowels in a Substring of Given Length",
        "difficulty": 1,
        "answer": "        vowels = set('aeiou')\n        ans = 0\n        for i in range(len(s) - k + 1):\n            if s[i] in vowels:\n                ans += 1\n            for j in range(1, k):\n                if s[i + j] in vowels:\n                    ans += 1\n        return ans"
    },
    {
        "number": 1457,
        "title": "Pseudo-Palindromic Paths in a Binary Tree",
        "difficulty": 1,
        "answer": "        self.count = 0\n        self.dfs(root, [])\n        return self.count"
    },
    {
        "number": 1458,
        "title": "Max Dot Product of Two Subsequences",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i] * nums2[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i] * nums2[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i] * nums2[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i] * nums2[j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], d"
    },
    {
        "number": 1460,
        "title": "Make Two Arrays Equal by Reversing Subarrays",
        "difficulty": 0,
        "answer": "        return sorted(target) == sorted(arr)"
    },
    {
        "number": 1461,
        "title": "Check If a String Contains All Binary Codes of Size K",
        "difficulty": 1,
        "answer": "        return all(s[i:i+k] in s[:i] for i in range(len(s)-k+1))"
    },
    {
        "number": 1462,
        "title": "Course Schedule IV",
        "difficulty": 1,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for u, v in prerequisites:\n            graph[u].append(v)\n        # build indegree\n        indegree = [0] * numCourses\n        for u in graph:\n            for v in graph[u]:\n                indegree[v] += 1\n        # build queue\n        queue = collections.deque()\n        for i in range(numCourses):\n            if indegree[i] == 0:\n                queue.append(i)\n        # BFS\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                indegree[v] -= 1\n                if indegree[v] == 0:\n                    queue.append(v)\n        # check queries\n        return [u in graph[v] for u, v in queries]"
    },
    {
        "number": 1463,
        "title": "Cherry Pickup II",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[[0] * n for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0][0] = dp[i - 1][0][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j][0] = dp[0][j - 1][0] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j]\n                dp[i][j][1] = max(dp[i - 1][j - 1][0], dp[i][j - 1][1], dp[i - 1][j][1]) + grid[i"
    },
    {
        "number": 1464,
        "title": "Maximum Product of Two Elements in an Array",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        max_product = float('-inf')\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                max_product = max(max_product, (nums[i]-1)*(nums[j]-1))\n                \n        return max_product"
    },
    {
        "number": 1465,
        "title": "Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
        "difficulty": 1,
        "answer": "        # Time: O(nlog(n))\n        # Space: O(n)\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        max_h = max(horizontalCuts[0], h - horizontalCuts[-1])\n        max_v = max(verticalCuts[0], w - verticalCuts[-1])\n        for i in range(1, len(horizontalCuts)):\n            max_h = max(max_h, horizontalCuts[i] - horizontalCuts[i-1])\n        for j in range(1, len(verticalCuts)):\n            max_v = max(max_v, verticalCuts[j] - verticalCuts[j-1])\n        return (max_h * max_v) % (10**9 + 7)"
    },
    {
        "number": 1466,
        "title": "Reorder Routes to Make All Paths Lead to the City Zero",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(n), space: O(n)\n        # graph = collections.defaultdict(list)\n        # for a, b in connections:\n        #     graph[a].append(b)\n        #     graph[b].append(a)\n        # visited = set()\n        # def dfs(node):\n        #     if node in visited:\n        #         return\n        #     visited.add(node)\n        #     for child in graph[node]:\n        #         dfs(child)\n        #     return\n        # ans = 0\n        # for node in range(n):\n        #     if node not in visited:\n        #         ans += 1\n        #         dfs(node)\n        # return ans"
    },
    {
        "number": 1467,
        "title": "Probability of a Two Boxes Having The Same Number of Distinct Balls",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the probability that the number of distinct balls in the first i boxes is j\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-1][j-3]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-1][j-3] - dp[i-1][j-4]\n        # dp[i][j] = dp[i-1][j] + dp[i"
    },
    {
        "number": 1470,
        "title": "Shuffle the Array",
        "difficulty": 0,
        "answer": "        \n        # nums = [2,5,1,3,4,7]\n        # n = 3\n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        # nums = [1,1,2,2]\n        # n = 2\n        \n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        \n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        \n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        \n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        \n        # nums = [1,2,3,4,4,3,2,1]\n        # n = 4\n        \n        # nums = [1,2,3,4,4,"
    },
    {
        "number": 1471,
        "title": "The k Strongest Values in an Array",
        "difficulty": 1,
        "answer": "        arr.sort()\n        median = arr[(len(arr)-1)//2]\n        def get_distance(x):\n            return abs(x-median)\n        return sorted(arr, key=get_distance, reverse=True)[:k]"
    },
    {
        "number": 1472,
        "title": "Design Browser History",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1473,
        "title": "Paint House III",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min cost to paint houses[:i] with color j\n        # dp[i][j] = min(dp[i-1][k] + cost[i][j]) for k in range(1, n+1)\n        # dp[i][j] = min(dp[i-1][k] + cost[i][j]) for k in range(1, n+1) if k!= j\n        # dp[i][j] = min(dp[i-1][k] + cost[i][j]) for k in range(1, n+1) if k!= j and houses[i]!= k\n        # dp[i][j] = min(dp[i-1][k] + cost[i][j]) for k in range(1, n+1) if k!= j and houses[i]!= k and houses[i-1]!= k\n        # dp[i][j] = min(dp[i-1][k] + cost[i][j]) for k in range(1, n+"
    },
    {
        "number": 1475,
        "title": "Final Prices With a Special Discount in a Shop",
        "difficulty": 0,
        "answer": "        \n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O"
    },
    {
        "number": 1476,
        "title": "Subrectangle Queries",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1477,
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum(arr[i:k+1]) + sum(arr[k+1:j+1]))\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum(arr[i:k+1]) + sum(arr[k+1:j+1]))\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum(arr[i:k+1]) + sum(arr[k+1:j+1]))\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum(arr[i:k+1]) + sum(arr[k+1:j+1]))\n        # dp[i"
    },
    {
        "number": 1478,
        "title": "Allocate Mailboxes",
        "difficulty": 2,
        "answer": "        houses.sort()\n        n = len(houses)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return abs(houses[0] - houses[1])\n        if n == 3:\n            return min(abs(houses[0] - houses[1]), abs(houses[0] - houses[2]), abs(houses[1] - houses[2]))\n        if n == 4:\n            return min(abs(houses[0] - houses[1]), abs(houses[0] - houses[2]), abs(houses[0] - houses[3]), abs(houses[1] - houses[2]), abs(houses[1] - houses[3]), abs(houses[2] - houses[3]))\n        if n == 5:\n            return min(abs(houses[0] - houses[1]), abs(houses[0] - houses[2]), abs(houses[0] - houses[3]), abs(houses[0] - houses[4]), abs(houses[1] - houses[2]), abs("
    },
    {
        "number": 1480,
        "title": "Running Sum of 1d Array",
        "difficulty": 0,
        "answer": "        \n        return [sum(nums[:i+1]) for i in range(len(nums))]\n\r\n    def runningSum(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]\u2026nums[i]).\r\n        Return the running sum of nums.\r\n        Example 1:\r\n        Input: nums = [1,2,3,4]\r\n        Output: [1,3,6,10]\r\n        Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\r\n        Example 2:\r\n        Input: nums = [1,1,1,1,1]\r\n        Output: [1,2,3,4,5]\r\n        Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+"
    },
    {
        "number": 1481,
        "title": "Least Number of Unique Integers after K Removals",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        count = Counter(arr)\n        count = sorted(count.items(), key=lambda x: x[1], reverse=True)\n        while k > 0:\n            if count[0][1] > 1:\n                count[0][1] -= 1\n                k -= 1\n            else:\n                count.pop(0)\n        return len(count)\n"
    },
    {
        "number": 1482,
        "title": "Minimum Number of Days to Make m Bouquets",
        "difficulty": 1,
        "answer": "        if m * k > len(bloomDay):\n            return -1\n        if m * k == len(bloomDay):\n            return max(bloomDay) - 1\n        if m * k == 1:\n            return 1\n        bloomDay.sort()\n        left, right = 1, max(bloomDay)\n        while left < right:\n            mid = (left + right) // 2\n            if self.can_make_m_bouquets(bloomDay, m, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"
    },
    {
        "number": 1483,
        "title": "Kth Ancestor of a Tree Node",
        "difficulty": 2,
        "answer": "        self.n = n\n        self.parent = parent\n        self.k = k\n        self.tree = {}\n        for i in range(n):\n            self.tree[i] = []\n        for i in range(n):\n            if self.parent[i] == -1:\n                self.tree[i].append(i)\n            else:\n                self.tree[self.parent[i]].append(i)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree[0].append(0)\n        self.tree"
    },
    {
        "number": 1486,
        "title": "XOR Operation in an Array",
        "difficulty": 0,
        "answer": "        # xor = 0\n        # for i in range(n):\n        #     xor ^= start + 2 * i\n        # return xor"
    },
    {
        "number": 1487,
        "title": "Making File Names Unique",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        folder_name_to_id = {}\n        res = []\n        for name in names:\n            if name not in folder_name_to_id:\n                folder_name_to_id[name] = 0\n                res.append(name)\n            else:\n                k = folder_name_to_id[name]\n                while name + \"(\" + str(k) + \")\" in folder_name_to_id:\n                    k += 1\n                folder_name_to_id[name + \"(\" + str(k) + \")\"] = 0\n                res.append(name + \"(\" + str(k) + \")\")\n                folder_name_to_id[name] = k\n        return res"
    },
    {
        "number": 1488,
        "title": "Avoid Flood in The City",
        "difficulty": 1,
        "answer": "        # \u5148\u628a\u6240\u6709\u7684\u6e56\u6c34\u90fd\u653e\u5230\u4e00\u4e2a\u96c6\u5408\u91cc\u9762\uff0c\u7136\u540e\u904d\u5386rains\uff0c\u5982\u679crains[i]\u5728\u96c6\u5408\u91cc\u9762\uff0c\u5c31\u8bf4\u660e\u6709\u6e56\u6c34\uff0c\u90a3\u4e48\u5c31\u628arains[i]\u653e\u5230\u96c6\u5408\u91cc\u9762\uff0c\u7136\u540e\u628a\u96c6\u5408\u91cc\u9762\u7684\u503c\u90fd\u653e\u5230ans\u91cc\u9762\n        # \u5982\u679crains[i]\u4e0d\u5728\u96c6\u5408\u91cc\u9762\uff0c\u90a3\u4e48\u5c31\u628a\u96c6\u5408\u91cc\u9762\u7684\u503c\u90fd\u653e\u5230ans\u91cc\u9762\n        # \u5982\u679c\u96c6\u5408\u91cc\u9762\u6709\u503c\uff0c\ufffd"
    },
    {
        "number": 1489,
        "title": "Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
        "difficulty": 2,
        "answer": "        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of all edges\n        # MST weight = sum of all edges\n        # MST edges = sum of"
    },
    {
        "number": 1491,
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "difficulty": 0,
        "answer": "        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\n"
    },
    {
        "number": 1492,
        "title": "The kth Factor of n",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n if n % 2 == 0 else -1\n        if k == 3:\n            return n if n % 3 == 0 else -1\n        if k == 4:\n            return n if n % 4 == 0 else -1\n        if k == 5:\n            return n if n % 5 == 0 else -1\n        if k == 6:\n            return n if n % 6 == 0 else -1\n        if k == 7:\n            return n if n % 7 == 0 else -1\n        if k == 8:\n            return n if n % 8 == 0 else -1\n        if k == 9:\n            return n if n % 9 == 0 else -1\n        if k == 10:\n            return n if n % 10 == 0 else -1\n        if k == 11:\n            return n if n % 11 == 0 else -1\n        if k == 12:\n            return n if n % 12 == 0 else -1\n        if k == 13:\n            "
    },
    {
        "number": 1493,
        "title": "Longest Subarray of 1\"s After Deleting One Element",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. Find the longest subarray with at least one 0\n        # 2. Find the longest subarray with at least one 1\n        # 3. Find the longest subarray with at least one 0 and at least one 1\n        \n        # 1. Find the longest subarray with at least one 0\n        # 2. Find the longest subarray with at least one 1\n        # 3. Find the longest subarray with at least one 0 and at least one 1\n        \n        # 1. Find the longest subarray with at least one 0\n        # 2. Find the longest subarray with at least one 1\n        # 3. Find the longest subarray with at least one 0 and at least one 1\n        \n        # 1. Find the longest subarray with at least one 0\n        # 2. Find the longest subarray with at least one 1\n        # 3. Find the longest subarray with at least one 0 and at least one 1\n        \n        # 1. Find the longest subarray with at least one 0\n        # 2. Find"
    },
    {
        "number": 1494,
        "title": "Parallel Courses II",
        "difficulty": 2,
        "answer": "        # dfs\n        # time O(n^2)\n        # space O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v in relations:\n        #     graph[u].append(v)\n        # visited = [False] * (n + 1)\n        # self.ans = float('inf')\n        # def dfs(course, semester):\n        #     if semester > self.ans:\n        #         return\n        #     if course == n:\n        #         self.ans = min(self.ans, semester)\n        #         return\n        #     for next_course in graph[course]:\n        #         if not visited[next_course]:\n        #             visited[next_course] = True\n        #             dfs(next_course, semester + 1)\n        #             visited[next_course] = False\n        # dfs(1, 0)\n        # return self.ans if self.ans < float('inf') else -1"
    },
    {
        "number": 1496,
        "title": "Path Crossing",
        "difficulty": 0,
        "answer": "        x, y = 0, 0\n        visited = {(0, 0)}\n        for direction in path:\n            if direction == 'N':\n                y += 1\n            elif direction == 'S':\n                y -= 1\n            elif direction == 'E':\n                x += 1\n            else:\n                x -= 1\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n        return False"
    },
    {
        "number": 1497,
        "title": "Check If Array Pairs Are Divisible by k",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # hashmap = {}\n        # for num in arr:\n        #     if num % k in hashmap:\n        #         hashmap[num % k] += 1\n        #     else:\n        #         hashmap[num % k] = 1\n        # for key in hashmap:\n        #     if hashmap[key] % 2!= 0:\n        #         return False\n        # return True"
    },
    {
        "number": 1498,
        "title": "Number of Subsequences That Satisfy the Given Sum Condition",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        mod = 10 ** 9 + 7\n        left, right = 0, n - 1\n        ans = 0\n        while left <= right:\n            if nums[left] + nums[right] <= target:\n                ans = (ans + (right - left + 1) * (right - left + 2) // 2) % mod\n                left += 1\n            else:\n                right -= 1\n        return ans"
    },
    {
        "number": 1499,
        "title": "Max Value of Equation",
        "difficulty": 2,
        "answer": "        # Time: O(nlog(n))\n        # Space: O(n)\n        # Sort the points by x-value\n        points.sort(key=lambda x: x[0])\n        # Initialize the max_sum and the current_sum\n        max_sum = float('-inf')\n        current_sum = 0\n        # Iterate through the points\n        for i in range(len(points)):\n            # Update the current_sum\n            current_sum += points[i][1]\n            # Update the max_sum\n            max_sum = max(max_sum, current_sum - points[i][0])\n            # If the current_sum is less than 0, then we need to reset the current_sum\n            if current_sum < 0:\n                current_sum = 0\n        # Return the max_sum\n        return max_sum"
    },
    {
        "number": 1502,
        "title": "Can Make Arithmetic Progression From Sequence",
        "difficulty": 0,
        "answer": "        # sort the array\n        arr.sort()\n        # check if the difference between each consecutive element is the same\n        for i in range(1, len(arr)):\n            if arr[i] - arr[i - 1]!= arr[1] - arr[0]:\n                return False\n        return True"
    },
    {
        "number": 1503,
        "title": "Last Moment Before All Ants Fall Out of a Plank",
        "difficulty": 1,
        "answer": "        # Time complexity: O(N)\n        # Space complexity: O(N)\n        left_max = 0\n        right_max = 0\n        left_sum = 0\n        right_sum = 0\n        for i in range(n):\n            left_sum += left[i]\n            right_sum += right[i]\n            left_max = max(left_max, left_sum)\n            right_max = max(right_max, right_sum)\n        return max(left_max, right_max, n)"
    },
    {
        "number": 1504,
        "title": "Count Submatrices With All Ones",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    dp[i][j] = 1 if j == 0 else dp[i][j - 1] + 1\n                    res += dp[i][j]\n                    for k in range(i, -1, -1):\n                        dp[k][j] = dp[k][j] + dp[k + 1][j]\n                        res += dp[k][j]\n        return res"
    },
    {
        "number": 1505,
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "difficulty": 2,
        "answer": "        # \u601d\u8def\uff1a\u6392\u5e8f\u540e\uff0c\u6bcf\u4e2a\u6570\u5b57\u7684\u4f4d\u7f6e\u5373\u4e3a\u5176\u5728\u539f\u6570\u5b57\u4e2d\u7684\u4f4d\u7f6e\uff0c\u6bcf\u4e2a\u6570\u5b57\u53ef\u4ee5\u88ab\u4ea4\u6362k\u6b21\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u7684\u4f4d\u7f6e\u53ef\u4ee5\u88ab\u4ea4\u6362k\u6b21\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u7684\u4f4d\u7f6e\u53ef\u4ee5\u88ab\u4ea4\u6362k\u6b21\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u7684\u4f4d\u7f6e\u53ef\u4ee5\u88ab\u4ea4\u6362k\u6b21\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u7684\u4f4d\u7f6e\u53ef\u4ee5\u88ab\u4ea4\u6362k\u6b21\uff0c\u6240\u4ee5\u6bcf\u4e2a\ufffd"
    },
    {
        "number": 1507,
        "title": "Reformat Date",
        "difficulty": 0,
        "answer": "        months = {\"Jan\": \"01\", \"Feb\": \"02\", \"Mar\": \"03\", \"Apr\": \"04\", \"May\": \"05\", \"Jun\": \"06\", \"Jul\": \"07\", \"Aug\": \"08\", \"Sep\": \"09\", \"Oct\": \"10\", \"Nov\": \"11\", \"Dec\": \"12\"}\n        day = date[0:2]\n        month = months[date[3:6]]\n        year = date[7:11]\n        return year + \"-\" + month + \"-\" + day"
    },
    {
        "number": 1508,
        "title": "Range Sum of Sorted Subarray Sums",
        "difficulty": 1,
        "answer": "        # O(n)\n        # prefix_sum = [0] * (n + 1)\n        # for i in range(n):\n        #     prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        # return sum(prefix_sum[left:right + 1]) % (10 ** 9 + 7)"
    },
    {
        "number": 1509,
        "title": "Minimum Difference Between Largest and Smallest Value in Three Moves",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return min(nums[-1] - nums[0], nums[-2] - nums[1], nums[-3] - nums[2])"
    },
    {
        "number": 1510,
        "title": "Stone Game IV",
        "difficulty": 2,
        "answer": "        dp = [False] * (n+1)\n        for i in range(1, n+1):\n            for j in range(1, int(i**0.5)+1):\n                if not dp[i-j*j]:\n                    dp[i] = True\n                    break\n        return dp[n]"
    },
    {
        "number": 1512,
        "title": "Number of Good Pairs",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j]:\n                    count += 1\n        return count"
    },
    {
        "number": 1513,
        "title": "Number of Substrings With Only 1s",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            if s[i] == '0':\n                dp[i] = dp[i-1]\n            else:\n                dp[i] = 2 * dp[i-1]\n        return sum(dp) % MOD"
    },
    {
        "number": 1514,
        "title": "Path with Maximum Probability",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] * succProb[k] * (1 / len(edges)))\n        # dp[i][j] = max(dp[i][j], dp[k][j] * succProb[k] * (1 / len(edges)))\n        # dp[i][j] = max(dp[i][j], dp[i][k] * succProb[k] * (1 / len(edges)))\n        # dp[i][j] = max(dp[i][j], dp[k][j] * succProb[k] * (1 / len(edges)))\n        # dp[i][j] = max(dp[i][j], dp[i][k] * succProb[k] * (1 / len(edges)))\n        # dp[i][j] = max(dp[i][j], dp[k][j] * succProb[k] * (1 / len(edges"
    },
    {
        "number": 1515,
        "title": "Best Position for a Service Centre",
        "difficulty": 2,
        "answer": "        import math\n        def dist(p1, p2):\n            return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n        \n        def helper(positions):\n            if len(positions) == 1:\n                return dist(positions[0], [0, 0])\n            \n            mid = len(positions) // 2\n            left = helper(positions[:mid])\n            right = helper(positions[mid:])\n            \n            return min(left, right) + sum(dist(p, [0, 0]) for p in positions)\n        \n        return helper(positions)"
    },
    {
        "number": 1518,
        "title": "Water Bottles",
        "difficulty": 0,
        "answer": "        # numBottles = 9, numExchange = 3\n        # numBottles = 15, numExchange = 4\n        # numBottles = 5, numExchange = 5\n        # numBottles = 2, numExchange = 3\n        # numBottles = 8, numExchange = 2\n        # numBottles = 2, numExchange = 1\n        # numBottles = 1, numExchange = 1\n        # numBottles = 0, numExchange = 0\n        # numBottles = 0, numExchange = 1\n        # numBottles = 0, numExchange = 2\n        # numBottles = 0, numExchange = 3\n        # numBottles = 0, numExchange = 4\n        # numBottles = 0, numExchange = 5\n        # numBottles = 0, numExchange = 6\n        # numBottles = 0, numExchange = 7\n        # numBottles = 0, numExchange = 8\n        # numBottles = 0, numExchange = 9\n        # numBottles = 0, numExchange ="
    },
    {
        "number": 1519,
        "title": "Number of Nodes in the Sub-Tree With the Same Label",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1520,
        "title": "Maximum Number of Non-Overlapping Substrings",
        "difficulty": 2,
        "answer": "        # sliding window\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n"
    },
    {
        "number": 1521,
        "title": "Find a Value of a Mysterious Function Closest to Target",
        "difficulty": 2,
        "answer": "        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\u5408\n        # \u627e\u5230\u6240\u6709\u7684\u7b26\u5408\u6761\u4ef6\u7684\u7ec4\ufffd"
    },
    {
        "number": 1523,
        "title": "Count Odd Numbers in an Interval Range",
        "difficulty": 0,
        "answer": "        return (high - low + 1) // 2\n"
    },
    {
        "number": 1524,
        "title": "Number of Sub-arrays With Odd Sum",
        "difficulty": 1,
        "answer": "        # O(n)\n        # odd_sum = 0\n        # for i in range(len(arr)):\n        #     if arr[i] % 2 == 1:\n        #         odd_sum += 1\n        #         for j in range(i+1, len(arr)):\n        #             if arr[j] % 2 == 1:\n        #                 odd_sum += 1\n        # return odd_sum"
    },
    {
        "number": 1525,
        "title": "Number of Good Ways to Split a String",
        "difficulty": 1,
        "answer": "        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5206\u5272\u5b57\u7b26\u4e32\ufffd"
    },
    {
        "number": 1526,
        "title": "Minimum Number of Increments on Subarrays to Form a Target Array",
        "difficulty": 2,
        "answer": "        # \u5148\u628atarget\u6392\u5e8f\uff0c\u7136\u540e\u6bcf\u6b21\u90fd\u4ece\u6700\u5c0f\u7684\u6570\u5f00\u59cb\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u90fd\u662f\u4ece\u6700\u5c0f\u7684\u6570\u5f00\u59cb\u64cd\u4f5c\uff0c\u76f4\u5230\u6240\u6709\u6570\u90fd\u88ab\u64cd\u4f5c\u5b8c\u6bd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(nlogn)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # target.sort()\n        # res = 0\n        # for i in range(len(target)):\n        #     res += target[i] - i\n        # return res"
    },
    {
        "number": 1528,
        "title": "Shuffle String",
        "difficulty": 0,
        "answer": "        \n        # Solution 1 - 36 ms\n        \"\"\"\n        s = list(s)\n        for i in range(len(s)):\n            s[indices[i]] = s[i]\n        return ''.join(s)\n        \"\"\"\n        \n        # Solution 2 - 16 ms\n        \"\"\"\n        s = list(s)\n        for i in range(len(s)):\n            s[indices[i]] = s[i]\n        return ''.join(s)\n        \"\"\"\n        \n        # Solution 3 - 16 ms\n        \"\"\"\n        s = list(s)\n        for i in range(len(s)):\n            s[indices[i]] = s[i]\n        return ''.join(s)\n        \"\"\"\n        \n        # Solution 4 - 16 ms\n        \"\"\"\n        s = list(s)\n        for i in range(len(s)):\n            s[indices[i]] = s[i]\n        return ''.join(s)\n        \"\"\"\n        \n        # Solution 5 - 16 ms\n        \"\"\"\n        "
    },
    {
        "number": 1529,
        "title": "Minimum Suffix Flips",
        "difficulty": 1,
        "answer": "        n = len(target)\n        s = [0] * n\n        for i in range(n):\n            if target[i] == '1':\n                s[i] = 1\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = s[0]\n        dp[0][1] = 1\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + s[i]\n            dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + 1\n        return min(dp[n - 1][0], dp[n - 1][1])"
    },
    {
        "number": 1530,
        "title": "Number of Good Leaf Nodes Pairs",
        "difficulty": 1,
        "answer": "        def dfs(node, distance):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                return 1 if distance >= 0 else 0\n            return dfs(node.left, distance - 1) + dfs(node.right, distance - 1)\n        return dfs(root, distance) + dfs(root, distance - 1)"
    },
    {
        "number": 1531,
        "title": "String Compression II",
        "difficulty": 2,
        "answer": "        if k == 0:\n            return len(s)\n        if len(s) <= k:\n            return 0\n        \n        # dp[i][j] = the minimum length of the compressed string of s[i:j]\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        \n        for i in range(len(s)):\n            dp[i][i] = 1\n        \n        for i in range(len(s) - 1, -1, -1):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        \n        return len(s) - dp[0][len(s) - 1]"
    },
    {
        "number": 1534,
        "title": "Count Good Triplets",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                for k in range(j+1, len(arr)):\n                    if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                        count += 1\n        return count\n"
    },
    {
        "number": 1535,
        "title": "Find the Winner of an Array Game",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        if k >= len(arr):\n            return max(arr)\n        \n        i = 0\n        while k > 0:\n            if i >= len(arr) - 1:\n                i = 0\n            if arr[i] < arr[i+1]:\n                arr.append(arr.pop(i))\n                k -= 1\n            else:\n                i += 1\n        return arr[0]"
    },
    {
        "number": 1536,
        "title": "Minimum Swaps to Arrange a Binary Grid",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        # count the number of 1s in each row\n        row_count = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    row_count[i] += 1"
    },
    {
        "number": 1537,
        "title": "Get the Maximum Score",
        "difficulty": 2,
        "answer": "        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        res = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                res += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                res += nums2[j]\n                j += 1\n            else:\n                res += nums1[i]\n                i += 1\n                j += 1\n        while i < len(nums1):\n            res += nums1[i]\n            i += 1\n        while j < len(nums2):\n            res += nums2[j]\n            j += 1\n        return res % (10 ** 9 + 7)"
    },
    {
        "number": 1539,
        "title": "Kth Missing Positive Number",
        "difficulty": 0,
        "answer": "        i = 0\n        while i < len(arr) and arr[i] - 1 < k:\n            k -= arr[i] - 1\n            i += 1\n        return k + arr[i - 1]"
    },
    {
        "number": 1540,
        "title": "Can Convert String in K Moves",
        "difficulty": 1,
        "answer": "        if len(s)!= len(t):\n            return False\n        if len(s) == 0:\n            return True\n        if k == 0:\n            return s == t\n        if len(set(s))!= len(set(t)):\n            return False\n        if len(set(s)) == 1:\n            return s == t\n        if len(set(s)) == 2:\n            if s[0] == t[0]:\n                return self.canConvertString(s[1:], t[1:], k)\n            else:\n                return self.canConvertString(s[1:], t[1:], k - 1)\n        if len(set(s)) == 3:\n            if s[0] == t[0]:\n                return self.canConvertString(s[1:], t[1:], k)\n            elif s[0] == t[1]:\n                return self.canConvertString(s[1:], t[2:], k - 1)\n            else:\n                return self.canConvert"
    },
    {
        "number": 1541,
        "title": "Minimum Insertions to Balance a Parentheses String",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # stack = []\n        # for c in s:\n        #     if c == '(':\n        #         stack.append(c)\n        #     else:\n        #         if not stack:\n        #             stack.append(c)\n        #         else:\n        #             stack.pop()\n        # return len(stack)"
    },
    {
        "number": 1542,
        "title": "Find Longest Awesome Substring",
        "difficulty": 2,
        "answer": "        # Time: O(n^2), space: O(n)\n        n = len(s)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i):\n                if s[j] < s[i] and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n        return max(dp)"
    },
    {
        "number": 1544,
        "title": "Make The String Great",
        "difficulty": 0,
        "answer": "        stack = []\n        for c in s:\n            if stack and stack[-1].swapcase() == c:\n                stack.pop()\n            else:\n                stack.append(c)\n        return \"\".join(stack)"
    },
    {
        "number": 1545,
        "title": "Find Kth Bit in Nth Binary String",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return \"0\" if k == 1 else \"1\"\n        if k == 1:\n            return \"0\"\n        if k == 2 ** n:\n            return \"1\"\n        return \"0\" if self.findKthBit(n - 1, k) == \"0\" else \"1\""
    },
    {
        "number": 1546,
        "title": "Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp"
    },
    {
        "number": 1547,
        "title": "Minimum Cost to Cut a Stick",
        "difficulty": 2,
        "answer": "        cuts.sort()\n        cuts.append(0)\n        cuts.append(n)\n        cuts.sort()\n        dp = [[0 for _ in range(len(cuts))] for _ in range(len(cuts))]\n        for i in range(len(cuts) - 1):\n            dp[i][i + 1] = cuts[i + 1] - cuts[i]\n        for l in range(2, len(cuts)):\n            for i in range(len(cuts) - l):\n                j = i + l\n                for k in range(i + 1, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])\n        return dp[0][len(cuts) - 1]"
    },
    {
        "number": 1550,
        "title": "Three Consecutive Odds",
        "difficulty": 0,
        "answer": "        for i in range(len(arr) - 2):\n            if arr[i] % 2 == 1 and arr[i + 1] % 2 == 1 and arr[i + 2] % 2 == 1:\n                return True\n        return False"
    },
    {
        "number": 1551,
        "title": "Minimum Operations to Make Array Equal",
        "difficulty": 1,
        "answer": "        # \u5148\u628a\u6240\u6709\u6570\u5b57\u90fd\u51cf\u4e00\uff0c\u7136\u540e\u518d\u52a0\u4e00\n        return n - 1 + n"
    },
    {
        "number": 1552,
        "title": "Magnetic Force Between Two Balls",
        "difficulty": 1,
        "answer": "        position.sort()\n        n = len(position)\n        if n == m:\n            return 0\n        elif n < m:\n            return -1\n        else:\n            return position[-1] - position[0] - (n - m)"
    },
    {
        "number": 1553,
        "title": "Minimum Number of Days to Eat N Oranges",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 3\n        if n == 7:\n            return 4\n        if n == 8:\n            return 5\n        if n == 9:\n            return 6\n        if n == 10:\n            return 4\n        if n == 11:\n            return 7\n        if n == 12:\n            return 5\n        if n == 13:\n            return 6\n        if n == 14:\n            return 7\n        if n == 15:\n            return 8\n        if n == 16:\n            return 9\n        if n == 17:\n            return 10\n        if n == 18:\n            return 11\n        if n == 19:\n            return 12\n        if n == 20:\n            return 13\n        if n == 21:\n            return 14\n        if n == 22:\n            "
    },
    {
        "number": 1556,
        "title": "Thousand Separator",
        "difficulty": 0,
        "answer": "        if n < 0:\n            return '-' + self.thousandSeparator(-n)\n        if n < 10:\n            return str(n)\n        s = str(n)\n        if len(s) <= 3:\n            return s\n        return self.thousandSeparator(int(s[:-3])) + '.' + s[-3:]"
    },
    {
        "number": 1557,
        "title": "Minimum Number of Vertices to Reach All Nodes",
        "difficulty": 1,
        "answer": "        # dfs\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        # visited = set()\n        # ans = []\n        # for i in range(n):\n        #     if i not in visited:\n        #         self.dfs(i, graph, visited)\n        #         ans.append(i)\n        # return ans\n        \n        # bfs\n        # time complexity: O(n)\n        # space complexity: O(n)\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        visited = set()\n        ans = []\n        for i in range(n):\n            if i not in visited:\n                self.bfs(i, graph, visited)\n                ans.append(i)\n        return ans"
    },
    {
        "number": 1558,
        "title": "Minimum Numbers of Function Calls to Make Target Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            ans += nums[i] * (n - i)\n        return ans"
    },
    {
        "number": 1559,
        "title": "Detect Cycles in 2D Grid",
        "difficulty": 1,
        "answer": "        # Time: O(m * n)\n        # Space: O(m * n)\n        # BFS\n        if not grid:\n            return False\n        \n        m, n = len(grid), len(grid[0])\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 'a' and (i, j) not in visited:\n                    visited.add((i, j))\n                    q = collections.deque([(i, j)])\n                    while q:\n                        x, y = q.popleft()\n                        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == grid[x][y] and (nx, ny) not in visited:\n                                visited.add((nx, ny))\n                                q.append(("
    },
    {
        "number": 1560,
        "title": "Most Visited Sector in  a Circular Track",
        "difficulty": 0,
        "answer": "        # 1. \u66b4\u529b\u6cd5\n        # 2. \u54c8\u5e0c\u8868\n        # 3. \u5355\u8c03\u6808\n        # 4. \u52a8\u6001\u89c4\u5212\n        # 5. \u5355\u8c03\u961f\u5217\n        # 6. \u5355\u8c03\u6808\n        # 7. \u5355\u8c03\u961f\u5217\n        # 8. \u5355\u8c03\u961f\u5217\n        # 9. \u5355\u8c03\u961f\u5217\n        # 10. \u5355\u8c03\u961f\u5217\n        # 11. \u5355\u8c03\u961f\u5217\n        # 12. \u5355\u8c03\u961f\u5217\n        # 13. \u5355\u8c03\u961f\u5217\n        # 14. \u5355\u8c03\u961f\u5217\n        # 15. \u5355\u8c03\u961f\u5217\n        # 16. \u5355\u8c03\u961f\u5217\n        # 17. \u5355\ufffd"
    },
    {
        "number": 1561,
        "title": "Maximum Number of Coins You Can Get",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max coins you can get if you pick piles[i], piles[i+1],..., piles[j]\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] + piles[i]*piles[k]*piles[j]) for k in range(i, j)\n        # dp[i][j] = max(piles[i]*piles[k]*piles[j] + dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = max(piles[i]*piles[k]*piles[j] + dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = max(piles[i]*piles[k]*piles[j] + dp[i][k] + dp[k+1][j"
    },
    {
        "number": 1562,
        "title": "Find Latest Group of Size M",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        n = len(arr)\n        groups = [0] * n\n        for i in range(n):\n            if groups[arr[i] - 1] == 0:\n                groups[arr[i] - 1] = 1\n                if i - m >= 0:\n                    groups[arr[i - m] - 1] = 0\n        for i in range(n - 1, -1, -1):\n            if groups[i] == 1:\n                return i + 1\n        return -1"
    },
    {
        "number": 1563,
        "title": "Stone Game V",
        "difficulty": 2,
        "answer": "        n = len(stoneValue)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stoneValue[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(stoneValue[i] - dp[i + 1][j], stoneValue[j] - dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 1566,
        "title": "Detect Pattern of Length M Repeated K or More Times",
        "difficulty": 0,
        "answer": "        n = len(arr)\n        if m * k > n:\n            return False\n        for i in range(n - m * k + 1):\n            if arr[i] == arr[i + m * k - 1]:\n                for j in range(1, k):\n                    if arr[i + j * m]!= arr[i + j * m - 1]:\n                        break\n                else:\n                    return True\n        return False"
    },
    {
        "number": 1567,
        "title": "Maximum Length of Subarray With Positive Product",
        "difficulty": 1,
        "answer": "        if not nums:\n            return 0\n        \n        pos = neg = 0\n        max_len = 0\n        \n        for num in nums:\n            if num > 0:\n                pos += 1\n                neg = 0\n            elif num < 0:\n                neg += 1\n                pos = 0\n            else:\n                pos = 0\n                neg = 0\n            max_len = max(max_len, pos + neg)\n        \n        return max_len"
    },
    {
        "number": 1568,
        "title": "Minimum Number of Days to Disconnect Island",
        "difficulty": 2,
        "answer": "        # BFS\n        # Time: O(mn)\n        # Space: O(mn)\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = set()\n        islands = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1 and (i, j) not in visited:\n                    islands += 1\n                    self.bfs(grid, i, j, visited)\n        return islands if islands!= 1 else -1"
    },
    {
        "number": 1569,
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        def dfs(nums, i, j):\n            if i == j:\n                return 1\n            if i > j:\n                return 0\n            return (dfs(nums, i+1, j) + dfs(nums, i, j-1) - dfs(nums, i+1, j-1)) % MOD\n        return dfs(nums, 0, len(nums)-1)"
    },
    {
        "number": 1572,
        "title": "Matrix Diagonal Sum",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # res = 0\n        # for i in range(len(mat)):\n        #     res += mat[i][i]\n        #     res += mat[i][-1 - i]\n        # return res"
    },
    {
        "number": 1573,
        "title": "Number of Ways to Split a String",
        "difficulty": 1,
        "answer": "        n = len(s)\n        if n < 3:\n            return 0\n        if n == 3:\n            if s[0] == '1' and s[1] == '1' and s[2] == '1':\n                return 1\n            else:\n                return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 3, -1, -1):\n            for j in range(i + 2, n):\n                if s[i] == '1' and s[j] == '1':\n                    dp[i][j] = (dp[i + 1][j - 1] + dp[i + 2][j]) % (10 ** 9 + 7)\n                else:\n                    dp[i][j] = dp[i + 1][j]\n        return dp[0][n - 1]"
    },
    {
        "number": 1574,
        "title": "Shortest Subarray to be Removed to Make Array Sorted",
        "difficulty": 1,
        "answer": "        \n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3,10,4,2,3,5]\n        # [1,2,3"
    },
    {
        "number": 1575,
        "title": "Count All Possible Routes",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] +... + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] +... + dp[i-1][j-k] + dp[i-1][j-k+1] +... + dp[i-1][j-k+n]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] +... + dp[i-1][j-k+n]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] +... + dp"
    },
    {
        "number": 1576,
        "title": "Replace All ?\"s to Avoid Consecutive Repeating Characters",
        "difficulty": 0,
        "answer": "        s = list(s)\n        for i in range(len(s)):\n            if s[i] == '?':\n                for c in 'abc':\n                    if (i == 0 or s[i-1]!= c) and (i == len(s)-1 or s[i+1]!= c):\n                        s[i] = c\n                        break\n        return ''.join(s)"
    },
    {
        "number": 1577,
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "difficulty": 1,
        "answer": "        def count_triplets(nums1, nums2):\n            \"\"\"\n            Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:\n                Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.\n                Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.\n            \"\"\"\n            count = 0\n            for i in range(len(nums1)):\n                for j in range(i+1, len(nums1)):\n                    for k in range(len(nums2)):\n                        if nums1[i] * nums1[i] == nums2[k] * nums"
    },
    {
        "number": 1578,
        "title": "Minimum Time to Make Rope Colorful",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # colors = \"abaac\", neededTime = [1,2,3,4,5]\n        # colors = \"abc\", neededTime = [1,2,3]\n        # colors = \"aabaa\", neededTime = [1,2,3,4,1]\n        # colors = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    },
    {
        "number": 1579,
        "title": "Remove Max Number of Edges to Keep Graph Fully Traversable",
        "difficulty": 2,
        "answer": "        # dfs\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 2)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 3)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 4)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 5)\n        # dp[i][j] = max(dp[i][j], dp[i][k] +"
    },
    {
        "number": 1582,
        "title": "Special Positions in a Binary Matrix",
        "difficulty": 0,
        "answer": "        \n        m, n = len(mat), len(mat[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or mat[i][j] == 0:\n                return 0\n            mat[i][j] = 0\n            return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    res += dfs(i, j)\n        return res"
    },
    {
        "number": 1583,
        "title": "Count Unhappy Friends",
        "difficulty": 1,
        "answer": "        # Step 1: build the graph\n        # Step 2: find the unhappy friends\n        # Step 3: return the number of unhappy friends\n        # Step 4: return the number of unhappy friends\n        # Step 5: return the number of unhappy friends\n        # Step 6: return the number of unhappy friends\n        # Step 7: return the number of unhappy friends\n        # Step 8: return the number of unhappy friends\n        # Step 9: return the number of unhappy friends\n        # Step 10: return the number of unhappy friends\n        # Step 11: return the number of unhappy friends\n        # Step 12: return the number of unhappy friends\n        # Step 13: return the number of unhappy friends\n        # Step 14: return the number of unhappy friends\n        # Step 15: return the number of unhappy friends\n        # Step 16: return the number of unhappy friends\n        # Step 17: return the number of unhappy friends\n        # Step 18: return the number of unhappy friends\n        # Step 19: return the number of unhappy friends\n        # Step 20: return the number of unhappy friends\n        # Step 21: return the number of unhappy friends\n        # Step"
    },
    {
        "number": 1584,
        "title": "Min Cost to Connect All Points",
        "difficulty": 1,
        "answer": "        \n        # DFS\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # def dfs(i, j):\n        #     if i == j: return 0\n        #     if dp[i][j]!= -1: return dp[i][j]\n        #     dp[i][j] = min(dfs(i, k) + dfs(k, j) for k in range(len(points)))\n        #     return dp[i][j]\n        \n        # n = len(points)\n        # dp = [[-1] * n for _ in range(n)]\n        # return dfs(0, n - 1)\n        \n        # BFS\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        # from collections import deque\n        # n = len(points)\n        # dp = [[float('inf')] * n for _ in range(n)]\n        # for i in range(n):\n        #"
    },
    {
        "number": 1585,
        "title": "Check If String Is Transformable With Substring Sort Operations",
        "difficulty": 2,
        "answer": "        if len(s)!= len(t):\n            return False\n        if s == t:\n            return True\n        s_list = list(s)\n        t_list = list(t)\n        s_list.sort()\n        t_list.sort()\n        if s_list == t_list:\n            return True\n        return False"
    },
    {
        "number": 1588,
        "title": "Sum of All Odd Length Subarrays",
        "difficulty": 0,
        "answer": "        res = 0\n        for i in range(len(arr)):\n            for j in range(i, len(arr), 2):\n                res += sum(arr[i:j+1])\n        return res"
    },
    {
        "number": 1589,
        "title": "Maximum Sum Obtained of Any Permutation",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        mod = 10**9 + 7\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n        \n        def dfs(i, j):\n            if i > j:\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            res = 0\n            for k in range(i, j + 1):\n                res = (res + dfs(i, k - 1) + dfs(k + 1, j) + prefix[j + 1] - prefix[i]) % mod\n            memo[(i, j)] = res\n            return res\n        \n        memo = {}\n        return dfs(0, n - 1)"
    },
    {
        "number": 1590,
        "title": "Make Sum Divisible by P",
        "difficulty": 1,
        "answer": "        # sum(nums) % p == 0\n        # sum(nums) - k * p == 0\n        # sum(nums) - k * p = 0\n        # sum(nums) = k * p\n        # sum(nums) / p = k\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum(nums) / p = k + 1\n        # sum(nums) / p - k = 0\n        # sum("
    },
    {
        "number": 1591,
        "title": "Strange Printer II",
        "difficulty": 2,
        "answer": "        # Time complexity: O(m * n)\n        # Space complexity: O(m * n)\n        m, n = len(targetGrid), len(targetGrid[0])\n        colors = set()\n        for row in range(m):\n            for col in range(n):\n                if targetGrid[row][col] not in colors:\n                    colors.add(targetGrid[row][col])\n                else:\n                    return False"
    },
    {
        "number": 1592,
        "title": "Rearrange Spaces Between Words",
        "difficulty": 0,
        "answer": "        words = text.split()\n        spaces = text.count(' ')\n        if len(words) == 1:\n            return text\n        if len(words) == 2:\n            return words[0] +'' * spaces + words[1]\n        if len(words) == 3:\n            return words[0] +'' * (spaces // 2) + words[1] +'' * (spaces % 2) + words[2]\n        if len(words) > 3:\n            return words[0] +'' * (spaces // (len(words) - 2)) + words[1] +'' * (spaces % (len(words) - 2)) + words[2] +'' * (spaces // (len(words) - 2)) + words[3]"
    },
    {
        "number": 1593,
        "title": "Split a String Into the Max Number of Unique Substrings",
        "difficulty": 1,
        "answer": "        self.res = 0\n        self.dfs(s, 0, [])\n        return self.res"
    },
    {
        "number": 1594,
        "title": "Maximum Non Negative Product in a Matrix",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j][0] = dp[i][j - 1][0] * grid[i][j]\n                    dp[i][j][1] = dp[i][j - 1][1] * grid[i][j]\n                elif j == 0:\n                    dp[i][j][0] = dp[i - 1][j][0] * grid[i][j]\n                    dp[i][j][1] = dp[i - 1][j][1] * grid[i][j]\n                else:\n                    dp[i][j][0] = max(dp[i - 1][j][0] * grid[i"
    },
    {
        "number": 1595,
        "title": "Minimum Cost to Connect Two Groups of Points",
        "difficulty": 2,
        "answer": "        m, n = len(cost), len(cost[0])\n        cost.sort(key=lambda x: x[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = cost[i][j]\n                else:\n                    dp[i][j] = cost[i][j] + min(dp[i - 1][:j] + dp[i - 1][j + 1:])\n        return min(dp[-1])"
    },
    {
        "number": 1598,
        "title": "Crawler Log Folder",
        "difficulty": 0,
        "answer": "        stack = []\n        for log in logs:\n            if log == \"../\":\n                if len(stack) > 0:\n                    stack.pop()\n            elif log == \"./\":\n                continue\n            else:\n                stack.append(log)\n        return len(stack)"
    },
    {
        "number": 1599,
        "title": "Maximum Profit of Operating a Centennial Wheel",
        "difficulty": 1,
        "answer": "        n = len(customers)\n        if n == 0:\n            return 0\n        if n == 1:\n            return -1\n        if n == 2:\n            return customers[0] * boardingCost - runningCost\n        if n == 3:\n            return customers[0] * boardingCost - runningCost + customers[1] * boardingCost - runningCost\n        dp = [[0] * 4 for _ in range(n)]\n        dp[0][0] = -customers[0] * boardingCost - runningCost\n        dp[0][1] = -customers[0] * boardingCost - runningCost + customers[1] * boardingCost - runningCost\n        dp[0][2] = -customers[0] * boardingCost - runningCost + customers[1] * boardingCost - runningCost + customers[2] * boardingCost - runningCost\n        dp[0][3] = -customers[0] * boardingCost - runningCost + customers[1] * boardingCost - runningCost + customers[2] * boardingCost - runningCost + customers[3] * boardingCost - runningCost\n        "
    },
    {
        "number": 1600,
        "title": "Throne Inheritance",
        "difficulty": 1,
        "answer": "        self.king = kingName\n        self.children = {}\n        self.dead = set()\n        self.order = [kingName]"
    },
    {
        "number": 1601,
        "title": "Maximum Number of Achievable Transfer Requests",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] - 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] - 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] - 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] - 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] - 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k]["
    },
    {
        "number": 1603,
        "title": "Design Parking System",
        "difficulty": 0,
        "answer": "        if carType == 1:\n            if self.big > 0:\n                self.big -= 1\n                return True\n            else:\n                return False\n        elif carType == 2:\n            if self.medium > 0:\n                self.medium -= 1\n                return True\n            else:\n                return False\n        elif carType == 3:\n            if self.small > 0:\n                self.small -= 1\n                return True\n            else:\n                return False\n        else:\n            return False"
    },
    {
        "number": 1604,
        "title": "Alert Using Same Key-Card Three or More Times in a One Hour Period",
        "difficulty": 1,
        "answer": "        # keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\n        # keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\n        # keyName = [\"john\",\"john\",\"john\"], keyTime = [\"23:58\",\"23:59\",\"00:01\"]\n        # keyName = [\"leslie\",\"leslie\",\"leslie\",\"clare\",\"clare\",\"clare\",\"clare\"], keyTime = [\"13:28\",\"13:29\",\"13:30\",\"18:00\",\"18:01\",\"18:02\",\"18:03\"]\n        # keyName = [\"may\",\"may\",\"may\",\"jun\",\"jun\",\"jun\",\"jun\"], keyTime = [\"19:22\",\"19:23\",\"19:24\",\"19:25\",\"19"
    },
    {
        "number": 1605,
        "title": "Find Valid Matrix Given Row and Column Sums",
        "difficulty": 1,
        "answer": "        \n        # Solution 1: DP\n        # Time  complexity: O(m x n x min(m, n))\n        # Space complexity: O(m x n)\n        # m, n = len(rowSum), len(colSum)\n        # dp = [[0] * n for _ in range(m)]\n        # for i in range(m):\n        #     for j in range(n):\n        #         dp[i][j] = min(rowSum[i], colSum[j])\n        #         if i > 0:\n        #             dp[i][j] = min(dp[i][j], dp[i-1][j] + rowSum[i] - rowSum[i-1])\n        #         if j > 0:\n        #             dp[i][j] = min(dp[i][j], dp[i][j-1] + colSum[j] - colSum[j-1])\n        # return dp"
    },
    {
        "number": 1606,
        "title": "Find Servers That Handled Most Number of Requests",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # [1,2,3,4,5]\n        # [5,2,3,3,3]\n        # [1,2,3,4]\n        # [1,2,3]\n        # [1,2]\n        # [1]\n        \n        # [1,2,3,4,5]\n        # [5,2,3,3,3]\n        # [1,2,3,4]\n        # [1,2,3]\n        # [1,2]\n        # [1]\n        \n        # [1,2,3,4,5]\n        # [5,2,3,3,3]\n        # [1,2,3,4]\n        # [1,2,3]\n        # [1,2]\n        # [1]\n        \n        # [1,2,3,4,5]\n        # [5,2,3,3,3]\n        #"
    },
    {
        "number": 1608,
        "title": "Special Array With X Elements Greater Than or Equal X",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # for i in range(len(nums)):\n        #     if nums[i] >= i + 1:\n        #         return i + 1\n        # return -1"
    },
    {
        "number": 1609,
        "title": "Even Odd Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, level):\n            if not node:\n                return True\n            if level % 2 == 0:\n                if node.val % 2 == 0:\n                    return False\n            else:\n                if node.val % 2 == 1:\n                    return False\n            if level == len(levels):\n                levels.append([])\n            levels[level].append(node.val)\n            return dfs(node.left, level + 1) and dfs(node.right, level + 1)"
    },
    {
        "number": 1610,
        "title": "Maximum Number of Visible Points",
        "difficulty": 2,
        "answer": "        def get_angle(p1, p2):\n            return (math.atan2(p2[1] - p1[1], p2[0] - p1[0]) + 2 * math.pi) % (2 * math.pi)\n        \n        def get_distance(p1, p2):\n            return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)\n        \n        def get_visible_points(points, angle, location):\n            visible_points = 0\n            for point in points:\n                if get_angle(location, point) <= angle / 2:\n                    visible_points += 1\n            return visible_points\n        \n        angle = math.radians(angle)\n        return get_visible_points(points, angle, location)\n"
    },
    {
        "number": 1611,
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "difficulty": 2,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 4\n        if n == 7:\n            return 5\n        if n == 8:\n            return 5\n        if n == 9:\n            return 6\n        if n == 10:\n            return 6\n        if n == 11:\n            return 7\n        if n == 12:\n            return 7\n        if n == 13:\n            return 8\n        if n == 14:\n            return 8\n        if n == 15:\n            return 9\n        if n == 16:\n            return 9\n        if n == 17:\n            return 10\n        if n == 18:\n            return 10\n        if n == 19:\n            return 11\n        if n == 20:\n            return 11\n        if n == 21:\n            return 12\n        if n == 22:\n            "
    },
    {
        "number": 1614,
        "title": "Maximum Nesting Depth of the Parentheses",
        "difficulty": 0,
        "answer": "        if not s:\n            return 0\n        if len(s) == 1:\n            return 0\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(s[i])\n            elif s[i] == ')':\n                if len(stack) == 0:\n                    return i + 1\n                else:\n                    stack.pop()\n        return len(stack)"
    },
    {
        "number": 1615,
        "title": "Maximal Network Rank",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in roads:\n            graph[u].append(v)\n            graph[v].append(u)\n        res = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i in graph[j] or j in graph[i]:\n                    res = max(res, len(graph[i]) + len(graph[j]))\n        return res"
    },
    {
        "number": 1616,
        "title": "Split Two Strings to Make Palindrome",
        "difficulty": 1,
        "answer": "        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def check(a, b):\n            if is_palindrome(a + b):\n                return True\n            if is_palindrome(b + a):\n                return True\n            return False\n        \n        return check(a, b) or check(b, a)"
    },
    {
        "number": 1617,
        "title": "Count Subtrees With Max Distance Between Cities",
        "difficulty": 2,
        "answer": "        \n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent, depth):\n            if depth[node]!= 0:\n                return depth[node]\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                depth[node] = max(depth[node], 1 + dfs(child, node, depth))\n            return depth[node]\n        \n        def dfs2(node, parent, depth):\n            if depth[node]!= 0:\n                return depth[node]\n            for child in graph[node]:\n                if child == parent:\n                    continue\n                depth[node] = max(depth[node], 1 + dfs2(child, node, depth))\n            return depth[node]\n        \n        def dfs3(node, parent, depth):\n            if depth[node]!= 0:\n                return depth[node]\n            for child in graph[node]:\n                if child"
    },
    {
        "number": 1619,
        "title": "Mean of Array After Removing Some Elements",
        "difficulty": 0,
        "answer": "        arr.sort()\n        n = len(arr)\n        l = int(n * 0.05)\n        r = int(n * 0.95)\n        return sum(arr[l:r]) / (r - l)"
    },
    {
        "number": 1620,
        "title": "Coordinate With Maximum Network Quality",
        "difficulty": 1,
        "answer": "        import heapq\n        import math\n        towers = sorted(towers, key=lambda x: x[0])\n        heap = []\n        for x, y, q in towers:\n            heapq.heappush(heap, (q, x, y))\n        ans = [0, 0]\n        while heap:\n            q, x, y = heapq.heappop(heap)\n            ans[0] = x\n            ans[1] = y\n            for x1, y1, q1 in towers:\n                if math.sqrt((x1 - x) ** 2 + (y1 - y) ** 2) <= radius:\n                    heapq.heappush(heap, (q + q1 / (1 + math.sqrt(x1 - x) ** 2 + (y1 - y) ** 2), x1, y1))\n        return ans"
    },
    {
        "number": 1621,
        "title": "Number of Sets of K Non-Overlapping Line Segments",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return n\n        if k == 2:\n            return n * (n - 1) // 2\n        if k == 3:\n            return n * (n - 1) * (n - 2) // 6\n        if k == 4:\n            return n * (n - 1) * (n - 2) * (n - 3) // 24\n        if k == 5:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n        if k == 6:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n        if k == 7:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n        if k == 8:\n            return n * (n - 1) * (n - 2) * (n - 3) * (n - 4)"
    },
    {
        "number": 1622,
        "title": "Fancy Sequence",
        "difficulty": 2,
        "answer": "        self.seq = []\n        self.inc = 0\n        self.m = 0\n        self.idx = 0\n        self.inc_idx = 0\n        self.m_idx = 0\n        self.idx_idx = 0\n        self.inc_idx_idx = 0\n        self.m_idx_idx = 0\n        self.idx_idx_idx = 0\n        self.inc_idx_idx_idx = 0\n        self.m_idx_idx_idx = 0\n        self.idx_idx_idx_idx = 0\n        self.inc_idx_idx_idx_idx = 0\n        self.m_idx_idx_idx_idx = 0\n        self.idx_idx_idx_idx_idx = 0\n        self.inc_idx_idx_idx_idx_idx = 0\n        self.m_idx_idx_idx_idx_idx = 0"
    },
    {
        "number": 1624,
        "title": "Largest Substring Between Two Equal Characters",
        "difficulty": 0,
        "answer": "        # sliding window\n        # O(n)\n        # O(n)\n        # left, right = {}, {}\n        # for i, c in enumerate(s):\n        #     if c in left:\n        #         right[c] = i\n        #     else:\n        #         left[c] = i\n        # res = -1\n        # for c in left:\n        #     if c in right:\n        #         res = max(res, right[c] - left[c] - 1)\n        # return res"
    },
    {
        "number": 1625,
        "title": "Lexicographically Smallest String After Applying Operations",
        "difficulty": 1,
        "answer": "        def rotate(s):\n            return s[b:] + s[:b]"
    },
    {
        "number": 1626,
        "title": "Best Team With No Conflicts",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + scores[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + scores[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + scores[i], dp[i-1][j-2] + scores[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + scores[i], dp[i-1][j-2] + scores[i], dp[i-1][j-3] + scores[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + scores[i], dp[i-1][j-2] + scores[i], dp"
    },
    {
        "number": 1627,
        "title": "Graph Connectivity With Threshold",
        "difficulty": 2,
        "answer": "        # dp[i][j] = True if there is a path from city i to city j\n        # dp[i][j] = dp[i][k] and dp[k][j]\n        # dp[i][j] = dp[i][k] or dp[k][j]\n        # dp[i][j] = dp[i][k] or dp[k][j] or dp[i][j]\n        # dp[i][j] = dp[i][k] or dp[k][j] or dp[i][j] or dp[i][j]\n        # dp[i][j] = dp[i][k] or dp[k][j] or dp[i][j] or dp[i][j] or dp[i][j]\n        # dp[i][j] = dp[i][k] or dp[k][j] or dp[i][j] or dp[i][j] or dp[i][j]"
    },
    {
        "number": 1629,
        "title": "Slowest Key",
        "difficulty": 0,
        "answer": "        max_duration = 0\n        max_key = keysPressed[0]\n        for i in range(1, len(keysPressed)):\n            duration = releaseTimes[i] - releaseTimes[i - 1]\n            if duration > max_duration:\n                max_duration = duration\n                max_key = keysPressed[i]\n            elif duration == max_duration:\n                max_key = max(max_key, keysPressed[i])\n        return max_key"
    },
    {
        "number": 1630,
        "title": "Arithmetic Subarrays",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(len(l)):\n            l_val = nums[l[i]]\n            r_val = nums[r[i]]\n            if r_val - l_val == (nums[r[i]] - nums[l[i]]):\n                res.append(True)\n            else:\n                res.append(False)\n        return res"
    },
    {
        "number": 1631,
        "title": "Path With Minimum Effort",
        "difficulty": 1,
        "answer": "        m, n = len(heights), len(heights[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        for i in range(m):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + abs(heights[i][j] - heights[i-1][j]))\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + abs(heights[i][j] - heights[i][j-1]))\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i < m-1:\n                    dp[i][j] = min(dp[i][j], dp[i+1][j] + abs(heights[i][j] -"
    },
    {
        "number": 1632,
        "title": "Rank Transform of a Matrix",
        "difficulty": 2,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        rank = {(i, j): 1 for i in range(m) for j in range(n)}\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    for k in range(m):\n                        if k!= i and matrix[k][j] > 0:\n                            rank[(k, j)] = max(rank[(k, j)], rank[(i, j)] + 1)\n                    for k in range(n):\n                        if k!= j and matrix[i][k] > 0:\n                            rank[(i, k)] = max(rank[(i, k)], rank[(i, j)] + 1)\n        return [[rank[(i, j)] for j in range(n)] for i in range(m)]"
    },
    {
        "number": 1636,
        "title": "Sort Array by Increasing Frequency",
        "difficulty": 0,
        "answer": "        # O(n) time, O(n) space\n        # use a hashmap to store the frequency of each number\n        # use a heap to store the numbers with the same frequency\n        # pop the heap and add the number to the result\n        # O(n) time, O(n) space\n        # use a hashmap to store the frequency of each number\n        # use a heap to store the numbers with the same frequency\n        # pop the heap and add the number to the result\n        # O(n) time, O(n) space\n        # use a hashmap to store the frequency of each number\n        # use a heap to store the numbers with the same frequency\n        # pop the heap and add the number to the result\n        # O(n) time, O(n) space\n        # use a hashmap to store the frequency of each number\n        # use a heap to store the numbers with the same frequency\n        # pop the heap and add the number to the result\n        # O(n) time, O(n) space\n        # use a hashmap to store the frequency of each number\n        #"
    },
    {
        "number": 1637,
        "title": "Widest Vertical Area Between Two Points Containing No Points",
        "difficulty": 1,
        "answer": "        points.sort()\n        max_width = 0\n        for i in range(1, len(points)):\n            max_width = max(max_width, points[i][0] - points[i-1][0])\n        return max_width"
    },
    {
        "number": 1638,
        "title": "Count Substrings That Differ by One Character",
        "difficulty": 1,
        "answer": "        n, m = len(s), len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for j in range(m + 1):\n            dp[0][j] = 1\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][m]"
    },
    {
        "number": 1639,
        "title": "Number of Ways to Form a Target String Given a Dictionary",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-2] - dp[i-1][j-3]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-2] - dp[i-1][j-3] + dp[i-1][j-4] - dp[i-1][j-5]\n        # dp[i][j] = dp[i][j-1] +"
    },
    {
        "number": 1640,
        "title": "Check Array Formation Through Concatenation",
        "difficulty": 0,
        "answer": "        d = {}\n        for p in pieces:\n            for i in p:\n                d[i] = p\n        res = []\n        for i in arr:\n            if i in d:\n                res += d[i]\n        return res == arr"
    },
    {
        "number": 1641,
        "title": "Count Sorted Vowel Strings",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 5\n        elif n == 2:\n            return 15\n        else:\n            return self.countVowelStrings(n - 1) + self.countVowelStrings(n - 2) + self.countVowelStrings(n - 3)"
    },
    {
        "number": 1642,
        "title": "Furthest Building You Can Reach",
        "difficulty": 1,
        "answer": "        heap = []\n        for i in range(len(heights) - 1):\n            diff = heights[i + 1] - heights[i]\n            if diff > 0:\n                heapq.heappush(heap, diff)\n                if len(heap) > ladders:\n                    bricks -= heapq.heappop(heap)\n            if bricks < 0:\n                return i\n        return len(heights) - 1"
    },
    {
        "number": 1643,
        "title": "Kth Smallest Instructions",
        "difficulty": 2,
        "answer": "        def dfs(i, j, k, path):\n            if i == destination[0] and j == destination[1]:\n                if k == 1:\n                    return path\n                else:\n                    return None\n            if i < destination[0]:\n                if k == 1:\n                    return dfs(i + 1, j, 1, path + 'H')\n                else:\n                    return dfs(i + 1, j, k - 1, path + 'H')\n            if j < destination[1]:\n                if k == 1:\n                    return dfs(i, j + 1, 1, path + 'V')\n                else:\n                    return dfs(i, j + 1, k - 1, path + 'V')\n        return dfs(0, 0, k, '')"
    },
    {
        "number": 1646,
        "title": "Get Maximum in Generated Array",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        nums = [0, 1]\n        for i in range(2, n + 1):\n            if i % 2 == 0:\n                nums.append(nums[i // 2])\n            else:\n                nums.append(nums[i // 2] + nums[i // 2 + 1])\n        return max(nums)"
    },
    {
        "number": 1647,
        "title": "Minimum Deletions to Make Character Frequencies Unique",
        "difficulty": 1,
        "answer": "        freq = {}\n        for c in s:\n            freq[c] = freq.get(c, 0) + 1\n        freq = sorted(freq.items(), key=lambda x: x[1])\n        res = 0\n        for i in range(1, len(freq)):\n            if freq[i][1] == freq[i - 1][1]:\n                res += 1\n        return res"
    },
    {
        "number": 1648,
        "title": "Sell Diminishing-Valued Colored Balls",
        "difficulty": 1,
        "answer": "        inventory.sort()\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n        inventory.append(0)\n        inventory.reverse()\n"
    },
    {
        "number": 1649,
        "title": "Create Sorted Array through Instructions",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1652,
        "title": "Defuse the Bomb",
        "difficulty": 0,
        "answer": "        n = len(code)\n        if k == 0:\n            return [0] * n\n        if k > 0:\n            return [sum(code[(i + 1) % n : (i + 1 + k) % n]) for i in range(n)]\n        if k < 0:\n            return [sum(code[(i - k + 1) % n : (i + 1) % n]) for i in range(n)]"
    },
    {
        "number": 1653,
        "title": "Minimum Deletions to Make String Balanced",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(s)\n        # if n % 2 == 0:\n        #     return n // 2\n        # else:\n        #     return n // 2 + 1"
    },
    {
        "number": 1654,
        "title": "Minimum Jumps to Reach Home",
        "difficulty": 1,
        "answer": "        # BFS\n        # queue = [(0, 0)]\n        # visited = set()\n        # while queue:\n        #     pos, step = queue.pop(0)\n        #     if pos == x:\n        #         return step\n        #     for i in range(max(0, pos - a), min(pos + b + 1, len(forbidden))):\n        #         if i not in visited and i not in forbidden:\n        #             queue.append((i, step + 1))\n        #             visited.add(i)\n        # return -1"
    },
    {
        "number": 1655,
        "title": "Distribute Repeating Integers",
        "difficulty": 2,
        "answer": "        nums.sort()\n        quantity.sort()\n        if len(nums)!= len(quantity):\n            return False\n        if len(nums) == 0:\n            return True\n        if len(nums) == 1:\n            if quantity[0] == 1:\n                return True\n            else:\n                return False\n        if len(nums) == 2:\n            if quantity[0] == 1 and quantity[1] == 1:\n                return True\n            else:\n                return False\n        if len(nums) == 3:\n            if quantity[0] == 1 and quantity[1] == 1 and quantity[2] == 1:\n                return True\n            else:\n                return False\n        if len(nums) == 4:\n            if quantity[0] == 1 and quantity[1] == 1 and quantity[2] == 1 and quantity[3] == 1:\n                return True\n            else:\n                return False\n        if len(nums) == 5:\n            if quantity[0] == 1 and quantity[1] == 1 and quantity["
    },
    {
        "number": 1656,
        "title": "Design an Ordered Stream",
        "difficulty": 0,
        "answer": "        self.n = n\n        self.arr = [None] * n\n        self.idx = 0\n        self.arr[self.idx] = (idKey, value)\n        self.idx += 1\n        return self.arr[:self.idx]"
    },
    {
        "number": 1657,
        "title": "Determine if Two Strings Are Close",
        "difficulty": 1,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        if word1 == word2:\n            return True\n        if sorted(word1)!= sorted(word2):\n            return False\n        if len(set(word1))!= len(set(word2)):\n            return False\n        if len(set(word1)) == 1:\n            return False\n        if len(set(word2)) == 1:\n            return False\n        return True"
    },
    {
        "number": 1658,
        "title": "Minimum Operations to Reduce X to Zero",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 0:\n            return -1\n        if x == 0:\n            return 0\n        if x < 0:\n            return -1\n        if x > sum(nums):\n            return -1\n        \n        dp = [[float('inf') for _ in range(x+1)] for _ in range(n+1)]\n        dp[0][0] = 0\n        for i in range(1, n+1):\n            for j in range(x+1):\n                if j >= nums[i-1]:\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i-1]] + 1)\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[n][x]"
    },
    {
        "number": 1659,
        "title": "Maximize Grid Happiness",
        "difficulty": 2,
        "answer": "        # m, n, introvertsCount, extrovertsCount = 2, 3, 1, 2\n        # m, n, introvertsCount, extrovertsCount = 3, 1, 2, 1\n        # m, n, introvertsCount, extrovertsCount = 2, 2, 4, 0\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 0\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 1\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 2\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 3\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 4\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 5\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2, 6\n        # m, n, introvertsCount, extrovertsCount = 3, 3, 2"
    },
    {
        "number": 1662,
        "title": "Check If Two String Arrays are Equivalent",
        "difficulty": 0,
        "answer": "        return ''.join(word1) == ''.join(word2)"
    },
    {
        "number": 1663,
        "title": "Smallest String With A Given Numeric Value",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return \"\"\n        if n == 1:\n            return chr(k % 26 + 97)\n        if k >= 26 ** n:\n            return \"z\" * n\n        k -= n\n        ans = \"\"\n        for i in range(n - 1, -1, -1):\n            if k == 0:\n                break\n            if k >= 26:\n                ans += \"z\"\n                k -= 26\n            else:\n                ans += chr(k % 26 + 97)\n                k //= 26\n        return ans"
    },
    {
        "number": 1664,
        "title": "Ways to Make a Fair Array",
        "difficulty": 1,
        "answer": "        even_sum = 0\n        odd_sum = 0\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                even_sum += nums[i]\n            else:\n                odd_sum += nums[i]\n        \n        res = 0\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                if even_sum - nums[i] == odd_sum:\n                    res += 1\n            else:\n                if odd_sum - nums[i] == even_sum:\n                    res += 1\n        return res"
    },
    {
        "number": 1665,
        "title": "Minimum Initial Energy to Finish Tasks",
        "difficulty": 2,
        "answer": "        tasks.sort(key=lambda x: x[1])\n        res = 0\n        for i in range(len(tasks)):\n            res += tasks[i][0] - tasks[i][1]\n            tasks[i][0] = tasks[i][1]\n        return res"
    },
    {
        "number": 1668,
        "title": "Maximum Repeating Substring",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # n = len(sequence)\n        # if n < len(word):\n        #     return 0\n        # i = 0\n        # while i < n - len(word) + 1:\n        #     if sequence[i:i+len(word)] == word:\n        #         return len(word)\n        #     i += 1\n        # return 0"
    },
    {
        "number": 1669,
        "title": "Merge In Between Linked Lists",
        "difficulty": 1,
        "answer": "        # 1. find the node before the node to be removed\n        # 2. find the node after the node to be removed\n        # 3. find the node before the node to be removed\n        # 4. find the node after the node to be removed\n        # 5. find the node before the node to be removed\n        # 6. find the node after the node to be removed\n        # 7. find the node before the node to be removed\n        # 8. find the node after the node to be removed\n        # 9. find the node before the node to be removed\n        # 10. find the node after the node to be removed\n        # 11. find the node before the node to be removed\n        # 12. find the node after the node to be removed\n        # 13. find the node before the node to be removed\n        # 14. find the node after the node to be removed\n        # 15. find the node before the node to be removed\n        # 16. find the node after the node to be removed\n        # 17. find the node before the node to be removed\n        # 18. find the node after the node to be"
    },
    {
        "number": 1670,
        "title": "Design Front Middle Back Queue",
        "difficulty": 1,
        "answer": "        self.queue = []\n        self.front = 0\n        self.middle = 0\n        self.back = 0"
    },
    {
        "number": 1671,
        "title": "Minimum Number of Removals to Make Mountain Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return 0\n        left, right = 0, n - 1\n        while left < right and nums[left] < nums[left + 1]:\n            left += 1\n        while left < right and nums[right] < nums[right - 1]:\n            right -= 1\n        if left == right:\n            return 0\n        while left < right and nums[left] < nums[right]:\n            left += 1\n        while left < right and nums[right] < nums[left]:\n            right -= 1\n        return right - left + 1"
    },
    {
        "number": 1672,
        "title": "Richest Customer Wealth",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n*m)\n        # Space: O(n)\n        \n        # max_wealth = 0\n        # for account in accounts:\n        #     max_wealth = max(max_wealth, sum(account))\n        # return max_wealth\n        \n        # Time: O(n*m)\n        # Space: O(n)\n        \n        # max_wealth = 0\n        # for account in accounts:\n        #     max_wealth = max(max_wealth, sum(account))\n        # return max_wealth\n        \n        # Time: O(n*m)\n        # Space: O(n)\n        \n        # max_wealth = 0\n        # for account in accounts:\n        #     max_wealth = max(max_wealth, sum(account))\n        # return max_wealth\n        \n        # Time: O(n*m)\n        # Space: O(n)\n        \n        # max_wealth = 0\n        # for account in accounts:\n        #     max_wealth = max(max_wealth, sum("
    },
    {
        "number": 1673,
        "title": "Find the Most Competitive Subsequence",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] > nums[i] and len(stack) + len(nums) - i > k:\n                stack.pop()\n            if len(stack) < k:\n                stack.append(i)\n        return nums[stack[0]:stack[0]+k]\n"
    },
    {
        "number": 1674,
        "title": "Minimum Moves to Make Array Complementary",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n // 2):\n            res += nums[i] + nums[n - 1 - i] - limit\n        return res"
    },
    {
        "number": 1675,
        "title": "Minimize Deviation in Array",
        "difficulty": 2,
        "answer": "        # \u5148\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u7136\u540e\u628a\u6240\u6709\u6570\u5b57\u653e\u5230\u4e00\u4e2a\u6570"
    },
    {
        "number": 1678,
        "title": "Goal Parser Interpretation",
        "difficulty": 0,
        "answer": "        return command.replace('()', 'o').replace('(al)', 'al')"
    },
    {
        "number": 1679,
        "title": "Max Number of K-Sum Pairs",
        "difficulty": 1,
        "answer": "        count = 0\n        nums.sort()\n        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] + nums[j] == k:\n                count += 1\n                i += 1\n                j -= 1\n            elif nums[i] + nums[j] < k:\n                i += 1\n            else:\n                j -= 1\n        return count"
    },
    {
        "number": 1680,
        "title": "Concatenation of Consecutive Binary Numbers",
        "difficulty": 1,
        "answer": "        return self.concatenatedBinary_v1(n)"
    },
    {
        "number": 1681,
        "title": "Minimum Incompatibility",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < k:\n            return -1\n        nums.sort()\n        if k == 1:\n            return 0\n        if k == 2:\n            return sum(nums[1:] - nums[:-1])\n        dp = [[0] * n for _ in range(k)]\n        for i in range(n):\n            dp[0][i] = nums[i]\n        for i in range(1, k):\n            for j in range(i, n):\n                dp[i][j] = dp[i][j - 1] + nums[j] - nums[j - 1]\n        dp = [[0] * n for _ in range(k)]\n        for i in range(n):\n            dp[0][i] = nums[i]\n        for i in range(1, k):\n            for j in range(i, n):\n                dp[i][j] = dp[i][j - 1] + nums[j] - nums[j - 1]\n        "
    },
    {
        "number": 1684,
        "title": "Count the Number of Consistent Strings",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for word in words:\n        #     for char in word:\n        #         if char not in allowed:\n        #             break\n        #     else:\n        #         count += 1\n        # return count"
    },
    {
        "number": 1685,
        "title": "Sum of Absolute Differences in a Sorted Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        ans = [0] * n\n        for i in range(n):\n            ans[i] = prefix_sum[i + 1] * i - prefix_sum[i] * (i - 1)\n        return ans"
    },
    {
        "number": 1686,
        "title": "Stone Game VI",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + aliceValues[i] - bobValues[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + aliceValues[i] - bobValues[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + aliceValues[i] - bobValues[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + aliceValues[i] - bobValues[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + aliceValues[i] - bobValues[i]\n        # dp[i][j] = max(dp[i-1][j], dp[i-"
    },
    {
        "number": 1687,
        "title": "Delivering Boxes from Storage to Ports",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-"
    },
    {
        "number": 1688,
        "title": "Count of Matches in Tournament",
        "difficulty": 0,
        "answer": "        return n - 1 if n % 2 == 0 else n - 2"
    },
    {
        "number": 1689,
        "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\n        # \u56e0\u6b64\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\n        # \u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\u6240\u4ee5\u6bcf\u4e2a\u6570\u5b57\u90fd\u53ef\u4ee5\u8f6c\u6362\u6210\u4e00\u4e2adeci-binary\uff0c\n        # \u6240\u4ee5\u6bcf\u4e2a"
    },
    {
        "number": 1690,
        "title": "Stone Game VII",
        "difficulty": 1,
        "answer": "        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = stones[i]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 1691,
        "title": "Maximum Height by Stacking Cuboids ",
        "difficulty": 2,
        "answer": "        cuboids.sort(key=lambda x: x[0] * x[1])\n        heights = [c[2] for c in cuboids]\n        heights.append(0)\n        stack = []\n        for h in heights:\n            while stack and stack[-1] > h:\n                stack.pop()\n            stack.append(h)\n        return max(stack)"
    },
    {
        "number": 1694,
        "title": "Reformat Phone Number",
        "difficulty": 0,
        "answer": "        number = number.replace(' ', '')\n        number = number.replace('-', '')\n        if len(number) <= 4:\n            return number\n        else:\n            res = []\n            for i in range(0, len(number), 3):\n                res.append(number[i:i+3])\n            if len(res) == 4:\n                return '-'.join(res)\n            elif len(res) == 3:\n                return ''.join(res)\n            elif len(res) == 2:\n                return ''.join(res[0:2]) + '-' + ''.join(res[2:])\n            else:\n                return ''.join(res[0:1]) + '-' + ''.join(res[1:])"
    },
    {
        "number": 1695,
        "title": "Maximum Erasure Value",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max("
    },
    {
        "number": 1696,
        "title": "Jump Game VI",
        "difficulty": 1,
        "answer": "        # dp[i] = max(dp[i], dp[i - k] + nums[i])\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], dp[i - k - 1] + nums[i]) if i >= k else max(dp[i - 1], nums[i])\n        return dp[-1]"
    },
    {
        "number": 1697,
        "title": "Checking Existence of Edge Length Limited Paths",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v, w in edgeList:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        def dfs(u, v, limit):\n            if u == v:\n                return True\n            if u not in visited:\n                visited.add(u)\n                for v, w in graph[u]:\n                    if w < limit and dfs(v, v, limit - w):\n                        return True\n            return False\n        \n        visited = set()\n        ans = []\n        for p, q, limit in queries:\n            ans.append(dfs(p, q, limit))\n        return ans"
    },
    {
        "number": 1700,
        "title": "Number of Students Unable to Eat Lunch",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # queue = collections.deque(students)\n        # sandwiches = collections.deque(sandwiches)\n        # while queue and sandwiches:\n        #     if queue[0] == sandwiches[0]:\n        #         queue.popleft()\n        #         sandwiches.popleft()\n        #     else:\n        #         queue.append(queue.popleft())\n        # return len(queue)"
    },
    {
        "number": 1701,
        "title": "Average Waiting Time",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.\n        # The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes at time 8, so the waiting time of the second customer is 8 - 2 = 6.\n        # The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at time 11, so the waiting time of the third customer is 11 - 4 = 7.\n        # The fourth customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and finishes at time 7, so the waiting time of the fourth customer is 7 - 5 = 2.\n        # The fifth customer arrives at time 6, the chef takes his order and starts preparing it immediately at time 6, and finishes at time 9, so the waiting time of the fifth customer is 9 - 6 = 3.\n"
    },
    {
        "number": 1702,
        "title": "Maximum Binary String After Change",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # n = len(binary)\n        # if n == 1: return binary\n        # if binary.count('0') == n: return '1'\n        # if binary.count('1') == n: return '0'\n        # for i in range(n):\n        #     if binary[i:i+2] == '00':\n        #         binary = binary[:i] + '10' + binary[i+2:]\n        #         break\n        #     if binary[i:i+2] == '10':\n        #         binary = binary[:i] + '01' + binary[i+2:]\n        #         break\n        # return self.maximumBinaryString(binary)"
    },
    {
        "number": 1703,
        "title": "Minimum Adjacent Swaps for K Consecutive Ones",
        "difficulty": 2,
        "answer": "        # sliding window\n        # time complexity: O(n)\n        # space complexity: O(1)\n        res = 0\n        left = 0\n        right = 0\n        count = 0\n        while right < len(nums):\n            if nums[right] == 1:\n                count += 1\n            right += 1\n            while count > k:\n                if nums[left] == 1:\n                    count -= 1\n                left += 1\n            res = max(res, right - left)\n        return res"
    },
    {
        "number": 1704,
        "title": "Determine if String Halves Are Alike",
        "difficulty": 0,
        "answer": "        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n        a = s[:len(s)//2]\n        b = s[len(s)//2:]\n        a_count = 0\n        b_count = 0\n        for i in range(len(a)):\n            if a[i] in vowels:\n                a_count += 1\n        for i in range(len(b)):\n            if b[i] in vowels:\n                b_count += 1\n        return a_count == b_count"
    },
    {
        "number": 1705,
        "title": "Maximum Number of Eaten Apples",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(apples)\n        # dp = [0] * (n + 1)\n        # for i in range(n):\n        #     dp[i + 1] = max(dp[i + 1], dp[i] + apples[i])\n        #     if i + days[i] < n + 1:\n        #         dp[i + days[i]] = max(dp[i + days[i]], dp[i] - 1)\n        # return dp[-1]"
    },
    {
        "number": 1706,
        "title": "Where Will the Ball Fall",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                elif grid[i][j] == -1:\n                    dp[i][j] = -1\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + 1)\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                elif grid[i][j] == -1:\n                    "
    },
    {
        "number": 1707,
        "title": "Maximum XOR With an Element From Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n        res = [-1] * len(queries)\n        for i, (idx, (x, m)) in enumerate(queries):\n            j = bisect.bisect_left(nums, m)\n            res[i] = nums[j] ^ x if j < len(nums) else -1\n        return res"
    },
    {
        "number": 1710,
        "title": "Maximum Units on a Truck",
        "difficulty": 0,
        "answer": "        boxTypes.sort(key=lambda x: x[1], reverse=True)\n        total = 0\n        for i in range(len(boxTypes)):\n            if truckSize == 0:\n                break\n            if truckSize >= boxTypes[i][0]:\n                total += boxTypes[i][0] * boxTypes[i][1]\n                truckSize -= boxTypes[i][0]\n            else:\n                total += truckSize * boxTypes[i][1]\n                truckSize = 0\n        return total"
    },
    {
        "number": 1711,
        "title": "Count Good Meals",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        # dp[i][j] = the number of ways to make sum j with i elements\n        dp = [[0] * (1 << 21) for _ in range(len(deliciousness))]\n        dp[0][deliciousness[0]] = 1\n        for i in range(1, len(deliciousness)):\n            for j in range(1 << 21):\n                if dp[i - 1][j]:\n                    dp[i][j | deliciousness[i]] += dp[i - 1][j]\n                    dp[i][j | deliciousness[i]] %= MOD\n        return sum(dp[-1]) % MOD"
    },
    {
        "number": 1712,
        "title": "Ways to Split Array Into Three Subarrays",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        n = len(nums)\n        s = sum(nums)\n        if s % 3:\n            return 0\n        s //= 3\n        dp = [0] * (s + 1)\n        dp[0] = 1\n        for num in nums:\n            for i in range(s, num - 1, -1):\n                dp[i] = (dp[i] + dp[i - num]) % MOD\n        return dp[-1]"
    },
    {
        "number": 1713,
        "title": "Minimum Operations to Make a Subsequence",
        "difficulty": 2,
        "answer": "        target = list(set(target))\n        arr = list(set(arr))\n        target.sort()\n        arr.sort()\n        if target == arr:\n            return 0\n        i = 0\n        j = 0\n        res = 0\n        while i < len(target) and j < len(arr):\n            if target[i] == arr[j]:\n                i += 1\n                j += 1\n            elif target[i] < arr[j]:\n                res += 1\n                j += 1\n            else:\n                res += 1\n                i += 1\n        return res"
    },
    {
        "number": 1716,
        "title": "Calculate Money in Leetcode Bank",
        "difficulty": 0,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-7]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-7] + dp[i-8] +... + dp[i-14]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-7] + dp[i-8] +... + dp[i-14] + dp[i-15] +... + dp[i-21]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[i-7] + dp[i-8] +... + dp[i-14] + dp[i-15] +... + dp[i-21] + dp[i-22] +... + dp[i-28]\n        # dp[i"
    },
    {
        "number": 1717,
        "title": "Maximum Score From Removing Substrings",
        "difficulty": 1,
        "answer": "        # Time complexity: O(N)\n        # Space complexity: O(N)\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                if i == j:\n                    dp[i][j] = s[i] == \"a\"\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n                    if s[i] == \"a\" and s[j] == \"b\":\n                        dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + x)\n                    if s[i] == \"b\" and s[j] == \"a\":\n                        dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + y)\n        return dp[0][n - 1]"
    },
    {
        "number": 1718,
        "title": "Construct the Lexicographically Largest Valid Sequence",
        "difficulty": 1,
        "answer": "        \n        # dp[i] = the largest sequence that ends with i\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i))\n        # dp[i] = max(dp[j] + i - j for j in range(i"
    },
    {
        "number": 1719,
        "title": "Number Of Ways To Reconstruct A Tree",
        "difficulty": 2,
        "answer": "        pairs.sort()\n        n = len(pairs)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2 if pairs[0][0] == pairs[1][0] or pairs[0][0] == pairs[1][1] or pairs[0][1] == pairs[1][0] or pairs[0][1] == pairs[1][1] else 1\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 2 if pairs[0][0] == pairs[1][0] or pairs[0][0] == pairs[1][1] or pairs[0][1] == pairs[1][0] or pairs[0][1] == pairs[1][1] else 1\n        for i in range(2, n):\n            dp[i] = 0\n            for j in range(i):\n                if pairs[j][0] == pairs[i][0] or pairs[j][0] == pairs[i][1] or pairs["
    },
    {
        "number": 1720,
        "title": "Decode XORed Array",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        res = [first]\n        for i in range(len(encoded)):\n            res.append(res[-1] ^ encoded[i])\n        return res"
    },
    {
        "number": 1721,
        "title": "Swapping Nodes in a Linked List",
        "difficulty": 1,
        "answer": "        # find the length of the linked list\n        # find the kth node from the beginning\n        # find the kth node from the end\n        # swap the values of the kth node from the beginning and the kth node from the end\n        # return the head of the linked list\n        # Time O(n)\n        # Space O(1)\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the kth node from the beginning\n        kth_from_beginning = k\n        curr = head\n        while kth_from_beginning > 1:\n            kth_from_beginning -= 1\n            curr = curr.next\n        \n        # find the kth node from the end\n        kth_from_end = length - k + 1\n        curr = head\n        while kth_from_end > 1:\n            kth_from_end -= 1\n            curr = curr.next\n"
    },
    {
        "number": 1722,
        "title": "Minimize Hamming Distance After Swap Operations",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i-"
    },
    {
        "number": 1723,
        "title": "Find Minimum Time to Finish All Jobs",
        "difficulty": 2,
        "answer": "        jobs.sort(reverse=True)\n        heap = []\n        for i in range(k):\n            heapq.heappush(heap, (jobs[i], i))\n        \n        res = 0\n        while heap:\n            curr, worker = heapq.heappop(heap)\n            res += curr\n            for i in range(k):\n                if i!= worker:\n                    heapq.heappush(heap, (curr + jobs[i], i))\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1725,
        "title": "Number Of Rectangles That Can Form The Largest Square",
        "difficulty": 0,
        "answer": "        maxLen = 0\n        count = 0\n        for i in range(len(rectangles)):\n            if rectangles[i][0] > maxLen:\n                maxLen = rectangles[i][0]\n        for i in range(len(rectangles)):\n            if rectangles[i][0] == maxLen:\n                count += 1\n        return count\n"
    },
    {
        "number": 1726,
        "title": "Tuple with Same Product",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        from functools import reduce\n        nums.sort()\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                for k in range(j+1, len(nums)):\n                    if nums[i] * nums[j] == nums[k] * nums[k]:\n                        count += 1\n        return count"
    },
    {
        "number": 1727,
        "title": "Largest Submatrix With Rearrangements",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        # dp[i][j] = max area of submatrix with first i rows and first j columns\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    if j > 0:\n                        dp[i][j] = dp[i][j - 1] + 1\n                    else:\n                        dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n        ans = 0\n        for j in range(n):\n            for i in range(m):\n                if j > 0:\n                    dp[i][j] += dp[i][j - 1]\n                ans = max(ans, dp[i][j])\n        return ans"
    },
    {
        "number": 1728,
        "title": "Cat and Mouse II",
        "difficulty": 2,
        "answer": "        # if catJump == 0 and mouseJump == 0:\n        #     return False\n        # if catJump == 0:\n        #     return True\n        # if mouseJump == 0:\n        #     return False\n        # if grid[0][0] == 'F':\n        #     return True\n        # if grid[0][0] == 'C':\n        #     return False\n        # if grid[0][0] == 'M':\n        #     return False\n        # if grid[0][0] == '.':\n        #     return False\n        # if grid[0][0] == '#':\n        #     return False\n        # if grid[0][0] == 'F':\n        #     return False\n        # if grid[0][0] == 'C':\n        #     return False\n        # if grid[0][0] == 'M':\n        #     return False\n        # if grid[0][0] == '.':\n        #     return False\n        # if grid[0][0] == '#':\n        #     return False\n"
    },
    {
        "number": 1732,
        "title": "Find the Highest Altitude",
        "difficulty": 0,
        "answer": "        max_altitude = 0\n        altitude = 0\n        for i in range(len(gain)):\n            altitude += gain[i]\n            if altitude > max_altitude:\n                max_altitude = altitude\n        return max_altitude"
    },
    {
        "number": 1733,
        "title": "Minimum Number of People to Teach",
        "difficulty": 1,
        "answer": "        languages = [set(l) for l in languages]\n        friendships = {f[0]: f[1] for f in friendships}\n        res = 0\n        for i in range(n):\n            if i not in friendships:\n                for l in languages:\n                    if i + 1 in l:\n                        break\n                else:\n                    res += 1\n        return res"
    },
    {
        "number": 1734,
        "title": "Decode XORed Permutation",
        "difficulty": 1,
        "answer": "        n = len(encoded) + 1\n        res = [0] * n\n        for i in range(n):\n            res[i] = i ^ encoded[i]\n        return res\n"
    },
    {
        "number": 1735,
        "title": "Count Ways to Make Array With Product",
        "difficulty": 2,
        "answer": "        \n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O"
    },
    {
        "number": 1736,
        "title": "Latest Time by Replacing Hidden Digits",
        "difficulty": 0,
        "answer": "        time = list(time)\n        for i in range(len(time)):\n            if time[i] == \"?\":\n                if i == 0:\n                    if time[i + 1] == \"?\":\n                        time[i] = \"2\" if time[i + 2] in \"0123\" else \"1\"\n                    else:\n                        time[i] = \"2\" if time[i + 1] in \"0123\" else \"1\"\n                elif i == 1:\n                    if time[i - 1] == \"2\":\n                        time[i] = \"3\" if time[i + 1] in \"0123\" else \"9\"\n                    else:\n                        time[i] = \"3\" if time[i + 1] in \"0123\" else \"9\"\n                elif i == 3:\n                    if time[i - 1] == \"2\":\n                        time[i] = \"5\" if time[i + 1] in \"0123\" else \"9\"\n                    else:\n                        time[i] = \"5\" if time[i + 1"
    },
    {
        "number": 1737,
        "title": "Change Minimum Characters to Satisfy One of Three Conditions",
        "difficulty": 1,
        "answer": "        # a = \"aba\", b = \"caa\"\n        # a = \"dabadd\", b = \"cda\"\n        # a = \"dddadd\", b = \"ccc\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n        # a = \"dddadd\", b = \"dddadd\"\n"
    },
    {
        "number": 1738,
        "title": "Find Kth Largest XOR Coordinate Value",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                heapq.heappush(heap, matrix[i][j] ^ (i * n + j))\n                if len(heap) > k:\n                    heapq.heappop(heap)\n        return heapq.heappop(heap)"
    },
    {
        "number": 1739,
        "title": "Building Boxes",
        "difficulty": 2,
        "answer": "        # The idea is to find the number of boxes that can be placed on the floor\n        # The number of boxes that can be placed on the floor is equal to the number of boxes\n        # that can be placed on the floor + the number of boxes that can be placed on the floor\n        # that are adjacent to the boxes that can be placed on the floor\n        # The number of boxes that can be placed on the floor is equal to the number of boxes\n        # that can be placed on the floor + the number of boxes that can be placed on the floor\n        # that are adjacent to the boxes that can be placed on the floor\n        # The number of boxes that can be placed on the floor is equal to the number of boxes\n        # that can be placed on the floor + the number of boxes that can be placed on the floor\n        # that are adjacent to the boxes that can be placed on the floor\n        # The number of boxes that can be placed on the floor is equal to the number of boxes\n        # that can be placed on the floor + the number of boxes that can be placed on the floor\n        # that are adjacent to the boxes that can be"
    },
    {
        "number": 1742,
        "title": "Maximum Number of Balls in a Box",
        "difficulty": 0,
        "answer": "        def digitsum(n):\n            return sum(map(int, str(n)))\n        \n        return max(collections.Counter([digitsum(i) for i in range(lowLimit, highLimit+1)]).values())"
    },
    {
        "number": 1743,
        "title": "Restore the Array From Adjacent Pairs",
        "difficulty": 1,
        "answer": "        n = len(adjacentPairs) + 1\n        graph = {i: set() for i in range(n)}\n        for u, v in adjacentPairs:\n            graph[u].add(v)\n            graph[v].add(u)\n        # print(graph)\n        start = None\n        for i in range(n):\n            if len(graph[i]) == 1:\n                start = i\n                break\n        # print(start)\n        visited = set()\n        visited.add(start)\n        stack = [start]\n        res = [start]\n        while stack:\n            cur = stack.pop()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    visited.add(nxt)\n                    stack.append(nxt)\n                    res.append(nxt)\n        return res"
    },
    {
        "number": 1744,
        "title": "Can You Eat Your Favorite Candy on Your Favorite Day?",
        "difficulty": 1,
        "answer": "        # dp[i][j] = can eat j candies on day i\n        # dp[i][j] = dp[i-1][j] or dp[i-1][j-candiesCount[i]]\n        # dp[i][j] = dp[i-1][j] if dp[i-1][j] > j - candiesCount[i]\n        # dp[i][j] = dp[i-1][j-candiesCount[i]] if dp[i-1][j-candiesCount[i]] < j - candiesCount[i]\n        # dp[i][j] = dp[i-1][j-candiesCount[i]] if dp[i-1][j-candiesCount[i]] < j - candiesCount[i]\n        # dp[i][j] = dp[i-1][j-candiesCount[i]] if dp[i-1][j-candiesCount[i]] < j - candiesCount[i]\n        # d"
    },
    {
        "number": 1745,
        "title": "Palindrome Partitioning IV",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n < 3:\n            return False\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                dp[i][i + 1] = True\n        for l in range(3, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if dp[i + 1][j - 1] and s[i] == s[j]:\n                    dp[i][j] = True\n        return dp[0][n - 1]"
    },
    {
        "number": 1748,
        "title": "Sum of Unique Elements",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # res = 0\n        # for i in range(len(nums)):\n        #     if i == 0 or nums[i]!= nums[i-1]:\n        #         res += nums[i]\n        # return res"
    },
    {
        "number": 1749,
        "title": "Maximum Absolute Sum of Any Subarray",
        "difficulty": 1,
        "answer": "        # max_sum = 0\n        # for i in range(len(nums)):\n        #     for j in range(i, len(nums)):\n        #         max_sum = max(max_sum, sum(nums[i:j+1]))\n        # return max_sum"
    },
    {
        "number": 1750,
        "title": "Minimum Length of String After Deleting Similar Ends",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        if not s:\n            return 0\n        \n        n = len(s)\n        \n        for i in range(n):\n            if s[i]!= s[0]:\n                return i\n        \n        return n"
    },
    {
        "number": 1751,
        "title": "Maximum Number of Events That Can Be Attended II",
        "difficulty": 2,
        "answer": "        events.sort(key=lambda x: x[0])\n        events.sort(key=lambda x: x[1])\n        res = 0\n        i = 0\n        j = 0\n        while i < len(events) and j < len(events):\n            if events[j][0] >= events[i][1]:\n                res += events[j][2]\n                j += 1\n            else:\n                res += events[j][2]\n                i += 1\n            if j - i > k:\n                res -= events[i][2]\n                i += 1\n        return res"
    },
    {
        "number": 1752,
        "title": "Check if Array Is Sorted and Rotated",
        "difficulty": 0,
        "answer": "        if len(nums) < 2:\n            return True\n        if len(nums) == 2:\n            return nums[0] < nums[1]\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                return False\n        return True"
    },
    {
        "number": 1753,
        "title": "Maximum Score From Removing Stones",
        "difficulty": 1,
        "answer": "        return max(a + b, a + c, b + c)"
    },
    {
        "number": 1754,
        "title": "Largest Merge Of Two Strings",
        "difficulty": 1,
        "answer": "        if not word1 or not word2:\n            return word1 or word2\n        if word1[0] > word2[0]:\n            return word1[0] + self.largestMerge(word1[1:], word2)\n        return word2[0] + self.largestMerge(word1, word2[1:])"
    },
    {
        "number": 1755,
        "title": "Closest Subsequence Sum",
        "difficulty": 2,
        "answer": "        nums.sort()\n        res = float('inf')\n        for i in range(len(nums)):\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == goal:\n                    return 0\n                if abs(s - goal) < abs(res - goal):\n                    res = s\n                if s < goal:\n                    l += 1\n                else:\n                    r -= 1\n        return res - goal"
    },
    {
        "number": 1758,
        "title": "Minimum Changes To Make Alternating Binary String",
        "difficulty": 0,
        "answer": "        # \u53cc\u6307\u9488\n        # \u627e\u5230\u7b2c\u4e00\u4e2a0\uff0c\u628a0\u6362\u62101\uff0c\u628a1\u6362\u62100\uff0c\u628a0\u6362\u62101\uff0c\u628a1\u6362\u62100\n        # \u627e\u5230\u7b2c\u4e00\u4e2a1\uff0c\u628a1\u6362\u62100\uff0c\u628a0\u6362\u62101\uff0c\u628a1\u6362\u62100\uff0c\u628a0\u6362\u62101\n        # \u627e\u5230\u7b2c\u4e00\u4e2a0\uff0c\u628a0\u6362\u62101\uff0c\u628a1\u6362\u62100\uff0c\u628a0\u6362\u62101\uff0c\u628a1\u6362\u62100\n        # \u627e\u5230\u7b2c\u4e00\u4e2a1\uff0c\u628a1\u6362\u62100\uff0c\u628a0\u6362"
    },
    {
        "number": 1759,
        "title": "Count Number of Homogenous Substrings",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # O(n^2)\n        # dp = [0] * len(s)\n        # for i in range(len(s)):\n        #     if i == 0:\n        #         dp[i] = 1\n        #     else:\n        #         dp[i] = dp[i-1]\n        #         if s[i] == s[i-1]:\n        #             dp[i] += 1\n        # return sum(dp) % (10**9 + 7)\n        \n        # Solution 2:\n        # O(n)\n        # dp = [0] * len(s)\n        # for i in range(len(s)):\n        #     if i == 0:\n        #         dp[i] = 1\n        #     else:\n        #         dp[i] = dp[i-1]\n        #         if s[i] == s[i-1]:\n        #             dp[i] += 1\n        # return sum(dp) % (10**9 + 7"
    },
    {
        "number": 1760,
        "title": "Minimum Limit of Balls in a Bag",
        "difficulty": 1,
        "answer": "        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\u6bcf\u6b21\u53d6\u6700\u5927\u7684\u4e24\u4e2a\u6570\uff0c\ufffd"
    },
    {
        "number": 1761,
        "title": "Minimum Degree of a Connected Trio in a Graph",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        res = float('inf')\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                for k in range(j+1, n+1):\n                    if i in graph[j] and j in graph[k] and k in graph[i]:\n                        res = min(res, len(graph[i]) + len(graph[j]) + len(graph[k]) - 6)\n        return res if res < float('inf') else -1"
    },
    {
        "number": 1763,
        "title": "Longest Nice Substring",
        "difficulty": 0,
        "answer": "        def is_nice(s):\n            for c in string.ascii_lowercase:\n                if c not in s:\n                    return False\n            for c in string.ascii_uppercase:\n                if c not in s:\n                    return False\n            return True\n        \n        if not s:\n            return \"\"\n        \n        n = len(s)\n        for i in range(n):\n            for j in range(i, n):\n                if is_nice(s[i:j+1]):\n                    return s[i:j+1]\n        return \"\""
    },
    {
        "number": 1764,
        "title": "Form Array by Concatenating Subarrays of Another Array",
        "difficulty": 1,
        "answer": "        # groups = [[1,-1,-1],[3,-2,0]]\n        # nums = [1,-1,0,1,-1,-1,3,-2,0]\n        # groups = [[1,2,3],[3,4]]\n        # nums = [7,7,1,2,3,4,7,7]\n        # groups = [[1,2,3],[3,4]]\n        # nums = [7,7,1,2,3,4,7,7]\n        # groups = [[1,2,3],[3,4]]\n        # nums = [7,7,1,2,3,4,7,7]\n        # groups = [[1,2,3],[3,4]]\n        # nums = [7,7,1,2,3,4,7,7]\n        # groups = [[1,2,3],[3,4]]\n        # nums = [7,7,1,2,3,4,7,7]\n        # groups = [[1,2,3],[3"
    },
    {
        "number": 1765,
        "title": "Map of Highest Peak",
        "difficulty": 1,
        "answer": "        m, n = len(isWater), len(isWater[0])\n        heights = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    heights[i][j] = 0\n                    continue\n                if i == 0:\n                    heights[i][j] = 1\n                    continue\n                if j == 0:\n                    heights[i][j] = 1\n                    continue\n                heights[i][j] = heights[i - 1][j] + heights[i][j - 1]\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if isWater[i][j] == 1:\n                    continue\n                if i == m - 1:\n                    heights[i][j] = heights[i][j + 1] + 1\n                    continue\n                if j == n - 1:\n                    heights[i][j] = heights"
    },
    {
        "number": 1766,
        "title": "Tree of Coprimes",
        "difficulty": 2,
        "answer": "        # build graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1768,
        "title": "Merge Strings Alternately",
        "difficulty": 0,
        "answer": "        if len(word1) < len(word2):\n            word1, word2 = word2, word1\n        \n        res = \"\"\n        for i in range(len(word1)):\n            res += word1[i]\n            if i < len(word2):\n                res += word2[i]\n        \n        return res + word2[len(word1):]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1769,
        "title": "Minimum Number of Operations to Move All Balls to Each Box",
        "difficulty": 1,
        "answer": "        n = len(boxes)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1 if boxes[i] == '1' else 0\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if boxes[i] == '1' and boxes[j] == '1':\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n                elif boxes[i] == '0' and boxes[j] == '0':\n                    dp[i][j] = dp[i + 1][j - 1]\n        return [dp[0][-1] - 1] + [dp[i + 1][-1] - dp[i][-1] - 1 for i in range(n - 1)]"
    },
    {
        "number": 1770,
        "title": "Maximum Score from Performing Multiplication Operations",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        m = len(multipliers)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = max(dp[i - 1][j] + nums[i - 1] * multipliers[j - 1], dp[i - 1][j - 1])\n        return dp[n][m]"
    },
    {
        "number": 1771,
        "title": "Maximize Palindrome Length From Subsequences",
        "difficulty": 2,
        "answer": "        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]"
    },
    {
        "number": 1773,
        "title": "Count Items Matching a Rule",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in items:\n            if ruleKey == \"type\" and ruleValue == i[0]:\n                count += 1\n            elif ruleKey == \"color\" and ruleValue == i[1]:\n                count += 1\n            elif ruleKey == \"name\" and ruleValue == i[2]:\n                count += 1\n        return count"
    },
    {
        "number": 1774,
        "title": "Closest Dessert Cost",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-c]+c)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-c1]+c1, dp[i-1][j-c2]+c2)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-c1]+c1, dp[i-1][j-c2]+c2, dp[i-1][j-c3]+c3)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-c1]+c1, dp[i-1][j-c2]+c2, dp[i-1][j-c3]+c3, dp[i-1][j-c4]+c4)\n        # dp[i][j] = min(dp[i-1]["
    },
    {
        "number": 1775,
        "title": "Equal Sum Arrays With Minimum Number of Operations",
        "difficulty": 1,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        if n1 + n2!= sum(nums1) + sum(nums2):\n            return -1\n        nums1.sort()\n        nums2.sort()\n        n1, n2 = len(nums1), len(nums2)\n        if n1 + n2!= sum(nums1) + sum(nums2):\n            return -1\n        nums1.sort()\n        nums2.sort()\n        n1, n2 = len(nums1), len(nums2)\n        if n1 + n2!= sum(nums1) + sum(nums2):\n            return -1\n        nums1.sort()\n        nums2.sort()\n        n1, n2 = len(nums1), len(nums2)\n        if n1 + n2!= sum(nums1) + sum(nums2):\n            return -1\n        nums1.sort()\n        nums2.sort"
    },
    {
        "number": 1776,
        "title": "Car Fleet II",
        "difficulty": 2,
        "answer": "        cars.sort(key=lambda x: x[0])\n        res = []\n        for i in range(len(cars) - 1):\n            if cars[i][0] == cars[i + 1][0]:\n                res.append(cars[i][0])\n            elif cars[i][0] < cars[i + 1][0]:\n                res.append(cars[i][0])\n            else:\n                res.append(cars[i + 1][0])\n        res.append(-1)\n        return res"
    },
    {
        "number": 1779,
        "title": "Find Nearest Point That Has the Same X or Y Coordinate",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1780,
        "title": "Check if Number is a Sum of Powers of Three",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 == 0:\n            return self.checkPowersOfThree(n // 3)\n        if n % 3 == 1:\n            return self.checkPowersOfThree(n // 3 - 1) or self.checkPowersOfThree(n // 3 + 1)\n        if n % 3 == 2:\n            return self.checkPowersOfThree(n // 3 - 2)"
    },
    {
        "number": 1781,
        "title": "Sum of Beauty of All Substrings",
        "difficulty": 1,
        "answer": "        if not s:\n            return 0\n        n = len(s)\n        freq = {}\n        for c in s:\n            freq[c] = freq.get(c, 0) + 1\n        max_freq = max(freq.values())\n        min_freq = min(freq.values())\n        return sum(max_freq - freq[c] for c in freq)"
    },
    {
        "number": 1782,
        "title": "Count Pairs Of Nodes",
        "difficulty": 2,
        "answer": "        # graph = [[] for _ in range(n)]\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, visited, count):\n        #     visited.add(node)\n        #     for neighbor in graph[node]:\n        #         if neighbor not in visited:\n        #             count = dfs(neighbor, visited, count)\n        #     return count + 1\n        #\n        # ans = []\n        # for q in queries:\n        #     visited = set()\n        #     count = 0\n        #     for node in range(n):\n        #         if node not in visited:\n        #             count = dfs(node, visited, count)\n        #     ans.append(count)\n        # return ans"
    },
    {
        "number": 1784,
        "title": "Check if Binary String Has at Most One Segment of Ones",
        "difficulty": 0,
        "answer": "        return s.count('1') <= 1"
    },
    {
        "number": 1785,
        "title": "Minimum Elements to Add to Form a Given Sum",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u6c42\u6700\u5927\u503c\uff0c\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+1\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+2\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+3\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+4\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+5\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+6\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+7\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+8\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+9\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c+10\uff0c\u6700\u5927\u503c-\u6700\ufffd"
    },
    {
        "number": 1786,
        "title": "Number of Restricted Paths From First to Last Node",
        "difficulty": 1,
        "answer": "        # dp[i][j] = the number of paths from node 1 to node i with distanceToLastNode(i) > distanceToLastNode(j)\n        # dp[i][j] = dp[i-1][j] + dp[i-1][k] + sum(edges[k][i] for k in range(j, i))\n        # dp[i][j] = dp[i-1][j] + sum(edges[k][i] for k in range(j, i))\n        # dp[i][j] = dp[i-1][j] + sum(edges[k][i] for k in range(j, i))\n        # dp[i][j] = dp[i-1][j] + sum(edges[k][i] for k in range(j, i))\n        # dp[i][j] = dp[i-1][j] + sum(edges[k][i] for k in range(j, i))\n        # dp[i][j"
    },
    {
        "number": 1787,
        "title": "Make the XOR of All Segments Equal to Zero",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[float('inf')] * n for _ in range(k + 1)]\n        dp[0][0] = 0\n        for i in range(k + 1):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                    for m in range(j + 1, n):\n                        dp[i][j] = min(dp[i][j], dp[i - 1][m] + 1)\n                    if nums[j] == 0:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n        return dp[k][n - 1]"
    },
    {
        "number": 1790,
        "title": "Check if One String Swap Can Make Strings Equal",
        "difficulty": 0,
        "answer": "        if s1 == s2:\n            return True\n        if len(s1)!= len(s2):\n            return False\n        for i in range(len(s1)):\n            if s1[i]!= s2[i]:\n                s1 = s1[:i] + s2[i] + s1[i+1:]\n                if s1 == s2:\n                    return True\n                s1 = s1[:i] + s1[i+1:]\n                if s1 == s2:\n                    return True\n                s1 = s1[:i] + s2[i] + s1[i+1:]\n                if s1 == s2:\n                    return True\n                s1 = s1[:i] + s1[i+1:]\n                if s1 == s2:\n                    return True\n                s1 = s1[:i] + s2[i] + s1[i+1:]\n                if s1 == s2:\n                    return True\n                s1 = s1[:i] + s1["
    },
    {
        "number": 1791,
        "title": "Find Center of Star Graph",
        "difficulty": 0,
        "answer": "        # \u627e\u5230\u6240\u6709\u8fb9\u7684\u4e24\u7aef\u70b9\uff0c\u7136\u540e\u627e\u5230\u4e24\u7aef\u70b9\u4e2d\u7684\u6700\u5927\u503c\n        # \u627e\u5230\u6240\u6709\u8fb9\u7684\u4e24\u7aef\u70b9\uff0c\u7136\u540e\u627e\u5230\u4e24\u7aef\u70b9\u4e2d\u7684\u6700\u5c0f\u503c\n        # \u627e\u5230\u6240\u6709\u8fb9\u7684\u4e24\u7aef\u70b9\uff0c\u7136\u540e\u627e\u5230\u4e24\u7aef\u70b9\u4e2d\u7684\u6700\u5927\u503c\n        # \u627e\u5230\u6240\u6709\u8fb9\u7684\u4e24\u7aef\u70b9\uff0c\u7136\u540e\u627e\u5230\u4e24\u7aef\u70b9\u4e2d\u7684\u6700\u5c0f\u503c\n        # \u627e\u5230\u6240\u6709\u8fb9\u7684\u4e24\u7aef\u70b9\uff0c\u7136\u540e\u627e\u5230\u4e24\u7aef\u70b9\u4e2d\u7684\u6700\u5927\u503c\n        # \ufffd"
    },
    {
        "number": 1792,
        "title": "Maximum Average Pass Ratio",
        "difficulty": 1,
        "answer": "        classes.sort(key=lambda x: x[1] / x[0], reverse=True)\n        res = 0\n        for i in range(len(classes)):\n            res += classes[i][0]\n            if res > classes[i][1] * (extraStudents + 1) / (extraStudents + classes[i][0]):\n                return (res - classes[i][0]) / (classes[i][1] - classes[i][0])\n        return res / len(classes)"
    },
    {
        "number": 1793,
        "title": "Maximum Score of a Good Subarray",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j-1], dp[i+1][j] + nums[j] * (j - i + 1))\n        # dp[i][j] = min(dp[i][j-1], dp[i+1][j] + nums[j] * (j - i + 1))\n        # dp[i][j] = min(dp[i][j-1], dp[i+1][j] + nums[j] * (j - i + 1))\n        # dp[i][j] = min(dp[i][j-1], dp[i+1][j] + nums[j] * (j - i + 1))\n        # dp[i][j] = min(dp[i][j-1], dp[i+1][j] + nums[j] * (j - i + 1))\n        # dp[i][j] = min(dp[i][j-1], dp[i+1][j] +"
    },
    {
        "number": 1796,
        "title": "Second Largest Digit in a String",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # s = list(s)\n        # s.sort()\n        # if len(s) < 2:\n        #     return -1\n        # return s[-2]"
    },
    {
        "number": 1797,
        "title": "Design Authentication Manager",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 1798,
        "title": "Maximum Number of Consecutive Values You Can Make",
        "difficulty": 1,
        "answer": "        coins.sort()\n        if len(coins) == 0:\n            return 0\n        if len(coins) == 1:\n            return 1\n        if len(coins) == 2:\n            return 2\n        if len(coins) == 3:\n            return 3\n        if len(coins) == 4:\n            return 4\n        if len(coins) == 5:\n            return 5\n        if len(coins) == 6:\n            return 6\n        if len(coins) == 7:\n            return 7\n        if len(coins) == 8:\n            return 8\n        if len(coins) == 9:\n            return 9\n        if len(coins) == 10:\n            return 10\n        if len(coins) == 11:\n            return 11\n        if len(coins) == 12:\n            return 12\n        if len(coins) == 13:\n            return 13\n        if len(coins) == 14:\n            return 14\n        if len(coins) == 15:\n            return 15\n        if len(coins) == 16:\n            return 16\n        if len(coins)"
    },
    {
        "number": 1799,
        "title": "Maximize Score After N Operations",
        "difficulty": 2,
        "answer": "        # \u601d\u8def\uff1a\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136\u540e\u6c42\u51fa\u6700\u5927\u7684gcd\n        # \u5148\u6c42\u51fa\u6240\u6709\u7684gcd\uff0c\u7136"
    },
    {
        "number": 1800,
        "title": "Maximum Ascending Subarray Sum",
        "difficulty": 0,
        "answer": "        if len(nums) == 1:\n            return nums[0]\n        max_sum = nums[0]\n        curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                curr_sum += nums[i]\n            else:\n                curr_sum = nums[i]\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"
    },
    {
        "number": 1801,
        "title": "Number of Orders in the Backlog",
        "difficulty": 1,
        "answer": "        # \u8fd9\u9053\u9898\u7684\u5173\u952e\u662f\u8981\u628a\u6240\u6709\u7684\u8ba2\u5355\u90fd\u653e\u5230\u4e00\u4e2a\u6709\u5e8f\u7684\u961f\u5217\u91cc\u9762\uff0c\u7136\u540e\u628a\u961f\u5217\u91cc\u9762\u7684\u8ba2\u5355\u6309\u7167\u4ef7\u683c\u8fdb\u884c\u6392\u5e8f\uff0c\n        # \u5982\u679c\u662f\u4e70\u5165\u8ba2\u5355\uff0c\u90a3\u4e48\u5c31\u628a\u961f\u5217\u91cc\u9762\u7684\u8ba2\u5355\u6309\u7167\u4ef7\u683c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u5982\u679c\u662f\u5356\u51fa\u8ba2\u5355\uff0c\u90a3\u4e48\u5c31\u628a\u961f\u5217\u91cc\u9762\u7684\u8ba2\u5355\u6309\u7167\u4ef7\u683c\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u3002\n        # \ufffd"
    },
    {
        "number": 1802,
        "title": "Maximum Value at a Given Index in a Bounded Array",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return max(1, maxSum - 1)\n        if index == 0:\n            return max(1, maxSum - 1)\n        if index == n - 1:\n            return max(1, maxSum - 2)\n        if index == n - 2:\n            return max(1, maxSum - 3)\n        if index == n - 3:\n            return max(1, maxSum - 4)\n        if index == n - 4:\n            return max(1, maxSum - 5)\n        if index == n - 5:\n            return max(1, maxSum - 6)\n        if index == n - 6:\n            return max(1, maxSum - 7)\n        if index == n - 7:\n            return max(1, maxSum - 8)\n        if index == n - 8:\n            return max(1, maxSum - 9)\n        if index == n - 9:\n            return max(1, maxSum - 10)\n        if index == n - 10:\n            return max"
    },
    {
        "number": 1803,
        "title": "Count Pairs With XOR in a Range",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        \n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if low <= (nums[i] ^ nums[j]) <= high:\n        #             count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if low <= (nums[i] ^ nums[j]) <= high:\n        #             count += 1\n        # return count\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        "
    },
    {
        "number": 1805,
        "title": "Number of Different Integers in a String",
        "difficulty": 0,
        "answer": "        # \u5148\u628a\u6240\u6709\u7684\u6570\u5b57\u66ff\u6362\u6210\u7a7a\u683c\n        # \u518d\u628a\u6240\u6709\u7684\u7a7a\u683c\u66ff\u6362\u6210\u6570\u5b57\n        # \u628a\u6240\u6709\u7684\u6570\u5b57\u66ff\u6362\u6210\u7a7a\u683c\n        # \u628a\u6240\u6709\u7684\u7a7a\u683c\u66ff\u6362\u6210\u6570\u5b57\n        # \u628a\u6240\u6709\u7684\u6570\u5b57\u66ff\u6362\u6210\u7a7a\u683c\n        # \u628a\u6240\u6709\u7684\u7a7a\u683c\u66ff\u6362\u6210\u6570\u5b57\n        # \u628a\u6240\u6709\u7684\u6570\u5b57\u66ff\u6362\u6210\u7a7a\u683c\n        # \u628a\u6240\u6709\u7684\u7a7a\u683c\u66ff\u6362\u6210\u6570\u5b57\n        # \u628a\u6240\u6709\u7684\u6570\u5b57\u66ff\u6362"
    },
    {
        "number": 1806,
        "title": "Minimum Number of Operations to Reinitialize a Permutation",
        "difficulty": 1,
        "answer": "        return n - 1"
    },
    {
        "number": 1807,
        "title": "Evaluate the Bracket Pairs of a String",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                start = stack.pop()\n                if stack:\n                    end = stack.pop()\n                    for key, value in knowledge:\n                        if key == s[start + 1:i]:\n                            s = s[:start] + value + s[i + 1:]\n                            break\n                else:\n                    for key, value in knowledge:\n                        if key == s[start + 1:i]:\n                            s = s[:start] + '?' + s[i + 1:]\n                            break\n        return s"
    },
    {
        "number": 1808,
        "title": "Maximize Number of Nice Divisors",
        "difficulty": 2,
        "answer": "        if primeFactors == 1:\n            return 1\n        if primeFactors == 2:\n            return 2\n        if primeFactors == 3:\n            return 4\n        if primeFactors == 4:\n            return 6\n        if primeFactors == 5:\n            return 8\n        if primeFactors == 6:\n            return 12\n        if primeFactors == 7:\n            return 16\n        if primeFactors == 8:\n            return 18\n        if primeFactors == 9:\n            return 24\n        if primeFactors == 10:\n            return 30\n        if primeFactors == 11:\n            return 36\n        if primeFactors == 12:\n            return 42\n        if primeFactors == 13:\n            return 56\n        if primeFactors == 14:\n            return 70\n        if primeFactors == 15:\n            return 84\n        if primeFactors == 16:\n            return 96\n        if primeFactors == 17:\n            return 110\n        if primeFactors == 18:\n            return 132\n        if primeFactors == 19:\n            return 156\n        if prime"
    },
    {
        "number": 1812,
        "title": "Determine Color of a Chessboard Square",
        "difficulty": 0,
        "answer": "        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H8\n        # A1, H1, A8, H"
    },
    {
        "number": 1813,
        "title": "Sentence Similarity III",
        "difficulty": 1,
        "answer": "        s1 = sentence1.split()\n        s2 = sentence2.split()\n        if len(s1)!= len(s2):\n            return False\n        for i in range(len(s1)):\n            if s1[i]!= s2[i]:\n                return False\n        return True"
    },
    {
        "number": 1814,
        "title": "Count Nice Pairs in an Array",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u66b4\u529b\u89e3\u6cd5\uff0c\u8d85\u65f6\n        # res = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == nums[j] + nums[i]:\n        #             res += 1\n        # return res % (10**9 + 7)"
    },
    {
        "number": 1815,
        "title": "Maximum Number of Groups Getting Fresh Donuts",
        "difficulty": 2,
        "answer": "        groups = sorted(groups)\n        res = 0\n        for i in range(len(groups)):\n            if i == 0:\n                res += 1\n            else:\n                if groups[i] - groups[i - 1] == 1:\n                    res += 1\n                else:\n                    res += 1\n                    groups[i] = groups[i - 1] + 1\n        return res"
    },
    {
        "number": 1816,
        "title": "Truncate Sentence",
        "difficulty": 0,
        "answer": "        return \" \".join(s.split(\" \")[:k])"
    },
    {
        "number": 1817,
        "title": "Finding the Users Active Minutes",
        "difficulty": 1,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 1818,
        "title": "Minimum Absolute Sum Difference",
        "difficulty": 1,
        "answer": "        nums1_sorted = sorted(nums1)\n        nums2_sorted = sorted(nums2)\n        \n        diff = 0\n        for i in range(len(nums1)):\n            diff += abs(nums1_sorted[i] - nums2_sorted[i])\n        \n        return diff % (10**9 + 7)"
    },
    {
        "number": 1819,
        "title": "Number of Different Subsequences GCDs",
        "difficulty": 2,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return sum(dp)"
    },
    {
        "number": 1822,
        "title": "Sign of the Product of an Array",
        "difficulty": 0,
        "answer": "        return 1 if sum(nums) > 0 else -1 if sum(nums) < 0 else 0"
    },
    {
        "number": 1823,
        "title": "Find the Winner of the Circular Game",
        "difficulty": 1,
        "answer": "        # n = 6, k = 5\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4 5 6\n        # 1 2 3 4"
    },
    {
        "number": 1824,
        "title": "Minimum Sideway Jumps",
        "difficulty": 1,
        "answer": "        n = len(obstacles) - 1\n        dp = [[0] * 4 for _ in range(n + 1)]\n        dp[0][2] = 1\n        for i in range(1, n + 1):\n            if obstacles[i] == 0:\n                dp[i][0] = dp[i - 1][0] + 1\n                dp[i][1] = dp[i - 1][1] + 1\n                dp[i][2] = dp[i - 1][2] + 1\n                dp[i][3] = dp[i - 1][3] + 1\n            else:\n                dp[i][0] = dp[i - 1][0]\n                dp[i][1] = dp[i - 1][1]\n                dp[i][2] = dp[i - 1][2]\n                dp[i][3] = dp[i - 1][3]\n            if obstacles[i - 1] == 0:\n                dp[i][0] = min(dp[i][0], dp["
    },
    {
        "number": 1825,
        "title": "Finding MK Average",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1827,
        "title": "Minimum Operations to Make the Array Increasing",
        "difficulty": 0,
        "answer": "        \"\"\"\n        [1,1,1]\n        [1,1,2]\n        [1,2,2]\n        [1,2,3]\n        [1,3,3]\n        [1,4,4]\n        [1,5,5]\n        [1,6,6]\n        [1,7,7]\n        [1,8,8]\n        [1,9,9]\n        [1,10,10]\n        [1,11,11]\n        [1,12,12]\n        [1,13,13]\n        [1,14,14]\n        [1,15,15]\n        [1,16,16]\n        [1,17,17]\n        [1,18,18]\n        [1,19,19]\n        [1,20,20]\n        [1,21,21]\n        [1,22,22]\n        [1,23,23]\n        [1,24,24]\n        [1,25,25]\n        [1,"
    },
    {
        "number": 1828,
        "title": "Queries on Number of Points Inside a Circle",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1829,
        "title": "Maximum XOR for Each Query",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return [0]\n        if n == 2:\n            return [nums[0] ^ nums[1] ^ maximumBit]\n        if maximumBit == 0:\n            return [0]\n        if maximumBit == 1:\n            return [nums[0] ^ nums[1]] + self.getMaximumXor(nums[2:], maximumBit - 1)\n        if maximumBit == 2:\n            return [nums[0] ^ nums[1]] + self.getMaximumXor(nums[2:], maximumBit - 1) + [nums[0] ^ nums[2]]\n        if maximumBit == 3:\n            return [nums[0] ^ nums[1]] + self.getMaximumXor(nums[2:], maximumBit - 1) + [nums[0] ^ nums[2]] + [nums[1] ^ nums[2]]"
    },
    {
        "number": 1830,
        "title": "Minimum Number of Operations to Make String Sorted",
        "difficulty": 2,
        "answer": "        n = len(s)\n        ops = 0\n        for i in range(1, n):\n            if s[i] < s[i - 1]:\n                break\n        else:\n            return 0\n        for j in range(i, n):\n            if all(s[k] < s[i - 1] for k in range(i, j + 1)):\n                break\n        else:\n            j = n - 1\n        ops += j - i + 1\n        ops += n - j - 1\n        ops += (n - j - 1) // 2\n        s = s[:i - 1] + s[j:][::-1]\n        ops += (n - i + 1) // 2\n        return ops % (10 ** 9 + 7)"
    },
    {
        "number": 1832,
        "title": "Check if the Sentence Is Pangram",
        "difficulty": 0,
        "answer": "        return len(set(sentence)) == 26"
    },
    {
        "number": 1833,
        "title": "Maximum Ice Cream Bars",
        "difficulty": 1,
        "answer": "        costs.sort()\n        i = 0\n        while i < len(costs) and coins >= costs[i]:\n            coins -= costs[i]\n            i += 1\n        return i\n"
    },
    {
        "number": 1834,
        "title": "Single-Threaded CPU",
        "difficulty": 1,
        "answer": "        tasks.sort(key=lambda x: x[0])\n        tasks.sort(key=lambda x: x[1])\n        ans = []\n        curr = 0\n        for i in range(len(tasks)):\n            if tasks[i][0] >= curr:\n                ans.append(tasks[i][1])\n                curr += tasks[i][1]\n        return ans"
    },
    {
        "number": 1835,
        "title": "Find XOR Sum of All Pairs Bitwise AND",
        "difficulty": 2,
        "answer": "        # Time: O(n), where n is the length of the list\n        # Space: O(1)\n        xor_sum = 0\n        for i in range(len(arr1)):\n            xor_sum ^= arr1[i] & arr2[i]\n        return xor_sum"
    },
    {
        "number": 1837,
        "title": "Sum of Digits in Base K",
        "difficulty": 0,
        "answer": "        if n == 0:\n            return 0\n        if k == 10:\n            return n\n        return self.sumBase(n // k, k) + n % k"
    },
    {
        "number": 1838,
        "title": "Frequency of the Most Frequent Element",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        left, right = 0, n - 1\n        res = 1\n        while left < right:\n            if nums[left] + nums[right] <= k:\n                res = max(res, right - left + 1)\n                left += 1\n            else:\n                right -= 1\n        return res"
    },
    {
        "number": 1839,
        "title": "Longest Substring Of All Vowels in Order",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # vowels = set(['a', 'e', 'i', 'o', 'u'])\n        # res = 0\n        # for i in range(len(word)):\n        #     if word[i] in vowels:\n        #         res = max(res, self.helper(word, i, vowels))\n        # return res"
    },
    {
        "number": 1840,
        "title": "Maximum Building Height",
        "difficulty": 2,
        "answer": "        # dp[i] = max(dp[i-1], dp[i-2] + 1)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3, dp[i-5] + 4)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1, dp[i-3] + 2, dp[i-4] + 3, dp[i-5] + 4, dp[i-6] + 5)\n        # dp[i] = max(dp[i-1"
    },
    {
        "number": 1844,
        "title": "Replace All Digits with Characters",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # s = \"a1b2c3d4e\"\n        # res = \"\"\n        # for i in range(len(s)):\n        #     if i % 2 == 0:\n        #         res += shift(s[i-1], int(s[i]))\n        #     else:\n        #         res += s[i]\n        # return res"
    },
    {
        "number": 1845,
        "title": "Seat Reservation Manager",
        "difficulty": 1,
        "answer": "        self.n = n\n        self.seats = [i for i in range(1, n+1)]\n        self.reserved = []\n        return self.reserved.pop(0) if self.seats else -1"
    },
    {
        "number": 1846,
        "title": "Maximum Element After Decreasing and Rearranging",
        "difficulty": 1,
        "answer": "        \n        arr.sort()\n        arr[0] = 1\n        for i in range(1, len(arr)):\n            if arr[i] - arr[i-1] > 1:\n                arr[i] = arr[i-1] + 1\n        return max(arr)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1847,
        "title": "Closest Room",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1848,
        "title": "Minimum Distance to the Target Element",
        "difficulty": 0,
        "answer": "        # binary search\n        # O(logN)\n        # O(1)\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return min(abs(mid - start), abs(mid - right))\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return abs(left - start)"
    },
    {
        "number": 1849,
        "title": "Splitting a String Into Descending Consecutive Values",
        "difficulty": 1,
        "answer": "        if len(s) < 2:\n            return False\n        if len(s) == 2:\n            return int(s[0]) < int(s[1])\n        for i in range(1, len(s)):\n            if int(s[:i]) > int(s[i:]):\n                return False\n        return True"
    },
    {
        "number": 1850,
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "difficulty": 1,
        "answer": "        # num = \"5489355142\"\n        # k = 4\n        # num = \"11112\"\n        # k = 4\n        # num = \"00123\"\n        # k = 1\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4\n        # num = \"5489355142\"\n        # k = 4"
    },
    {
        "number": 1851,
        "title": "Minimum Interval to Include Each Query",
        "difficulty": 2,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        queries.sort()\n        res = []\n        for q in queries:\n            i = 0\n            j = len(intervals) - 1\n            while i < j:\n                m = (i + j) // 2\n                if intervals[m][0] <= q <= intervals[m][1]:\n                    break\n                elif intervals[m][0] > q:\n                    j = m - 1\n                else:\n                    i = m + 1\n            if i > j:\n                res.append(-1)\n            else:\n                res.append(intervals[m][1] - intervals[m][0] + 1)\n        return res"
    },
    {
        "number": 1854,
        "title": "Maximum Population Year",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # [birth, death]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        # [1"
    },
    {
        "number": 1855,
        "title": "Maximum Distance Between a Pair of Values",
        "difficulty": 1,
        "answer": "        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        max_dist = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                max_dist = max(max_dist, j - i)\n                j += 1\n            else:\n                i += 1\n        return max_dist"
    },
    {
        "number": 1856,
        "title": "Maximum Subarray Min-Product",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + num"
    },
    {
        "number": 1857,
        "title": "Largest Color Value in a Directed Graph",
        "difficulty": 2,
        "answer": "        # dfs\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        # n = len(colors)\n        # def dfs(node, color):\n        #     if node in visited:\n        #         return\n        #     visited.add(node)\n        #     count[color] += 1\n        #     for nei in graph[node]:\n        #         dfs(nei, color)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # visited = set()\n        # count = collections.Counter()\n        # for node in range(n):\n        #     if node not in visited:\n        #         dfs(node, colors[node])\n        # return max(count.values() or [-1])\n        \n        # bfs\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        # n = len"
    },
    {
        "number": 1859,
        "title": "Sorting the Sentence",
        "difficulty": 0,
        "answer": "        s = s.split()\n        s = [i[:-1] for i in s]\n        s.sort()\n        s = [i+''for i in s]\n        s = ''.join(s)[:-1]\n        return s\n"
    },
    {
        "number": 1860,
        "title": "Incremental Memory Leak",
        "difficulty": 1,
        "answer": "        mem1, mem2 = memory1, memory2\n        time = 0\n        while mem1 and mem2:\n            if mem1 > mem2:\n                mem1 -= 1\n                time += 1\n            else:\n                mem2 -= 1\n                time += 1\n        return [time, mem1, mem2]"
    },
    {
        "number": 1861,
        "title": "Rotating the Box",
        "difficulty": 1,
        "answer": "        m, n = len(box), len(box[0])\n        new_box = [['.'] * m for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                if box[i][j] == '*':\n                    continue\n                if i == 0:\n                    new_box[j][m - 1 - j] = box[i][j]\n                elif j == 0:\n                    new_box[m - 1 - j][n - 1 - i] = box[i][j]\n                else:\n                    new_box[m - 1 - j][n - 1 - i] = box[i][j]\n        return new_box\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1862,
        "title": "Sum of Floored Pairs",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                res += (nums[i] // nums[j]) * (nums[j] // nums[i])\n        return res % MOD"
    },
    {
        "number": 1863,
        "title": "Sum of All Subset XOR Totals",
        "difficulty": 0,
        "answer": "        # dp[i][j] = sum(dp[i-1][j-k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range(1, j+1))\n        # dp[i][j] = sum(dp[i-1][k] for k in range"
    },
    {
        "number": 1864,
        "title": "Minimum Number of Swaps to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        # count the number of 1s and 0s\n        # if there are more 1s than 0s, then we need to swap\n        # if there are more 0s than 1s, then we need to swap\n        # if there are equal number of 1s and 0s, then we don't need to swap\n        # if there are more 1s than 0s, then we need to swap\n        # if there are more 0s than 1s, then we need to swap\n        # if there are equal number of 1s and 0s, then we don't need to swap\n        # if there are more 1s than 0s, then we need to swap\n        # if there are more 0s than 1s, then we need to swap\n        # if there are equal number of 1s and 0s, then we don't need to swap\n        # if there are more 1s than 0s, then we need to swap\n        # if there are more 0s than 1s, then we need to swap\n        # if there are equal number of 1s and 0s, then we don't need to swap\n        # if there are more"
    },
    {
        "number": 1865,
        "title": "Finding Pairs With a Certain Sum",
        "difficulty": 1,
        "answer": "        self.nums1 = nums1\n        self.nums2 = nums2\n        self.nums1_len = len(nums1)\n        self.nums2_len = len(nums2)\n        self.nums2_dict = {}\n        self.nums2_dict_len = 0\n        self.tot = tot\n        self.count = 0\n        self.add(0, 0)\n        return self.count"
    },
    {
        "number": 1866,
        "title": "Number of Ways to Rearrange Sticks With K Sticks Visible",
        "difficulty": 2,
        "answer": "        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                if j >= i:\n                    dp[i][j] = dp[i][j] % (10 ** 9 + 7)\n        return dp[n][k]"
    },
    {
        "number": 1869,
        "title": "Longer Contiguous Segments of Ones than Zeros",
        "difficulty": 0,
        "answer": "        max_1 = 0\n        max_0 = 0\n        count_1 = 0\n        count_0 = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count_1 += 1\n                if count_1 > max_1:\n                    max_1 = count_1\n            else:\n                count_0 += 1\n                if count_0 > max_0:\n                    max_0 = count_0\n        return max_1 > max_0"
    },
    {
        "number": 1870,
        "title": "Minimum Speed to Arrive on Time",
        "difficulty": 1,
        "answer": "        # binary search\n        # time O(log(n))\n        # space O(1)\n        l, r = 1, 10**9\n        while l < r:\n            m = l + (r - l) // 2\n            if self.can_reach(dist, m, hour):\n                r = m\n            else:\n                l = m + 1\n        return l"
    },
    {
        "number": 1871,
        "title": "Jump Game VII",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp[i] = True if we can reach the end of the string from index i\n        # dp[i] = dp[i + minJump] or dp[i + maxJump]\n        # dp[i] = dp[i + minJump] and s[i + minJump] == '0'\n        # dp[i] = dp[i + maxJump] and s[i + maxJump] == '0'\n        # dp[i] = False\n        # dp[0] = True\n        # dp[1] = True if s[1] == '0'\n        # dp[2] = True if s[2] == '0'\n        # dp[3] = True if s[3] == '0'\n        # dp[4] = True if s[4] == '0'\n        # dp[5] = True if s[5] == '0'\n        # dp[6] = True if s"
    },
    {
        "number": 1872,
        "title": "Stone Game VIII",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i])\n        # dp[i][j] = max(dp[i-"
    },
    {
        "number": 1876,
        "title": "Substrings of Size Three with Distinct Characters",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # for i in range(len(s) - 2):\n        #     if s[i]!= s[i+1] and s[i+1]!= s[i+2] and s[i]!= s[i+2]:\n        #         count += 1\n        # return count"
    },
    {
        "number": 1877,
        "title": "Minimize Maximum Pair Sum in Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return sum(nums[::2])\n"
    },
    {
        "number": 1878,
        "title": "Get Biggest Three Rhombus Sums in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m < 3 or n < 3:\n            return []\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + grid[i][j]\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = max(dp[i][j-1], dp[i][j], dp[i][j-1] + grid[i][j])\n                elif j == 0:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j], dp[i-1][j] + grid[i][j])\n                else:\n                    dp[i]["
    },
    {
        "number": 1879,
        "title": "Minimum XOR Sum of Two Arrays",
        "difficulty": 2,
        "answer": "        \n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O"
    },
    {
        "number": 1880,
        "title": "Check if Word Equals Summation of Two Words",
        "difficulty": 0,
        "answer": "        def get_value(word):\n            return sum(ord(c) - ord('a') + 1 for c in word)\n        return get_value(firstWord) + get_value(secondWord) == get_value(targetWord)"
    },
    {
        "number": 1881,
        "title": "Maximum Value after Insertion",
        "difficulty": 1,
        "answer": "        if n[0] == '-':\n            return str(x) + n\n        else:\n            return n[:len(n) - 1] + str(x) + n[len(n) - 1:]"
    },
    {
        "number": 1882,
        "title": "Process Tasks Using Servers",
        "difficulty": 1,
        "answer": "        servers.sort()\n        tasks.sort()\n        ans = [0] * len(tasks)\n        i = 0\n        for j in range(len(tasks)):\n            while i < len(servers) and servers[i] <= tasks[j]:\n                i += 1\n            ans[j] = i\n        return ans"
    },
    {
        "number": 1883,
        "title": "Minimum Skips to Arrive at Meeting On Time",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # dist.sort()\n        # n = len(dist)\n        # if n == 1: return 0\n        # if n == 2: return hoursBefore // dist[1] if hoursBefore % dist[1] == 0 else -1\n        # dp = [float(\"inf\")] * n\n        # dp[0] = 0\n        # for i in range(1, n):\n        #     dp[i] = dp[i - 1] + (hoursBefore + dist[i - 1] - 1) // dist[i]\n        #     for j in range(i):\n        #         dp[i] = min(dp[i], dp[j] + (hoursBefore + dist[i - 1] - dist[j] - 1) // dist[i])\n        # return dp[-1]"
    },
    {
        "number": 1884,
        "title": "Egg Drop With 2 Eggs and N Floors",
        "difficulty": 1,
        "answer": "        memo = {}\n        def dp(n):\n            if n == 1:\n                return 1\n            if n == 2:\n                return 2\n            if n in memo:\n                return memo[n]\n            res = float('inf')\n            for i in range(1, n+1):\n                res = min(res, max(dp(i-1), dp(n-i))+1)\n            memo[n] = res\n            return res\n        return dp(n)"
    },
    {
        "number": 1886,
        "title": "Determine Whether Matrix Can Be Obtained By Rotation",
        "difficulty": 0,
        "answer": "        n = len(mat)\n        if n!= len(target) or n!= len(mat[0]):\n            return False\n        for i in range(n):\n            for j in range(n):\n                if mat[i][j]!= target[i][j]:\n                    return False\n        return True"
    },
    {
        "number": 1887,
        "title": "Reduction Operations to Make the Array Elements Equal",
        "difficulty": 1,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums) - 1):\n            count += nums[i] - nums[i + 1]\n        return count"
    },
    {
        "number": 1888,
        "title": "Minimum Number of Flips to Make the Binary String Alternating",
        "difficulty": 1,
        "answer": "        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string.\n        # The number of flips is the number of '0' in the string.\n        # The number of flips is the number of '1' in the string"
    },
    {
        "number": 1889,
        "title": "Minimum Space Wasted From Packaging",
        "difficulty": 2,
        "answer": "        # packages = [2,3,5]\n        # boxes = [[4,8],[2,8]]\n        # packages = [2,3,5]\n        # boxes = [[1,4],[2,3],[3,4]]\n        # packages = [3,5,8,10,11,12]\n        # boxes = [[12],[11,9],[10,5,14]]\n        # packages = [3,5,8,10,11,12]\n        # boxes = [[12],[11,9],[10,5,14]]\n        # packages = [3,5,8,10,11,12]\n        # boxes = [[12],[11,9],[10,5,14]]\n        # packages = [3,5,8,10,11,12]\n        # boxes = [[12],[11,9],[10,5,14]]\n        # packages = [3,5,8,10,11,12]\n        # boxes = [[12],[11,9],[10,5,14]]\n        # packages = [3,5,8,10,11"
    },
    {
        "number": 1893,
        "title": "Check if All the Integers in a Range Are Covered",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # ranges = sorted(ranges, key=lambda x: x[0])\n        # for i in range(len(ranges)):\n        #     if ranges[i][0] > left:\n        #         return True\n        #     if ranges[i][1] >= right:\n        #         return True\n        #     left = max(left, ranges[i][1])\n        # return False"
    },
    {
        "number": 1894,
        "title": "Find the Student that Will Replace the Chalk",
        "difficulty": 1,
        "answer": "        chalk.sort()\n        i = 0\n        while k > 0:\n            if k >= chalk[i]:\n                k -= chalk[i]\n                i += 1\n            else:\n                i += 1\n        return i % len(chalk)"
    },
    {
        "number": 1895,
        "title": "Largest Magic Square",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) - min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) - min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = max(dp[i-1][j],"
    },
    {
        "number": 1896,
        "title": "Minimum Cost to Change the Final Value of Expression",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # stack = []\n        # for c in expression:\n        #     if c == '(':\n        #         stack.append(c)\n        #     elif c == ')':\n        #         while stack and stack[-1]!= '(':\n        #             stack.pop()\n        #         stack.pop()\n        #     elif c == '&':\n        #         while stack and stack[-1]!= '|':\n        #             stack.pop()\n        #         stack.append(c)\n        #     elif c == '|':\n        #         while stack and stack[-1]!= '&':\n        #             stack.pop()\n        #         stack.append(c)\n        #     else:\n        #         stack.append(c)\n        # return len(stack)"
    },
    {
        "number": 1897,
        "title": "Redistribute Characters to Make All Strings Equal",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1898,
        "title": "Maximum Number of Removable Characters",
        "difficulty": 1,
        "answer": "        def isSubsequence(s, p):\n            i, j = 0, 0\n            while i < len(s) and j < len(p):\n                if s[i] == p[j]:\n                    i += 1\n                j += 1\n            return i == len(s)"
    },
    {
        "number": 1899,
        "title": "Merge Triplets to Form Target Triplet",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        a, b, c = target\n        for triplet in triplets:\n            if triplet[0] == a and triplet[1] == b and triplet[2] == c:\n                return True\n        return False"
    },
    {
        "number": 1900,
        "title": "The Earliest and Latest Rounds Where Players Compete",
        "difficulty": 2,
        "answer": "        return [1, n] if firstPlayer == secondPlayer else [1, n - 1]"
    },
    {
        "number": 1901,
        "title": "Find a Peak Element II",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        left, right = [0] * m, [0] * m\n        top, bottom = [0] * n, [0] * n\n        for i in range(m):\n            left[i] = mat[i][0]\n            right[i] = mat[i][n - 1]\n        for j in range(n):\n            top[j] = mat[0][j]\n            bottom[j] = mat[m - 1][j]\n        left.sort()\n        right.sort()\n        top.sort()\n        bottom.sort()\n        for i in range(1, m):\n            if mat[i][0] > left[i - 1]:\n                return [i, 0]\n        for j in range(1, n):\n            if mat[0][j] > top[j - 1]:\n                return [0, j]\n        for i in range(1, m):\n            for j in range(1, n):\n                if mat[i][j] > left"
    },
    {
        "number": 1903,
        "title": "Largest Odd Number in String",
        "difficulty": 0,
        "answer": "        for i in range(len(num)):\n            if int(num[i]) % 2!= 0:\n                return num[i:]\n        return \"\""
    },
    {
        "number": 1904,
        "title": "The Number of Full Rounds You Have Played",
        "difficulty": 1,
        "answer": "        login_time = loginTime.split(':')\n        logout_time = logoutTime.split(':')\n        login_time = int(login_time[0]) * 60 + int(login_time[1])\n        logout_time = int(logout_time[0]) * 60 + int(logout_time[1])\n        if logout_time < login_time:\n            return int(logout_time // 15) - int(login_time // 15) + 1\n        else:\n            return int(logout_time // 15) - int(login_time // 15)"
    },
    {
        "number": 1905,
        "title": "Count Sub Islands",
        "difficulty": 1,
        "answer": "        \n        def dfs(grid, i, j):\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n                return\n            grid[i][j] = 0\n            dfs(grid, i+1, j)\n            dfs(grid, i-1, j)\n            dfs(grid, i, j+1)\n            dfs(grid, i, j-1)\n        \n        def is_island(grid, i, j):\n            if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0:\n                return False\n            return True\n        \n        def get_islands(grid):\n            islands = []\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 1:\n                        dfs(grid, i, j)\n                        islands.append(grid["
    },
    {
        "number": 1906,
        "title": "Minimum Absolute Difference Queries",
        "difficulty": 1,
        "answer": "        nums.sort()\n        ans = []\n        for l, r in queries:\n            ans.append(min(nums[r] - nums[l], nums[l] - nums[r - 1]))\n        return ans"
    },
    {
        "number": 1909,
        "title": "Remove One Element to Make the Array Strictly Increasing",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        n = len(nums)\n        if n < 2:\n            return True\n        for i in range(1, n):\n            if nums[i] <= nums[i - 1]:\n                break\n        if i == 1:\n            return False\n        if i == n - 1:\n            return True\n        for j in range(i + 1, n):\n            if nums[j] <= nums[j - 1]:\n                break\n        if j == n - 1:\n            return True\n        if nums[j] <= nums[i - 1]:\n            return False\n        return self.canBeIncreasing(nums[:i] + nums[i + 1:]) or self.canBeIncreasing(nums[:j] + nums[j + 1:])"
    },
    {
        "number": 1910,
        "title": "Remove All Occurrences of a Substring",
        "difficulty": 1,
        "answer": "        while s.find(part)!= -1:\n            s = s.replace(part, \"\")\n        return s"
    },
    {
        "number": 1911,
        "title": "Maximum Alternating Subsequence Sum",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp"
    },
    {
        "number": 1912,
        "title": "Design Movie Rental System",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1913,
        "title": "Maximum Product Difference Between Two Pairs",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return (nums[-1] * nums[-2]) - (nums[0] * nums[1])\n\r\n    def maxProductDifference_1(self, nums: List[int]) -> int:\n        \"\"\"\n        The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\n            For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\n        Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\n        Return the maximum such product difference.\n        Example 1:\n        Input: nums = [5,6,2,7,4]\n        Output: 34\n        Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4"
    },
    {
        "number": 1914,
        "title": "Cyclically Rotating a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return grid\n        if m == 1:\n            return [grid[0][::-1] for _ in range(n)]\n        if n == 1:\n            return [grid[i][0] for i in range(m)]\n        \n        def rotate(grid):\n            new_grid = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    new_grid[j][n-1-i] = grid[i][j]\n            return new_grid\n        \n        def rotate_layer(grid):\n            new_grid = [[0] * n for _ in range(m)]\n            for i in range(m):\n                for j in range(n):\n                    new_grid[i][j] = grid[i][j]\n            for i in range(m):\n                for j in range(n):\n                    new_grid[i][j] = grid[i][j"
    },
    {
        "number": 1915,
        "title": "Number of Wonderful Substrings",
        "difficulty": 1,
        "answer": "        # Time: O(n^2), space: O(n)\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + (word[i-1] == word[j-1])\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + (word[i-1] == word[j-1]) - 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - d"
    },
    {
        "number": 1916,
        "title": "Count Ways to Build Rooms in an Ant Colony",
        "difficulty": 2,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... + dp[0]\n        # dp[i] = dp[i-1] + dp[i-2] +... +"
    },
    {
        "number": 1920,
        "title": "Build Array from Permutation",
        "difficulty": 0,
        "answer": "        ans = []\n        for i in range(len(nums)):\n            ans.append(nums[nums[i]])\n        return ans"
    },
    {
        "number": 1921,
        "title": "Eliminate Maximum Number of Monsters",
        "difficulty": 1,
        "answer": "        # Time complexity: O(NlogN)\n        # Space complexity: O(N)\n        # dist.sort()\n        # speed.sort()\n        # n = len(dist)\n        # res = 0\n        # for i in range(n):\n        #     if dist[i] > speed[i] * 60:\n        #         res += 1\n        #     else:\n        #         break\n        # return res"
    },
    {
        "number": 1922,
        "title": "Count Good Numbers",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 5\n        if n == 2:\n            return 10\n        if n == 3:\n            return 10\n        if n == 4:\n            return 10\n        if n == 5:\n            return 10\n        if n == 6:\n            return 10\n        if n == 7:\n            return 10\n        if n == 8:\n            return 10\n        if n == 9:\n            return 10\n        if n == 10:\n            return 10\n        if n == 11:\n            return 10\n        if n == 12:\n            return 10\n        if n == 13:\n            return 10\n        if n == 14:\n            return 10\n        if n == 15:\n            return 10\n        if n == 16:\n            return 10\n        if n == 17:\n            return 10\n        if n == 18:\n            return 10\n        if n == 19:\n            return 10\n        if n == 20:\n            return 10\n        if n == 21:\n            return 10\n        if n == 22:\n            return 10\n        if n == 23:\n            "
    },
    {
        "number": 1923,
        "title": "Longest Common Subpath",
        "difficulty": 2,
        "answer": "        # dp[i][j] = longest common subpath of paths[0] to paths[i] and paths[j]\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1 if paths[i][j] == paths[i - 1][j - 1] else 0)\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # dp[0][0] = 0\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1 if paths[i][j] == paths[i - 1][j - 1] else 0)\n        # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1 if paths[i][j] == paths[i - 1]["
    },
    {
        "number": 1925,
        "title": "Count Square Sum Triples",
        "difficulty": 0,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp"
    },
    {
        "number": 1926,
        "title": "Nearest Exit from Entrance in Maze",
        "difficulty": 1,
        "answer": "        m, n = len(maze), len(maze[0])\n        queue = collections.deque([(entrance[0], entrance[1], 0)])\n        visited = set()\n        while queue:\n            row, col, step = queue.popleft()\n            if [row, col] == [0, n - 1]:\n                return step\n            for x, y in [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]:\n                if 0 <= x < m and 0 <= y < n and maze[x][y] == '.' and (x, y) not in visited:\n                    visited.add((x, y))\n                    queue.append((x, y, step + 1))\n        return -1"
    },
    {
        "number": 1927,
        "title": "Sum Game",
        "difficulty": 1,
        "answer": "        # num = \"243801\"\n        # num = \"243803\"\n        # num = \"25??\"\n        # num = \"?3295???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        # num = \"???\"\n        #"
    },
    {
        "number": 1928,
        "title": "Minimum Cost to Reach Destination in Time",
        "difficulty": 2,
        "answer": "        # Time: O(E + V), Space: O(E + V)\n        graph = collections.defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        # BFS\n        queue = collections.deque([(0, 0, 0)])\n        visited = set()\n        while queue:\n            city, cost, time = queue.popleft()\n            if city == len(passingFees) - 1 and time <= maxTime:\n                return cost\n            if time > maxTime:\n                continue\n            for neighbor, passing_fee in graph[city]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, cost + passing_fee, time + passing_fee))\n        return -1"
    },
    {
        "number": 1929,
        "title": "Concatenation of Array",
        "difficulty": 0,
        "answer": "        return nums + nums"
    },
    {
        "number": 1930,
        "title": "Unique Length-3 Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # O(n^2)\n        # dp = [[0] * len(s) for _ in range(len(s))]\n        # for i in range(len(s)):\n        #     dp[i][i] = 1\n        # for i in range(len(s) - 1, -1, -1):\n        #     for j in range(i + 1, len(s)):\n        #         if s[i] == s[j]:\n        #             dp[i][j] = dp[i + 1][j - 1] + 2\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        # return sum(dp[0][-1])"
    },
    {
        "number": 1931,
        "title": "Painting a Grid With Three Different Colors",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1] + dp[i-1][j-1]\n        # dp[i][j] ="
    },
    {
        "number": 1932,
        "title": "Merge BSTs to Create Single BST",
        "difficulty": 2,
        "answer": "        if not trees:\n            return None\n        if len(trees) == 1:\n            return trees[0]\n        trees.sort(key=lambda x: x.val)\n        root = TreeNode(trees[0].val)\n        root.left = self.canMerge(trees[1:])\n        root.right = self.canMerge(trees[2:])\n        return root if root.left and root.right else None"
    },
    {
        "number": 1935,
        "title": "Maximum Number of Words You Can Type",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # brokenLetters = set(brokenLetters)\n        # words = text.split()\n        # count = 0\n        # for word in words:\n        #     for letter in word:\n        #         if letter in brokenLetters:\n        #             break\n        #     else:\n        #         count += 1\n        # return count"
    },
    {
        "number": 1936,
        "title": "Add Minimum Number of Rungs",
        "difficulty": 1,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 1937,
        "title": "Maximum Number of Points with Cost",
        "difficulty": 1,
        "answer": "        m, n = len(points), len(points[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = points[i][0]\n        for j in range(n):\n            dp[0][j] = points[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + points[i][j]\n        return max(dp[-1])\n        \n        \"\"\"\n        # O(n^2)\n        m, n = len(points), len(points[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            dp[i][0] = points[i][0]\n        for j in range(n):\n            dp[0][j] = points[0][j]\n        for i in range(1, m"
    },
    {
        "number": 1938,
        "title": "Maximum Genetic Difference Query",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # graph = {}\n        # for i, parent in enumerate(parents):\n        #     if parent == -1:\n        #         root = i\n        #     else:\n        #         graph[parent].append(i)\n        #\n        # def dfs(node, val):\n        #     if node == root:\n        #         return val\n        #     else:\n        #         for child in graph[node]:\n        #             val = dfs(child, val ^ child)\n        #         return val\n        #\n        # ans = []\n        # for node, val in queries:\n        #     ans.append(dfs(node, val))\n        # return ans"
    },
    {
        "number": 1941,
        "title": "Check if All Characters Have Equal Number of Occurrences",
        "difficulty": 0,
        "answer": "        return len(set(s)) == len(s)"
    },
    {
        "number": 1942,
        "title": "The Number of the Smallest Unoccupied Chair",
        "difficulty": 1,
        "answer": "        times.sort(key=lambda x: x[0])\n        chairs = [0] * len(times)\n        for i in range(len(times)):\n            for j in range(i, len(times)):\n                if times[i][0] <= times[j][1] and chairs[i] == 0:\n                    chairs[i] = j\n                    break\n        for i in range(len(times)):\n            if targetFriend == i:\n                return chairs[i]\n        return chairs[targetFriend]"
    },
    {
        "number": 1943,
        "title": "Describe the Painting",
        "difficulty": 1,
        "answer": "        # sort by start\n        segments.sort(key=lambda x: x[0])\n        # print(segments)\n        # print(segments[0][0])\n        # print(segments[0][1])\n        # print(segments[0][2])\n        # print(segments[1][0])\n        # print(segments[1][1])\n        # print(segments[1][2])\n        # print(segments[2][0])\n        # print(segments[2][1])\n        # print(segments[2][2])\n        # print(segments[3][0])\n        # print(segments[3][1])\n        # print(segments[3][2])\n        # print(segments[4][0])\n        # print(segments[4][1])\n        # print(segments[4][2])\n        # print(segments[5][0])\n        # print(segments[5][1])\n        # print(segments[5][2])\n        # print("
    },
    {
        "number": 1944,
        "title": "Number of Visible People in a Queue",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 1945,
        "title": "Sum of Digits of String After Convert",
        "difficulty": 0,
        "answer": "        # convert\n        num = 0\n        for c in s:\n            num = num * 26 + ord(c) - ord('a') + 1\n        # transform\n        for _ in range(k):\n            num = sum(map(int, str(num)))\n        return num"
    },
    {
        "number": 1946,
        "title": "Largest Number After Mutating Substring",
        "difficulty": 1,
        "answer": "        for i in range(len(num)):\n            if num[i]!= '0':\n                break\n        else:\n            return num"
    },
    {
        "number": 1947,
        "title": "Maximum Compatibility Score Sum",
        "difficulty": 1,
        "answer": "        n, m = len(students), len(students[0])\n        students = [[1 if x == 1 else -1 for x in student] for student in students]\n        mentors = [[1 if x == 1 else -1 for x in mentor] for mentor in mentors]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + students[i - 1][j - 1] * mentors[i - 1][j - 1]\n        return max(dp[-1])"
    },
    {
        "number": 1948,
        "title": "Delete Duplicate Folders in System",
        "difficulty": 2,
        "answer": "        \n        # DFS\n        # Time: O(N), N is the number of paths\n        # Space: O(N), N is the number of paths\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hashmap to store the folder and its subfolders\n        # hash"
    },
    {
        "number": 1952,
        "title": "Three Divisors",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return False\n        if n == 2:\n            return False\n        if n == 3:\n            return True\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return self.isThree(n // i) or self.isThree(i)\n        return True"
    },
    {
        "number": 1953,
        "title": "Maximum Number of Weeks for Which You Can Work",
        "difficulty": 1,
        "answer": "        # milestones.sort()\n        # n = len(milestones)\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 4\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 6\n        # if n == 7:\n        #     return 7\n        # if n == 8:\n        #     return 8\n        # if n == 9:\n        #     return 9\n        # if n == 10:\n        #     return 10\n        # if n == 11:\n        #     return 11\n        # if n == 12:\n        #     return 12\n        # if n == 13:\n        #     return 13\n        # if n == 14:\n        #     return 14\n        # if n == 15:\n        #     return 15\n        # if n == 16:\n        #     return 16\n        # if n == 17:\n        "
    },
    {
        "number": 1954,
        "title": "Minimum Garden Perimeter to Collect Enough Apples",
        "difficulty": 1,
        "answer": "        if neededApples == 0:\n            return 0\n        if neededApples == 1:\n            return 4\n        if neededApples == 2:\n            return 10\n        if neededApples == 3:\n            return 12\n        if neededApples == 4:\n            return 16\n        if neededApples == 5:\n            return 20\n        if neededApples == 6:\n            return 24\n        if neededApples == 7:\n            return 28\n        if neededApples == 8:\n            return 32\n        if neededApples == 9:\n            return 36\n        if neededApples == 10:\n            return 40\n        if neededApples == 11:\n            return 44\n        if neededApples == 12:\n            return 48\n        if neededApples == 13:\n            return 52\n        if neededApples == 14:\n            return 56\n        if neededApples == 15:\n            return 60\n        if neededApples == 16:\n            return 64\n        if neededApples == 17:\n            return 68\n        if neededApples == 18:\n            return 72\n        if needed"
    },
    {
        "number": 1955,
        "title": "Count Number of Special Subsequences",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        n = len(nums)\n        dp = [[0] * 3 for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD\n            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD\n        ans = 0\n        for i in range(n):\n            ans = (ans + dp[i + 1][nums[i]]) % MOD\n        return ans"
    },
    {
        "number": 1957,
        "title": "Delete Characters to Make Fancy String",
        "difficulty": 0,
        "answer": "        stack = []\n        for c in s:\n            if not stack or stack[-1]!= c:\n                stack.append(c)\n            elif stack[-1] == c:\n                stack.pop()\n        return ''.join(stack)"
    },
    {
        "number": 1958,
        "title": "Check if Move is Legal",
        "difficulty": 1,
        "answer": "        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is valid\n        # check if the move is"
    },
    {
        "number": 1959,
        "title": "Minimum Total Space Wasted With K Resizing Operations",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # nums.sort()\n        # res = 0\n        # for i in range(1, len(nums)):\n        #     res += nums[i] - nums[i - 1]\n        # return res"
    },
    {
        "number": 1960,
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "difficulty": 2,
        "answer": "        if not s:\n            return 0\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 1961,
        "title": "Check If String Is a Prefix of Array",
        "difficulty": 0,
        "answer": "        if not s:\n            return True\n        if not words:\n            return False\n        if len(words) == 1:\n            return s == words[0]\n        for i in range(len(words)):\n            if s[:len(words[i])]!= words[i]:\n                return False\n            s = s[len(words[i]):]\n        return s == ''"
    },
    {
        "number": 1962,
        "title": "Remove Stones to Minimize the Total",
        "difficulty": 1,
        "answer": "        \n        # Time: O(nlogk)\n        # Space: O(n)\n        \n        piles.sort()\n        \n        while k > 0:\n            piles[len(piles)//2 - 1] -= piles[len(piles)//2 - 1]//2\n            piles[len(piles)//2] -= piles[len(piles)//2]//2\n            k -= 1\n        \n        return sum(piles)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 1963,
        "title": "Minimum Number of Swaps to Make the String Balanced",
        "difficulty": 1,
        "answer": "        if len(s) == 0:\n            return 0\n        if len(s) == 1:\n            return 0\n        if len(s) == 2:\n            if s[0] == ']' and s[1] == '[':\n                return 0\n            else:\n                return 1\n        if len(s) == 3:\n            if s[0] == ']' and s[1] == ']':\n                return 1\n            else:\n                return 2\n        if len(s) == 4:\n            if s[0] == ']' and s[1] == ']':\n                return 1\n            else:\n                return 2\n        if len(s) == 5:\n            if s[0] == ']' and s[1] == ']':\n                return 1\n            else:\n                return 2\n        if len(s) == 6:\n            if s[0] == ']' and s[1] == ']':\n                return 1\n            else:\n                return 2\n        if len(s) == 7:\n            if s[0] == '"
    },
    {
        "number": 1964,
        "title": "Find the Longest Valid Obstacle Course at Each Position",
        "difficulty": 2,
        "answer": "        n = len(obstacles)\n        ans = [1] * n\n        for i in range(1, n):\n            if obstacles[i] > obstacles[i - 1]:\n                ans[i] = ans[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if obstacles[i] > obstacles[i + 1]:\n                ans[i] = max(ans[i], ans[i + 1] + 1)\n        return ans"
    },
    {
        "number": 1967,
        "title": "Number of Strings That Appear as Substrings in Word",
        "difficulty": 0,
        "answer": "        count = 0\n        for pattern in patterns:\n            if pattern in word:\n                count += 1\n        return count"
    },
    {
        "number": 1968,
        "title": "Array With Elements Not Equal to Average of Neighbors",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        mid = n // 2\n        for i in range(mid):\n            nums[i * 2 + 1], nums[n - i * 2 - 1] = nums[n - i * 2 - 1], nums[i * 2 + 1]\n        return nums"
    },
    {
        "number": 1969,
        "title": "Minimum Non-Zero Product of the Array Elements",
        "difficulty": 1,
        "answer": "        # p = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,"
    },
    {
        "number": 1970,
        "title": "Last Day Where You Can Still Cross",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the latest day to cross from top to bottom\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) if cells[i][j] == 0\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + 1 if cells[i][j] == 1\n        # dp[0][0] = 0\n        # dp[0][j] = 0\n        # dp[i][0] = 0\n        # dp[i][j] = 0 if cells[i][j] == 1\n        # dp[i][j] = dp[i-1][j] + 1 if cells[i][j] == 0\n        # dp[i][j] = dp[i][j-1] + 1 if cells[i][j] == 0\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + 1"
    },
    {
        "number": 1971,
        "title": "Find if Path Exists in Graph",
        "difficulty": 0,
        "answer": "        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 1974,
        "title": "Minimum Time to Type Word Using Special Typewriter",
        "difficulty": 0,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(1)\n        # ans = 0\n        # for c in word:\n        #     ans += min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n        # return ans"
    },
    {
        "number": 1975,
        "title": "Maximum Matrix Sum",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + matrix[i][j]\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1], dp[i-1][j-1] + matrix[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1], dp[i-1][j-1] + matrix[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1], dp[i-1]["
    },
    {
        "number": 1976,
        "title": "Number of Ways to Arrive at Destination",
        "difficulty": 1,
        "answer": "        # dp[i][j] = the number of ways to get to j from i\n        # dp[i][j] = dp[i][k] + dp[k][j]\n        # dp[i][j] = dp[i][k] + dp[k][j] + roads[i][2]\n        # dp[i][j] = dp[i][k] + dp[k][j] + roads[i][2] + roads[k][2]\n        # dp[i][j] = dp[i][k] + dp[k][j] + roads[i][2] + roads[k][2] + roads[i][2] + roads[k][2]\n        # dp[i][j] = dp[i][k] + dp[k][j] + roads[i][2] + roads[k][2] + roads[i][2] + roads[k][2] + roads[i][2] + roads[k][2]\n        # dp[i][j"
    },
    {
        "number": 1977,
        "title": "Number of Ways to Separate Numbers",
        "difficulty": 2,
        "answer": "        n = len(num)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if num[i - 1]!= '0':\n                dp[i] = dp[i - 1]\n            if i > 1 and num[i - 2]!= '0' and int(num[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[n] % (10 ** 9 + 7)"
    },
    {
        "number": 1979,
        "title": "Find Greatest Common Divisor of Array",
        "difficulty": 0,
        "answer": "        return reduce(gcd, nums)"
    },
    {
        "number": 1980,
        "title": "Find Unique Binary String",
        "difficulty": 1,
        "answer": "        # nums = [\"01\",\"10\"]\n        # nums = [\"00\",\"01\"]\n        # nums = [\"111\",\"011\",\"001\"]\n        # nums = [\"1110111011111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
        "number": 1981,
        "title": "Minimize the Difference Between Target and Chosen Elements",
        "difficulty": 1,
        "answer": "        m, n = len(mat), len(mat[0])\n        for i in range(m):\n            mat[i].sort()\n            target -= mat[i][0]\n            if target < 0:\n                return abs(target)\n        return 0"
    },
    {
        "number": 1982,
        "title": "Find Array Given Subset Sums",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        sums.sort()\n        left, right = 0, len(sums) - 1\n        while left < right:\n            if sums[left] + sums[right] > n:\n                right -= 1\n            elif sums[left] + sums[right] < n:\n                left += 1\n            else:\n                break\n        if left == right:\n            return [sums[left]] * n\n        else:\n            return [sums[left], sums[right]]"
    },
    {
        "number": 1984,
        "title": "Minimum Difference Between Highest and Lowest of K Scores",
        "difficulty": 0,
        "answer": "        nums.sort()\n        return min([nums[i+k-1] - nums[i] for i in range(len(nums)-k+1)])"
    },
    {
        "number": 1985,
        "title": "Find the Kth Largest Integer in the Array",
        "difficulty": 1,
        "answer": "        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u53d6\u6700\u540ek\u4e2a\n        nums.sort(key=lambda x: int(x), reverse=True)\n        return nums[k-1]"
    },
    {
        "number": 1986,
        "title": "Minimum Number of Work Sessions to Finish the Tasks",
        "difficulty": 1,
        "answer": "        tasks.sort()\n        n = len(tasks)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = min(dp[i], dp[i - 1] + 1)\n            for j in range(i):\n                if tasks[j] + j <= i:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return dp[n]"
    },
    {
        "number": 1987,
        "title": "Number of Unique Good Subsequences",
        "difficulty": 2,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-1][j-3] - dp[i-1][j-4] + dp[i-1][j-5] - dp[i-1][j-6] + dp[i-1][j-7] - dp[i-1][j-8] + dp[i-1][j-9] - dp[i-1][j-10] + dp[i-1][j-11] - dp[i-1][j-12] + dp[i-1][j-13"
    },
    {
        "number": 1991,
        "title": "Find the Middle Index in Array",
        "difficulty": 0,
        "answer": "        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if sum(nums[:mid+1]) == sum(nums[mid+1:]):\n                return mid\n            elif sum(nums[:mid+1]) < sum(nums[mid+1:]):\n                left = mid + 1\n            else:\n                right = mid\n        return -1"
    },
    {
        "number": 1992,
        "title": "Find All Groups of Farmland",
        "difficulty": 1,
        "answer": "        m, n = len(land), len(land[0])\n        res = []\n        for i in range(m):\n            for j in range(n):\n                if land[i][j] == 1:\n                    land[i][j] = 0\n                    stack = [(i, j)]\n                    while stack:\n                        x, y = stack.pop()\n                        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < m and 0 <= ny < n and land[nx][ny] == 1:\n                                land[nx][ny] = 0\n                                stack.append((nx, ny))\n                    res.append([i, j, i, j])\n        return res"
    },
    {
        "number": 1993,
        "title": "Operations on Tree",
        "difficulty": 1,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 1994,
        "title": "The Number of Good Subsets",
        "difficulty": 2,
        "answer": "        # nums = [1,2,3,4]\n        # nums = [4,2,3,15]\n        # nums = [1,2,3,4,5,6]\n        # nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98"
    },
    {
        "number": 1995,
        "title": "Count Special Quadruplets",
        "difficulty": 0,
        "answer": "        nums.sort()\n        count = 0\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                k, l = j + 1, len(nums) - 1\n                while k < l:\n                    s = nums[i] + nums[j] + nums[k] + nums[l]\n                    if s > 0:\n                        l -= 1\n                    elif s < 0:\n                        k += 1\n                    else:\n                        count += 1\n                        k += 1\n                        l -= 1\n                        while k < l and nums[k] == nums[k - 1]:\n                            k += 1\n                        while k < l and nums[l] == nums[l + 1]:\n                            l -= 1\n        return count"
    },
    {
        "number": 1996,
        "title": "The Number of Weak Characters in the Game",
        "difficulty": 1,
        "answer": "        properties.sort(key=lambda x: x[0])\n        res = 0\n        for i in range(1, len(properties)):\n            if properties[i][0] <= properties[i-1][1]:\n                res += 1\n        return res"
    },
    {
        "number": 1997,
        "title": "First Day Where You Have Been in All the Rooms",
        "difficulty": 1,
        "answer": "        n = len(nextVisit)\n        dp = [0] * n\n        dp[0] = nextVisit[0]\n        for i in range(1, n):\n            dp[i] = (dp[i - 1] + nextVisit[i]) % (i + 1)\n        return dp[-1]"
    },
    {
        "number": 1998,
        "title": "GCD Sort of an Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        for i in range(len(nums) - 1):\n            if nums[i] >= nums[i + 1]:\n                return False\n        return True"
    },
    {
        "number": 2000,
        "title": "Reverse Prefix of Word",
        "difficulty": 0,
        "answer": "        if ch not in word:\n            return word\n        else:\n            return word[:word.index(ch)] + word[word.index(ch):][::-1]"
    },
    {
        "number": 2001,
        "title": "Number of Pairs of Interchangeable Rectangles",
        "difficulty": 1,
        "answer": "        from collections import defaultdict\n        d = defaultdict(int)\n        for w, h in rectangles:\n            d[w/h] += 1\n        return sum(d[k]*(d[k]-1)//2 for k in d)"
    },
    {
        "number": 2002,
        "title": "Maximum Product of the Length of Two Palindromic Subsequences",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = 2 + dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 2003,
        "title": "Smallest Missing Genetic Value in Each Subtree",
        "difficulty": 2,
        "answer": "        self.ans = [float('inf')] * len(parents)\n        self.nums = nums\n        self.parents = parents\n        self.root = 0\n        self.visited = set()\n        self.dfs(0)\n        return self.ans"
    },
    {
        "number": 2006,
        "title": "Count Number of Pairs With Absolute Difference K",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # res = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) == k:\n        #             res += 1\n        # return res"
    },
    {
        "number": 2007,
        "title": "Find Original Array From Doubled Array",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        nums = [0] * len(changed)\n        for i in range(len(changed)):\n            nums[changed[i] % len(nums)] += 1\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                return []\n        return nums"
    },
    {
        "number": 2008,
        "title": "Maximum Earnings From Taxi",
        "difficulty": 1,
        "answer": "        rides.sort(key=lambda x: x[1])\n        dp = [0] * n\n        for s, e, t in rides:\n            dp[s - 1] += t\n            dp[e] -= t\n        return max(dp)"
    },
    {
        "number": 2009,
        "title": "Minimum Number of Operations to Make Array Continuous",
        "difficulty": 2,
        "answer": "        nums.sort()\n        diff = nums[-1] - nums[0]\n        if diff == len(nums) - 1:\n            return 0\n        else:\n            return len(nums) - 1 - diff"
    },
    {
        "number": 2011,
        "title": "Final Value of Variable After Performing Operations",
        "difficulty": 0,
        "answer": "        # X++: X is incremented by 1, X = 0 + 1 = 1.\n        # X++: X is incremented by 1, X = 1 + 1 = 2.\n        # --X: X is decremented by 1, X = 2 - 1 = 1.\n        # X--: X is decremented by 1, X = 1 - 1 = 0.\n        # X++: X is incremented by 1, X = 0 + 1 = 1.\n        # X++: X is incremented by 1, X = 1 + 1 = 2.\n        # --X: X is decremented by 1, X = 2 - 1 = 1.\n        # X--: X is decremented by 1, X = 1 - 1 = 0.\n        # X++: X is incremented by 1, X = 0 + 1 = 1.\n        # X++: X is incremented by 1, X = 1 + 1 = 2.\n        # --X: X is decremented by 1, X = 2 - 1 = 1.\n        # X--: X is decremented by 1, X = 1 - 1 = 0"
    },
    {
        "number": 2012,
        "title": "Sum of Beauty in the Array",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 1 if nums[0] < nums[1] else 0\n        dp[2] = 2 if nums[0] < nums[2] and nums[1] < nums[2] else 0\n        for i in range(3, n):\n            dp[i] = 2 if nums[i - 1] < nums[i] < nums[i + 1] else 0\n            if dp[i - 1] == 2 and dp[i] == 2:\n                dp[i] = 1\n        return sum(dp)"
    },
    {
        "number": 2013,
        "title": "Detect Squares",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2014,
        "title": "Longest Subsequence Repeated k Times",
        "difficulty": 2,
        "answer": "        # dp[i][j] = longest subsequence of s[i:j] repeated k times\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n        # dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j"
    },
    {
        "number": 2016,
        "title": "Maximum Difference Between Increasing Elements",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n < 2:\n            return -1\n        max_diff = -1\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] < nums[j]:\n                    max_diff = max(max_diff, nums[j] - nums[i])\n        return max_diff"
    },
    {
        "number": 2017,
        "title": "Grid Game",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[-1][-1]"
    },
    {
        "number": 2018,
        "title": "Check if Word Can Be Placed In Crossword",
        "difficulty": 1,
        "answer": "        def is_valid_position(row, col, word, direction):\n            if direction == 'h':\n                if col + len(word) > len(board[0]):\n                    return False\n                for i in range(len(word)):\n                    if board[row][col+i]!='' and board[row][col+i]!= word[i]:\n                        return False\n                for i in range(row):\n                    if board[i][col] =='':\n                        return False\n                for i in range(row+1, len(board)):\n                    if board[i][col] =='':\n                        return False\n                return True\n            else:\n                if row + len(word) > len(board):\n                    return False\n                for i in range(len(word)):\n                    if board[row+i][col]!='' and board[row+i][col]!= word[i]:\n                        return False\n                for i in range(col):\n                    if board[row][i] =='':\n                        return False\n                for i in range"
    },
    {
        "number": 2019,
        "title": "The Score of Students Solving Math Expression",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # N = len(answers)\n        # dp = [0] * (N + 1)\n        # for i in range(1, N + 1):\n        #     if s[i - 1] == '+':\n        #         dp[i] = dp[i - 2] + answers[i - 1]\n        #     elif s[i - 1] == '*':\n        #         dp[i] = dp[i - 2] * answers[i - 1]\n        #     else:\n        #         dp[i] = dp[i - 1]\n        # return sum(dp)"
    },
    {
        "number": 2022,
        "title": "Convert 1D Array Into 2D Array",
        "difficulty": 0,
        "answer": "        if m * n!= len(original):\n            return []\n        res = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                res[i][j] = original[i * n + j]\n        return res"
    },
    {
        "number": 2023,
        "title": "Number of Pairs of Strings With Concatenation Equal to Target",
        "difficulty": 1,
        "answer": "        nums = [int(i) for i in nums]\n        target = int(target)\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    count += 1\n        return count"
    },
    {
        "number": 2024,
        "title": "Maximize the Confusion of an Exam",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # n = len(answerKey)\n        # if k >= n:\n        #     return n\n        # dp = [0] * n\n        # for i in range(n):\n        #     if answerKey[i] == 'T':\n        #         dp[i] = dp[i-1] + 1 if i > 0 else 1\n        #     else:\n        #         dp[i] = dp[i-1] if i > 0 else 0\n        # for j in range(k):\n        #     for i in range(n-1, -1, -1):\n        #         if answerKey[i] == 'T':\n        #             dp[i] = max(dp[i], dp[i-1] + 1)\n        #         else:\n        #             dp[i] = max(dp[i], dp[i-1])\n        # return dp[-1]"
    },
    {
        "number": 2025,
        "title": "Maximum Number of Ways to Partition an Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(n):\n            for j in range(k + 1):\n                if j - nums[i] >= 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n - 1][k]"
    },
    {
        "number": 2027,
        "title": "Minimum Moves to Convert String",
        "difficulty": 0,
        "answer": "        return s.count('X') - 1"
    },
    {
        "number": 2028,
        "title": "Find Missing Observations",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # n = len(rolls)\n        # m = len(rolls[0])\n        # mean = sum(rolls) / n\n        # ans = []\n        # for i in range(n):\n        #     ans.append(mean - sum(rolls[i]))\n        # return ans"
    },
    {
        "number": 2029,
        "title": "Stone Game IX",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = Alice's score if the last stone is on the ith position, and Bob's score if the last stone is on the jth position\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) if stones[i] + stones[j] % 3!= 0\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) if stones[i] + stones[j] % 3 == 0\n        # dp[i][j] = max(dp[i-1][j], dp[i][j-1]) if stones[i] + stones[j] % 3 == 0\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) if stones[i] + stones[j] % 3!= 0\n        \n        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range"
    },
    {
        "number": 2030,
        "title": "Smallest K-Length Subsequence With Occurrences of a Letter",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return letter * repetition\n        if repetition == 0:\n            return \"\"\n        if k == len(s):\n            return s\n        if letter not in s:\n            return s[:k]\n        if letter * repetition not in s:\n            return s[:k]\n        if letter * repetition * 2 not in s:\n            return s[:k]\n        if letter * repetition * 3 not in s:\n            return s[:k]\n        if letter * repetition * 4 not in s:\n            return s[:k]\n        if letter * repetition * 5 not in s:\n            return s[:k]\n        if letter * repetition * 6 not in s:\n            return s[:k]\n        if letter * repetition * 7 not in s:\n            return s[:k]\n        if letter * repetition * 8 not in s:\n            return s[:k]\n        if letter * repetition * 9 not in s:\n            return s[:k]\n        if letter * repetition * 10 not in s:\n            return s[:k]"
    },
    {
        "number": 2032,
        "title": "Two Out of Three",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2033,
        "title": "Minimum Operations to Make a Uni-Value Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return 0 if grid[0][0] == x else -1\n        if m == 1:\n            return -1 if grid[0][0]!= x else n\n        if n == 1:\n            return -1 if grid[0][0]!= x else m\n        \n        # dp[i][j] = min operations to make grid[i][j] == x\n        dp = [[float('inf')] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == x:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + 1\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + 1"
    },
    {
        "number": 2034,
        "title": "Stock Price Fluctuation ",
        "difficulty": 1,
        "answer": "        self.prices = []\n        self.max_price = float('-inf')\n        self.min_price = float('inf')"
    },
    {
        "number": 2035,
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "difficulty": 2,
        "answer": "        nums.sort()\n        return min(nums[i+1] - nums[i] for i in range(len(nums)-1))"
    },
    {
        "number": 2037,
        "title": "Minimum Number of Moves to Seat Everyone",
        "difficulty": 0,
        "answer": "        seats.sort()\n        students.sort()\n        res = 0\n        for i in range(len(students)):\n            res += abs(seats[i] - students[i])\n        return res"
    },
    {
        "number": 2038,
        "title": "Remove Colored Pieces if Both Neighbors are the Same Color",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        n = len(colors)\n        if n < 3:\n            return False\n        dp = [[0] * n for _ in range(2)]\n        dp[0][0] = 1 if colors[0] == 'A' else -1\n        dp[1][0] = 1 if colors[0] == 'B' else -1\n        for i in range(1, n):\n            dp[0][i] = dp[1][i - 1]\n            dp[1][i] = dp[0][i - 1]\n            if colors[i] == 'A':\n                dp[0][i] += 1\n                dp[1][i] -= 1\n            elif colors[i] == 'B':\n                dp[0][i] -= 1\n                dp[1][i] += 1\n        return dp[0][-1] > 0"
    },
    {
        "number": 2039,
        "title": "The Time When the Network Becomes Idle",
        "difficulty": 1,
        "answer": "        n = len(patience)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print(n)\n        # print(edges)\n        # print(graph)\n        # print(patience)\n        # print("
    },
    {
        "number": 2040,
        "title": "Kth Smallest Product of Two Sorted Arrays",
        "difficulty": 2,
        "answer": "        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        res = 0\n        while i < len(nums1) and j < len(nums2):\n            if i == 0 or nums1[i] * nums2[j] > res:\n                res = nums1[i] * nums2[j]\n                j += 1\n            else:\n                i += 1\n            if j == len(nums2) or i == len(nums1):\n                break\n        return res"
    },
    {
        "number": 2042,
        "title": "Check if Numbers Are Ascending in a Sentence",
        "difficulty": 0,
        "answer": "        nums = [int(i) for i in s.split() if i.isdigit()]\n        return all(nums[i] < nums[i+1] for i in range(len(nums)-1))"
    },
    {
        "number": 2043,
        "title": "Simple Bank System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2044,
        "title": "Count Number of Maximum Bitwise-OR Subsets",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = dp[i - 1] | nums[i]\n        return sum(dp)"
    },
    {
        "number": 2045,
        "title": "Second Minimum Time to Reach Destination",
        "difficulty": 2,
        "answer": "        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes.\n        # The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n        # The minimum time path is 1 -> 2 with time = 3 minutes."
    },
    {
        "number": 2047,
        "title": "Number of Valid Words in a Sentence",
        "difficulty": 0,
        "answer": "        # split the sentence into words\n        words = sentence.split()\n        # count the number of valid words\n        count = 0\n        for word in words:\n            # check if the word is valid\n            if self.isValid(word):\n                count += 1\n        return count"
    },
    {
        "number": 2048,
        "title": "Next Greater Numerically Balanced Number",
        "difficulty": 1,
        "answer": "        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,"
    },
    {
        "number": 2049,
        "title": "Count Nodes With the Highest Score",
        "difficulty": 1,
        "answer": "        self.res = 0\n        self.max_score = 0\n        self.n = len(parents)\n        self.graph = collections.defaultdict(list)\n        for i in range(self.n):\n            self.graph[parents[i]].append(i)\n        self.dfs(0, 1)\n        return self.res"
    },
    {
        "number": 2050,
        "title": "Parallel Courses III",
        "difficulty": 2,
        "answer": "        # DFS\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-1] + time[j] + relations[j][0]\n        # time[i] = time[i-"
    },
    {
        "number": 2053,
        "title": "Kth Distinct String in an Array",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the kth distinct string\n        \n        # hashmap\n        # count the number of each distinct string\n        # return the k"
    },
    {
        "number": 2054,
        "title": "Two Best Non-Overlapping Events",
        "difficulty": 1,
        "answer": "        events.sort()\n        n = len(events)\n        dp = [0] * n\n        dp[0] = events[0][2]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + events[i][2])\n            if i >= 2:\n                dp[i] = max(dp[i], dp[i - 2] + events[i][2])\n        return dp[-1]"
    },
    {
        "number": 2055,
        "title": "Plates Between Candles",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2056,
        "title": "Number of Valid Move Combinations On Chessboard",
        "difficulty": 2,
        "answer": "        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B = 3\n        # R = 1, Q = 2, B ="
    },
    {
        "number": 2057,
        "title": "Smallest Index With Equal Value",
        "difficulty": 0,
        "answer": "        for i in range(len(nums)):\n            if i % 10 == nums[i]:\n                return i\n        return -1"
    },
    {
        "number": 2058,
        "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
        "difficulty": 1,
        "answer": "        # Time complexity: O(N)\n        # Space complexity: O(N)\n        # 1. Initialize prev, curr, next to None, head, head.next\n        # 2. Initialize prev_prev, prev, curr, next to None, None, head, head.next\n        # 3. Initialize prev_prev_prev, prev_prev, prev, curr, next to None, None, None, head, head.next\n        # 4. Initialize prev_prev_prev_prev, prev_prev_prev, prev_prev, prev, curr, next to None, None, None, None, head\n        # 5. Initialize prev_prev_prev_prev_prev, prev_prev_prev_prev, prev_prev_prev, prev_prev, prev, curr, next to None, None, None, None, None\n        # 6. Initialize prev_prev_prev_prev_prev_prev, prev_prev_prev_prev_prev, prev_prev_prev_prev, prev_prev_prev, prev_prev, curr, next to None, None,"
    },
    {
        "number": 2059,
        "title": "Minimum Operations to Convert Number",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = min operations to convert nums[:i] to nums[:j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1, dp[i-1][j-2] + 2)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1, dp[i-1][j-2] + 2)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1, dp[i-1][j-2] + 2)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1, dp[i-1][j-2] + 2)\n        # dp[i][j] = min(dp[i-1][j], dp[i"
    },
    {
        "number": 2060,
        "title": "Check if an Original String Exists Given Two Encoded Strings",
        "difficulty": 2,
        "answer": "        def encode(s):\n            return ''.join(str(len(x)) for x in s.split('a'))\n        return encode(s1) == encode(s2)"
    },
    {
        "number": 2062,
        "title": "Count Vowel Substrings of a String",
        "difficulty": 0,
        "answer": "        vowels = set('aeiou')\n        ans = 0\n        for i in range(len(word)):\n            for j in range(i, len(word)):\n                if set(word[i:j+1]) == vowels:\n                    ans += 1\n        return ans"
    },
    {
        "number": 2063,
        "title": "Vowels of All Substrings",
        "difficulty": 1,
        "answer": "        vowels = ['a', 'e', 'i', 'o', 'u']\n        count = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                count += 1\n            for j in range(i+1, len(word)):\n                if word[j] in vowels:\n                    count += 1\n        return count"
    },
    {
        "number": 2064,
        "title": "Minimized Maximum of Products Distributed to Any Store",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7c7b\u578b\u7684\u6570\u91cf\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\ufffd"
    },
    {
        "number": 2065,
        "title": "Maximum Path Quality of a Graph",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + values[i] + values[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + values[i] + values[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + values[i] + values[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + values[i] + values[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + values[i] + values[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k"
    },
    {
        "number": 2068,
        "title": "Check Whether Two Strings are Almost Equivalent",
        "difficulty": 0,
        "answer": "        if len(word1)!= len(word2):\n            return False\n        d = {}\n        for i in word1:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        for i in word2:\n            if i in d:\n                d[i] -= 1\n            else:\n                d[i] = 1\n        for i in d:\n            if abs(d[i]) > 3:\n                return False\n        return True"
    },
    {
        "number": 2069,
        "title": "Walking Robot Simulation II",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2070,
        "title": "Most Beautiful Item for Each Query",
        "difficulty": 1,
        "answer": "        items.sort(key=lambda x: x[0])\n        items.sort(key=lambda x: x[1], reverse=True)\n        res = []\n        for q in queries:\n            i = 0\n            while i < len(items) and items[i][0] <= q:\n                i += 1\n            res.append(items[i-1][1] if i > 0 else 0)\n        return res"
    },
    {
        "number": 2071,
        "title": "Maximum Number of Tasks You Can Assign",
        "difficulty": 2,
        "answer": "        # sort the tasks by their strength\n        tasks.sort(reverse=True)\n        workers.sort(reverse=True)\n        # print(tasks, workers)\n        # print(tasks[0], workers[0])\n        # print(tasks[1], workers[1])\n        # print(tasks[2], workers[2])\n        # print(tasks[3], workers[3])\n        # print(tasks[4], workers[4])\n        # print(tasks[5], workers[5])\n        # print(tasks[6], workers[6])\n        # print(tasks[7], workers[7])\n        # print(tasks[8], workers[8])\n        # print(tasks[9], workers[9])\n        # print(tasks[10], workers[10])\n        # print(tasks[11], workers[11])\n        # print(tasks[12], workers[12])\n        # print(tasks[13], workers[13])\n        # print(tasks[14], workers[14])\n"
    },
    {
        "number": 2073,
        "title": "Time Needed to Buy Tickets",
        "difficulty": 0,
        "answer": "        \n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)\n        \n        # Greedy\n        # Time: O(N), where N is the number of tickets\n        # Space: O(1)"
    },
    {
        "number": 2074,
        "title": "Reverse Nodes in Even Length Groups",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the length of each group\n        group_length = 1\n        curr = head\n        while curr:\n            group_length += 1\n            curr = curr.next\n        \n        # reverse the linked list\n        curr = head\n        prev = None\n        while group_length > 0:\n            # reverse the group\n            for _ in range(group_length // 2):\n                curr.val, prev.val = prev.val, curr.val\n                curr = curr.next\n                prev = prev.next\n            \n            # move to the next group\n            group_length -= 1\n            curr = curr.next\n        \n        return head"
    },
    {
        "number": 2075,
        "title": "Decode the Slanted Ciphertext",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        if rows == 1:\n            return encodedText\n        \n        n = len(encodedText)\n        cols = n // rows\n        \n        matrix = [[''for _ in range(cols)] for _ in range(rows)]\n        \n        row, col = 0, 0\n        for i in range(n):\n            matrix[row][col] = encodedText[i]\n            col += 1\n            if col == cols:\n                col = 0\n                row += 1\n        \n        decodedText = ''\n        for i in range(cols):\n            for j in range(rows):\n                decodedText += matrix[j][i]\n        \n        return decodedText"
    },
    {
        "number": 2076,
        "title": "Process Restricted Friend Requests",
        "difficulty": 2,
        "answer": "        # build graph\n        graph = [[] for _ in range(n)]\n        for u, v in restrictions:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # build indegree and outdegree\n        indegree = [0] * n\n        outdegree = [0] * n\n        for u, v in requests:\n            indegree[u] += 1\n            outdegree[v] += 1\n        \n        # BFS\n        queue = collections.deque()\n        for i in range(n):\n            if indegree[i] == 0:\n                queue.append(i)\n        \n        res = [False] * len(requests)\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                indegree[v] -= 1\n                outdegree[v] -= 1\n                if indegree[v] == 0:\n                    queue.append(v)\n                if outdegree[v] == 0:\n                    res[requests.index(["
    },
    {
        "number": 2078,
        "title": "Two Furthest Houses With Different Colors",
        "difficulty": 0,
        "answer": "        # O(n)\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-1]\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-2]\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-3]\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-4]\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-5]\n        # dp[i] = max(dp[i-1], dp[i-2] + 1) if colors[i]!= colors[i-6]\n        # dp[i] = max"
    },
    {
        "number": 2079,
        "title": "Watering Plants",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if not plants:\n        #     return 0\n        # if len(plants) == 1:\n        #     return 0 if plants[0] > capacity else 1\n        # if capacity == 0:\n        #     return 0\n        # if capacity < plants[0]:\n        #     return len(plants)\n        # if capacity == plants[0]:\n        #     return 1\n        # if capacity > plants[0]:\n        #     return 1 + self.wateringPlants(plants[1:], capacity - plants[0])\n        # if capacity < plants[0]:\n        #     return 1 + self.wateringPlants(plants[1:], capacity)"
    },
    {
        "number": 2080,
        "title": "Range Frequency Queries",
        "difficulty": 1,
        "answer": "        self.arr = arr\n        self.freq = {}\n        for num in arr:\n            if num in self.freq:\n                self.freq[num] += 1\n            else:\n                self.freq[num] = 1"
    },
    {
        "number": 2081,
        "title": "Sum of k-Mirror Numbers",
        "difficulty": 2,
        "answer": "        \n        def dfs(k, n, cur, res):\n            if k == 0:\n                res.append(cur)\n                return\n            for i in range(10):\n                if i == 0:\n                    continue\n                dfs(k-1, n, cur + str(i), res)\n        \n        res = []\n        dfs(k, n, '', res)\n        return sum(int(x, base=k) for x in res)"
    },
    {
        "number": 2085,
        "title": "Count Common Words With One Occurrence",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n"
    },
    {
        "number": 2086,
        "title": "Minimum Number of Food Buckets to Feed the Hamsters",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H..H\"\n        # hamsters = \".H.H.\"\n        # hamsters = \".HHH.\"\n        # hamsters = \"H.."
    },
    {
        "number": 2087,
        "title": "Minimum Cost Homecoming of a Robot in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(rowCosts), len(colCosts)\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[startPos[0]][startPos[1]] = 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1] + colCosts[j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + rowCosts[i]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + rowCosts[i], dp[i][j - 1] + colCosts[j])\n        return dp[-1][-1]"
    },
    {
        "number": 2088,
        "title": "Count Fertile Pyramids in a Land",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        \n        def count_pyramids(grid, i, j, h):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return 0\n            if i == 0:\n                return 1\n            return count_pyramids(grid, i - 1, j, h - 1) + count_pyramids(grid, i, j + 1, h - 1) + count_pyramids(grid, i, j, h - 1)\n        \n        def count_inverse_pyramids(grid, i, j, h):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return 0\n            if i == m - 1:\n                return 1\n            return count_inverse_pyramids(grid, i + 1, j, h - 1) + count_inverse_pyramids(grid, i, j + 1, h - 1) + count_inverse_pyramids(grid"
    },
    {
        "number": 2089,
        "title": "Find Target Indices After Sorting Array",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # return sorted([i for i in range(len(nums)) if nums[i] == target])"
    },
    {
        "number": 2090,
        "title": "K Radius Subarray Averages",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # res = [0] * len(nums)\n        # for i in range(k, len(nums) - k):\n        #     res[i] = sum(nums[i - k:i + k + 1]) / (2 * k + 1)\n        # return res"
    },
    {
        "number": 2091,
        "title": "Removing Minimum and Maximum From Array",
        "difficulty": 1,
        "answer": "        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) - max_val - min_val\n        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) - max_val - min_val\n        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) - max_val - min_val\n        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) - max_val - min_val\n        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) - max_val - min_val\n        \n        # min_val = min(nums)\n        # max_val = max(nums)\n        # return len(nums) -"
    },
    {
        "number": 2092,
        "title": "Find All People With Secret",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # graph = collections.defaultdict(list)\n        # for u, v, t in meetings:\n        #     graph[u].append((v, t))\n        #     graph[v].append((u, t))\n        #\n        # def dfs(u, t):\n        #     if u not in seen:\n        #         seen.add(u)\n        #         if t == firstPerson:\n        #             return True\n        #         for v, tt in graph[u]:\n        #             if dfs(v, tt):\n        #                 return True\n        #     return False\n        #\n        # seen = set()\n        # return [u for u in range(n) if dfs(u, 0)]"
    },
    {
        "number": 2094,
        "title": "Finding 3-Digit Even Numbers",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # Time: O(n^2), Space: O(n)\n        # res = []\n        # for i in range(len(digits)):\n        #     for j in range(i+1, len(digits)):\n        #         for k in range(j+1, len(digits)):\n        #             if digits[i] + digits[j] + digits[k] % 2 == 0:\n        #                 res.append(digits[i] + digits[j] + digits[k])\n        # return sorted(res)"
    },
    {
        "number": 2095,
        "title": "Delete the Middle Node of a Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        \n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        if fast:\n            slow = slow.next\n        \n        if slow:\n            slow.val = slow.next.val\n            slow.next = slow.next.next\n        \n        return head"
    },
    {
        "number": 2096,
        "title": "Step-By-Step Directions From a Binary Tree Node to Another",
        "difficulty": 1,
        "answer": "        if not root:\n            return \"\"\n        if root.val == startValue:\n            return \"U\"\n        if root.val == destValue:\n            return \"L\"\n        return self.getDirections(root.left, startValue, destValue) + self.getDirections(root.right, startValue, destValue) + \"L\""
    },
    {
        "number": 2097,
        "title": "Valid Arrangement of Pairs",
        "difficulty": 2,
        "answer": "        \n        def dfs(i, pairs, visited):\n            if i == len(pairs):\n                return True\n            for j in range(len(pairs)):\n                if j not in visited and pairs[j][0] == i:\n                    visited.add(j)\n                    if dfs(i+1, pairs, visited):\n                        return True\n                    visited.remove(j)\n            return False\n        \n        return [pairs[i] for i in range(len(pairs)) if dfs(i+1, pairs, {i})]"
    },
    {
        "number": 2099,
        "title": "Find Subsequence of Length K With the Largest Sum",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums[i"
    },
    {
        "number": 2100,
        "title": "Find Good Days to Rob the Bank",
        "difficulty": 1,
        "answer": "        res = []\n        for i in range(len(security)):\n            if i - time >= 0 and i + time < len(security):\n                if all(security[i - time] >= security[i - time + 1] <= security[i] <= security[i + time - 1] <= security[i + time] for i in range(i - time, i + time + 1)):\n                    res.append(i)\n        return res"
    },
    {
        "number": 2101,
        "title": "Detonate the Maximum Bombs",
        "difficulty": 1,
        "answer": "        bombs = sorted(bombs, key=lambda x: x[2], reverse=True)\n        dp = [0] * len(bombs)\n        for i, (x, y, r) in enumerate(bombs):\n            for j in range(i):\n                if (bombs[j][0] - x) ** 2 + (bombs[j][1] - y) ** 2 <= r ** 2:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 2102,
        "title": "Sequentially Ordinal Rank Tracker",
        "difficulty": 2,
        "answer": "    def add(self, name: str, score: int) -> None:\n        \"\"\"\n        A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.\n        You are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\n            Adding scenic locations, one at a time.\n            Querying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).\n                For example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.\n        Note that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.\n        Implement the SORTracker class:\n            SORTracker() Initializes the tracker system.\n            void add"
    },
    {
        "number": 2103,
        "title": "Rings and Rods",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(1) space\n        # count = 0\n        # for i in range(len(rings)):\n        #     if rings[i] == 'R' and rings[i+1] == 'G' and rings[i+2] == 'B':\n        #         count += 1\n        # return count"
    },
    {
        "number": 2104,
        "title": "Sum of Subarray Ranges",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(len(nums)):\n            if i == 0:\n                res += nums[i]\n            else:\n                res += nums[i] - nums[i-1]\n        return res"
    },
    {
        "number": 2105,
        "title": "Watering Plants II",
        "difficulty": 1,
        "answer": "        n = len(plants)\n        if n == 1:\n            return 0\n        i = 0\n        j = n - 1\n        a_can = capacityA\n        b_can = capacityB\n        while i <= j:\n            if a_can >= plants[i]:\n                a_can -= plants[i]\n                i += 1\n            else:\n                a_can = capacityA\n                b_can -= plants[i]\n                i += 1\n            if b_can >= plants[j]:\n                b_can -= plants[j]\n                j -= 1\n            else:\n                b_can = capacityB\n                j -= 1\n        return i"
    },
    {
        "number": 2106,
        "title": "Maximum Fruits Harvested After at Most K Steps",
        "difficulty": 2,
        "answer": "        \n        # Time: O(NlogN)\n        # Space: O(N)\n        \n        # Greedy\n        # sort by position\n        # iterate through fruits\n        # if position is greater than current position, then we can't reach that position\n        # if position is less than current position, then we can reach that position\n        # if position is equal to current position, then we can harvest that fruit\n        # iterate through fruits again\n        # if position is greater than current position, then we can't reach that position\n        # if position is less than current position, then we can reach that position\n        # if position is equal to current position, then we can harvest that fruit\n        # iterate through fruits again\n        # if position is greater than current position, then we can't reach that position\n        # if position is less than current position, then we can reach that position\n        # if position is equal to current position, then we can harvest that fruit\n        # iterate through fruits again\n        # if position is greater than current position, then we can't reach that position\n        # if position is less than current position,"
    },
    {
        "number": 2108,
        "title": "Find First Palindromic String in the Array",
        "difficulty": 0,
        "answer": "        for word in words:\n            if word == word[::-1]:\n                return word\n        return \"\""
    },
    {
        "number": 2109,
        "title": "Adding Spaces to a String",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        res = []\n        for i in range(len(s)):\n            if i in spaces:\n                res.append(' ')\n            res.append(s[i])\n        return ''.join(res)"
    },
    {
        "number": 2110,
        "title": "Number of Smooth Descent Periods of a Stock",
        "difficulty": 1,
        "answer": "        if not prices:\n            return 0\n        n = len(prices)\n        res = 0\n        for i in range(1, n):\n            if prices[i] - prices[i - 1] == 1:\n                res += 1\n            elif prices[i] - prices[i - 1] == -1:\n                res += 1\n                for j in range(i + 1, n):\n                    if prices[j] - prices[j - 1] == 1:\n                        res += 1\n                    else:\n                        break\n        return res"
    },
    {
        "number": 2111,
        "title": "Minimum Operations to Make the Array K-Increasing",
        "difficulty": 2,
        "answer": "        n = len(arr)\n        if k > n:\n            return 0\n        dp = [0] * n\n        for i in range(k):\n            dp[i] = 1\n        for i in range(k, n):\n            dp[i] = min(dp[i-1] + 1, dp[i-k] + 1)\n        return dp[-1]"
    },
    {
        "number": 2114,
        "title": "Maximum Number of Words Found in Sentences",
        "difficulty": 0,
        "answer": "        \n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O"
    },
    {
        "number": 2115,
        "title": "Find All Possible Recipes from Given Supplies",
        "difficulty": 1,
        "answer": "        # build a graph\n        graph = {}\n        for recipe in recipes:\n            graph[recipe] = set()\n        for i in range(len(ingredients)):\n            for ingredient in ingredients[i]:\n                if ingredient not in graph:\n                    graph[ingredient] = set()\n                graph[ingredient].add(recipes[i])\n        # BFS\n        queue = deque()\n        for ingredient in graph:\n            if ingredient not in supplies:\n                queue.append(ingredient)\n        res = []\n        while queue:\n            cur = queue.popleft()\n            res.append(cur)\n            for neighbor in graph[cur]:\n                if neighbor not in supplies:\n                    queue.append(neighbor)\n                    supplies.append(neighbor)\n        return res"
    },
    {
        "number": 2116,
        "title": "Check if a Parentheses String Can Be Valid",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        # stack = []\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(s[i])\n        #     else:\n        #         if not stack:\n        #             return False\n        #         stack.pop()\n        # return not stack"
    },
    {
        "number": 2117,
        "title": "Abbreviating the Product of a Range",
        "difficulty": 2,
        "answer": "        # \u53ef\u4ee5\u628a\u7ed3\u679c\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\n        # \u53ef\u4ee5\u628a\u7ed3\u679c\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\n        # \u53ef\u4ee5\u628a\u7ed3\u679c\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u628a\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u6570\u5b57\uff0c\u7136\u540e\u628a\u6570\u5b57\u8f6c\ufffd"
    },
    {
        "number": 2119,
        "title": "A Number After a Double Reversal",
        "difficulty": 0,
        "answer": "        return str(num) == str(num)[::-1]"
    },
    {
        "number": 2120,
        "title": "Execution of All Suffix Instructions Staying in a Grid",
        "difficulty": 1,
        "answer": "        # n = 3, startPos = [0,1], s = \"RRDDLU\"\n        # n = 2, startPos = [1,1], s = \"LURD\"\n        # n = 1, startPos = [0,0], s = \"LRUD\"\n        # n = 2, startPos = [1,1], s = \"LURD\"\n        # n = 3, startPos = [0,1], s = \"RRDDLU\"\n        # n = 2, startPos = [1,1], s = \"LURD\"\n        # n = 1, startPos = [0,0], s = \"LRUD\"\n        # n = 2, startPos = [1,1], s = \"LURD\"\n        # n = 3, startPos = [0,1], s = \"RRDDLU\"\n        # n = 2, startPos = [1,1], s = \"LURD\"\n        # n = 1, startPos = [0,0], s = \"LRUD\"\n        # n = 2, startPos = [1"
    },
    {
        "number": 2121,
        "title": "Intervals Between Identical Elements",
        "difficulty": 1,
        "answer": "        res = [0] * len(arr)\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] == arr[j]:\n                    res[i] += j - i\n                    res[j] += i - j\n        return res"
    },
    {
        "number": 2122,
        "title": "Recover the Original Array",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the two duplicates\n        \n        # Find the two missing numbers\n        # Find the"
    },
    {
        "number": 2124,
        "title": "Check if All A\"s Appears Before All B\"s",
        "difficulty": 0,
        "answer": "        if len(s) == 0:\n            return True\n        if len(s) == 1:\n            return False\n        a_count = 0\n        b_count = 0\n        for i in range(len(s)):\n            if s[i] == 'a':\n                a_count += 1\n            if s[i] == 'b':\n                b_count += 1\n            if a_count > b_count:\n                return False\n        return True"
    },
    {
        "number": 2125,
        "title": "Number of Laser Beams in a Bank",
        "difficulty": 1,
        "answer": "        m, n = len(bank), len(bank[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = 1 if bank[i][j] == '1' else 0\n                else:\n                    dp[i][j] = dp[i - 1][j] + (1 if bank[i][j] == '1' else 0)\n        return sum(dp[-1])"
    },
    {
        "number": 2126,
        "title": "Destroying Asteroids",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        stack = []\n        for asteroid in asteroids:\n            if asteroid > 0:\n                stack.append(asteroid)\n            else:\n                while stack and stack[-1] > 0 and stack[-1] < abs(asteroid):\n                    stack.pop()\n                if not stack or stack[-1] < 0:\n                    stack.append(asteroid)\n                elif stack[-1] == abs(asteroid):\n                    stack.pop()\n        return not stack"
    },
    {
        "number": 2127,
        "title": "Maximum Employees to Be Invited to a Meeting",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2129,
        "title": "Capitalize the Title",
        "difficulty": 0,
        "answer": "        return''.join(word.capitalize() for word in title.split())"
    },
    {
        "number": 2130,
        "title": "Maximum Twin Sum of a Linked List",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        d = {}\n        curr = head\n        while curr:\n            d[curr] = d.get(curr, 0) + curr.val\n            curr = curr.next\n        \n        return max(d.values())"
    },
    {
        "number": 2131,
        "title": "Longest Palindrome by Concatenating Two Letter Words",
        "difficulty": 1,
        "answer": "        # dp[i][j] = True if s[i:j+1] is a palindrome\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] or dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] or dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j] and dp[i+1][j] and dp[i][j-1]\n        # dp[i][j] = dp[i+1][j-1] and s[i] == s[j] and dp[i+1][j] and dp[i][j"
    },
    {
        "number": 2132,
        "title": "Stamping the Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if i + stampHeight > m or j + stampWidth > n:\n                        return False\n                    for x in range(i, i + stampHeight):\n                        for y in range(j, j + stampWidth):\n                            if grid[x][y] == 1:\n                                return False\n        return True"
    },
    {
        "number": 2133,
        "title": "Check if Every Row and Column Contains All Numbers",
        "difficulty": 0,
        "answer": "        n = len(matrix)\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return True"
    },
    {
        "number": 2134,
        "title": "Minimum Swaps to Group All 1\"s Together II",
        "difficulty": 1,
        "answer": "        # count the number of 1s\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n        # if the number of 1s is odd, we can't swap\n        if count % 2 == 1:\n            return -1\n        # if the number of 1s is even, we can swap\n        else:\n            # count the number of 0s\n            count = 0\n            for num in nums:\n                if num == 0:\n                    count += 1\n            # if the number of 0s is odd, we can't swap\n            if count % 2 == 1:\n                return -1\n            # if the number of 0s is even, we can swap\n            else:\n                # count the number of 1s\n                count = 0\n                for num in nums:\n                    if num == 1:\n                        count += 1\n                # if the number of 1s is odd, we can't swap\n                if count % 2 == 1:\n                    return -1\n                # if the number of 1s is even, we can swap\n                else:\n                    "
    },
    {
        "number": 2135,
        "title": "Count Words Obtained After Adding a Letter",
        "difficulty": 1,
        "answer": "        # Time: O(N^2), where N is the length of startWords\n        # Space: O(N^2)\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word, value is the count\n        # hashmap: key is the word,"
    },
    {
        "number": 2136,
        "title": "Earliest Possible Day of Full Bloom",
        "difficulty": 2,
        "answer": "        plant_time = [0] + plantTime\n        grow_time = [0] + growTime\n        n = len(plantTime)\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 1] + plant_time[i])\n            dp[i] = max(dp[i], dp[i - 1] + grow_time[i])\n        return dp[-1]"
    },
    {
        "number": 2138,
        "title": "Divide a String Into Groups of Size k",
        "difficulty": 0,
        "answer": "        if k == 1:\n            return [s]\n        if len(s) < k:\n            return []\n        if len(s) == k:\n            return [s]\n        if len(s) == k + 1:\n            return [s[:k], s[k:]]\n        if len(s) == k + 2:\n            return [s[:k], s[k:k+1], s[k+1:]]\n        if len(s) == k + 3:\n            return [s[:k], s[k:k+2], s[k+2:]]\n        if len(s) == k + 4:\n            return [s[:k], s[k:k+3], s[k+3:]]\n        if len(s) == k + 5:\n            return [s[:k], s[k:k+4], s[k+4:]]\n        if len(s) == k + 6:\n            return [s[:k], s[k:k+5], s[k+5:]]\n        "
    },
    {
        "number": 2139,
        "title": "Minimum Moves to Reach Target Score",
        "difficulty": 1,
        "answer": "        if target == 1:\n            return 0\n        if maxDoubles == 0:\n            return 1\n        if target % 2 == 0:\n            return 1 + self.minMoves(target // 2, maxDoubles - 1)\n        else:\n            return 1 + min(self.minMoves(target - 1, maxDoubles - 1), self.minMoves(target + 1, maxDoubles - 1))"
    },
    {
        "number": 2140,
        "title": "Solving Questions With Brainpower",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2141,
        "title": "Maximum Running Time of N Computers",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp["
    },
    {
        "number": 2144,
        "title": "Minimum Cost of Buying Candies With Discount",
        "difficulty": 0,
        "answer": "        cost.sort()\n        cost.append(0)\n        res = 0\n        for i in range(1, len(cost)):\n            res += cost[i] - cost[i - 1]\n        return res"
    },
    {
        "number": 2145,
        "title": "Count the Hidden Sequences",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1] - dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1] - dp[i - 1][j] + dp[i - 1][j]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1] - dp[i - 1][j] + dp[i - 1][j] + dp[i - 1][j]\n        # dp[i][j] = dp[i"
    },
    {
        "number": 2146,
        "title": "K Highest Ranked Items Within a Price Range",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(m * n * log(m * n))\n        # Space complexity: O(m * n)\n        import heapq\n        import itertools\n        m, n = len(grid), len(grid[0])\n        heap = []\n        for i, j in itertools.product(range(m), range(n)):\n            if grid[i][j] > 0:\n                heapq.heappush(heap, (grid[i][j], i, j))\n        \n        while k:\n            price, i, j = heapq.heappop(heap)\n            if i == start[0] and j == start[1] and price >= pricing[0] and price <= pricing[1]:\n                k -= 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > 0"
    },
    {
        "number": 2147,
        "title": "Number of Ways to Divide a Long Corridor",
        "difficulty": 2,
        "answer": "        n = len(corridor)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            if corridor[i] == 'P':\n                dp[i] = 0\n            else:\n                dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[-1] % (10 ** 9 + 7)"
    },
    {
        "number": 2148,
        "title": "Count Elements With Strictly Smaller and Greater Elements ",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # count = 0\n        # for i in range(len(nums)):\n        #     if i > 0 and nums[i] == nums[i-1]:\n        #         continue\n        #     for j in range(i+1, len(nums)):\n        #         if nums[j] == nums[i] + 1:\n        #             count += 1\n        #             break\n        # return count"
    },
    {
        "number": 2149,
        "title": "Rearrange Array Elements by Sign",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                res.append(nums[i])\n            else:\n                res.append(nums[len(nums) - i - 1])\n        return res"
    },
    {
        "number": 2150,
        "title": "Find All Lonely Numbers in the Array",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # result = []\n        # for i in range(len(nums)):\n        #     if nums[i] not in nums[:i] + nums[i+1:]:\n        #         result.append(nums[i])\n        # return result"
    },
    {
        "number": 2151,
        "title": "Maximum Good People Based on Statements",
        "difficulty": 2,
        "answer": "        n = len(statements)\n        good = [0] * n\n        bad = [0] * n\n        for i in range(n):\n            for j in range(n):\n                if statements[i][j] == 0:\n                    good[i] += 1\n                elif statements[i][j] == 1:\n                    bad[i] += 1\n        return sum(good) + sum(bad) - max(good) - max(bad)"
    },
    {
        "number": 2154,
        "title": "Keep Multiplying Found Values by Two",
        "difficulty": 0,
        "answer": "        \n        while True:\n            if original in nums:\n                original = 2 * original\n            else:\n                break\n        return original\n"
    },
    {
        "number": 2155,
        "title": "All Divisions With the Highest Score of a Binary Array",
        "difficulty": 1,
        "answer": "        \n        # Time: O(n), space: O(n)\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        # dp[i] = max(dp[i-1], dp[i-2]"
    },
    {
        "number": 2156,
        "title": "Find Substring With Given Hash Value",
        "difficulty": 2,
        "answer": "        if k == 1:\n            return s[0]\n        if k == 2:\n            return s[0:2]\n        if k == 3:\n            return s[0:3]\n        if k == 4:\n            return s[0:4]\n        if k == 5:\n            return s[0:5]\n        if k == 6:\n            return s[0:6]\n        if k == 7:\n            return s[0:7]\n        if k == 8:\n            return s[0:8]\n        if k == 9:\n            return s[0:9]\n        if k == 10:\n            return s[0:10]\n        if k == 11:\n            return s[0:11]\n        if k == 12:\n            return s[0:12]\n        if k == 13:\n            return s[0:13]\n        if k == 14:\n            return s[0:14]\n        if k == 15:\n            return s[0:15]\n        if k == 16:\n            return s[0"
    },
    {
        "number": 2157,
        "title": "Groups of Strings",
        "difficulty": 2,
        "answer": "        # Solution 1:\n        # O(n^2)\n        # d = {}\n        # for word in words:\n        #     key = tuple(sorted(word))\n        #     d[key] = d.get(key, []) + [word]\n        # ans = []\n        # for key in d:\n        #     if len(d[key]) > 1:\n        #         ans.append(len(d[key]))\n        # ans.sort()\n        # return ans[-1], ans[-1]"
    },
    {
        "number": 2160,
        "title": "Minimum Sum of Four Digit Number After Splitting Digits",
        "difficulty": 0,
        "answer": "        # num = str(num)\n        # num = list(num)\n        # num.sort()\n        # print(num)\n        # num = [int(i) for i in num]\n        # print(num)\n        # num = [str(i) for i in num]\n        # print(num)\n        # num = ''.join(num)\n        # print(num)\n        # num = int(num)\n        # print(num)\n        # num = str(num)\n        # print(num)\n        # num = list(num)\n        # print(num)\n        # num = [int(i) for i in num]\n        # print(num)\n        # num = [str(i) for i in num]\n        # print(num)\n        # num = ''.join(num)\n        # print(num)\n        # num = int(num)\n        # print(num)\n        # num = str(num)\n        # print(num)\n        # num = list(num)\n        # print(num"
    },
    {
        "number": 2161,
        "title": "Partition Array According to Given Pivot",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     if nums[left] < pivot:\n        #         left += 1\n        #     elif nums[right] > pivot:\n        #         right -= 1\n        #     else:\n        #         nums[left], nums[right] = nums[right], nums[left]\n        #         left += 1\n        #         right -= 1\n        # return nums"
    },
    {
        "number": 2162,
        "title": "Minimum Cost to Set Cooking Time",
        "difficulty": 1,
        "answer": "        if targetSeconds == 0:\n            return 0\n        if targetSeconds < 0:\n            return -1\n        if startAt == 0:\n            return targetSeconds * pushCost\n        if startAt == 1:\n            return targetSeconds * pushCost + min(moveCost, pushCost)\n        if startAt == 2:\n            return targetSeconds * pushCost + min(moveCost, pushCost) + min(moveCost, pushCost)\n        if startAt == 3:\n            return targetSeconds * pushCost + min(moveCost, pushCost) + min(moveCost, pushCost) + min(moveCost, pushCost)\n        if startAt == 4:\n            return targetSeconds * pushCost + min(moveCost, pushCost) + min(moveCost, pushCost) + min(moveCost, pushCost) + min(moveCost, pushCost)\n        if startAt == 5:\n            return targetSeconds * pushCost + min(moveCost, pushCost) + min(moveCost, pushCost) + min(moveCost, pushCost) + min(moveCost"
    },
    {
        "number": 2163,
        "title": "Minimum Difference in Sums After Removal of Elements",
        "difficulty": 2,
        "answer": "        n = len(nums) // 3\n        nums.sort()\n        return min(nums[n] - nums[n * 2 - 1], nums[n * 2] - nums[n * 2 - 2])"
    },
    {
        "number": 2164,
        "title": "Sort Even and Odd Indices Independently",
        "difficulty": 0,
        "answer": "        odd = sorted(nums[1::2])\n        even = sorted(nums[0::2], reverse=True)\n        return odd + even"
    },
    {
        "number": 2165,
        "title": "Smallest Value of the Rearranged Number",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # num_str = str(num)\n        # num_str = ''.join(sorted(num_str, key=lambda x: x if x!= '0' else '', reverse=True))\n        # return int(num_str) if num_str[0]!= '0' else int(num_str[1:])\n        \n        # Solution 2:\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        # num_str = str(num)\n        # num_str = ''.join(sorted(num_str, key=lambda x: x if x!= '0' else '', reverse=True))\n        # return int(num_str) if num_str[0]!= '0' else int(num_str[1:])\n        \n        # Solution 3:\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        # num_str = str("
    },
    {
        "number": 2166,
        "title": "Design Bitset",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2167,
        "title": "Minimum Time to Remove All Cars Containing Illegal Goods",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # s = \"1100101\"\n        # s = \"0010\"\n        # s = \"1110111101101111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
        "number": 2169,
        "title": "Count Operations to Obtain Zero",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # if num1 == 0 or num2 == 0:\n        #     return 0\n        # if num1 > num2:\n        #     return self.countOperations(num1 - num2, num2) + 1\n        # else:\n        #     return self.countOperations(num1, num2 - num1) + 1"
    },
    {
        "number": 2170,
        "title": "Minimum Operations to Make the Array Alternating",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1] + 1)\n        # dp["
    },
    {
        "number": 2171,
        "title": "Removing Minimum Number of Magic Beans",
        "difficulty": 1,
        "answer": "        \n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O"
    },
    {
        "number": 2172,
        "title": "Maximum AND Sum of Array",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 2 * numSlots:\n            return 0\n        nums.sort()\n        res = 0\n        for i in range(numSlots):\n            res = max(res, nums[i] & nums[n - 1 - i])\n        return res"
    },
    {
        "number": 2176,
        "title": "Count Equal and Divisible Pairs in an Array",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # count = collections.Counter(nums)\n        # res = 0\n        # for num in count:\n        #     if k % num == 0:\n        #         res += count[num] * (count[num] - 1) // 2\n        #     elif k % num!= 0:\n        #         res += count[num] * (count[num] - 1) // 2\n        #         res += count[num] * (count[num] - 2) // 2\n        # return res"
    },
    {
        "number": 2177,
        "title": "Find Three Consecutive Integers That Sum to a Given Number",
        "difficulty": 1,
        "answer": "        # num = 33\n        # num = 4\n        # num = 10\n        # num = 11\n        # num = 12\n        # num = 13\n        # num = 14\n        # num = 15\n        # num = 16\n        # num = 17\n        # num = 18\n        # num = 19\n        # num = 20\n        # num = 21\n        # num = 22\n        # num = 23\n        # num = 24\n        # num = 25\n        # num = 26\n        # num = 27\n        # num = 28\n        # num = 29\n        # num = 30\n        # num = 31\n        # num = 32\n        # num = 33\n        # num = 34\n        # num = 35\n        # num = 36\n        # num = 37\n        # num = 38\n        # num = 39\n        # num = 40\n        # num = 41\n        # num = 42\n        # num = 43\n        # num = 44\n        # num = 45\n        # num = 46\n        # num = 47\n        # num = 48\n        # num ="
    },
    {
        "number": 2178,
        "title": "Maximum Split of Positive Even Integers",
        "difficulty": 1,
        "answer": "        \n        def dfs(s, i, curr, ans):\n            if i == len(s):\n                if curr % 2 == 0 and curr <= finalSum:\n                    ans.append(curr)\n                return\n            if s[i] == '0':\n                dfs(s, i+1, curr, ans)\n            else:\n                dfs(s, i+1, curr + int(s[i]), ans)\n                dfs(s, i+1, curr, ans)\n        \n        s = str(finalSum)\n        ans = []\n        dfs(s, 0, 0, ans)\n        return ans"
    },
    {
        "number": 2179,
        "title": "Count Good Triplets in an Array",
        "difficulty": 2,
        "answer": "        # nums1 = [2,0,1,3]\n        # nums2 = [0,1,2,3]\n        # nums1 = [4,0,1,3,2]\n        # nums2 = [4,1,0,2,3]\n        # nums1 = [1,2,3,4,0]\n        # nums2 = [2,3,4,0,1]\n        # nums1 = [1,2,3,4,0]\n        # nums2 = [2,3,4,0,1]\n        # nums1 = [1,2,3,4,0]\n        # nums2 = [2,3,4,0,1]\n        # nums1 = [1,2,3,4,0]\n        # nums2 = [2,3,4,0,1]\n        # nums1 = [1,2,3,4,0]\n        # nums2 = [2,3,4,0,1]\n        #"
    },
    {
        "number": 2180,
        "title": "Count Integers With Even Digit Sum",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 3\n        if num == 4:\n            return 4\n        if num == 5:\n            return 6\n        if num == 6:\n            return 7\n        if num == 7:\n            return 8\n        if num == 8:\n            return 9\n        if num == 9:\n            return 10\n        if num == 10:\n            return 11\n        if num == 11:\n            return 12\n        if num == 12:\n            return 13\n        if num == 13:\n            return 14\n        if num == 14:\n            return 15\n        if num == 15:\n            return 16\n        if num == 16:\n            return 17\n        if num == 17:\n            return 18\n        if num == 18:\n            return 19\n        if num == 19:\n            return 20\n        if num == 20:\n            return 21\n        if num == 21:\n            return 22\n        if num == 22:\n            "
    },
    {
        "number": 2181,
        "title": "Merge Nodes in Between Zeros",
        "difficulty": 1,
        "answer": "        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = dummy\n        while curr.next:\n            if curr.next.val == 0 and curr.next.next:\n                left = curr.next\n                right = left.next\n                \n                while right and right.val == 0:\n                    right = right.next\n                    \n                if not right:\n                    curr.next = None\n                    break\n                \n                left.val += right.val\n                left.next = right.next\n                right.next = None\n                \n                curr = left\n            else:\n                curr = curr.next\n                \n        return dummy.next"
    },
    {
        "number": 2182,
        "title": "Construct String With Repeat Limit",
        "difficulty": 1,
        "answer": "        if not s:\n            return \"\"\n        if repeatLimit == 1:\n            return s\n        \n        res = \"\"\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n                if count > repeatLimit:\n                    res += s[i]\n                    count = 1\n            else:\n                count = 1\n            if i == len(s)-1:\n                if count <= repeatLimit:\n                    res += s[i]\n        return res"
    },
    {
        "number": 2183,
        "title": "Count Array Pairs Divisible by K",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     if nums[i] % k in hashmap:\n        #         hashmap[nums[i] % k] += 1\n        #     else:\n        #         hashmap[nums[i] % k] = 1\n        # ans = 0\n        # for i in range(len(nums)):\n        #     if k % nums[i] == 0:\n        #         ans += hashmap[0]\n        #     elif k % nums[i] in hashmap:\n        #         ans += hashmap[k % nums[i]]\n        # return ans // 2"
    },
    {
        "number": 2185,
        "title": "Counting Words With a Given Prefix",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        count = 0\n        for word in words:\n            if word.startswith(pref):\n                count += 1\n        return count"
    },
    {
        "number": 2186,
        "title": "Minimum Number of Steps to Make Two Strings Anagram II",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        s_count = Counter(s)\n        t_count = Counter(t)\n        res = 0\n        for k, v in t_count.items():\n            if k not in s_count or v > s_count[k]:\n                return -1\n            res += abs(v - s_count[k])\n        return res"
    },
    {
        "number": 2187,
        "title": "Minimum Time to Complete Trips",
        "difficulty": 1,
        "answer": "        # time = [1,2,3]\n        # totalTrips = 5\n        # time = [2]\n        # totalTrips = 1\n        # time = [1,2,3,4,5,6,7,8,9,10]\n        # totalTrips = 20\n        # time = [1,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,33,34,34,35,35,36,36,37,37,38,38,39,39,40,40,41,41,42,42,43,43,44,44,45,45"
    },
    {
        "number": 2188,
        "title": "Minimum Time to Finish the Race",
        "difficulty": 2,
        "answer": "        # Time: O(NlogN), where N is the number of tires\n        # Space: O(N)\n        tires.sort(key=lambda x: x[0])\n        tires.sort(key=lambda x: x[1])\n        \n        def get_time(tires, change_time, num_laps):\n            time = 0\n            for i in range(len(tires)):\n                time += tires[i][0] * tires[i][1]\n                if i < len(tires) - 1:\n                    time += change_time\n            return time\n        \n        return get_time(tires, changeTime, numLaps)"
    },
    {
        "number": 2190,
        "title": "Most Frequent Number Following Key In an Array",
        "difficulty": 0,
        "answer": "        count = {}\n        for i in nums:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        max_count = 0\n        max_key = 0\n        for i in count:\n            if count[i] > max_count and i!= key:\n                max_count = count[i]\n                max_key = i\n        return max_key"
    },
    {
        "number": 2191,
        "title": "Sort the Jumbled Numbers",
        "difficulty": 1,
        "answer": "        mapping = {i: j for i, j in enumerate(mapping)}\n        return sorted(nums, key=lambda x: int(''.join(str(mapping[i]) for i in x)))"
    },
    {
        "number": 2192,
        "title": "All Ancestors of a Node in a Directed Acyclic Graph",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, visited, ancestors):\n            if node in visited:\n                return\n            visited.add(node)\n            ancestors.append(node)\n            for child in graph[node]:\n                dfs(child, visited, ancestors)\n        \n        ans = []\n        for i in range(n):\n            visited = set()\n            ancestors = []\n            dfs(i, visited, ancestors)\n            ans.append(ancestors)\n        return ans"
    },
    {
        "number": 2193,
        "title": "Minimum Number of Moves to Make Palindrome",
        "difficulty": 2,
        "answer": "        return len(s) - self.helper(s)"
    },
    {
        "number": 2194,
        "title": "Cells in a Range on an Excel Sheet",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # cols = [chr(i) for i in range(ord('A'), ord('Z') + 1)]\n        # rows = [i for i in range(1, 10)]\n        # res = []\n        # for i in range(len(s)):\n        #     if s[i] in cols:\n        #         res.append(s[i] + str(rows[0]))\n        #         rows.pop(0)\n        #     elif s[i] in rows:\n        #         res.append(s[i] + str(rows[0]))\n        #         rows.pop(0)\n        # return res"
    },
    {
        "number": 2195,
        "title": "Append K Integers With Minimal Sum",
        "difficulty": 1,
        "answer": "        # Time: O(nlogk)\n        # Space: O(k)\n        # heapq.heapify(nums)\n        # for _ in range(k):\n        #     heapq.heappop(nums)\n        # return sum(nums)"
    },
    {
        "number": 2196,
        "title": "Create Binary Tree From Descriptions",
        "difficulty": 1,
        "answer": "        if not descriptions:\n            return None\n        root = TreeNode(descriptions[0][0])\n        stack = [root]\n        for i in range(1, len(descriptions)):\n            node = TreeNode(descriptions[i][0])\n            if descriptions[i][2] == 0:\n                stack[-1].left = node\n            else:\n                stack[-1].right = node\n            stack.append(node)\n            if descriptions[i][1]!= 0:\n                stack.append(None)\n        return root"
    },
    {
        "number": 2197,
        "title": "Replace Non-Coprime Numbers in Array",
        "difficulty": 2,
        "answer": "        # nums = [6,4,3,2,7,6,2]\n        # nums = [2,2,1,1,3,3,3]\n        # nums = [1,1,1,1,1,1,1]\n        # nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1"
    },
    {
        "number": 2200,
        "title": "Find All K-Distant Indices in an Array",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # result = []\n        # for i in range(len(nums)):\n        #     if abs(nums[i] - key) <= k:\n        #         result.append(i)\n        # return result"
    },
    {
        "number": 2201,
        "title": "Count Artifacts That Can Be Extracted",
        "difficulty": 1,
        "answer": "        # Time: O(n^2), space: O(n^2)\n        # dp[i][j] = number of artifacts that can be extracted from the subgrid (i, j)\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dig[i][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + dig[i][j] - dig[i-1][j] - dig[i][j-1] + dig[i-"
    },
    {
        "number": 2202,
        "title": "Maximize the Topmost Element After K Moves",
        "difficulty": 1,
        "answer": "        \n        # Time: O(N), where N is the length of nums\n        # Space: O(N)\n        \n        stack = []\n        for num in nums:\n            while stack and stack[-1] < num and k > 0:\n                stack.pop()\n                k -= 1\n            stack.append(num)\n        return stack[0] if k == 0 else -1"
    },
    {
        "number": 2203,
        "title": "Minimum Weighted Subgraph With the Required Paths",
        "difficulty": 2,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        # dfs\n        def dfs(node, visited, weight):\n            if node == dest:\n                return weight\n            visited.add(node)\n            for nxt, w in graph[node]:\n                if nxt not in visited:\n                    res = dfs(nxt, visited, weight + w)\n                    if res!= -1:\n                        return res\n            return -1\n        \n        return dfs(src1, set(), 0) + dfs(src2, set(), 0)"
    },
    {
        "number": 2206,
        "title": "Divide Array Into Equal Pairs",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        nums.sort()\n        for i in range(0, len(nums), 2):\n            if nums[i]!= nums[i+1]:\n                return False\n        return True\n"
    },
    {
        "number": 2207,
        "title": "Maximize Number of Subsequences in a String",
        "difficulty": 1,
        "answer": "        # sliding window\n        # O(n)\n        # O(1)\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j]\n        # dp[i][j] = dp[i][j-1]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i][j]\n        # dp[i][j] = dp[i]["
    },
    {
        "number": 2208,
        "title": "Minimum Operations to Halve Array Sum",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The idea is to use binary search to find the minimum number of operations to reduce the sum of nums by at least half.\n        # The"
    },
    {
        "number": 2209,
        "title": "Minimum White Tiles After Covering With Carpets",
        "difficulty": 2,
        "answer": "        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # N is the length of the floor string\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding window to solve this problem.\n        # We can use a sliding"
    },
    {
        "number": 2210,
        "title": "Count Hills and Valleys in an Array",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # if not nums:\n        #     return 0\n        # valley = 0\n        # hill = 0\n        # for i in range(1, len(nums)):\n        #     if nums[i] > nums[i-1]:\n        #         valley += 1\n        #     elif nums[i] < nums[i-1]:\n        #         hill += 1\n        # return valley + hill\n        \n        # Solution 2:\n        # O(n) time\n        # O(1) space\n        if not nums:\n            return 0\n        valley = 0\n        hill = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                valley += 1\n            elif nums[i] < nums[i-1]:\n                hill += 1\n        return valley + hill\n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2211,
        "title": "Count Collisions on a Road",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # directions = \"RLRSLL\"\n        # directions = \"LLRR\"\n        # directions = \"LR\"\n        # directions = \"RS\"\n        # directions = \"R\"\n        # directions = \"L\"\n        # directions = \"S\"\n        # directions = \"LRSLL\"\n        # directions = \"LLLRSLL\"\n        # directions = \"LLRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR"
    },
    {
        "number": 2212,
        "title": "Maximum Points in an Archery Competition",
        "difficulty": 1,
        "answer": "        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]\n        # aliceArrows = [0,0,1,0,0,0"
    },
    {
        "number": 2213,
        "title": "Longest Substring of One Repeating Character",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(s)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1, -1, -1):\n        #     for j in range(i + 1, n):\n        #         if s[i] == s[j]:\n        #             dp[i][j] = dp[i + 1][j - 1] + 2\n        #         else:\n        #             dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        # return [dp[i][j] for i, j in zip(queryIndices, queryIndices[1:] + [n])]"
    },
    {
        "number": 2215,
        "title": "Find the Difference of Two Arrays",
        "difficulty": 0,
        "answer": "        nums1_set = set(nums1)\n        nums2_set = set(nums2)\n        return [list(nums1_set - nums2_set), list(nums2_set - nums1_set)]"
    },
    {
        "number": 2216,
        "title": "Minimum Deletions to Make Array Beautiful",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n % 2 == 1:\n            return 1\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] > nums[j]:\n                    dp[i][j] = dp[i + 1][j] + 1\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return n - dp[0][n - 1]"
    },
    {
        "number": 2217,
        "title": "Find Palindrome With Fixed Length",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2218,
        "title": "Maximum Value of K Coins From Piles",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-piles[i]] + piles[i][j"
    },
    {
        "number": 2220,
        "title": "Minimum Bit Flips to Convert Number",
        "difficulty": 0,
        "answer": "        # dp[i][j] = min number of flip to convert i to j\n        # dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1)\n        # dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1)\n        # dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1, dp[i-1][j-2] + 1)\n        # dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1, dp[i-1][j-1] + 1, dp[i-1][j-2] + 1, dp[i-1][j-3] + 1)\n        #"
    },
    {
        "number": 2221,
        "title": "Find Triangular Sum of an Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        new_nums = [0] * (n - 1)\n        for i in range(n - 1):\n            new_nums[i] = (nums[i] + nums[i + 1]) % 10\n        return self.triangularSum(new_nums)"
    },
    {
        "number": 2222,
        "title": "Number of Ways to Select Buildings",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(1)\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-5] - dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] - dp[i-4] + dp[i-5] - dp[i-6] + dp["
    },
    {
        "number": 2223,
        "title": "Sum of Scores of Built Strings",
        "difficulty": 2,
        "answer": "        n = len(s)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = 1\n            for j in range(i):\n                if s[i] == s[j] and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n        return sum(dp)"
    },
    {
        "number": 2224,
        "title": "Minimum Number of Operations to Convert Time",
        "difficulty": 0,
        "answer": "        current_h, current_m = current.split(':')\n        correct_h, correct_m = correct.split(':')\n        current_h, current_m = int(current_h), int(current_m)\n        correct_h, correct_m = int(correct_h), int(correct_m)\n        if current_h == correct_h:\n            return abs(current_m - correct_m)\n        if current_h < correct_h:\n            current_h += 24\n        return abs(current_h - correct_h) + abs(current_m - correct_m)"
    },
    {
        "number": 2225,
        "title": "Find Players With Zero or One Losses",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2226,
        "title": "Maximum Candies Allocated to K Children",
        "difficulty": 1,
        "answer": "        # \u601d\u8def\uff1a\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6240\u4ee5\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\u5806\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u62ff\u4e00\ufffd"
    },
    {
        "number": 2227,
        "title": "Encrypt and Decrypt Strings",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2231,
        "title": "Largest Number After Digit Swaps by Parity",
        "difficulty": 0,
        "answer": "        num = list(str(num))\n        i = 0\n        while i < len(num) - 1:\n            if num[i] == num[i + 1]:\n                num[i], num[i + 1] = num[i + 1], num[i]\n                i = 0\n            else:\n                i += 1\n        return int(''.join(num))"
    },
    {
        "number": 2232,
        "title": "Minimize Result by Adding Parentheses to Expression",
        "difficulty": 1,
        "answer": "        stack = []\n        for i in range(len(expression)):\n            if expression[i] == '+':\n                stack.append(expression[i])\n            elif expression[i] == '*':\n                stack.append(expression[i])\n            elif expression[i] == '(':\n                stack.append(expression[i])\n            elif expression[i] == ')':\n                while stack[-1]!= '(':\n                    stack.append(expression[i])\n                stack.pop()\n            else:\n                stack.append(expression[i])\n        return ''.join(stack)"
    },
    {
        "number": 2233,
        "title": "Maximum Product After K Increments",
        "difficulty": 1,
        "answer": "        \n        # Time: O(NlogN)\n        # Space: O(N)\n        \n        nums.sort()\n        \n        if k >= len(nums):\n            return nums[-1] * nums[-2] * nums[-3]\n        \n        if k == 1:\n            return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n        \n        if k == 2:\n            return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n        \n        if k == 3:\n            return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n        \n        if k == 4:\n            return max(nums[0] * nums[1] * nums["
    },
    {
        "number": 2234,
        "title": "Maximum Total Beauty of the Gardens",
        "difficulty": 2,
        "answer": "        if newFlowers == 0:\n            return 0\n        if target == 0:\n            return 0\n        if newFlowers < 0:\n            return -1\n        if target < 0:\n            return -1\n        if full < 0:\n            return -1\n        if partial < 0:\n            return -1\n        if flowers[0] < target:\n            return -1\n        if flowers[0] > target:\n            return 0\n        if len(flowers) == 1:\n            return full\n        if len(flowers) == 2:\n            return full + partial * min(flowers)\n        if len(flowers) == 3:\n            return full + partial * min(flowers) + max(flowers)\n        if len(flowers) == 4:\n            return full + partial * min(flowers) + max(flowers) + partial * min(flowers)\n        if len(flowers) == 5:\n            return full + partial * min(flowers) + max(flowers) + partial * min(flowers) + max(flowers)\n"
    },
    {
        "number": 2235,
        "title": "Add Two Integers",
        "difficulty": 0,
        "answer": "        return num1 + num2"
    },
    {
        "number": 2236,
        "title": "Root Equals Sum of Children",
        "difficulty": 0,
        "answer": "        if not root:\n            return True\n        if root.left and root.right:\n            return root.val == root.left.val + root.right.val and self.checkTree(root.left) and self.checkTree(root.right)\n        elif root.left:\n            return root.val == root.left.val and self.checkTree(root.left)\n        elif root.right:\n            return root.val == root.right.val and self.checkTree(root.right)\n        else:\n            return True\n"
    },
    {
        "number": 2239,
        "title": "Find Closest Number to Zero",
        "difficulty": 0,
        "answer": "        nums.sort()\n        if len(nums) == 1:\n            return nums[0]\n        elif len(nums) == 2:\n            return nums[1] if nums[1] - nums[0] < nums[0] - 0 else nums[0]\n        else:\n            return nums[0] if nums[1] - nums[0] < nums[0] - 0 else nums[1]"
    },
    {
        "number": 2240,
        "title": "Number of Ways to Buy Pens and Pencils",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-2]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + dp[i-1][j-2] - dp[i-1][j-3]\n        # dp[i][j] = dp[i][j-1] + dp[i-1"
    },
    {
        "number": 2241,
        "title": "Design an ATM Machine",
        "difficulty": 1,
        "answer": "        self.banknotes = [20, 50, 100, 200, 500]\n        self.banknotesCount = banknotesCount\n        self.amount = amount\n        self.banknotesCount = [0, 0, 0, 0, 0]\n        self.banknotesCount[self.banknotes.index(20)] += self.amount // 20\n        self.amount = self.amount % 20\n        self.banknotesCount[self.banknotes.index(50)] += self.amount // 50\n        self.amount = self.amount % 50\n        self.banknotesCount[self.banknotes.index(100)] += self.amount // 100\n        self.amount = self.amount % 100\n        self.banknotesCount[self.banknotes.index(200)] += self.amount // 200\n        self.amount = self.amount % 200\n        self.banknotesCount[self.banknotes.index(500)] += self.amount // 500\n        self.amount = self.amount % 500\n        if self.amount!= 0:\n            return [-1]\n        return self.banknotesCount"
    },
    {
        "number": 2242,
        "title": "Maximum Score of a Node Sequence",
        "difficulty": 2,
        "answer": "        # dfs\n        # time complexity: O(n^2)\n        # space complexity: O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(curr, visited):\n        #     if len(visited) == 4:\n        #         return True\n        #     if curr in visited:\n        #         return False\n        #     visited.add(curr)\n        #     for nxt in graph[curr]:\n        #         if dfs(nxt, visited):\n        #             return True\n        #     return False\n        #\n        # ans = -1\n        # for i in range(len(scores)):\n        #     visited = set()\n        #     if dfs(i, visited):\n        #         ans = max(ans, sum(scores[i] for i in visited))\n        # return ans"
    },
    {
        "number": 2243,
        "title": "Calculate Digit Sum of a String",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n), where n is the length of s\n        # Space: O(1)\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        # k = 3\n        \n        # s = \"123456789\"\n        "
    },
    {
        "number": 2244,
        "title": "Minimum Rounds to Complete All Tasks",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min rounds to complete all tasks from 0 to i, with j tasks completed in each round\n        # dp[i][j] = min(dp[i-1][j-2] + 2, dp[i-1][j-3] + 3)\n        # dp[i][j] = min(dp[i-1][j-2] + 2, dp[i-1][j-3] + 3, dp[i-1][j-4] + 4)\n        # dp[i][j] = min(dp[i-1][j-2] + 2, dp[i-1][j-3] + 3, dp[i-1][j-4] + 4, dp[i-1][j-5] + 5)\n        # dp[i][j] = min(dp[i-1][j-2] + 2, dp[i-1][j-3] + 3, dp[i-1][j-4] + 4, dp[i-1"
    },
    {
        "number": 2245,
        "title": "Maximum Trailing Zeros in a Cornered Path",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] * grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] * grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] * grid[i][j] + dp[i][j - 1] * grid[i][j]\n        return max(dp[-1])"
    },
    {
        "number": 2246,
        "title": "Longest Path With Different Adjacent Characters",
        "difficulty": 2,
        "answer": "        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # bfs\n        # time O(n)\n        # space O(n)\n        \n        # bfs\n        # time O(n)\n        # space O(n)\n        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # bfs\n        # time O(n)\n        # space O(n)\n        \n        # bfs\n        # time O(n)\n        # space O(n)\n        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # dfs\n        # time O(n)\n        # space O(n)\n        \n        # bfs\n        # time O(n)\n        # space O("
    },
    {
        "number": 2248,
        "title": "Intersection of Multiple Arrays",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        # hash table\n        "
    },
    {
        "number": 2249,
        "title": "Count Lattice Points Inside a Circle",
        "difficulty": 1,
        "answer": "        \n        def is_inside(x, y, r, circles):\n            for cx, cy, cr in circles:\n                if (x - cx) ** 2 + (y - cy) ** 2 <= cr ** 2:\n                    return True\n            return False\n        \n        res = 0\n        for x, y, r in circles:\n            for i in range(x - r, x + r + 1):\n                for j in range(y - r, y + r + 1):\n                    if is_inside(i, j, r, circles):\n                        res += 1\n        return res"
    },
    {
        "number": 2250,
        "title": "Count Number of Rectangles Containing Each Point",
        "difficulty": 1,
        "answer": "        \n        # O(N^2)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        "
    },
    {
        "number": 2251,
        "title": "Number of Flowers in Full Bloom",
        "difficulty": 2,
        "answer": "        # Time: O(nlogn)\n        # Space: O(n)\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key=lambda x: x[0])\n        # flowers.sort(key=lambda x: x[1])\n        # flowers.sort(key"
    },
    {
        "number": 2255,
        "title": "Count Prefixes of a Given String",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        prefix_count = 0\n        for word in words:\n            if word.startswith(s):\n                prefix_count += 1\n        return prefix_count"
    },
    {
        "number": 2256,
        "title": "Minimum Average Difference",
        "difficulty": 1,
        "answer": "        \n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O"
    },
    {
        "number": 2257,
        "title": "Count Unguarded Cells in the Grid",
        "difficulty": 1,
        "answer": "        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn)\n        # O(mn"
    },
    {
        "number": 2258,
        "title": "Escape the Spreading Fire",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        queue = collections.deque([(0, 0, 0)])\n        visited = set()\n        while queue:\n            i, j, minutes = queue.popleft()\n            if i == m - 1 and j == n - 1:\n                return minutes\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and (x, y) not in visited and grid[x][y]!= 2:\n                    visited.add((x, y))\n                    queue.append((x, y, minutes + 1))\n        return -1"
    },
    {
        "number": 2259,
        "title": "Remove Digit From Number to Maximize Result",
        "difficulty": 0,
        "answer": "        if digit not in number:\n            return number\n        if number.count(digit) == 1:\n            return number.replace(digit, \"\")\n        else:\n            return number.replace(digit, \"\") + digit"
    },
    {
        "number": 2260,
        "title": "Minimum Consecutive Cards to Pick Up",
        "difficulty": 1,
        "answer": "        cards.sort()\n        n = len(cards)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if cards[i] == cards[j] + 1:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp[-1] if dp[-1] > 0 else -1"
    },
    {
        "number": 2261,
        "title": "K Divisible Elements Subarrays",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # hashmap = {}\n        # res = 0\n        # for i in range(len(nums)):\n        #     if i >= k:\n        #         if nums[i] % p == 0:\n        #             if nums[i] in hashmap:\n        #                 res += hashmap[nums[i]]\n        #             else:\n        #                 res += 1\n        #             if nums[i - k] % p == 0:\n        #                 if nums[i - k] in hashmap:\n        #                     hashmap[nums[i - k]] += 1\n        #                 else:\n        #                     hashmap[nums[i - k]] = 1\n        #         else:\n        #             if nums[i - k] % p == 0:\n        #                 if nums[i - k] in hashmap:\n        #                     hashmap[nums[i - k]] -= 1\n        #                     if hashmap[nums[i -"
    },
    {
        "number": 2262,
        "title": "Total Appeal of A String",
        "difficulty": 2,
        "answer": "        return sum(self.appeal(s[i:j]) for i in range(len(s)) for j in range(i + 1, len(s) + 1))"
    },
    {
        "number": 2264,
        "title": "Largest 3-Same-Digit Number in String",
        "difficulty": 0,
        "answer": "        if len(num) < 3:\n            return \"\"\n        if len(num) == 3:\n            if num[0] == \"0\":\n                return \"\"\n            return num\n        if len(num) == 4:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 5:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 6:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 7:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 8:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 9:\n            if num[0] == \"0\":\n                return \"0\"\n            return num\n        if len(num) == 10:\n            if num[0] == \"0\":\n"
    },
    {
        "number": 2265,
        "title": "Count Nodes Equal to Average of Subtree",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0, 0\n            left_sum, left_count = dfs(node.left)\n            right_sum, right_count = dfs(node.right)\n            total_sum = left_sum + right_sum + node.val\n            total_count = left_count + right_count + 1\n            return total_sum, total_count\n        \n        total_sum, total_count = dfs(root)\n        return total_count - total_sum // total_count"
    },
    {
        "number": 2266,
        "title": "Count Number of Texts",
        "difficulty": 1,
        "answer": "        # key: digit, value: list of possible letters\n        key = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r','s'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        # key: letter, value: list of possible digits\n        key_reversed = {\n            'a': ['2'],\n            'b': ['2'],\n            'c': ['2'],\n            'd': ['3'],\n            'e': ['3'],\n            'f': ['3'],\n            'g': ['4'],\n            'h': ['4'],\n            'i': ['4'],\n            '"
    },
    {
        "number": 2267,
        "title": " Check if There Is a Valid Parentheses String Path",
        "difficulty": 2,
        "answer": "        \n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        def isValid(s):\n            stack = []\n            for c in s:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if len(stack) == 0:\n                        return False\n                    stack.pop()\n            return len(stack) == 0\n        \n        def dfs(i, j, path):\n            if i == m - 1 and j == n - 1:\n                if isValid(path):\n                    self.valid = True\n                return\n            if i < m - 1:\n                dfs(i + 1, j, path + grid[i + 1][j])\n            if j < n - 1:\n                dfs(i, j + 1, path + grid[i][j + 1])\n        \n        m = len(grid)\n        n = len(grid[0])\n        self.valid = False\n        dfs(0, 0, '')\n        return self.valid\n"
    },
    {
        "number": 2269,
        "title": "Find the K-Beauty of a Number",
        "difficulty": 0,
        "answer": "        if k == 1:\n            return 1\n        if k == 2:\n            return 2 if '0' not in str(num) else 1\n        if k == 3:\n            return 3 if '0' not in str(num) else 2\n        if k == 4:\n            return 4 if '0' not in str(num) else 3\n        if k == 5:\n            return 5 if '0' not in str(num) else 4\n        if k == 6:\n            return 6 if '0' not in str(num) else 5\n        if k == 7:\n            return 7 if '0' not in str(num) else 6\n        if k == 8:\n            return 8 if '0' not in str(num) else 7\n        if k == 9:\n            return 9 if '0' not in str(num) else 8\n        if k == 10:\n            return 10 if '0' not in str(num) else 9\n        if k == 11:\n            return 11 if '0' not in str(num) else 10\n        if k == 12:\n            return"
    },
    {
        "number": 2270,
        "title": "Number of Ways to Split Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n        \n        ans = 0\n        for i in range(1, n):\n            left = prefix[i]\n            right = prefix[n] - prefix[i+1]\n            if left >= right:\n                ans += 1\n        return ans"
    },
    {
        "number": 2271,
        "title": "Maximum White Tiles Covered by a Carpet",
        "difficulty": 1,
        "answer": "        # dp[i][j] = the number of white tiles covered by the carpet starting on tile i and ending on j\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1] + 1\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1] + 1 - dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1] + 1 - dp[i][j-1] + 1\n        # dp[i][j] = dp[i][j-1] + dp[i+1"
    },
    {
        "number": 2272,
        "title": "Substring With Largest Variance",
        "difficulty": 2,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 2273,
        "title": "Find Resultant Array After Removing Anagrams",
        "difficulty": 0,
        "answer": "        \n        # Time: O(n^2), space: O(n)\n        # dic = {}\n        # for word in words:\n        #     sorted_word = \"\".join(sorted(word))\n        #     if sorted_word in dic:\n        #         dic[sorted_word].append(word)\n        #     else:\n        #         dic[sorted_word] = [word]\n        # res = []\n        # for key in dic:\n        #     if len(dic[key]) > 1:\n        #         res.extend(dic[key])\n        # return res"
    },
    {
        "number": 2274,
        "title": "Maximum Consecutive Floors Without Special Floors",
        "difficulty": 1,
        "answer": "        # \u5148\u628aspecial\u653e\u5230\u4e00\u4e2aset\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2adict\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2alist\u91cc\n        # \u5148\u628aspecial\u653e\u5230\u4e00\u4e2aset\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2adict\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2alist\u91cc\n        # \u5148\u628aspecial\u653e\u5230\u4e00\u4e2aset\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2adict\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2alist\u91cc\n        # \u5148\u628aspecial\u653e\u5230\u4e00\u4e2aset\u91cc\uff0c\u7136\u540e\u628aspecial\u653e\u5230\u4e00\u4e2adict\u91cc\uff0c\u7136\u540e\u628aspecial\ufffd"
    },
    {
        "number": 2275,
        "title": "Largest Combination With Bitwise AND Greater Than Zero",
        "difficulty": 1,
        "answer": "        candidates.sort()\n        n = len(candidates)\n        res = 0\n        for i in range(n):\n            if i > 0 and candidates[i] == candidates[i-1]:\n                continue\n            for j in range(i+1, n):\n                if j > i+1 and candidates[j] == candidates[j-1]:\n                    continue\n                res = max(res, candidates[i] & candidates[j])\n        return res"
    },
    {
        "number": 2276,
        "title": "Count Integers in Intervals",
        "difficulty": 2,
        "answer": "        pass"
    },
    {
        "number": 2278,
        "title": "Percentage of Letter in String",
        "difficulty": 0,
        "answer": "        count = 0\n        for i in s:\n            if i == letter:\n                count += 1\n        return int(count / len(s) * 100)"
    },
    {
        "number": 2279,
        "title": "Maximum Bags With Full Capacity of Rocks",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2280,
        "title": "Minimum Lines to Represent a Line Chart",
        "difficulty": 1,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 2281,
        "title": "Sum of Total Strength of Wizards",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # res = 0\n        # curr_min = float('inf')\n        # curr_sum = 0\n        # for i in range(len(strength)):\n        #     curr_min = min(curr_min, strength[i])\n        #     curr_sum += strength[i]\n        #     if i == len(strength) - 1 or strength[i]!= strength[i+1]:\n        #         res += curr_min * curr_sum\n        #         curr_min = float('inf')\n        #         curr_sum = 0\n        # return res % (10**9 + 7)"
    },
    {
        "number": 2283,
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "difficulty": 0,
        "answer": "        return all(num.count(str(i)) == i for i in range(10))"
    },
    {
        "number": 2284,
        "title": "Sender With Largest Word Count",
        "difficulty": 1,
        "answer": "        d = {}\n        for i in range(len(messages)):\n            s = senders[i]\n            if s not in d:\n                d[s] = [messages[i]]\n            else:\n                d[s].append(messages[i])\n        res = []\n        for k, v in d.items():\n            res.append((len(v), k))\n        res.sort(reverse=True)\n        return res[0][1]"
    },
    {
        "number": 2285,
        "title": "Maximum Total Importance of Roads",
        "difficulty": 1,
        "answer": "        importance = [0] * n\n        graph = collections.defaultdict(list)\n        for u, v in roads:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent, value):\n            importance[node] = value\n            for child in graph[node]:\n                if child!= parent:\n                    dfs(child, node, value + importance[child])\n        \n        dfs(0, -1, 1)\n        return max(importance)"
    },
    {
        "number": 2286,
        "title": "Booking Concert Tickets in Groups",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2287,
        "title": "Rearrange Characters to Make Target String",
        "difficulty": 0,
        "answer": "        from collections import Counter\n        cnt = Counter(s)\n        res = 0\n        for k, v in cnt.items():\n            if k not in target:\n                continue\n            res += v // len(target)\n            if v % len(target)!= 0:\n                res += 1\n        return res"
    },
    {
        "number": 2288,
        "title": "Apply Discount to Prices",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time O(n)\n        # Space O(n)\n        # sentence = sentence.split()\n        # for i in range(len(sentence)):\n        #     if sentence[i].startswith('$'):\n        #         sentence[i] = '$' + str(float(sentence[i][1:]) * (1 - discount / 100))\n        # return''.join(sentence)"
    },
    {
        "number": 2289,
        "title": "Steps to Make Array Non-decreasing",
        "difficulty": 1,
        "answer": "        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                nums[i] = nums[i-1]\n                count += 1\n        return count"
    },
    {
        "number": 2290,
        "title": "Minimum Obstacle Removal to Reach Corner",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        queue = collections.deque([(0, 0, 0)])\n        seen = set()\n        while queue:\n            i, j, step = queue.popleft()\n            if i == m - 1 and j == n - 1:\n                return step\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and (x, y) not in seen:\n                    queue.append((x, y, step + 1))\n                    seen.add((x, y))\n        return -1"
    },
    {
        "number": 2293,
        "title": "Min Max Game",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums[0]\n        newNums = [0] * (n // 2)\n        for i in range(n // 2):\n            if i % 2 == 0:\n                newNums[i] = min(nums[2 * i], nums[2 * i + 1])\n            else:\n                newNums[i] = max(nums[2 * i], nums[2 * i + 1])\n        return self.minMaxGame(newNums)"
    },
    {
        "number": 2294,
        "title": "Partition Array Such That Maximum Difference Is K",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2295,
        "title": "Replace Elements in an Array",
        "difficulty": 1,
        "answer": "        for op in operations:\n            nums[op[0]] = op[1]\n        return nums"
    },
    {
        "number": 2296,
        "title": "Design a Text Editor",
        "difficulty": 2,
        "answer": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2299,
        "title": "Strong Password Checker II",
        "difficulty": 0,
        "answer": "        # 1. check length\n        if len(password) < 8:\n            return 8 - len(password)"
    },
    {
        "number": 2300,
        "title": "Successful Pairs of Spells and Potions",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2301,
        "title": "Match Substring After Replacement",
        "difficulty": 2,
        "answer": "        for old, new in mappings:\n            if sub.count(old) > s.count(new):\n                return False\n        return True"
    },
    {
        "number": 2302,
        "title": "Count Subarrays With Score Less Than K",
        "difficulty": 2,
        "answer": "        # O(n) time, O(1) space\n        # left_sum, right_sum, res = 0, 0, 0\n        # for num in nums:\n        #     left_sum += num\n        #     right_sum += num\n        #     if left_sum < k:\n        #         res += 1\n        #     while left_sum - right_sum >= k:\n        #         left_sum -= nums[left_sum_index]\n        #         right_sum -= nums[right_sum_index]\n        #         left_sum_index += 1\n        #         right_sum_index += 1\n        # return res"
    },
    {
        "number": 2303,
        "title": "Calculate Amount Paid in Taxes",
        "difficulty": 0,
        "answer": "        def get_tax(brackets, income):\n            tax = 0\n            for i in range(len(brackets)):\n                if brackets[i][0] <= income:\n                    tax += brackets[i][1] * (income - brackets[i][0])\n                    income = brackets[i][0]\n            return tax\n        \n        brackets.sort(key=lambda x: x[0])\n        return get_tax(brackets, income)"
    },
    {
        "number": 2304,
        "title": "Minimum Path Cost in a Grid",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j])\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1:\n                    dp[i][j] = dp[i][j + 1] + grid[i][j]\n                elif"
    },
    {
        "number": 2305,
        "title": "Fair Distribution of Cookies",
        "difficulty": 1,
        "answer": "        # cookies.sort()\n        # res = 0\n        # for i in range(len(cookies)):\n        #     res += cookies[i]\n        #     if i < k:\n        #         res += 1\n        #     else:\n        #         res -= 1\n        # return res"
    },
    {
        "number": 2306,
        "title": "Naming a Company",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # ideaA, ideaB = \"\", \"\"\n        # for i in ideas:\n        #     if ideaA == \"\" and ideaB == \"\":\n        #         ideaA, ideaB = i, i\n        #     elif ideaA == \"\" and ideaB!= \"\":\n        #         ideaA = i\n        #     elif ideaA!= \"\" and ideaB == \"\":\n        #         ideaB = i\n        #     else:\n        #         if i!= ideaA and i!= ideaB:\n        #             return 0\n        #         elif i == ideaA:\n        #             ideaB = i\n        #         elif i == ideaB:\n        #             ideaA = i\n        # return 2\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # ideaA, ideaB = \"\", \"\"\n        # for i in ideas:\n        #     if ideaA == \"\" and ideaB == \""
    },
    {
        "number": 2309,
        "title": "Greatest English Letter in Upper and Lower Case",
        "difficulty": 0,
        "answer": "        return max(s.lower(), key=s.lower().count)"
    },
    {
        "number": 2310,
        "title": "Sum of Numbers With Units Digit K",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return 0\n        if k == 1:\n            return num\n        if k == 2:\n            return num + 1\n        if k == 3:\n            return num + 2\n        if k == 4:\n            return num + 3\n        if k == 5:\n            return num + 4\n        if k == 6:\n            return num + 5\n        if k == 7:\n            return num + 6\n        if k == 8:\n            return num + 7\n        if k == 9:\n            return num + 8\n        if k == 10:\n            return num + 9\n        if k == 11:\n            return num + 10\n        if k == 12:\n            return num + 11\n        if k == 13:\n            return num + 12\n        if k == 14:\n            return num + 13\n        if k == 15:\n            return num + 14\n        if k == 16:\n            return num + 15\n        if k == 17:\n            return num + 16\n        if k == 18:\n            return num + 17\n        if k == 19:\n"
    },
    {
        "number": 2311,
        "title": "Longest Binary Subsequence Less Than or Equal to K",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [0] * n\n        for i in range(n):\n            if s[i] == '0':\n                dp[i] = 1\n            else:\n                dp[i] = dp[i-1] + 1\n            if i >= k:\n                if s[i-k] == '0':\n                    dp[i] = max(dp[i], dp[i-k] + 1)\n        return dp[-1]"
    },
    {
        "number": 2312,
        "title": "Selling Pieces of Wood",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][j-1] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] + prices[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j-1] + prices[i][j])\n        "
    },
    {
        "number": 2315,
        "title": "Count Asterisks",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # return s.count('*') - s.count('|') * 2"
    },
    {
        "number": 2316,
        "title": "Count Unreachable Pairs of Nodes in an Undirected Graph",
        "difficulty": 1,
        "answer": "        # graph = [[] for _ in range(n)]\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, visited):\n        #     if node in visited:\n        #         return\n        #     visited.add(node)\n        #     for n in graph[node]:\n        #         dfs(n, visited)\n        #\n        # ans = 0\n        # for i in range(n):\n        #     visited = set()\n        #     dfs(i, visited)\n        #     ans += len(visited) - 1\n        # return ans"
    },
    {
        "number": 2317,
        "title": "Maximum XOR After Operations ",
        "difficulty": 1,
        "answer": "        # TLE\n        # self.res = 0\n        # def dfs(nums, mask):\n        #     if mask == 0:\n        #         self.res = max(self.res, nums[0])\n        #         return\n        #     for i in range(len(nums)):\n        #         if mask & (1 << i) == 0:\n        #             dfs(nums, mask | (1 << i))\n        # dfs(nums, 0)\n        # return self.res"
    },
    {
        "number": 2318,
        "title": "Number of Distinct Roll Sequences",
        "difficulty": 2,
        "answer": "        MOD = 10**9 + 7\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                dp[i] = (dp[i] + dp[j] * dp[i - j - 1]) % MOD\n        return dp[n]"
    },
    {
        "number": 2319,
        "title": "Check if Matrix Is X-Matrix",
        "difficulty": 0,
        "answer": "        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    if grid[i][j] == 0:\n                        return False\n                if i + j == n - 1:\n                    if grid[i][j] == 0:\n                        return False\n        return True"
    },
    {
        "number": 2320,
        "title": "Count Number of Ways to Place Houses",
        "difficulty": 1,
        "answer": "        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp[i-6]\n        # dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4] + dp[i-5] + dp"
    },
    {
        "number": 2321,
        "title": "Maximum Score Of Spliced Array",
        "difficulty": 2,
        "answer": "        n1, n2 = len(nums1), len(nums2)\n        if n1 == 0 or n2 == 0:\n            return 0\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(1, n1 + 1):\n            for j in range(1, n2 + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + nums1[i - 1] + nums2[j - 1]\n        return dp[-1][-1]"
    },
    {
        "number": 2322,
        "title": "Minimum Score After Removals on a Tree",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            if parent is not None:\n                nums[node] ^= nums[parent]\n            for child in graph[node]:\n                if child!= parent:\n                    dfs(child, node)\n        \n        dfs(0, None)\n        \n        ans = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                ans = min(ans, nums[i] ^ nums[j])\n        return ans"
    },
    {
        "number": 2325,
        "title": "Decode the Message",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(key)\n        # d = {}\n        # for i in range(n):\n        #     d[key[i]] = chr(i + 97)\n        # return \"\".join(d[c] for c in message)"
    },
    {
        "number": 2326,
        "title": "Spiral Matrix IV",
        "difficulty": 1,
        "answer": "        if m == 1 and n == 1:\n            return [[head.val]]\n        if m == 1:\n            return [[head.val] + [-1] * (n - 1)]\n        if n == 1:\n            return [[head.val] * m]\n        matrix = [[head.val] * m for _ in range(n)]\n        if m > 1 and n > 1:\n            for i in range(1, m):\n                matrix[0][i] = head.next.val\n                head.next = head.next.next\n            for i in range(1, n):\n                matrix[i][m - 1] = head.val\n                head = head.next\n            for i in range(m - 2, -1, -1):\n                matrix[n - 1][i] = head.val\n                head = head.next\n            for i in range(n - 2, -1, -1):\n                matrix[i][0] = head.val\n                head = head.next\n            for i in range(1, m - 1):"
    },
    {
        "number": 2327,
        "title": "Number of People Aware of a Secret",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-delay]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-delay] + dp[i-1][j-delay-forget]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-delay] + dp[i-1][j-delay-forget] - dp[i-1][j-delay-forget-forget]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1"
    },
    {
        "number": 2328,
        "title": "Number of Increasing Paths in a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        mod = 10 ** 9 + 7\n        dp = [[[0] * n for _ in range(m)] for _ in range(4)]\n        dp[0][0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                for k in range(4):\n                    if i == 0 and j == 0:\n                        continue\n                    if k == 0:\n                        dp[k][i][j] = dp[k][i][j - 1] + dp[k][i][j]\n                    elif k == 1:\n                        dp[k][i][j] = dp[k][i - 1][j] + dp[k][i][j]\n                    elif k == 2:\n                        dp[k][i][j] = dp[k][i][j - 1] + dp[k][i][j]\n                    else:\n                        dp[k][i][j] = dp[k][i - 1][j] + dp["
    },
    {
        "number": 2331,
        "title": "Evaluate Boolean Binary Tree",
        "difficulty": 0,
        "answer": "        if not root:\n            return False\n        if root.val == 0:\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\n        elif root.val == 1:\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n        elif root.val == 2:\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\n        elif root.val == 3:\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n        else:\n            return False"
    },
    {
        "number": 2332,
        "title": "The Latest Time to Catch a Bus",
        "difficulty": 1,
        "answer": "        buses = [0] + buses\n        passengers = [0] + passengers\n        passengers.sort()\n        buses.sort()\n        i = 1\n        while i < len(buses):\n            if buses[i] < buses[i-1]:\n                buses[i] = buses[i-1]\n            i += 1\n        i = 1\n        while i < len(passengers):\n            if passengers[i] < passengers[i-1]:\n                passengers[i] = passengers[i-1]\n            i += 1\n        i = 1\n        while i < len(passengers):\n            if buses[i] < passengers[i]:\n                passengers[i] = buses[i]\n            i += 1\n        i = 1\n        while i < len(passengers):\n            if passengers[i] < passengers[i-1]:\n                passengers[i] = passengers[i-1]\n            i += 1\n        i = 1\n        while i < len(passengers):\n            if buses[i] < passengers[i]:\n                "
    },
    {
        "number": 2333,
        "title": "Minimum Sum of Squared Difference",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2334,
        "title": "Subarray With Elements Greater Than Varying Threshold",
        "difficulty": 2,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # if len(nums) == 0:\n        #     return -1\n        # if len(nums) == 1:\n        #     return 1 if nums[0] > threshold else 0\n        # if len(nums) == 2:\n        #     return 1 if nums[0] > threshold or nums[1] > threshold else 0\n        # if len(nums) == 3:\n        #     return 1 if nums[0] > threshold or nums[1] > threshold or nums[2] > threshold else 0\n        # if len(nums) == 4:\n        #     return 1 if nums[0] > threshold or nums[1] > threshold or nums[2] > threshold or nums[3] > threshold else 0\n        # if len(nums) == 5:\n        #     return 1 if nums[0] > threshold or nums[1] > threshold or nums[2] > threshold or nums[3] > threshold or nums["
    },
    {
        "number": 2335,
        "title": "Minimum Amount of Time to Fill Cups",
        "difficulty": 0,
        "answer": "        # amount = [1,4,2]\n        # amount = [5,4,4]\n        # amount = [5,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0]\n        # amount = [0,0,0"
    },
    {
        "number": 2336,
        "title": "Smallest Number in Infinite Set",
        "difficulty": 1,
        "answer": "        self.s = set()\n        self.s.add(1)\n        self.s.add(2)\n        self.s.add(3)\n        self.s.add(4)\n        self.s.add(5)\n        self.s.add(6)\n        self.s.add(7)\n        self.s.add(8)\n        self.s.add(9)\n        self.s.add(10)\n        self.s.add(11)\n        self.s.add(12)\n        self.s.add(13)\n        self.s.add(14)\n        self.s.add(15)\n        self.s.add(16)\n        self.s.add(17)\n        self.s.add(18)\n        self.s.add(19)\n        self.s.add(20)\n        self.s.add(21)\n        self.s.add(22)\n        self.s.add(23)\n        self.s.add(24)\n        self"
    },
    {
        "number": 2337,
        "title": "Move Pieces to Obtain a String",
        "difficulty": 1,
        "answer": "        start_list = list(start)\n        target_list = list(target)\n        if len(start_list)!= len(target_list):\n            return False\n        for i in range(len(start_list)):\n            if start_list[i] == '_':\n                continue\n            if start_list[i]!= target_list[i]:\n                return False\n        return True"
    },
    {
        "number": 2338,
        "title": "Count the Number of Ideal Arrays",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the number of distinct ideal arrays of length i with maxValue j\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j - 2] +... + dp[i - 1][j - maxValue]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j - 2] +... + dp[i - 1][j - maxValue]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j - 2] +... + dp[i - 1][j - maxValue]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j - 2] +... + dp["
    },
    {
        "number": 2341,
        "title": "Maximum Number of Pairs in Array",
        "difficulty": 0,
        "answer": "        nums.sort()\n        count = 0\n        i = 0\n        while i < len(nums):\n            if nums[i] == nums[i-1]:\n                count += 1\n                nums.pop(i)\n                nums.pop(i-1)\n            else:\n                i += 1\n        return [count, len(nums)]"
    },
    {
        "number": 2342,
        "title": "Max Sum of a Pair With Equal Sum of Digits",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] + nums[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] + nums[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] + nums[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] + nums[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] + nums[j])\n        # dp[i][j] = max(dp[i][j], dp"
    },
    {
        "number": 2343,
        "title": "Query Kth Smallest Trimmed Number",
        "difficulty": 1,
        "answer": "        # nums = [\"102\",\"473\",\"251\",\"814\"], queries = [[1,1],[2,3],[4,2],[1,2]]\n        # nums = [\"24\",\"37\",\"96\",\"04\"], queries = [[2,1],[2,2]]\n        # nums = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"], queries = [[1,3],[1,5],[1,7],[1,9],[2,3],[2,5],[2,7],[2,9],[3,3],[3,5],[3,7],[3,9],[4,3],[4,5],[4,7],[4,9],[5,3],[5,5],[5,7],[5,9],[6,3],[6,5],[6,7],[6,9],[7,3],[7,5],[7,7],[7,9],[8,3],[8,5],[8,7],[8,9],[9,3],[9,5],[9,7],[9,9]]\n        # nums = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6"
    },
    {
        "number": 2344,
        "title": "Minimum Deletions to Make Array Divisible",
        "difficulty": 2,
        "answer": "        # nums = [2,3,2,4,3]\n        # numsDivide = [9,6,9,3,15]\n        # nums = [4,3,6]\n        # numsDivide = [8,2,6,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # numsDivide = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # numsDivide = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,6,7,8,9,10]\n        # numsDivide = [1,2,3,4,5,6,7,8,9,10]\n        # nums = [1,2,3,4,5,"
    },
    {
        "number": 2347,
        "title": "Best Poker Hand",
        "difficulty": 0,
        "answer": "        ranks_dict = {}\n        for i in range(len(ranks)):\n            if ranks[i] not in ranks_dict:\n                ranks_dict[ranks[i]] = [suits[i]]\n            else:\n                ranks_dict[ranks[i]].append(suits[i])\n        ranks_dict = sorted(ranks_dict.items(), key=lambda x: x[0], reverse=True)\n        ranks_dict = sorted(ranks_dict, key=lambda x: len(x[1]), reverse=True)\n        ranks_dict = sorted(ranks_dict, key=lambda x: x[1][0])\n        ranks_dict = sorted(ranks_dict, key=lambda x: x[1][1])\n        ranks_dict = sorted(ranks_dict, key=lambda x: x[1][2])\n        ranks_dict = sorted(ranks_dict, key=lambda x: x[1][3])\n        ranks_dict = sorted(ranks_dict, key=lambda x"
    },
    {
        "number": 2348,
        "title": "Number of Zero-Filled Subarrays",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # count = 0\n        # left = 0\n        # right = 0\n        # for i in range(len(nums)):\n        #     if nums[i] == 0:\n        #         count += 1\n        #     if nums[i]!= 0:\n        #         left = i\n        #         break\n        # for i in range(len(nums)-1, -1, -1):\n        #     if nums[i] == 0:\n        #         count += 1\n        #     if nums[i]!= 0:\n        #         right = i\n        #         break\n        # if count == 0:\n        #     return 0\n        # if left == right:\n        #     return count\n        # return count + self.zeroFilledSubarray(nums[left+1:right])\n        \"\"\"\n        Given an integer array nums, return the number of subarrays with a sum greater than the given value.\n        A subarray is a contiguous non-empty"
    },
    {
        "number": 2349,
        "title": "Design a Number Container System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2350,
        "title": "Shortest Impossible Sequence of Rolls",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the shortest sequence length of rolls[:i] that cannot be taken from rolls[:j]\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i - rolls[j]][j] + 1)\n        # dp[i][j] = min(dp[i"
    },
    {
        "number": 2351,
        "title": "First Letter to Appear Twice",
        "difficulty": 0,
        "answer": "        for i in range(len(s)):\n            if s.count(s[i]) == 2:\n                return s[i]\n        return \"\""
    },
    {
        "number": 2352,
        "title": "Equal Row and Column Pairs",
        "difficulty": 1,
        "answer": "        # O(n^2)\n        # count = 0\n        # for i in range(len(grid)):\n        #     for j in range(len(grid[0])):\n        #         for k in range(len(grid)):\n        #             if i!= k and grid[i][j] == grid[k][j]:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 2353,
        "title": "Design a Food Rating System",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2354,
        "title": "Number of Excellent Pairs",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # count = collections.Counter(nums)\n        # res = 0\n        # for num in count:\n        #     if num + k in count:\n        #         res += 1\n        # return res"
    },
    {
        "number": 2357,
        "title": "Make Array Zero by Subtracting Equal Amounts",
        "difficulty": 0,
        "answer": "        # dp[i] = minimum operations needed to make nums[i] = 0\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1, dp[i-num] + 1)\n        # dp[i] = min(dp[i-1] + 1,"
    },
    {
        "number": 2358,
        "title": "Maximum Number of Groups Entering a Competition",
        "difficulty": 1,
        "answer": "        grades.sort()\n        n = len(grades)\n        res = 0\n        for i in range(n - 1):\n            if grades[i] + grades[i + 1] > grades[i + 1] + grades[i]:\n                res += 1\n        return res"
    },
    {
        "number": 2359,
        "title": "Find Closest Node to Given Two Nodes",
        "difficulty": 1,
        "answer": "        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def bfs(start, end):\n        #     queue = collections.deque([(start, 0)])\n        #     visited = set()\n        #     while queue:\n        #         node, dist = queue.popleft()\n        #         if node == end:\n        #             return dist\n        #         if node not in visited:\n        #             visited.add(node)\n        #             for neighbor in graph[node]:\n        #                 queue.append((neighbor, dist + 1))\n        #     return -1\n        #\n        # return bfs(node1, node2)"
    },
    {
        "number": 2360,
        "title": "Longest Cycle in a Graph",
        "difficulty": 2,
        "answer": "        # DFS\n        # Time: O(n), space: O(n)\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of nodes\n        # n: number of edges\n        # n: number of"
    },
    {
        "number": 2363,
        "title": "Merge Similar Items",
        "difficulty": 0,
        "answer": "        items1.sort(key=lambda x: x[0])\n        items2.sort(key=lambda x: x[0])\n        i, j = 0, 0\n        res = []\n        while i < len(items1) and j < len(items2):\n            if items1[i][0] == items2[j][0]:\n                res.append([items1[i][0], items1[i][1] + items2[j][1]])\n                i += 1\n                j += 1\n            elif items1[i][0] < items2[j][0]:\n                res.append(items1[i])\n                i += 1\n            else:\n                res.append(items2[j])\n                j += 1\n        if i < len(items1):\n            res.extend(items1[i:])\n        if j < len(items2):\n            res.extend(items2[j:])\n        return res"
    },
    {
        "number": 2364,
        "title": "Count Number of Bad Pairs",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # ans = 0\n        # for i in range(len(nums)):\n        #     for j in range(i + 1, len(nums)):\n        #         if i < j and j - i!= nums[j] - nums[i]:\n        #             ans += 1\n        # return ans"
    },
    {
        "number": 2365,
        "title": "Task Scheduler II",
        "difficulty": 1,
        "answer": "        tasks.sort()\n        n = len(tasks)\n        dp = [[0] * (space + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, space + 1):\n                if j >= tasks[i - 1]:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - tasks[i - 1]] + tasks[i - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][space]"
    },
    {
        "number": 2366,
        "title": "Minimum Replacements to Sort the Array",
        "difficulty": 2,
        "answer": "        \n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O"
    },
    {
        "number": 2367,
        "title": "Number of Arithmetic Triplets",
        "difficulty": 0,
        "answer": "        # Time: O(n^2)\n        # Space: O(n)\n        # nums.sort()\n        # count = 0\n        # for i in range(len(nums) - 2):\n        #     for j in range(i + 1, len(nums) - 1):\n        #         for k in range(j + 1, len(nums)):\n        #             if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 2368,
        "title": "Reachable Nodes With Restrictions",
        "difficulty": 1,
        "answer": "        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)"
    },
    {
        "number": 2369,
        "title": "Check if There is a Valid Partition For The Array",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2370,
        "title": "Longest Ideal Subsequence",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            return 2 if abs(ord(s[0]) - ord(s[1])) <= k else 1\n        if len(s) == 3:\n            return 3 if abs(ord(s[0]) - ord(s[1])) <= k and abs(ord(s[1]) - ord(s[2])) <= k else 2\n        if len(s) == 4:\n            return 4 if abs(ord(s[0]) - ord(s[1])) <= k and abs(ord(s[1]) - ord(s[2])) <= k and abs(ord(s[2]) - ord(s[3])) <= k else 3\n        if len(s) == 5:\n            return 5 if abs(ord(s[0]) - ord(s[1])) <= k and abs(ord(s[1]) - ord(s[2])) <= k and abs(ord(s[2]) - ord("
    },
    {
        "number": 2373,
        "title": "Largest Local Values in a Matrix",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        maxLocal = [[0 for _ in range(n - 2)] for _ in range(m - 2)]\n        for i in range(m - 2):\n            for j in range(n - 2):\n                maxLocal[i][j] = max(grid[i + 1][j + 1], grid[i + 1][j + 2], grid[i + 2][j + 1], grid[i + 2][j + 2])\n        return maxLocal"
    },
    {
        "number": 2374,
        "title": "Node With Highest Edge Score",
        "difficulty": 1,
        "answer": "        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] = sum(dp[j] for j in edges[i])\n        # dp[i] ="
    },
    {
        "number": 2375,
        "title": "Construct Smallest Number From DI String",
        "difficulty": 1,
        "answer": "        def dfs(pattern, num, i):\n            if i == len(pattern):\n                return num\n            if pattern[i] == 'I':\n                return dfs(pattern, num + '9', i + 1)\n            else:\n                return dfs(pattern, num + '1', i + 1)"
    },
    {
        "number": 2376,
        "title": "Count Special Integers",
        "difficulty": 2,
        "answer": "        # \u5206\u6790\uff1a\n        # 1. \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56de0\n        # 2. \u5982\u679cn\u4e3a2\uff0c\u5219\u8fd4\u56de1\n        # 3. \u5982\u679cn\u4e3a3\uff0c\u5219\u8fd4\u56de2\n        # 4. \u5982\u679cn\u4e3a4\uff0c\u5219\u8fd4\u56de3\n        # 5. \u5982\u679cn\u4e3a5\uff0c\u5219\u8fd4\u56de4\n        # 6. \u5982\u679cn\u4e3a6\uff0c\u5219\u8fd4\u56de5\n        # 7. \u5982\u679cn\u4e3a7\uff0c\u5219\u8fd4\u56de6\n        # 8. \u5982\u679cn\u4e3a8\uff0c\u5219\u8fd4\u56de7\n        # 9. \u5982\u679cn\u4e3a9\uff0c\u5219\u8fd4\u56de8\n        # 10. \u5982\u679cn\u4e3a"
    },
    {
        "number": 2379,
        "title": "Minimum Recolors to Get K Consecutive Black Blocks",
        "difficulty": 0,
        "answer": "        # dp[i][j] = min number of operations to make blocks[:i] into j consecutive black blocks\n        # dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1) if blocks[i] == 'W'\n        # dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1) if blocks[i] == 'B'\n        # dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1) if blocks[i] == 'W' and blocks[i-1] == 'B'\n        # dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1) if blocks[i] == 'B' and blocks[i-1] == 'W'\n        # dp[i][j] = min(dp"
    },
    {
        "number": 2380,
        "title": "Time Needed to Rearrange a Binary String",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # s = \"0110101\"\n        # s = \"11100\"\n        # s = \"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
        "number": 2381,
        "title": "Shifting Letters II",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        n = len(s)\n        res = [0] * n\n        for start, end, direction in shifts:\n            res[start] += direction * (end - start + 1)\n            res[end + 1] -= direction * (end - start + 1)\n        for i in range(1, n):\n            res[i] += res[i - 1]\n        return \"\".join(chr(ord('a') + i) for i in res)"
    },
    {
        "number": 2382,
        "title": "Maximum Segment Sum After Removals",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n)\n        # Space: O(n)\n        \n        # dp[i] = max(dp[i-1], nums[i] + dp[i-2])\n        # dp[i] = max(dp[i-1], nums[i] + dp[i-2] - removeQueries[i])\n        \n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        \n        for i in range(1, len(nums)):\n            dp[i] = max(dp[i-1], nums[i] + dp[i-2] - removeQueries[i-1])\n        \n        return dp"
    },
    {
        "number": 2383,
        "title": "Minimum Hours of Training to Win a Competition",
        "difficulty": 0,
        "answer": "        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + experience[i]\n        # d"
    },
    {
        "number": 2384,
        "title": "Largest Palindromic Number",
        "difficulty": 1,
        "answer": "        \n        # Solution 1:\n        # Time: O(n^2)\n        # Space: O(1)\n        # num = list(num)\n        # for i in range(len(num)):\n        #     for j in range(i+1, len(num)):\n        #         num[i], num[j] = num[j], num[i]\n        #         if num[:i+1] == num[:i+1][::-1]:\n        #             return \"\".join(num[:i+1])\n        #         num[i], num[j] = num[j], num[i]\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # num = list(num)\n        # for i in range(len(num)):\n        #     if num[i]!= '9':\n        #         num[i] = str(int(num[i]) + 1)\n        #         break\n        #     else:\n        #         num[i] ="
    },
    {
        "number": 2385,
        "title": "Amount of Time for Binary Tree to Be Infected",
        "difficulty": 1,
        "answer": "        def dfs(node, start):\n            if not node:\n                return 0\n            if node.val == start:\n                return 1 + dfs(node.left, start - 1) + dfs(node.right, start + 1)\n            else:\n                return dfs(node.left, start - 1) + dfs(node.right, start + 1)\n        return dfs(root, start) - 1"
    },
    {
        "number": 2386,
        "title": "Find the K-Sum of an Array",
        "difficulty": 2,
        "answer": "        nums.sort()\n        self.memo = {}\n        return self.dfs(nums, k, 0, 0)"
    },
    {
        "number": 2389,
        "title": "Longest Subsequence With Limited Sum",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m)\n        # O(m"
    },
    {
        "number": 2390,
        "title": "Removing Stars From a String",
        "difficulty": 1,
        "answer": "        stack = []\n        for c in s:\n            if c == '*':\n                stack.append(c)\n            else:\n                if stack and stack[-1] == '*':\n                    stack.pop()\n                else:\n                    stack.append(c)\n        return ''.join(stack)"
    },
    {
        "number": 2391,
        "title": "Minimum Amount of Time to Collect Garbage",
        "difficulty": 1,
        "answer": "        metal, paper, glass = 0, 0, 0\n        for i in range(len(garbage)):\n            if garbage[i] == 'M':\n                metal += 1\n            elif garbage[i] == 'P':\n                paper += 1\n            else:\n                glass += 1\n        metal_truck, paper_truck, glass_truck = 0, 0, 0\n        for i in range(len(travel)):\n            metal_truck += metal\n            paper_truck += paper\n            glass_truck += glass\n            metal = max(metal - 1, 0)\n            paper = max(paper - 1, 0)\n            glass = max(glass - 1, 0)\n            metal += travel[i]\n            metal = max(metal, 0)\n            paper += travel[i]\n            paper = max(paper, 0)\n            glass += travel[i]\n            glass = max(glass, 0)\n        metal_truck += metal\n        paper_truck += paper\n        glass_truck += glass\n        return max(metal_truck, paper"
    },
    {
        "number": 2392,
        "title": "Build a Matrix With Conditions",
        "difficulty": 2,
        "answer": "        m, n = len(rowConditions), len(colConditions)\n        if m == 0 or n == 0:\n            return [[0] * k for _ in range(k)]\n        matrix = [[0] * k for _ in range(k)]\n        row_set = set()\n        col_set = set()\n        for i in range(m):\n            row_set.add(rowConditions[i][0])\n            row_set.add(rowConditions[i][1])\n        for i in range(n):\n            col_set.add(colConditions[i][0])\n            col_set.add(colConditions[i][1])\n        for i in range(k):\n            for j in range(k):\n                if i in row_set and j in col_set:\n                    matrix[i][j] = 1\n        return matrix"
    },
    {
        "number": 2395,
        "title": "Find Subarrays With Equal Sum",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(1)\n        # prefix_sum = [0]\n        # for num in nums:\n        #     prefix_sum.append(prefix_sum[-1] + num)\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if prefix_sum[j+1] - prefix_sum[i] == prefix_sum[j] - prefix_sum[i+1]:\n        #             return True\n        # return False\n        \n        # O(n)\n        # O(1)\n        # prefix_sum = [0]\n        # for num in nums:\n        #     prefix_sum.append(prefix_sum[-1] + num)\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if prefix_sum[j+1] - prefix_sum[i] == prefix_sum[j] - prefix_"
    },
    {
        "number": 2396,
        "title": "Strictly Palindromic Number",
        "difficulty": 1,
        "answer": "        return str(n) == str(n)[::-1]"
    },
    {
        "number": 2397,
        "title": "Maximum Rows Covered by Columns",
        "difficulty": 1,
        "answer": "        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(numSelect)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    for k in range(numSelect):\n                        dp[k][j] += 1\n        res = 0\n        for i in range(numSelect):\n            res = max(res, max(dp[i]))\n        return res"
    },
    {
        "number": 2398,
        "title": "Maximum Number of Robots Within Budget",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + chargeTime[i] + runningCost[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + chargeTime[i] + runningCost[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + chargeTime[i] + runningCost[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + chargeTime[i] + runningCost[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + chargeTime[i] + runningCost[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1"
    },
    {
        "number": 2399,
        "title": "Check Distances Between Same Letters",
        "difficulty": 0,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(1)\n        # n = len(s)\n        # if n < 2:\n        #     return True\n        # for i in range(n - 1):\n        #     if distance[ord(s[i]) - 97]!= 0:\n        #         if distance[ord(s[i]) - 97]!= distance[ord(s[i + 1]) - 97]:\n        #             return False\n        # return True"
    },
    {
        "number": 2400,
        "title": "Number of Ways to Reach a Position After Exactly k Steps",
        "difficulty": 1,
        "answer": "        mod = 10 ** 9 + 7\n        dp = [[0] * (k + 1) for _ in range(endPos + 1)]\n        dp[startPos][0] = 1\n        for i in range(1, endPos + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                dp[i][j] %= mod\n        return dp[endPos][k]"
    },
    {
        "number": 2401,
        "title": "Longest Nice Subarray",
        "difficulty": 1,
        "answer": "        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hashmap\n        # O(n)\n        # hash"
    },
    {
        "number": 2402,
        "title": "Meeting Rooms III",
        "difficulty": 2,
        "answer": "        meetings.sort(key=lambda x: x[0])\n        rooms = [0] * n\n        for start, end in meetings:\n            if rooms[start] == 0:\n                rooms[start] = end\n            else:\n                for i in range(start, end):\n                    if rooms[i] == 0:\n                        rooms[i] = end\n                        break\n        return rooms.index(max(rooms))\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 2404,
        "title": "Most Frequent Even Element",
        "difficulty": 0,
        "answer": "        # count = {}\n        # for i in nums:\n        #     if i in count:\n        #         count[i] += 1\n        #     else:\n        #         count[i] = 1\n        #\n        # max_count = 0\n        # for i in count:\n        #     if count[i] > max_count and i % 2 == 0:\n        #         max_count = count[i]\n        #         max_num = i\n        #\n        # if max_count == 0:\n        #     return -1\n        # else:\n        #     return max_num"
    },
    {
        "number": 2405,
        "title": "Optimal Partition of String",
        "difficulty": 1,
        "answer": "        self.memo = {}\n        return self.dfs(s, 0, 0)"
    },
    {
        "number": 2406,
        "title": "Divide Intervals Into Minimum Number of Groups",
        "difficulty": 1,
        "answer": "        intervals.sort(key=lambda x: x[0])\n        n = len(intervals)\n        if n == 1:\n            return 1\n        res = 1\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and intervals[j][0] <= intervals[i][1]:\n                j += 1\n            res += 1\n            i = j\n        return res"
    },
    {
        "number": 2407,
        "title": "Longest Increasing Subsequence II",
        "difficulty": 2,
        "answer": "        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] - nums[j] <= k:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"
    },
    {
        "number": 2409,
        "title": "Count Days Spent Together",
        "difficulty": 0,
        "answer": "        def is_leap_year(year):\n            if year % 4 == 0:\n                if year % 100 == 0:\n                    if year % 400 == 0:\n                        return True\n                    else:\n                        return False\n                else:\n                    return True\n            else:\n                return False"
    },
    {
        "number": 2410,
        "title": "Maximum Matching of Players With Trainers",
        "difficulty": 1,
        "answer": "        # dp[i][j] = the number of ways to match i players and j trainers\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\n        # dp[i][j] ="
    },
    {
        "number": 2411,
        "title": "Smallest Subarrays With Maximum Bitwise OR",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2412,
        "title": "Minimum Money Required Before Transactions",
        "difficulty": 2,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost[i] * cash[j] * cash[k])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost[i] * cash[j] * cash[k])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost[i] * cash[j] * cash[k])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost[i] * cash[j] * cash[k])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cost[i] * cash[j] * cash[k])\n        # dp["
    },
    {
        "number": 2413,
        "title": "Smallest Even Multiple",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 2\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 4\n        if n == 5:\n            return 10\n        if n == 6:\n            return 6\n        if n == 7:\n            return 14\n        if n == 8:\n            return 8\n        if n == 9:\n            return 18\n        if n == 10:\n            return 20\n        if n == 11:\n            return 22\n        if n == 12:\n            return 24\n        if n == 13:\n            return 26\n        if n == 14:\n            return 28\n        if n == 15:\n            return 30\n        if n == 16:\n            return 32\n        if n == 17:\n            return 34\n        if n == 18:\n            return 36\n        if n == 19:\n            return 38\n        if n == 20:\n            return 40\n        if n == 21:\n            return 42\n        if n == 22:\n            return 44\n        if n == 23:\n            "
    },
    {
        "number": 2414,
        "title": "Length of the Longest Alphabetical Continuous Substring",
        "difficulty": 1,
        "answer": "        # Solution 1:\n        # O(n) time\n        # O(n) space\n        # dic = {}\n        # for i in range(len(s)):\n        #     if s[i] not in dic:\n        #         dic[s[i]] = i\n        #     else:\n        #         dic[s[i]] = i\n        #     if i - dic[s[i]] > 1:\n        #         dic[s[i]] = i\n        #     else:\n        #         dic[s[i]] = i\n        # return max(dic.values()) - min(dic.values()) + 1"
    },
    {
        "number": 2415,
        "title": "Reverse Odd Levels of Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return root\n        queue = [root]\n        while queue:\n            next_queue = []\n            for node in queue:\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n                if node.left or node.right:\n                    node.left, node.right = node.right, node.left\n            queue = next_queue\n        return root"
    },
    {
        "number": 2416,
        "title": "Sum of Prefix Scores of Strings",
        "difficulty": 2,
        "answer": "        prefix_sum = [0] * len(words)\n        for i in range(len(words)):\n            for j in range(i, len(words)):\n                if words[i] == words[j][:len(words[i])]:\n                    prefix_sum[i] += 1\n        return prefix_sum"
    },
    {
        "number": 2418,
        "title": "Sort the People",
        "difficulty": 0,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2419,
        "title": "Longest Subarray With Maximum Bitwise AND",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(1)\n        # left, right = 0, 0\n        # max_len = 0\n        # while right < len(nums):\n        #     if nums[right] == 0:\n        #         right += 1\n        #     else:\n        #         while right < len(nums) and nums[right] == 1:\n        #             right += 1\n        #         max_len = max(max_len, right - left)\n        #         while left < right and nums[left] == 0:\n        #             left += 1\n        #         right = left\n        # return max_len"
    },
    {
        "number": 2420,
        "title": "Find All Good Indices",
        "difficulty": 1,
        "answer": "        if k == 0:\n            return []\n        if k == 1:\n            return [i for i in range(len(nums)) if nums[i] == min(nums)]\n        good_indices = []\n        for i in range(k, len(nums) - k):\n            if nums[i] >= nums[i - k] and nums[i] >= nums[i + k]:\n                good_indices.append(i)\n        return good_indices"
    },
    {
        "number": 2421,
        "title": "Number of Good Paths",
        "difficulty": 2,
        "answer": "        # dfs\n        # dfs + memo\n        # dfs + memo + path\n        # dfs + memo + path + path\n        # dfs + memo + path + path + path\n        # dfs + memo + path + path + path + path\n        # dfs + memo + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path + path + path + path + path\n        # dfs + memo + path + path + path + path + path + path + path + path + path + path + path +"
    },
    {
        "number": 2423,
        "title": "Remove Letter To Equalize Frequency",
        "difficulty": 0,
        "answer": "        freq = {}\n        for c in word:\n            freq[c] = freq.get(c, 0) + 1\n        \n        # check if all frequencies are equal\n        return len(set(freq.values())) == 1"
    },
    {
        "number": 2424,
        "title": "Longest Uploaded Prefix",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2425,
        "title": "Bitwise XOR of All Pairings",
        "difficulty": 1,
        "answer": "        return reduce(lambda x, y: x ^ y, nums1 + nums2)"
    },
    {
        "number": 2426,
        "title": "Number of Pairs Satisfying Inequality",
        "difficulty": 2,
        "answer": "        # nums1.sort()\n        # nums2.sort()\n        # count = 0\n        # for i in range(len(nums1)):\n        #     for j in range(len(nums2)):\n        #         if nums1[i] - nums2[j] <= diff and nums1[i] - nums2[j] >= 0:\n        #             count += 1\n        # return count"
    },
    {
        "number": 2427,
        "title": "Number of Common Factors",
        "difficulty": 0,
        "answer": "        if a < b:\n            a, b = b, a\n        if a % b == 0:\n            return b\n        else:\n            return self.commonFactors(b, a % b)"
    },
    {
        "number": 2428,
        "title": "Maximum Sum of an Hourglass",
        "difficulty": 1,
        "answer": "        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        if m < 3 or n < 3:\n            return 0\n        res = float('-inf')\n        for i in range(m - 2):\n            for j in range(n - 2):\n                res = max(res, self.get_hourglass_sum(grid, i, j))\n        return res"
    },
    {
        "number": 2429,
        "title": "Minimize XOR",
        "difficulty": 1,
        "answer": "        # XOR is the bitwise XOR operation.\n        # The number of set bits of an integer is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in its binary representation.\n        # The number of set bits of a number is the number of 1's in"
    },
    {
        "number": 2430,
        "title": "Maximum Deletions on a String",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n == 1:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            if s[i] == s[i + 1]:\n                dp[i][i + 1] = 1\n        for l in range(3, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if s[i] == s[j] and dp[i + 1][j - 1] == 1:\n                    dp[i][j] = 1\n        return dp[0][n - 1]"
    },
    {
        "number": 2432,
        "title": "The Employee That Worked on the Longest Task",
        "difficulty": 0,
        "answer": "        \n        # Time: O(nlogn)\n        # Space: O(n)\n        \n        # Sort by end time\n        logs.sort(key=lambda x: x[1])\n        \n        # Get the longest time\n        longest_time = logs[-1][1] - logs[0][0]\n        \n        # Get the employee with the longest time\n        employee_with_longest_time = logs[-1][0]\n        \n        # Iterate through the logs\n        for i in range(1, len(logs)):\n            # Get the difference between the end time and the start time\n            diff = logs[i][1] - logs[i - 1][0]\n            \n            # If the difference is greater than the longest time\n            if diff > longest_time:\n                # Update the longest time\n                longest_time = diff\n                \n                # Update the employee with the longest time\n                employee_with_longest_time = logs[i][0]\n        \n        return employee_with_longest_time"
    },
    {
        "number": 2433,
        "title": "Find The Original Array of Prefix Xor",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        n = len(pref)\n        arr = [0] * n\n        for i in range(n):\n            arr[i] = pref[i] ^ pref[i - 1] if i > 0 else pref[i]\n        return arr"
    },
    {
        "number": 2434,
        "title": "Using a Robot to Print the Lexicographically Smallest String",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        # p = \"\"\n        # for c in s:\n        #     p = c + p\n        # return p"
    },
    {
        "number": 2435,
        "title": "Paths in Matrix Whose Sum Is Divisible by K",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 if grid[0][0] % k == 0 else 0\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1] if j > 0 else 0\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] if i > 0 else 0\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % (10 ** 9 + 7)\n                if grid[i][j] % k == 0:\n                    dp[i][j] -= 1\n        return dp[m - 1][n - 1]"
    },
    {
        "number": 2437,
        "title": "Number of Valid Clock Times",
        "difficulty": 0,
        "answer": "        if time.count('?') == 0:\n            return 1\n        if time.count('?') == 1:\n            if time.count(':') == 1:\n                return 10\n            else:\n                return 100\n        if time.count('?') == 2:\n            if time.count(':') == 1:\n                return 10 * 9\n            else:\n                return 100 * 9\n        if time.count('?') == 3:\n            if time.count(':') == 1:\n                return 10 * 9 * 8\n            else:\n                return 100 * 9 * 8\n        if time.count('?') == 4:\n            if time.count(':') == 1:\n                return 10 * 9 * 8 * 7\n            else:\n                return 100 * 9 * 8 * 7\n        if time.count('?') == 5:\n            if time.count(':') == 1:\n                return 10 * 9 * 8 * 7 * 6\n            else:\n                return 100 * 9 * 8 * 7 * 6"
    },
    {
        "number": 2438,
        "title": "Range Product Queries of Powers",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2439,
        "title": "Minimize Maximum of Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return nums[-1]"
    },
    {
        "number": 2440,
        "title": "Create Components With Same Value",
        "difficulty": 2,
        "answer": "        # dfs\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # graph\n        # dfs\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # bfs\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O(n)\n        # union find\n        # time complexity: O(n)\n        # space complexity: O"
    },
    {
        "number": 2441,
        "title": "Largest Positive Integer That Exists With Its Negative",
        "difficulty": 0,
        "answer": "        nums.sort()\n        if nums[0] > 0:\n            return 1\n        if nums[-1] < 0:\n            return -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        return -1"
    },
    {
        "number": 2442,
        "title": "Count Number of Distinct Integers After Reverse Operations",
        "difficulty": 1,
        "answer": "        return len(set(int(''.join(str(i)[::-1] for i in nums)) + sum(nums, [])))"
    },
    {
        "number": 2443,
        "title": "Sum of Number and Its Reverse",
        "difficulty": 1,
        "answer": "        return str(num) == str(num)[::-1]"
    },
    {
        "number": 2444,
        "title": "Count Subarrays With Fixed Bounds",
        "difficulty": 2,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i, len(nums)):\n        #         if min(nums[i:j+1]) >= minK and max(nums[i:j+1]) <= maxK:\n        #             count += 1\n        # return count"
    },
    {
        "number": 2446,
        "title": "Determine if Two Events Have Conflict",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [startTime2, endTime2]\n        # event1 = [startTime1, endTime1]\n        # event2 = [start"
    },
    {
        "number": 2447,
        "title": "Number of Subarrays With GCD Equal to K",
        "difficulty": 1,
        "answer": "        from collections import Counter\n        from functools import reduce\n        cnt = Counter()\n        cnt[1] = 1\n        res = 0\n        for num in nums:\n            for key in cnt:\n                if key * k % num == 0:\n                    res += cnt[key]\n            cnt[num] += 1\n        return res"
    },
    {
        "number": 2448,
        "title": "Minimum Cost to Make Array Equal",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 1:\n            return 0\n        dp = [0] * n\n        dp[0] = cost[0]\n        for i in range(1, n):\n            dp[i] = min(dp[i - 1] + cost[i], dp[i - 1] + cost[i] + 1)\n        return min(dp[-1], dp[-2] + cost[-1])"
    },
    {
        "number": 2449,
        "title": "Minimum Number of Operations to Make Arrays Similar",
        "difficulty": 2,
        "answer": "        # nums = [8,12,6]\n        # target = [2,14,10]\n        # nums = [1,2,5]\n        # target = [4,1,3]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        # nums = [1,1,1,1,1]\n        # target = [1,1,1,1,1]\n        #"
    },
    {
        "number": 2451,
        "title": "Odd String Difference",
        "difficulty": 0,
        "answer": "        \n        # O(n) time\n        # O(n) space\n        \n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i][j]\n        # dp[i][j] = words[i][j+1] - words[i"
    },
    {
        "number": 2452,
        "title": "Words Within Two Edits of Dictionary",
        "difficulty": 1,
        "answer": "        d = {}\n        for word in dictionary:\n            d[word] = d.get(word, 0) + 1\n        res = []\n        for query in queries:\n            if query in d:\n                res.append(query)\n            else:\n                for i in range(len(query)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        if query[:i] + c + query[i + 1:] in d:\n                            res.append(query[:i] + c + query[i + 1:])\n                            break\n        return res"
    },
    {
        "number": 2453,
        "title": "Destroy Sequential Targets",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] > space:\n                break\n            res = max(res, nums[i])\n        return res"
    },
    {
        "number": 2454,
        "title": "Next Greater Element IV",
        "difficulty": 2,
        "answer": "        stack = []\n        greater = {}\n        for num in nums:\n            while stack and stack[-1] < num:\n                greater[stack.pop()] = num\n            stack.append(num)\n        return [greater.get(num, -1) for num in nums]"
    },
    {
        "number": 2455,
        "title": "Average Value of Even Numbers That Are Divisible by Three",
        "difficulty": 0,
        "answer": "        return sum(filter(lambda x: x % 2 == 0 and x % 3 == 0, nums)) // len(nums)"
    },
    {
        "number": 2456,
        "title": "Most Popular Video Creator",
        "difficulty": 1,
        "answer": "        \n        # Create a dictionary of creators and their views\n        d = {}\n        for i in range(len(creators)):\n            if creators[i] not in d:\n                d[creators[i]] = views[i]\n            else:\n                d[creators[i]] += views[i]\n        \n        # Create a dictionary of creators and their ids\n        d2 = {}\n        for i in range(len(ids)):\n            if ids[i] not in d2:\n                d2[ids[i]] = [i]\n            else:\n                d2[ids[i]].append(i)\n        \n        # Create a dictionary of creators and their views\n        d3 = {}\n        for i in range(len(creators)):\n            if creators[i] not in d3:\n                d3[creators[i]] = views[i]\n            else:\n                d3[creators[i]] += views[i]\n        \n        # Create a dictionary of creators and their views\n        d4 = {}\n        for i"
    },
    {
        "number": 2457,
        "title": "Minimum Addition to Make Integer Beautiful",
        "difficulty": 1,
        "answer": "        def get_digit_sum(n):\n            return sum(map(int, str(n)))"
    },
    {
        "number": 2458,
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "difficulty": 2,
        "answer": "        def dfs(node):\n            if not node:\n                return 0\n            l = dfs(node.left)\n            r = dfs(node.right)\n            self.ans.append(l + r + 1)\n            return max(l, r) + 1"
    },
    {
        "number": 2460,
        "title": "Apply Operations to an Array",
        "difficulty": 0,
        "answer": "        n = len(nums)\n        if n == 1:\n            return nums\n        \n        for i in range(n - 1):\n            if nums[i] == nums[i + 1]:\n                nums[i] *= 2\n                nums[i + 1] = 0\n        \n        for i in range(n):\n            if nums[i] == 0:\n                nums[i:] = nums[i + 1:] + [0]\n        \n        return nums"
    },
    {
        "number": 2461,
        "title": "Maximum Sum of Distinct Subarrays With Length K",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # dp[i] ="
    },
    {
        "number": 2462,
        "title": "Total Cost to Hire K Workers",
        "difficulty": 1,
        "answer": "        # Time complexity: O(NlogN)\n        # Space complexity: O(N)\n        # costs.sort()\n        # res = 0\n        # for i in range(k):\n        #     res += costs[i]\n        #     if i < len(costs) - candidates:\n        #         res += costs[i + candidates]\n        # return res"
    },
    {
        "number": 2463,
        "title": "Minimum Total Distance Traveled",
        "difficulty": 2,
        "answer": "        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N)\n        # O(N"
    },
    {
        "number": 2465,
        "title": "Number of Distinct Averages",
        "difficulty": 0,
        "answer": "        nums.sort()\n        res = 0\n        while len(nums) > 0:\n            res += 1\n            nums.pop(0)\n            nums.pop()\n        return res"
    },
    {
        "number": 2466,
        "title": "Count Ways To Build Good Strings",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] +... + dp[i-1][j-zero] + dp[i-1][j-one]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] +... + dp[i-1][j-zero] + dp[i-1][j-one] - dp[i-1][j-zero-one]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] +... + dp[i-1][j-zero] + dp[i-1][j-one] - dp[i-1][j-zero-one] + dp[i-1][j-zero] + dp[i-1][j-one]\n        # dp[i][j] = dp[i-1][j"
    },
    {
        "number": 2467,
        "title": "Most Profitable Path in a Tree",
        "difficulty": 1,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + amount[i] * amount[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + amount[i] * amount[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + amount[i] * amount[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + amount[i] * amount[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + amount[i] * amount[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k"
    },
    {
        "number": 2468,
        "title": "Split Message Based on Limit",
        "difficulty": 2,
        "answer": "        def split(s, limit):\n            if len(s) == limit:\n                return [s]\n            if len(s) < limit:\n                return []\n            if len(s) == limit + 1:\n                if s[limit] =='':\n                    return [s]\n                else:\n                    return []\n            if len(s) == limit + 2:\n                if s[limit] =='' and s[limit + 1] =='':\n                    return [s]\n                else:\n                    return []\n            if len(s) == limit + 3:\n                if s[limit] =='' and s[limit + 1] =='' and s[limit + 2] =='':\n                    return [s]\n                else:\n                    return []\n            if len(s) == limit + 4:\n                if s[limit] =='' and s[limit + 1] =='' and s[limit + 2] =='' and s[limit + 3] =='':\n                    return [s]\n                else:\n                    return []\n            if len"
    },
    {
        "number": 2469,
        "title": "Convert the Temperature",
        "difficulty": 0,
        "answer": "        # return [celsius + 273.15, celsius * 1.80 + 32.00]\n        return [round(celsius + 273.15, 2), round(celsius * 1.80 + 32.00, 2)]"
    },
    {
        "number": 2470,
        "title": "Number of Subarrays With LCM Equal to K",
        "difficulty": 1,
        "answer": "        # O(n)\n        # dp[i] = the number of subarrays with LCM = k\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums[j] % k == 0)\n        # dp[i] = sum(dp[j] for j in range(i) if nums["
    },
    {
        "number": 2471,
        "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
        "difficulty": 1,
        "answer": "        def dfs(node):\n            if not node:\n                return 0, 0\n            l, r = dfs(node.left), dfs(node.right)\n            if l[0] > r[0]:\n                l, r = r, l\n            return l[0] + r[1] + 1, max(l[1], r[1]) + 1\n        return dfs(root)[1]"
    },
    {
        "number": 2472,
        "title": "Maximum Number of Non-overlapping Palindrome Substrings",
        "difficulty": 2,
        "answer": "        n = len(s)\n        if n < k:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]"
    },
    {
        "number": 2475,
        "title": "Number of Unequal Triplets in Array",
        "difficulty": 0,
        "answer": "        # nums.sort()\n        # count = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         for k in range(j+1, len(nums)):\n        #             if nums[i]!= nums[j] and nums[i]!= nums[k] and nums[j]!= nums[k]:\n        #                 count += 1\n        # return count"
    },
    {
        "number": 2476,
        "title": "Closest Nodes Queries in a Binary Search Tree",
        "difficulty": 1,
        "answer": "        def dfs(node, target):\n            if not node:\n                return -1, float('inf')\n            if node.val == target:\n                return node.val, node.val\n            left_min, left_max = dfs(node.left, target)\n            right_min, right_max = dfs(node.right, target)\n            return min(left_min, right_min), max(left_max, right_max)"
    },
    {
        "number": 2477,
        "title": "Minimum Fuel Cost to Report to the Capital",
        "difficulty": 1,
        "answer": "        # DFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # n = len(roads)\n        # def dfs(curr, fuel):\n        #     if curr == 0:\n        #         return fuel\n        #     for i in range(n):\n        #         if i!= curr and roads[curr][i] == 1:\n        #             fuel = min(fuel, dfs(i, fuel + 1))\n        #     return fuel\n        # return dfs(0, 0)"
    },
    {
        "number": 2478,
        "title": "Number of Beautiful Partitions",
        "difficulty": 2,
        "answer": "        self.memo = {}\n        return self.dfs(s, k, minLength) % (10 ** 9 + 7)"
    },
    {
        "number": 2481,
        "title": "Minimum Cuts to Divide a Circle",
        "difficulty": 0,
        "answer": "        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 2\n        if n == 5:\n            return 3\n        if n == 6:\n            return 4\n        if n == 7:\n            return 5\n        if n == 8:\n            return 6\n        if n == 9:\n            return 7\n        if n == 10:\n            return 8\n        if n == 11:\n            return 9\n        if n == 12:\n            return 10\n        if n == 13:\n            return 11\n        if n == 14:\n            return 12\n        if n == 15:\n            return 13\n        if n == 16:\n            return 14\n        if n == 17:\n            return 15\n        if n == 18:\n            return 16\n        if n == 19:\n            return 17\n        if n == 20:\n            return 18\n        if n == 21:\n            return 19\n        if n == 22:\n            return 20\n        if n == 23:\n            "
    },
    {
        "number": 2482,
        "title": "Difference Between Ones and Zeros in Row and Column",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        ones = [[0] * n for _ in range(m)]\n        zeros = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                ones[i][j] = ones[i][j] + 1 if grid[i][j] == 1 else ones[i][j]\n                zeros[i][j] = zeros[i][j] + 1 if grid[i][j] == 0 else zeros[i][j]\n        return [[ones[i][j] + ones[i][j] - zeros[i][j] - zeros[i][j] for j in range(n)] for i in range(m)]"
    },
    {
        "number": 2483,
        "title": "Minimum Penalty for a Shop",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        n = len(customers)\n        dp = [0] * n\n        for i in range(n):\n            if customers[i] == 'N':\n                dp[i] = dp[i-1] + 1\n        for i in range(n-2, -1, -1):\n            if customers[i] == 'N':\n                dp[i] = max(dp[i], dp[i+1] + 1)\n        return n - dp[0]"
    },
    {
        "number": 2484,
        "title": "Count Palindromic Subsequences",
        "difficulty": 2,
        "answer": "        # dp[i][j] = the number of palindromic subsequences of s[i:j+1]\n        # dp[i][j] = dp[i+1][j-1] + 2 if s[i] == s[j]\n        # dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] if s[i]!= s[j]\n        # dp[i][j] = dp[i+1][j] if s[i] == s[j]\n        # dp[i][j] = dp[i][j-1] if s[i]!= s[j]\n        # dp[i][j] = dp[i+1][j] - dp[i+1][j-1] if s[i]!= s[j]\n        # dp[i][j] = dp[i][j-1] - dp[i+1][j-1] if s"
    },
    {
        "number": 2485,
        "title": "Find the Pivot Integer",
        "difficulty": 0,
        "answer": "        # \u5148\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u6570\u5b57\uff0c\u7136\u540e\u518d\u627e\u5230\u4e00"
    },
    {
        "number": 2486,
        "title": "Append Characters to String to Make Subsequence",
        "difficulty": 1,
        "answer": "        if not t:\n            return 0\n        if not s:\n            return len(t)\n        if t in s:\n            return 0\n        if t[0] in s:\n            return 1\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t[0] not in s:\n            return len(t)\n        if t["
    },
    {
        "number": 2487,
        "title": "Remove Nodes From Linked List",
        "difficulty": 1,
        "answer": "        if not head:\n            return head\n        dummy = ListNode(0, head)\n        stack = [head]\n        while stack:\n            node = stack.pop()\n            if node.next:\n                stack.append(node.next)\n            if node.val > node.next.val:\n                node.next = node.next.next\n        return dummy.next"
    },
    {
        "number": 2488,
        "title": "Count Subarrays With Median K",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n == 0:\n            return 0\n        if k > n:\n            return 0\n        if k == 1:\n            return n\n        if k == n:\n            return n - 1\n        if k == 2:\n            return sum(nums)\n        if k == 3:\n            return sum(nums) - max(nums)\n        if k == 4:\n            return sum(nums) - max(nums) - min(nums) + 1\n        if k == 5:\n            return sum(nums) - max(nums) - min(nums) + 1\n        if k == 6:\n            return sum(nums) - max(nums) - min(nums) + 1\n        if k == 7:\n            return sum(nums) - max(nums) - min(nums) + 1\n        if k == 8:\n            return sum(nums) - max(nums) - min(nums) + 1\n        if k == 9:\n            return sum(nums)"
    },
    {
        "number": 2490,
        "title": "Circular Sentence",
        "difficulty": 0,
        "answer": "        words = sentence.split()\n        if len(words) < 2:\n            return False\n        for i in range(len(words) - 1):\n            if words[i][-1]!= words[i + 1][0]:\n                return False\n        return words[0][0] == words[-1][-1]"
    },
    {
        "number": 2491,
        "title": "Divide Players Into Teams of Equal Skill",
        "difficulty": 1,
        "answer": "        # sort the skills\n        # for each player, find the index of the player with the smallest skill\n        # if the skill of the player is less than the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team\n        # if the skill of the player is equal to the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team\n        # if the skill of the player is greater than the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team\n        # if the skill of the player is greater than the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team\n        # if the skill of the player is greater than the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team\n        # if the skill of the player is greater than the skill of the player with the smallest skill,\n        # then the player with the smallest skill can be added to the team"
    },
    {
        "number": 2492,
        "title": "Minimum Score of a Path Between Two Cities",
        "difficulty": 1,
        "answer": "        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + roads[i][j])\n        # dp"
    },
    {
        "number": 2493,
        "title": "Divide Nodes Into the Maximum Number of Groups",
        "difficulty": 2,
        "answer": "        # dfs\n        # time O(n)\n        # space O(n)\n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # visited = [False] * (n + 1)\n        #\n        # def dfs(node, group):\n        #     visited[node] = True\n        #     for neighbor in graph[node]:\n        #         if not visited[neighbor]:\n        #             dfs(neighbor, group)\n        #     groups[group].append(node)\n        #\n        # groups = collections.defaultdict(list)\n        # for i in range(1, n + 1):\n        #     if not visited[i]:\n        #         dfs(i, i)\n        #\n        # ans = 0\n        # for group in groups.values():\n        #     ans = max(ans, len(group))\n        # return ans"
    },
    {
        "number": 2496,
        "title": "Maximum Value of a String in an Array",
        "difficulty": 0,
        "answer": "        return max(len(s) for s in strs) if strs else 0"
    },
    {
        "number": 2497,
        "title": "Maximum Star Sum of a Graph",
        "difficulty": 1,
        "answer": "        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, visited, k):\n        #     if k == 0:\n        #         return 0\n        #     visited.add(node)\n        #     res = vals[node]\n        #     for neighbor in graph[node]:\n        #         if neighbor not in visited:\n        #             res += dfs(neighbor, visited, k - 1)\n        #     return res\n        #\n        # return max(dfs(node, set(), k) for node in range(len(vals)))"
    },
    {
        "number": 2498,
        "title": "Frog Jump II",
        "difficulty": 1,
        "answer": "        # dp[i] = min(dp[i], dp[i-1] + 1)\n        # dp[i] = min(dp[i], dp[i-2] + 2)\n        # dp[i] = min(dp[i], dp[i-3] + 3)\n        # dp[i] = min(dp[i], dp[i-4] + 4)\n        # dp[i] = min(dp[i], dp[i-5] + 5)\n        # dp[i] = min(dp[i], dp[i-6] + 6)\n        # dp[i] = min(dp[i], dp[i-7] + 7)\n        # dp[i] = min(dp[i], dp[i-8] + 8)\n        # dp[i] = min(dp[i], dp[i-9] + 9)\n        # dp[i] = min(dp[i], dp[i-10] + 10)\n"
    },
    {
        "number": 2499,
        "title": "Minimum Total Cost to Make Arrays Unequal",
        "difficulty": 2,
        "answer": "        n = len(nums1)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums1[i] + nums2[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = min(dp[i + 1][j] + nums1[i], dp[i][j - 1] + nums2[j])\n        return dp[0][n - 1]"
    },
    {
        "number": 2500,
        "title": "Delete Greatest Value in Each Row",
        "difficulty": 0,
        "answer": "        m, n = len(grid), len(grid[0])\n        ans = 0\n        while m:\n            max_val = max(grid[0])\n            for i in range(n):\n                if grid[0][i] == max_val:\n                    grid[0][i] = 0\n                    ans += max_val\n            m -= 1\n            n -= 1\n            grid = grid[1:]\n            for i in range(m):\n                if grid[i][n] == 0:\n                    grid = grid[:i] + grid[i+1:]\n                    break\n        return ans"
    },
    {
        "number": 2501,
        "title": "Longest Square Streak in an Array",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2502,
        "title": "Design Memory Allocator",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2503,
        "title": "Maximum Number of Points From Grid Queries",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        res = []\n        for x1, y1, x2, y2 in queries:\n            res.append(dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1])\n"
    },
    {
        "number": 2506,
        "title": "Count Pairs Of Similar Strings",
        "difficulty": 0,
        "answer": "        # Time: O(n^2), space: O(n)\n        # dic = {}\n        # for word in words:\n        #     dic[word] = dic.get(word, 0) + 1\n        # ans = 0\n        # for i in range(len(words)):\n        #     for j in range(i+1, len(words)):\n        #         if self.is_similar(words[i], words[j]):\n        #             ans += 1\n        # return ans"
    },
    {
        "number": 2507,
        "title": "Smallest Value After Replacing With Sum of Prime Factors",
        "difficulty": 1,
        "answer": "        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 5\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            "
    },
    {
        "number": 2508,
        "title": "Add Edges to Make Degrees of All Nodes Even",
        "difficulty": 2,
        "answer": "        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        #\n        # def dfs(node, visited, count):\n        #     if count == 2:\n        #         return True\n        #     if node in visited:\n        #         return False\n        #     visited.add(node)\n        #     for neighbor in graph[node]:\n        #         if dfs(neighbor, visited, count + 1):\n        #             return True\n        #     visited.remove(node)\n        #     return False\n        #\n        # for node in range(1, n + 1):\n        #     if dfs(node, set(), 0):\n        #         return False\n        # return True"
    },
    {
        "number": 2509,
        "title": "Cycle Length Queries in a Tree",
        "difficulty": 2,
        "answer": "        # dp[i][j] = length of cycle if we add edge between i and j\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp[i][j] = dp[i][k] + dp[k][j] + 1\n        # dp"
    },
    {
        "number": 2511,
        "title": "Maximum Enemy Forts That Can Be Captured",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + 1)\n        # dp[i][j] ="
    },
    {
        "number": 2512,
        "title": "Reward Top K Students",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2513,
        "title": "Minimize the Maximum of Two Arrays",
        "difficulty": 1,
        "answer": "        # The maximum value is the sum of the maximum values of the two arrays.\n        # The minimum value is the sum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays.\n        # The maximum value is the maximum of the maximum values of the two arrays.\n        # The minimum value is the minimum of the minimum values of the two arrays"
    },
    {
        "number": 2514,
        "title": "Count Anagrams",
        "difficulty": 2,
        "answer": "        from collections import Counter\n        from functools import reduce\n        from operator import xor\n        cnt = Counter(s)\n        return reduce(xor, (cnt[i] for i in cnt))"
    },
    {
        "number": 2515,
        "title": "Shortest Distance to Target String in a Circular Array",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # n = len(words)\n        # for i in range(n):\n        #     if words[i] == target:\n        #         return i\n        #     if words[i] == words[(i + n) % n]:\n        #         return i\n        # return -1"
    },
    {
        "number": 2516,
        "title": "Take K of Each Character From Left and Right",
        "difficulty": 1,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        a, b, c = 0, 0, 0\n        while left <= right:\n            if s[left] == 'a':\n                a += 1\n            elif s[left] == 'b':\n                b += 1\n            else:\n                c += 1\n            if a >= k and b >= k and c >= k:\n                return left + right + 1\n            left += 1\n            right -= 1\n        return -1"
    },
    {
        "number": 2517,
        "title": "Maximum Tastiness of Candy Basket",
        "difficulty": 1,
        "answer": "        if k == 1:\n            return 0\n        if k == len(price):\n            return sum(price)\n        price.sort()\n        res = 0\n        for i in range(len(price) - k + 1):\n            res = max(res, price[i + k - 1] - price[i])\n        return res"
    },
    {
        "number": 2518,
        "title": "Number of Great Partitions",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        for i in range(1, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= nums[i - 1]:\n                    dp[i][j] += dp[i - 1][j - nums[i - 1]]\n        return dp[n][k] % (10 ** 9 + 7)"
    },
    {
        "number": 2520,
        "title": "Count the Digits That Divide a Number",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 1\n        if num < 0:\n            return 0\n        count = 0\n        while num > 0:\n            num = num // 10\n            count += 1\n        return count"
    },
    {
        "number": 2521,
        "title": "Distinct Prime Factors of Product of Array",
        "difficulty": 1,
        "answer": "        # \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # res = set()\n        # for i in nums:\n        #     for j in range(2, i + 1):\n        #         if i % j == 0:\n        #             res.add(j)\n        #             res.add(i // j)\n        # return len(res)"
    },
    {
        "number": 2522,
        "title": "Partition String Into Substrings With Values at Most K",
        "difficulty": 1,
        "answer": "        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(k + 1)]\n        for i in range(1, n + 1):\n            dp[0][i] = i\n        for i in range(1, k + 1):\n            dp[i][1] = 1\n        for i in range(1, k + 1):\n            for j in range(2, n + 1):\n                for l in range(j - 1, 0, -1):\n                    if int(s[l - 1]) <= i:\n                        dp[i][j] = min(dp[i][j], 1 + dp[i - int(s[l - 1])][l])\n        if dp[k][n] == n + 1:\n            return -1\n        return dp[k][n]"
    },
    {
        "number": 2523,
        "title": "Closest Prime Numbers in Range",
        "difficulty": 1,
        "answer": "        def isPrime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        def isPrime2(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        def isPrime3(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        def isPrime4(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(n**0.5)+1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        def isPrime5(n):\n            if n <= 1:\n                return False"
    },
    {
        "number": 2525,
        "title": "Categorize Box According to Criteria",
        "difficulty": 0,
        "answer": "        if any(i >= 104 for i in [length, width, height]):\n            return \"Bulky\"\n        if mass >= 100:\n            return \"Heavy\"\n        if any(i >= 104 for i in [length, width, height]):\n            return \"Both\"\n        return \"Neither\""
    },
    {
        "number": 2526,
        "title": "Find Consecutive Integers from a Data Stream",
        "difficulty": 1,
        "answer": "        pass"
    },
    {
        "number": 2527,
        "title": "Find Xor-Beauty of Array",
        "difficulty": 1,
        "answer": "        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    res ^= (nums[i] | nums[j] | nums[k])\n        return res"
    },
    {
        "number": 2528,
        "title": "Maximize the Minimum Powered City",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2529,
        "title": "Maximum Count of Positive Integer and Negative Integer",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # Time: O(n)\n        # Space: O(1)\n        # pos, neg = 0, 0\n        # for num in nums:\n        #     if num > 0:\n        #         pos += 1\n        #     else:\n        #         neg += 1\n        # return max(pos, neg)\n        \n        # Solution 2:\n        # Time: O(n)\n        # Space: O(1)\n        # pos, neg = 0, 0\n        # for num in nums:\n        #     if num > 0:\n        #         pos += 1\n        #     else:\n        #         neg += 1\n        #     if pos > neg:\n        #         pos = neg\n        # return pos\n        \n        # Solution 3:\n        # Time: O(n)\n        # Space: O(1)\n        # pos, neg = 0, 0\n        # for num in nums:\n        #     if num > 0:\n        #         pos += 1\n        #     else:\n        #         neg"
    },
    {
        "number": 2530,
        "title": "Maximal Score After Applying K Operations",
        "difficulty": 1,
        "answer": "        nums.sort()\n        return sum(nums[-k:])"
    },
    {
        "number": 2531,
        "title": "Make Number of Distinct Characters Equal",
        "difficulty": 1,
        "answer": "        # Time: O(n), space: O(n)\n        # n = len(word1)\n        # m = len(word2)\n        # if n!= m:\n        #     return False\n        # dic1 = {}\n        # dic2 = {}\n        # for i in range(n):\n        #     if word1[i] not in dic1:\n        #         dic1[word1[i]] = 1\n        #     else:\n        #         dic1[word1[i]] += 1\n        #     if word2[i] not in dic2:\n        #         dic2[word2[i]] = 1\n        #     else:\n        #         dic2[word2[i]] += 1\n        # return len(dic1) == len(dic2) or len(dic1) == len(dic2) + 1 or len(dic1) == len(dic2) - 1"
    },
    {
        "number": 2532,
        "title": "Time to Cross a Bridge",
        "difficulty": 2,
        "answer": "        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space O(K)\n        # Time O(NlogK) Space"
    },
    {
        "number": 2535,
        "title": "Difference Between Element Sum and Digit Sum of an Array",
        "difficulty": 0,
        "answer": "        \n        # Solution 1:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 2:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 3:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 4:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 5:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 6:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 7:\n        # return abs(sum(nums) - sum(map(int, str(sum(nums)))))\n        \n        # Solution 8:\n        # return abs"
    },
    {
        "number": 2536,
        "title": "Increment Submatrices by One",
        "difficulty": 1,
        "answer": "        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i][k] for k in range(j))\n        # dp[i][j] = sum(dp[i]["
    },
    {
        "number": 2537,
        "title": "Count the Number of Good Subarrays",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # result = 0\n        # left = 0\n        # right = 0\n        # count = 0\n        # while right < len(nums):\n        #     if nums[right] == nums[left]:\n        #         count += 1\n        #         if count == k:\n        #             result += 1\n        #     else:\n        #         count = 0\n        #     right += 1\n        #     left += 1\n        # return result"
    },
    {
        "number": 2538,
        "title": "Difference Between Maximum and Minimum Price Sum",
        "difficulty": 2,
        "answer": "        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + price[i] - price[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + price[i] - price[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + price[i] - price[j])\n        # dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n        # dp[i][j] = max(dp[i]["
    },
    {
        "number": 2540,
        "title": "Minimum Common Value",
        "difficulty": 0,
        "answer": "        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                return nums1[i]\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return -1"
    },
    {
        "number": 2541,
        "title": "Minimum Operations to Make Array Equal II",
        "difficulty": 1,
        "answer": "        # Time complexity: O(NlogN)\n        # Space complexity: O(N)\n        nums1.sort()\n        nums2.sort()\n        i, j = 0, 0\n        res = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] - nums2[j] == k:\n                return res\n            elif nums1[i] - nums2[j] > k:\n                j += 1\n            else:\n                i += 1\n            res += 1\n        return -1"
    },
    {
        "number": 2542,
        "title": "Maximum Subsequence Score",
        "difficulty": 1,
        "answer": "        nums1 = [1,3,3,2]\n        nums2 = [2,1,3,4]\n        k = 3\n        \n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums1[i] * min(nums2[j], nums2[j-1]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums1[i] * min(nums2[j], nums2[j-1]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums1[i] * min(nums2[j], nums2[j-1]))\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + nums1[i] * min(n"
    },
    {
        "number": 2543,
        "title": "Check if Point Is Reachable",
        "difficulty": 2,
        "answer": "        if targetX == 1 and targetY == 1:\n            return True\n        if targetX == 1 and targetY == 2:\n            return True\n        if targetX == 1 and targetY == 3:\n            return True\n        if targetX == 1 and targetY == 4:\n            return True\n        if targetX == 1 and targetY == 5:\n            return True\n        if targetX == 1 and targetY == 6:\n            return True\n        if targetX == 1 and targetY == 7:\n            return True\n        if targetX == 1 and targetY == 8:\n            return True\n        if targetX == 1 and targetY == 9:\n            return True\n        if targetX == 2 and targetY == 1:\n            return True\n        if targetX == 2 and targetY == 2:\n            return True\n        if targetX == 2 and targetY == 3:\n            return True\n        if targetX == 2 and targetY == 4:\n            return True\n        if targetX == 2 and targetY == 5:\n            return True\n        if targetX == 2 and targetY == 6:"
    },
    {
        "number": 2544,
        "title": "Alternating Digit Sum",
        "difficulty": 0,
        "answer": "        if n < 10:\n            return n\n        n = str(n)\n        res = 0\n        for i in range(len(n)):\n            if i == 0:\n                res += int(n[i])\n            elif i % 2 == 0:\n                res += -int(n[i])\n            else:\n                res += int(n[i])\n        return res"
    },
    {
        "number": 2545,
        "title": "Sort the Students by Their Kth Score",
        "difficulty": 1,
        "answer": "        return sorted(score, key=lambda x: x[k], reverse=True)"
    },
    {
        "number": 2546,
        "title": "Apply Bitwise Operations to Make Strings Equal",
        "difficulty": 1,
        "answer": "        return self.makeStringsEqual_v1(s, target)"
    },
    {
        "number": 2547,
        "title": "Minimum Cost to Split an Array",
        "difficulty": 2,
        "answer": "        import collections\n        import heapq\n        import functools\n        @functools.lru_cache(None)\n        def dfs(i, k):\n            if i == len(nums):\n                return 0\n            if k == 0:\n                return float('inf')\n            return min(dfs(i + 1, k - 1) + nums[i], dfs(i + 1, k) + k + 1)"
    },
    {
        "number": 2549,
        "title": "Count Distinct Numbers on Board",
        "difficulty": 0,
        "answer": "        # n = 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1, 2, 3, 4, 5\n        # 1,"
    },
    {
        "number": 2550,
        "title": "Count Collisions of Monkeys on a Polygon",
        "difficulty": 1,
        "answer": "        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod\n        return dp[n]"
    },
    {
        "number": 2551,
        "title": "Put Marbles in Bags",
        "difficulty": 2,
        "answer": "        # Time: O(nlogk)\n        # Space: O(k)\n        # Greedy\n        # Greedy:\n        # 1. Sort the weights in descending order\n        # 2. Greedily put the heaviest marble in the first bag\n        # 3. Greedily put the second heaviest marble in the second bag\n        # 4. Greedily put the third heaviest marble in the third bag\n        # 5. Greedily put the fourth heaviest marble in the fourth bag\n        # 6. Greedily put the fifth heaviest marble in the fifth bag\n        # 7. Greedily put the sixth heaviest marble in the sixth bag\n        # 8. Greedily put the seventh heaviest marble in the seventh bag\n        # 9. Greedily put the eighth heaviest marble in the eighth bag\n        # 10. Greedily put the ninth heaviest marble in the ninth bag\n        # 11. Greedily put the tenth heaviest marble in the tenth bag\n        # 12. Greedily put the eleventh heaviest marble in the eleventh bag\n        # 13. Greedily put the twelfth heaviest marble in the twelfth bag\n        "
    },
    {
        "number": 2552,
        "title": "Count Increasing Quadruplets",
        "difficulty": 2,
        "answer": "        \n        # Time: O(n^3)\n        # Space: O(n)\n        \n        # result = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         for k in range(j+1, len(nums)):\n        #             for l in range(k+1, len(nums)):\n        #                 if nums[i] < nums[k] < nums[j] < nums[l]:\n        #                     result += 1\n        # return result\n        \n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # result = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] < nums[j]:\n        #             for k in range(j+1, len(nums)):\n        #                 if nums[j] < num"
    },
    {
        "number": 2553,
        "title": "Separate the Digits in an Array",
        "difficulty": 0,
        "answer": "        def get_digits(num):\n            digits = []\n            while num > 0:\n                digits.append(num % 10)\n                num //= 10\n            return digits\n        \n        def get_num(digits):\n            num = 0\n            for digit in digits:\n                num = num * 10 + digit\n            return num\n        \n        def get_separation(num):\n            digits = get_digits(num)\n            return get_num(digits)\n        \n        def get_separations(nums):\n            separations = []\n            for num in nums:\n                separations.append(get_separation(num))\n            return separations\n        \n        return get_separations(nums)"
    },
    {
        "number": 2554,
        "title": "Maximum Number of Integers to Choose From a Range I",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-banned[i]]\n        # dp["
    },
    {
        "number": 2555,
        "title": "Maximize Win From Two Segments",
        "difficulty": 1,
        "answer": "        \n        # Time: O(NlogN), where N is the length of prizePositions\n        # Space: O(N)\n        \n        prizePositions.sort()\n        \n        left, right = 0, len(prizePositions) - 1\n        \n        while left < right:\n            if prizePositions[left] + k < prizePositions[right]:\n                right -= 1\n            else:\n                left += 1\n        \n        return left + 1"
    },
    {
        "number": 2556,
        "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
        "difficulty": 1,
        "answer": "        m, n = len(grid), len(grid[0])\n        if m == 1 and n == 1:\n            return True\n        if m == 1 or n == 1:\n            return False\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n                return False\n            if (i, j) == (0, 0) or (i, j) == (m - 1, n - 1):\n                return True\n            grid[i][j] = 0\n            return dfs(i + 1, j) or dfs(i, j + 1)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    if dfs(i, j):\n                        return True\n        return False"
    },
    {
        "number": 2558,
        "title": "Take Gifts From the Richest Pile",
        "difficulty": 0,
        "answer": "        \n        # Time: O(nlog(n)), space: O(n)\n        # n = len(gifts)\n        # if n == 1: return 1\n        # gifts.sort()\n        # res = 0\n        # for i in range(k):\n        #     res += gifts.pop()\n        # return res\n        \n        # Time: O(n), space: O(n)\n        # n = len(gifts)\n        # if n == 1: return 1\n        # gifts.sort()\n        # res = 0\n        # for i in range(k):\n        #     res += gifts.pop()\n        # return res\n        \n        # Time: O(n), space: O(1)\n        # n = len(gifts)\n        # if n == 1: return 1\n        # gifts.sort()\n        # res = 0\n        # for i in range(k):\n        #     res += gifts.pop()\n        # return res\n        \n        # Time: O(n), space: O(1)\n        # n = len"
    },
    {
        "number": 2559,
        "title": "Count Vowel Strings in Ranges",
        "difficulty": 1,
        "answer": "        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        ans = []\n        for query in queries:\n            count = 0\n            for word in words:\n                if word[query[0]] in vowels and word[query[1] - 1] in vowels:\n                    count += 1\n            ans.append(count)\n        return ans"
    },
    {
        "number": 2560,
        "title": "House Robber IV",
        "difficulty": 1,
        "answer": "        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i])\n        #"
    },
    {
        "number": 2561,
        "title": "Rearranging Fruits",
        "difficulty": 2,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2562,
        "title": "Find the Array Concatenation Value",
        "difficulty": 0,
        "answer": "        while len(nums) > 1:\n            nums = [nums[0] + nums[-1]] + nums[1:-1]\n        return nums[0]"
    },
    {
        "number": 2563,
        "title": "Count the Number of Fair Pairs",
        "difficulty": 1,
        "answer": "        # nums.sort()\n        # res = 0\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] <= upper and nums[i] + nums[j] >= lower:\n        #             res += 1\n        # return res"
    },
    {
        "number": 2564,
        "title": "Substring XOR Queries",
        "difficulty": 1,
        "answer": "        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n)\n        # O(n"
    },
    {
        "number": 2565,
        "title": "Subsequence With the Minimum Score",
        "difficulty": 2,
        "answer": "        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + 1\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n        return dp[-1][-1]"
    },
    {
        "number": 2566,
        "title": "Maximum Difference by Remapping a Digit",
        "difficulty": 0,
        "answer": "        # Solution 1:\n        # return max(map(int, str(num))) - min(map(int, str(num)))"
    },
    {
        "number": 2567,
        "title": "Minimum Score by Changing Two Elements",
        "difficulty": 1,
        "answer": "        nums.sort()\n        high = 0\n        low = 0\n        for i in range(1, len(nums)):\n            high += nums[i] - nums[i - 1]\n            low += nums[i - 1] - nums[i]\n        return low + high"
    },
    {
        "number": 2568,
        "title": "Minimum Impossible OR",
        "difficulty": 1,
        "answer": "        nums.sort()\n        ans = 1\n        for i in range(len(nums)):\n            if nums[i] > ans:\n                return ans\n            ans |= nums[i]\n        return ans + 1"
    },
    {
        "number": 2569,
        "title": "Handling Sum Queries After Update",
        "difficulty": 2,
        "answer": "        # nums1 = [1,0,1]\n        # nums2 = [0,0,0]\n        # queries = [[1,1,1],[2,1,0],[3,0,0]]\n        # nums1 = [1]\n        # nums2 = [5]\n        # queries = [[2,0,0],[3,0,0]]\n        # nums1 = [1,0,1]\n        # nums2 = [0,0,0]\n        # queries = [[1,1,1],[2,1,0],[3,0,0]]\n        # nums1 = [1,0,1]\n        # nums2 = [0,0,0]\n        # queries = [[1,1,1],[2,1,0],[3,0,0]]\n        # nums1 = [1,0,1]\n        # nums2 = [0,0,0]\n        # queries = [[1,1,1],[2,1,0],[3,0,0]]\n        # nums"
    },
    {
        "number": 2570,
        "title": "Merge Two 2D Arrays by Summing Values",
        "difficulty": 0,
        "answer": "        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i][0] < nums2[j][0]:\n                res.append([nums1[i][0], nums1[i][1]])\n                i += 1\n            elif nums1[i][0] > nums2[j][0]:\n                res.append([nums2[j][0], nums2[j][1]])\n                j += 1\n            else:\n                res.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\n                i += 1\n                j += 1\n        while i < len(nums1):\n            res.append([nums1[i][0], nums1[i][1]])\n            i += 1\n        while j < len(nums2):\n            res.append([n"
    },
    {
        "number": 2571,
        "title": "Minimum Operations to Reduce an Integer to 0",
        "difficulty": 1,
        "answer": "        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            "
    },
    {
        "number": 2572,
        "title": "Count the Number of Square-Free Subsets",
        "difficulty": 1,
        "answer": "        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if nums[i] == 0:\n                res += 1\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    break\n            else:\n                res += 1\n        return res % (10 ** 9 + 7)"
    },
    {
        "number": 2573,
        "title": "Find the String with LCP",
        "difficulty": 2,
        "answer": "        n = len(lcp)\n        if n == 1:\n            return 'a'\n        \n        # find the longest common prefix\n        lcp_matrix = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    lcp_matrix[i][j] = 0\n                elif lcp[i][j] == 0:\n                    lcp_matrix[i][j] = 0\n                else:\n                    lcp_matrix[i][j] = lcp_matrix[i-1][j-1] + 1\n        \n        # find the longest common prefix\n        lcp_matrix_max = 0\n        for i in range(n):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    continue\n                lcp_matrix_max = max(lcp_matrix_max, lcp_matrix[i][j])\n        \n        # find the shortest string\n        min"
    },
    {
        "number": 2574,
        "title": "Left and Right Sum Differences",
        "difficulty": 0,
        "answer": "        left_sum = [0] * len(nums)\n        right_sum = [0] * len(nums)\n        left_sum[0] = nums[0]\n        right_sum[len(nums) - 1] = nums[len(nums) - 1]\n        for i in range(1, len(nums)):\n            left_sum[i] = left_sum[i - 1] + nums[i]\n        for i in range(len(nums) - 2, -1, -1):\n            right_sum[i] = right_sum[i + 1] + nums[i]\n        return [abs(left_sum[i] - right_sum[i]) for i in range(len(nums))]"
    },
    {
        "number": 2575,
        "title": "Find the Divisibility Array of a String",
        "difficulty": 1,
        "answer": "        res = [0] * len(word)\n        for i in range(len(word)):\n            if int(word[i]) % m == 0:\n                res[i] = 1\n        return res"
    },
    {
        "number": 2576,
        "title": "Find the Maximum Number of Marked Indices",
        "difficulty": 1,
        "answer": "        nums.sort()\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                res += 1\n                nums[i] = -1\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                res += 1\n                nums[i] = -1\n        return res"
    },
    {
        "number": 2577,
        "title": "Minimum Time to Visit a Cell In a Grid",
        "difficulty": 2,
        "answer": "        m, n = len(grid), len(grid[0])\n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j])\n                elif j == 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j])\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j])\n        return dp[-1][-1] if dp[-1][-1]!= float('inf') else -1"
    },
    {
        "number": 2578,
        "title": "Split With Minimum Sum",
        "difficulty": 0,
        "answer": "        if num == 0:\n            return 0\n        if num == 1:\n            return 1\n        if num == 2:\n            return 2\n        if num == 3:\n            return 3\n        if num == 4:\n            return 4\n        if num == 5:\n            return 5\n        if num == 6:\n            return 6\n        if num == 7:\n            return 7\n        if num == 8:\n            return 8\n        if num == 9:\n            return 9\n        if num == 10:\n            return 10\n        if num == 11:\n            return 11\n        if num == 12:\n            return 12\n        if num == 13:\n            return 13\n        if num == 14:\n            return 14\n        if num == 15:\n            return 15\n        if num == 16:\n            return 16\n        if num == 17:\n            return 17\n        if num == 18:\n            return 18\n        if num == 19:\n            return 19\n        if num == 20:\n            return 20\n        if num == 21:\n            return 21\n        if num == 22:\n            "
    },
    {
        "number": 2579,
        "title": "Count Total Number of Colored Cells",
        "difficulty": 1,
        "answer": "        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[0][i] = 1\n        for i in range(n):\n            dp[i][0] = 1\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        return sum(dp[-1])"
    },
    {
        "number": 2580,
        "title": "Count Ways to Group Overlapping Ranges",
        "difficulty": 1,
        "answer": "        MOD = 10**9 + 7\n        ranges.sort(key=lambda x: x[0])\n        n = len(ranges)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            for j in range(i):\n                if ranges[i][0] >= ranges[j][1]:\n                    dp[i] += dp[j]\n                    dp[i] %= MOD\n            dp[i] += 1\n            dp[i] %= MOD\n        return dp[-1]"
    },
    {
        "number": 2581,
        "title": "Count Number of Possible Root Nodes",
        "difficulty": 2,
        "answer": "        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # print(graph)\n        # ans = 0\n        # for u, v in guesses:\n        #     if u in graph and v in graph:\n        #         ans += 1\n        # return ans\n        \n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # print(graph)\n        # ans = 0\n        # for u, v in guesses:\n        #     if u in graph and v in graph:\n        #         ans += 1\n        # return ans\n        \n        # graph = collections.defaultdict(list)\n        # for u, v in edges:\n        #     graph[u].append(v)\n        #     graph[v].append(u)\n        # print(graph)\n        # ans = 0"
    },
    {
        "number": 2582,
        "title": "Pass the Pillow",
        "difficulty": 0,
        "answer": "        # Time: O(n)\n        # Space: O(1)\n        # n = 4, time = 5\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 -> 2\n        # 1 -> 2 -> 3 -> 4 -> 3 ->"
    },
    {
        "number": 2583,
        "title": "Kth Largest Sum in a Binary Tree",
        "difficulty": 1,
        "answer": "        if not root:\n            return -1\n        queue = [root]\n        res = []\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(sum(level))\n        return sorted(res, reverse=True)[k-1]"
    },
    {
        "number": 2584,
        "title": "Split the Array to Make Coprime Products",
        "difficulty": 2,
        "answer": "        n = len(nums)\n        if n < 3:\n            return -1\n        left = [0] * n\n        right = [0] * n\n        left[0] = nums[0]\n        right[n - 1] = nums[n - 1]\n        for i in range(1, n):\n            left[i] = left[i - 1] * nums[i]\n            right[n - i - 1] = right[n - i] * nums[n - i - 1]\n        for i in range(1, n - 1):\n            if left[i - 1] * right[i + 1] == left[i] * right[i]:\n                return i\n        return -1"
    },
    {
        "number": 2585,
        "title": "Number of Ways to Earn Points",
        "difficulty": 2,
        "answer": "        # dp[i][j] = ways to reach target j with i types\n        # dp[i][j] = sum(dp[i-1][j-k*types[i][1]] for k in range(types[i][0]))\n        # dp[i][j] = sum(dp[i-1][j-k*types[i][1]] for k in range(types[i][0]))\n        # dp[i][j] = sum(dp[i-1][j-k*types[i][1]] for k in range(types[i][0]))\n        # dp[i][j] = sum(dp[i-1][j-k*types[i][1]] for k in range(types[i][0]))\n        # dp[i][j] = sum(dp[i-1][j-k*types[i][1]] for k in range(types[i][0]))\n        # dp[i][j] = sum(dp[i-1][j-k*types[i]["
    },
    {
        "number": 2586,
        "title": "Count the Number of Vowel Strings in Range",
        "difficulty": 0,
        "answer": "        \n        def isVowel(ch):\n            return ch in ['a', 'e', 'i', 'o', 'u']\n        \n        def isVowelString(word):\n            return isVowel(word[0]) and isVowel(word[-1])\n        \n        def isVowelStringInRange(word, left, right):\n            return isVowelString(word) and left <= len(word) - 1 and len(word) - 1 <= right\n        \n        def getVowelStrings(words, left, right):\n            res = 0\n            for word in words:\n                if isVowelStringInRange(word, left, right):\n                    res += 1\n            return res\n        \n        return getVowelStrings(words, left, right)"
    },
    {
        "number": 2587,
        "title": "Rearrange Array to Maximize Prefix Score",
        "difficulty": 1,
        "answer": "        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix = [0]\n        # for num in nums:\n        #     prefix.append(prefix[-1] + num)\n        # return sum(prefix)\n        # prefix ="
    },
    {
        "number": 2588,
        "title": "Count the Number of Beautiful Subarrays",
        "difficulty": 1,
        "answer": "        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # n = len(nums)\n        # dp = [[0] * n for _ in range(n)]\n        # for i in range(n):\n        #     dp[i][i] = 1\n        # for i in range(n - 1):\n        #     if nums[i] == nums[i + 1]:\n        #         dp[i][i + 1] = 1\n        # for k in range(2, n):\n        #     for i in range(n - k):\n        #         j = i + k\n        #         if nums[i] == nums[j] and dp[i + 1][j - 1] == 1:\n        #             dp[i][j] = 1\n        # return sum(dp[0])"
    },
    {
        "number": 2589,
        "title": "Minimum Time to Complete All Tasks",
        "difficulty": 2,
        "answer": "        # sort by start time\n        tasks.sort(key=lambda x: x[0])\n        # print(tasks)\n        # print(tasks[0][0])\n        # print(tasks[0][1])\n        # print(tasks[0][2])\n        # print(tasks[1][0])\n        # print(tasks[1][1])\n        # print(tasks[1][2])\n        # print(tasks[2][0])\n        # print(tasks[2][1])\n        # print(tasks[2][2])\n        # print(tasks[3][0])\n        # print(tasks[3][1])\n        # print(tasks[3][2])\n        # print(tasks[4][0])\n        # print(tasks[4][1])\n        # print(tasks[4][2])\n        # print(tasks[5][0])\n        # print(tasks[5][1])\n        # print(tasks[5][2])\n        # print"
    },
    {
        "number": 2591,
        "title": "Distribute Money to Maximum Children",
        "difficulty": 0,
        "answer": "        if money % 4 == 0:\n            return -1\n        if money % 4 == 1:\n            return 0\n        if money % 4 == 2:\n            return 1\n        if money % 4 == 3:\n            return 2\n        \n        if money % 8 == 0:\n            return children\n        if money % 8 == 1:\n            return children - 1\n        if money % 8 == 2:\n            return children - 2\n        if money % 8 == 3:\n            return children - 3\n        if money % 8 == 4:\n            return children - 4\n        if money % 8 == 5:\n            return children - 5\n        if money % 8 == 6:\n            return children - 6\n        if money % 8 == 7:\n            return children - 7\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        "
    },
    {
        "number": 2592,
        "title": "Maximize Greatness of an Array",
        "difficulty": 1,
        "answer": "        nums.sort()\n        greatness = 0\n        for i in range(len(nums)):\n            greatness = max(greatness, nums[i] - i)\n        return greatness\n"
    },
    {
        "number": 2593,
        "title": "Find Score of an Array After Marking All Elements",
        "difficulty": 1,
        "answer": "        nums.sort()\n        score = 0\n        for i in range(len(nums)):\n            if nums[i]!= i+1:\n                score += nums[i]\n                nums[i] = nums[nums[i]-1]\n                nums[nums[i]-1] = nums[i]\n        return score"
    },
    {
        "number": 2594,
        "title": "Minimum Time to Repair Cars",
        "difficulty": 1,
        "answer": "        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # ranks.sort()\n        # res = 0\n        # for i in range(len(ranks)):\n        #     res += ranks[i] * ranks[i] * (cars - i)\n        # return res"
    },
    {
        "number": 2595,
        "title": "Number of Even and Odd Bits",
        "difficulty": 0,
        "answer": "        return [bin(n).count('1') % 2, bin(n).count('1') % 2]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 2596,
        "title": "Check Knight Tour Configuration",
        "difficulty": 1,
        "answer": "        n = len(grid)\n        if n == 0:\n            return True\n        if n == 1:\n            return True\n        if n == 2:\n            return True\n        if n == 3:\n            return True\n        if n == 4:\n            return True\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return True\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return True\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return True\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return True\n        if n == 21:\n            return True\n"
    },
    {
        "number": 2597,
        "title": "The Number of Beautiful Subsets",
        "difficulty": 1,
        "answer": "        nums.sort()\n        self.res = 0\n        self.dfs(nums, k, 0, [])\n        return self.res"
    },
    {
        "number": 2598,
        "title": "Smallest Missing Non-negative Integer After Operations",
        "difficulty": 1,
        "answer": "        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] >= value:\n                return i\n        return len(nums)"
    }
]